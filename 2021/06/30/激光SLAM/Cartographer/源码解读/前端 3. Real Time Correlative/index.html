<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="前端 3. Real Time Correlative Scan Matcher"><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>前端 3. Real Time Correlative Scan Matcher | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#AddAccumulatedRangeData"><span class="toc-number">1.</span> <span class="toc-text">AddAccumulatedRangeData</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scan-match"><span class="toc-number">2.</span> <span class="toc-text">scan match</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Real-Time-Correlative-Scan-Matcher"><span class="toc-number">3.</span> <span class="toc-text">Real Time Correlative Scan Matcher</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SearchParameters"><span class="toc-number">3.1.</span> <span class="toc-text">SearchParameters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GenerateRotatedScans-%E5%88%87%E7%89%87%E6%97%8B%E8%BD%AC"><span class="toc-number">3.2.</span> <span class="toc-text">GenerateRotatedScans 切片旋转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ScoreCandidates"><span class="toc-number">3.3.</span> <span class="toc-text">ScoreCandidates</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">651</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">51</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">前端 3. Real Time Correlative Scan Matcher</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-06-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/06/30/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%89%8D%E7%AB%AF%203.%20Real%20Time%20Correlative/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/06/30/激光SLAM/Cartographer/源码解读/前端 3. Real Time Correlative/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">2.7k</span><span class="post-meta__separator">|</span><span>Reading time: 10 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="AddAccumulatedRangeData"><a href="#AddAccumulatedRangeData" class="headerlink" title="AddAccumulatedRangeData"></a>AddAccumulatedRangeData</h2><p>现在进入<code>AddAccumulatedRangeData</code>函数，返回类型为 <code>std::unique_ptr&lt;LocalTrajectoryBuilder2D::MatchingResult&gt;</code></p>
<p>所用参数为</p>
<ul>
<li><code>const common::Time time</code> &emsp;&emsp;&emsp;   当前同步时间</li>
<li><code>const sensor::RangeData&amp;    gravity_aligned_range_data</code> &emsp;&emsp;&emsp;  经过重力修正后的点云returns和miss</li>
<li><code>const transform::Rigid3d&amp;   gravity_alignment</code>, &emsp;&emsp;&emsp; 重力向量</li>
<li><code>const absl::optional&lt;common::Duration&gt;&amp;    sensor_duration</code></li>
</ul>
<p>先看开头，我交换了部分代码顺序，并不影响。这里实际是获得<code>scanMatch</code>的两个参数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (gravity_aligned_range_data.returns.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Dropped empty horizontal range data.&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sensor::PointCloud&amp;  filtered_gravity_aligned_point_cloud =</span><br><span class="line">sensor::<span class="built_in">AdaptiveVoxelFilter</span>(options_.<span class="built_in">adaptive_voxel_filter_options</span>())</span><br><span class="line">          .<span class="built_in">Filter</span>(gravity_aligned_range_data.returns);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (filtered_gravity_aligned_point_cloud.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><br>这一段就是流程图的<strong>Adaptive Voxel Filter</strong>环节，解释参考<a href="https://charon-cheung.github.io/2020/08/04/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/Voxel%20Filter%E5%92%8CAdaptive%20Voxel%20Filter/">(九) Voxel Filter和Adaptive Voxel Filter</a></p>
<p>然后是估计位姿部分<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transform::Rigid3d  non_gravity_aligned_pose_prediction =</span><br><span class="line">  extrapolator_-&gt;<span class="built_in">ExtrapolatePose</span>(time);</span><br><span class="line">  <span class="comment">// 经过重力方向计算投影后的2d位置</span></span><br><span class="line"><span class="keyword">const</span> transform::Rigid2d   pose_prediction = transform::<span class="built_in">Project2D</span>(</span><br><span class="line">      non_gravity_aligned_pose_prediction * gravity_alignment.<span class="built_in">inverse</span>() );</span><br></pre></td></tr></table></figure><br>返回的<code>pose_prediction</code>和上面的<code>filtered_gravity_aligned_point_cloud</code>一起进入 <strong>Scan Mathching</strong> 环节，这个在流程图上很明显。</p>
<p>表面上只是重力对齐以后再处理，其实这里面还为后续的匹配与查找减小了查找范围，因为<code>* gravity_alignment.inverse()</code>这一乘使得与上一帧数据的角度变化缩小了（基本是同一角度），所以<font size="4" color="blue"> 为后面的ScanMatch减小了角度的查找范围。  </font></p>
<p>在后面再把角度乘回来：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pose_estimate_2d =</span><br><span class="line">      <span class="built_in">ScanMatch</span>(time, pose_prediction, filtered_gravity_aligned_point_cloud);</span><br><span class="line"></span><br><span class="line">transform::Rigid3d pose_estimate =</span><br><span class="line">     transform::<span class="built_in">Embed3D</span>(*pose_estimate_2d) * gravity_alignment;</span><br></pre></td></tr></table></figure><br>这样就实现了角度的估计，gravity_alignment上下是同一数值，只是为了减少计算量，点云数据也按这个gravity_alignment做了处理</p>
<h2 id="scan-match"><a href="#scan-match" class="headerlink" title="scan match"></a>scan match</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// local map frame &lt;--- gravity-aligned frame</span></span><br><span class="line"><span class="comment">// 求 Scan 插入Submap的最优 Pose</span></span><br><span class="line">std::unique_ptr&lt;transform::Rigid2d&gt; pose_estimate_2d =</span><br><span class="line">    <span class="built_in">ScanMatch</span>(time, pose_prediction, filtered_gravity_aligned_point_cloud);</span><br><span class="line"><span class="keyword">if</span> (pose_estimate_2d == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;Scan matching failed.&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>ScanMatch</code>包含了<strong>real time correlative scan matcher</strong> 和 <strong>ceres scan match</strong>两部分，前者为后者提供好的初值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出是对该帧传感器数据的最优pose</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;transform::Rigid2d&gt; <span class="title">LocalTrajectoryBuilder2D::ScanMatch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> common::Time time,  <span class="keyword">const</span> transform::Rigid2d&amp;  pose_prediction,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> sensor::PointCloud&amp;  filtered_gravity_aligned_point_cloud)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 如果还没有子图，返回 PoseExtrapolator 的预测值</span></span><br><span class="line">  <span class="keyword">if</span> (active_submaps_.<span class="built_in">submaps</span>().<span class="built_in">empty</span>() )</span><br><span class="line">    <span class="keyword">return</span> absl::make_unique&lt;transform::Rigid2d&gt;(pose_prediction);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 永远是头部的子图做匹配   SCAN-to-MAP</span></span><br><span class="line">  std::shared_ptr&lt;<span class="keyword">const</span> Submap2D&gt; matching_submap =  </span><br><span class="line">      active_submaps_.<span class="built_in">submaps</span>().<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">  transform::Rigid2d initial_ceres_pose = pose_prediction;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数最终更新 initial_ceres_pose，返回匹配的最高分数</span></span><br><span class="line">  <span class="keyword">if</span> (options_.<span class="built_in">use_online_correlative_scan_matching</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> score = real_time_correlative_scan_matcher_.<span class="built_in">Match</span>(</span><br><span class="line">        pose_prediction,   filtered_gravity_aligned_point_cloud,</span><br><span class="line">        <span class="comment">// Grid2D类型</span></span><br><span class="line">        *matching_submap-&gt;<span class="built_in">grid</span>(),  &amp;initial_ceres_pose );</span><br><span class="line">    kRealTimeCorrelativeScanMatcherScoreMetric-&gt;<span class="built_in">Observe</span>(score);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ceres scan matcher 部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Real-Time-Correlative-Scan-Matcher"><a href="#Real-Time-Correlative-Scan-Matcher" class="headerlink" title="Real Time Correlative Scan Matcher"></a>Real Time Correlative Scan Matcher</h2><p>这里借用了karto的做法，即本质是<strong>暴力匹配</strong>，而hector是用了高斯牛顿法和多分辨率地图。但是karto还是用了多分辨率地图，而cartographer这里没有。</p>
<p>它使用类似于在回环检测中激光与子地图匹配的方式，然后最好的匹配用作Ceres Scan Matcher的先验。这个scan matcher非常消耗资源，但它在特征丰富的环境中是很鲁棒。</p>
<p>我们要找到机器人位姿的后验概率分布<script type="math/tex">p(x_i|x_{i-1}\ ,u,m,z)</script>，使用贝叶斯公式得到</p>
<script type="math/tex; mode=display">p(x_i\ |x_{i-1}\ ,u,m,z) \propto p(x_i\ |x_{i-1}\ , u)* p(z\ |x_i,m)</script><p>运动模型是已知的多元高斯分布，<font size="4" color="blue"> 算法只研究观测模型。观测模型难以计算，一般具有多极值。  </font>雷达观测数据 <script type="math/tex">z_t</script> 里包含了很多激光点数据，假设他们是完全独立的</p>
<script type="math/tex; mode=display">p(z_t\ |x_t,m_{t-1}\ ) = \prod \limits_i p(z_t^i\ |x_t,m_{t-1}\ )  \propto \sum\limits_i log\ p(z_t^i\ |x_t, m_{t-1}\ )</script><p>将一帧观测数据的概率拆分成了当前帧的每一个点的概率，在计算这个概率之前，我们需要对数据帧以及地图进行栅格化。</p>
<p>位姿估计器传来的预测值不适合做初值，真正初值是在它附近。</p>
<p>实时相关性scan match 以预测值为中心，在搜索窗口内枚举出所有候选位姿，并生成每个位姿对应的点云，也就是说按照 <script type="math/tex">x_i</script> 把当前观测 <script type="math/tex">z_i</script> 投影到栅格地图 m ( t 时刻的激光数据与 t-1 时刻的地图匹配， scan to map)，然后分别计算每个点云中<code>hit</code>点在栅格地图的<code>CellIndex</code>，并计算所有hit点的占据概率之和，概率最大值对应的位姿就是我们需要的。<strong>代表着在这个位姿下，激光点得映射到占据栅格中的可能性最大，当前观测与已知环境最为一致，前后帧匹配成功</strong>。  scan match非常重要，<strong>如果结果位姿很差，建图就会失败，后端怎么调整也没用</strong></p>
<p>搜索的精度是栅格地图的分辨率</p>
<p><img src="https://s2.loli.net/2022/04/20/7gBab2UqEVwmkuL.png" alt=""></p>
<font size="4" color="blue"> 这个scan matcher可以修改做重定位，不过搜索窗口扩大很多  </font>

<ol>
<li><p>暴力搜索<br>我们要计算 <script type="math/tex">p(z\ |x_i, m)</script>，这就需要一个三层for循环 <script type="math/tex">(x,y,\theta)</script> 计算每一个位姿，还有第四个循环，也就是遍历点云中每个点。<font size="4" color="blue"> 计算量巨大，因为每一个位姿都要重新投影，需要计算sin和cos函数  </font></p>
</li>
<li><p>计算2D切片<br>把三层循环交换顺序，最外层遍历 <script type="math/tex">\theta</script>，这样(x, y)的循环只有加法。</p>
</li>
<li><p>多分辨率搜索<br>首先选择一个相对低的分辨率对 map 和 scan 进行栅格化，每个栅格上保留高分辨率情况下的该区域的最高概率，这样在匹配时就不会错过正确的位姿估计<br>低分辨率找到最佳匹配后再在该位置进行高分辨率的栅格化，并设定相对较小的 search window 进行计算。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新 pose_estimate， 返回最高的分数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">RealTimeCorrelativeScanMatcher2D::Match</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> transform::Rigid2d&amp;  initial_pose_estimate,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> sensor::PointCloud&amp;  point_cloud, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Grid2D&amp;  grid,</span></span></span><br><span class="line"><span class="params"><span class="function">    transform::Rigid2d*  pose_estimate  )</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(pose_estimate != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 预测位姿的旋转量</span></span><br><span class="line">  <span class="keyword">const</span> Eigen::Rotation2Dd initial_rotation = initial_pose_estimate.<span class="built_in">rotation</span>();</span><br><span class="line">   <span class="comment">/*  左乘 initial_rotation， 将当前点云转换为</span></span><br><span class="line"><span class="comment">  初始角度坐标系下点云，这里只有 旋转  */</span></span><br><span class="line">  <span class="keyword">const</span> sensor::PointCloud rotated_point_cloud = sensor::<span class="built_in">TransformPointCloud</span>(</span><br><span class="line">      point_cloud,</span><br><span class="line">      transform::Rigid3f::<span class="built_in">Rotation</span>(Eigen::<span class="built_in">AngleAxisf</span>(</span><br><span class="line">          initial_rotation.cast&lt;<span class="keyword">float</span>&gt;().<span class="built_in">angle</span>(), </span><br><span class="line">          Eigen::Vector3f::<span class="built_in">UnitZ</span>()  )   )</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">const</span> SearchParameters <span class="title">search_parameters</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      options_.linear_search_window(),  options_.angular_search_window(),</span></span></span><br><span class="line"><span class="params"><span class="function">      rotated_point_cloud,   grid.limits().resolution()  )</span></span>;</span><br><span class="line">	<span class="comment">// 获取搜索窗口下机器人朝向各个方向角时的点云数据</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先通过角度切片，然后在xy方向上暴力搜索，为了减少计算量</span></span><br><span class="line">  <span class="comment">// 切片数目 num_scans , 按照搜索角度/步长，以初始值为基础，生成一些列的旋转后的点云</span></span><br><span class="line">  <span class="keyword">const</span> std::vector&lt;sensor::PointCloud&gt; rotated_scans =</span><br><span class="line">      <span class="built_in">GenerateRotatedScans</span>(rotated_point_cloud, search_parameters);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// DiscreteScan2D 就是 std::vector&lt;Eigen::Array2i&gt;</span></span><br><span class="line">     <span class="comment">/* 把切片后的旋转点云坐标，左乘initial_pose_estimate.translation</span></span><br><span class="line"><span class="comment">       转化到地图坐标，这里只有 平移</span></span><br><span class="line"><span class="comment">    最终通过GetCellIndex返回一系列的  激光点return所在的cell index*/</span></span><br><span class="line">  <span class="keyword">const</span> std::vector&lt;DiscreteScan2D&gt; discrete_scans = <span class="built_in">DiscretizeScans</span>(</span><br><span class="line">      grid.<span class="built_in">limits</span>(),   rotated_scans,</span><br><span class="line">      Eigen::<span class="built_in">Translation2f</span>( initial_pose_estimate.<span class="built_in">translation</span>().<span class="built_in">x</span>(),</span><br><span class="line">      initial_pose_estimate.<span class="built_in">translation</span>().<span class="built_in">y</span>()  )</span><br><span class="line">      );</span><br><span class="line">   <span class="comment">/*  获得candidates, size是 search_parameters.num_scans * </span></span><br><span class="line"><span class="comment">  (linear_bounds.max_x - inear_bounds.min_x) * (linear_bounds.max_y - inear_bounds.min_y)*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  这里是num_scans循环，x和y循环，没有 theta循环了</span></span><br><span class="line"><span class="comment">  成员是 scan_index, x_index_offset(逐步增加), y_index_offset(逐步增加), </span></span><br><span class="line"><span class="comment">  search_parameters意思其实是 每个激光点附近的矩形区域*/</span></span><br><span class="line">  std::vector&lt;Candidate2D&gt; candidates =</span><br><span class="line">      <span class="built_in">GenerateExhaustiveSearchCandidates</span>(search_parameters);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算当前帧在theta、x、y三层窗口中，每个状态在grid地图中的匹配的评分</span></span><br><span class="line">  <span class="comment">// search_parameters 实际没用</span></span><br><span class="line">  <span class="built_in">ScoreCandidates</span>(grid, discrete_scans, search_parameters, &amp;candidates);</span><br><span class="line">  <span class="comment">// 取最好的候选</span></span><br><span class="line">  <span class="keyword">const</span> Candidate2D&amp;   best_candidate =</span><br><span class="line">      *std::<span class="built_in">max_element</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后的结果是预测值加候选位姿</span></span><br><span class="line">  *pose_estimate = transform::<span class="built_in">Rigid2d</span>(</span><br><span class="line">      &#123;initial_pose_estimate.<span class="built_in">translation</span>().<span class="built_in">x</span>() + best_candidate.x,</span><br><span class="line">       initial_pose_estimate.<span class="built_in">translation</span>().<span class="built_in">y</span>() + best_candidate.y &#125;,</span><br><span class="line">       <span class="comment">// 前端观测，所以右乘</span></span><br><span class="line">      initial_rotation * Eigen::<span class="built_in">Rotation2Dd</span>(best_candidate.orientation) );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> best_candidate.score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>获取位姿估计器传来的初值的旋转分量，将激光点云左乘旋转分量，即先做旋转变换</li>
<li>根据搜索窗口x、y、yaw的大小计算 num_scans和LinearBounds， x y搜索的num_linear_perturbations</li>
<li>切片旋转：GenerateRotatedScans函数，其实就是theta循环，将角度进行序列化(初始角度跟search_window的大小相关，按步长增加)，点云依次左乘角度对应的旋转向量(旋转轴为z轴)，即可生成<code>num_scans</code>段点云</li>
<li>把点云中所有点做变换：左乘初值的平移部分，根据变换后的坐标，找出它在栅格地图中的<code>CellIndex</code>并保存</li>
<li>根据搜索范围，生成候选者，数量是<code>25*num_scans</code></li>
</ol>
<ul>
<li>根据保存的索引队列，从栅格地图中获取最大置信度，这就用到了ProbabilityGrid类，根据每个点的<code>CellIndex</code>获取<strong>占据概率</strong>，最终对分数进行加权处理</li>
<li>求得每个候选位置的score，score最高的为最佳位置。</li>
</ul>
<p><strong>候选者</strong>是针对<code>scan_index</code> (<code>0~num_scans</code>)所做的x y方向的offset，生成所有候选者的过程其实就是<code>num_scans</code>和x y三个循环<br><img src="https://s2.loli.net/2022/03/14/hw4MikzIuN2yPQx.png" alt=""></p>
<p><font size="4" color="blue">  Match 函数的计算量很大 </font>。 试验发现最终的分数，大部分在<code>0.6~0.9</code></p>
<h3 id="SearchParameters"><a href="#SearchParameters" class="headerlink" title="SearchParameters"></a>SearchParameters</h3><p>根据lua参数，确定后面的切片步长<code>angular_perturbation_step_size</code>，切片数<code>num_scans</code>，搜索区域<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">SearchParameters::<span class="built_in">SearchParameters</span>(</span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">double</span> linear_search_window,</span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">double</span> angular_search_window,</span><br><span class="line">               <span class="keyword">const</span> sensor::PointCloud&amp; point_cloud,</span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">double</span> resolution)</span><br><span class="line">    : <span class="built_in">resolution</span>(resolution)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// We set this value to something on the order of </span></span><br><span class="line">  <span class="comment">// resolution to make sure that the std::acos() below is defined.</span></span><br><span class="line">  <span class="keyword">float</span> max_scan_range = <span class="number">3.f</span> * resolution;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> sensor::RangefinderPoint&amp; point : point_cloud) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> range = point.position.head&lt;<span class="number">2</span>&gt;().<span class="built_in">norm</span>();</span><br><span class="line">    max_scan_range = std::<span class="built_in">max</span>(range, max_scan_range);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> kSafetyMargin = <span class="number">1.</span> - <span class="number">1e-3</span>;</span><br><span class="line">  angular_perturbation_step_size =</span><br><span class="line">      kSafetyMargin * std::<span class="built_in">acos</span>(<span class="number">1.</span> - common::<span class="built_in">Pow2</span>(resolution) /</span><br><span class="line">                                         (<span class="number">2.</span> * common::<span class="built_in">Pow2</span>(max_scan_range)));</span><br><span class="line">  <span class="comment">// 这两者的计算不同</span></span><br><span class="line">  num_angular_perturbations =</span><br><span class="line">      std::<span class="built_in">ceil</span>(angular_search_window / angular_perturbation_step_size);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> num_linear_perturbations =</span><br><span class="line">      std::<span class="built_in">ceil</span>(linear_search_window / resolution);</span><br><span class="line">  <span class="comment">// 切片数目，由于resolution不修改，实际取决于 max_scan_range 和 angular_search_window</span></span><br><span class="line">  num_scans = <span class="number">2</span> * num_angular_perturbations + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">/*  Linear search window in pixel offsets; bounds are inclusive.</span></span><br><span class="line"><span class="comment">  struct LinearBounds &#123;</span></span><br><span class="line"><span class="comment">    int min_x;</span></span><br><span class="line"><span class="comment">    int max_x;</span></span><br><span class="line"><span class="comment">    int min_y;</span></span><br><span class="line"><span class="comment">    int max_y;</span></span><br><span class="line"><span class="comment">  &#125;;</span></span><br><span class="line"><span class="comment">  std::vector&lt;LinearBounds&gt; linear_bounds;   Per rotated scans  */</span></span><br><span class="line">  linear_bounds.<span class="built_in">reserve</span>(num_scans);</span><br><span class="line">  <span class="comment">// 对同一帧scan, linear_bounds的元素都相同，不同帧就不同了</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != num_scans; ++i) &#123;</span><br><span class="line">    linear_bounds.<span class="built_in">push_back</span>(</span><br><span class="line">        LinearBounds&#123;-num_linear_perturbations, num_linear_perturbations,</span><br><span class="line">                     -num_linear_perturbations, num_linear_perturbations&#125; );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="GenerateRotatedScans-切片旋转"><a href="#GenerateRotatedScans-切片旋转" class="headerlink" title="GenerateRotatedScans 切片旋转"></a>GenerateRotatedScans 切片旋转</h3><p>生成序列化旋转的多段点云<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;sensor::PointCloud&gt; <span class="title">GenerateRotatedScans</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> sensor::PointCloud&amp;  point_cloud,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> SearchParameters&amp;  search_parameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::vector&lt;sensor::PointCloud&gt; rotated_scans;</span><br><span class="line">  rotated_scans.<span class="built_in">reserve</span>(search_parameters.num_scans);</span><br><span class="line">  <span class="comment">// 旋转角度步长</span></span><br><span class="line">  <span class="keyword">double</span> delta_theta = -search_parameters.num_angular_perturbations *</span><br><span class="line">                       search_parameters.angular_perturbation_step_size;</span><br><span class="line">  <span class="comment">//  个数 num_scans</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> scan_index = <span class="number">0</span>; scan_index &lt; search_parameters.num_scans;</span><br><span class="line">       ++scan_index,</span><br><span class="line">       delta_theta += search_parameters.angular_perturbation_step_size)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 左乘旋转向量，旋转轴为z轴</span></span><br><span class="line">    rotated_scans.<span class="built_in">push_back</span>(sensor::<span class="built_in">TransformPointCloud</span>(</span><br><span class="line">        point_cloud, transform::Rigid3f::<span class="built_in">Rotation</span>(Eigen::<span class="built_in">AngleAxisf</span>(</span><br><span class="line">                         delta_theta, Eigen::Vector3f::<span class="built_in">UnitZ</span>()) ) )  );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rotated_scans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ScoreCandidates"><a href="#ScoreCandidates" class="headerlink" title="ScoreCandidates"></a>ScoreCandidates</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ScoreCandidates</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Grid2D&amp; grid,  <span class="keyword">const</span> std::vector&lt;DiscreteScan2D&gt;&amp; discrete_scans,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> SearchParameters&amp;  search_parameters,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;Candidate2D&gt;*  <span class="keyword">const</span> candidates)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Candidate2D&amp; candidate : *candidates)</span><br><span class="line">  &#123;</span><br><span class="line">    candidate.score = <span class="built_in">ComputeCandidateScore</span>(</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> ProbabilityGrid&amp;&gt;(grid),</span><br><span class="line">        discrete_scans[candidate.scan_index],</span><br><span class="line">        candidate.x_index_offset,</span><br><span class="line">        candidate.y_index_offset);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 省略 GridType::TSDF</span></span><br><span class="line">      <span class="comment">// 进一步做权重处理</span></span><br><span class="line">    candidate.score *=</span><br><span class="line">        std::<span class="built_in">exp</span>(</span><br><span class="line">          -common::<span class="built_in">Pow2</span>(</span><br><span class="line">            std::<span class="built_in">hypot</span>(candidate.x, candidate.y) *</span><br><span class="line">            options_.<span class="built_in">translation_delta_cost_weight</span>() </span><br><span class="line">                        +</span><br><span class="line">            std::<span class="built_in">abs</span>(candidate.orientation) *</span><br><span class="line">            options_.<span class="built_in">rotation_delta_cost_weight</span>()</span><br><span class="line">                       )</span><br><span class="line">          );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中用到的函数， 计算每个候选的得分</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">ComputeCandidateScore</span><span class="params">(<span class="keyword">const</span> ProbabilityGrid&amp; probability_grid,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">const</span> DiscreteScan2D&amp;  discrete_scan,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> x_index_offset,  <span class="keyword">int</span> y_index_offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">float</span> candidate_score = <span class="number">0.f</span>;</span><br><span class="line">  <span class="comment">// 这里就用到前面获取的x y 索引队列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> Eigen::Array2i&amp; xy_index : discrete_scan)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Eigen::Array2i <span class="title">proposed_xy_index</span><span class="params">(xy_index.x() + x_index_offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           xy_index.y() + y_index_offset  )</span></span>;</span><br><span class="line">    <span class="comment">// Returns probability of the cell with  &#x27;cell_index&#x27;</span></span><br><span class="line">    <span class="comment">// 这个就是占据概率</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> probability =</span><br><span class="line">        probability_grid.<span class="built_in">GetProbability</span>(proposed_xy_index);</span><br><span class="line">    candidate_score += probability;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回的是一帧点云所有激光点得分的平均值</span></span><br><span class="line">  candidate_score /= <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(discrete_scan.<span class="built_in">size</span>());</span><br><span class="line">  <span class="built_in">CHECK_GT</span>(candidate_score, <span class="number">0.f</span>);</span><br><span class="line">  <span class="keyword">return</span> candidate_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考： <a target="_blank" rel="noopener" href="https://www.cswamp.com/post/120">RealTimeCorrelativeScanMatcher2D</a></p>
</div></article><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/06/30/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%89%8D%E7%AB%AF%204.%20Ceres%20scan%20matcher/"><i class="fa fa-chevron-left">  </i><span>前端 4. Ceres scan matcher</span></a></div><div class="next-post pull-right"><a href="/2021/06/28/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%88%B0%E9%9A%9C%E7%A2%8D%E7%89%A9%E7%9A%84%E8%B7%9D%E7%A6%BB%20calculateDistance/"><span>机器人到障碍物的距离 calculateDistance</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://charon-cheung.github.io/2021/06/30/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%89%8D%E7%AB%AF%203.%20Real%20Time%20Correlative/';
  this.page.identifier = '2021/06/30/激光SLAM/Cartographer/源码解读/前端 3. Real Time Correlative/';
  this.page.title = '前端 3. Real Time Correlative Scan Matcher';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '沉默杀手' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://沉默杀手.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2024 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>