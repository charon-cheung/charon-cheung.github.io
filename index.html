<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">604</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">50</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2023/05/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BD%8D%E7%BD%AE%E6%AD%A3%E7%A1%AE%EF%BC%8C%E6%9C%9D%E5%90%91%E4%B8%8D%E6%AD%A3%E7%A1%AE%E4%BC%9A%E5%A6%82%E4%BD%95%E8%A7%84%E5%88%92%E8%B7%AF%E5%BE%84/">机器人位置正确，朝向不正确会如何规划路径</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-05-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%85%B6%E4%BB%96/">其他</a></span><div class="content"><p><img src="https://s2.loli.net/2023/05/15/qhB3YTEIfgoAvRJ.png" alt=""><br>如图所示，起点的朝向为0°，终点朝向相同，这个路径显然就是直着走。</p>
<p>假如机器人实际朝向为90°，但定位程序给出的是0°，那么传给路径规划后，规划出的是直线，路径点的朝向都不变，输出的角速度为0，只有线速度。那么车会朝90°直着走，这就偏离路径了。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/05/14/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move_base%20%E5%88%86%E6%9E%90/%E6%9B%B4%E6%8D%A2%E7%AE%97%E6%B3%95%E5%87%BA%E7%8E%B0%E7%9A%84%E7%96%91%E9%9A%BEbug/">动态切换算法出现的疑难bug</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-05-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move-base%E5%88%86%E6%9E%90/">move_base分析</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2023/05/14/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move_base%20%E5%88%86%E6%9E%90/%E6%9B%B4%E6%8D%A2%E7%AE%97%E6%B3%95%E5%87%BA%E7%8E%B0%E7%9A%84%E7%96%91%E9%9A%BEbug/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/05/04/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/Gazebo%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/">Gazebo使用心得</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-05-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/">ROS机器人</a></span><div class="content"><p><strong>Gazebo不好上手，费了一番功夫终于熟悉了，内容太多，只记录注意事项。</strong></p>
<p>Gazebo里用的是<font size="4" color="blue"> 前x 左y 上z的右手坐标系 </font>，gazebo的栅格范围是<code>20mX20m</code></p>
<p>启动<code>simple_world.launch</code>，然后在Gazebo里添加一个圆柱体，保存覆盖<code>simple.world</code>文件。再次启动时，报错 <font color=orange >  SpawnModel: Failure - model name sunny already exist. [Spawn service failed. Exiting. </font> 和 <font color=orange > [spawn_urdf-6] process has died  </font></p>
<p>按<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44236630/article/details/124609824">网上说的方法</a>没能解决，也不能重命名<code>model</code>，修改<code>simple.world</code>无效。 最后删除了<code>&lt;node pkg=&quot;gazebo_ros&quot; type=&quot;spawn_model&quot; name=&quot;spawn_urdf&quot;  args=&quot;-urdf -model sunny -x $(arg x_pos) -y $(arg y_pos) -z $(arg z_pos) -param robot_description&quot; /&gt;</code> 解决问题。</p>
<h2 id="urdf-和-xacro"><a href="#urdf-和-xacro" class="headerlink" title="urdf 和 xacro"></a>urdf 和 xacro</h2><p><code>urdf.xacro</code>文件里，<code>&lt;link name=&quot;base_link&quot;&gt;</code>代表机器人的主体。<code>&lt;geometry&gt; &lt;box size=&quot;0.4 0.39 0.5&quot; /&gt;</code>是尺寸。</p>
<p>gazebo插件，可以简单理解为就是连接gazebo和ros的一个桥梁，一边插件通过gazebo的api来控制仿真环境的机器人关节等数据，一边通过关节数据通过运动学模型生成里程计、雷达的scan、image等类似的信息</p>
<h2 id="solidworks生成urdf"><a href="#solidworks生成urdf" class="headerlink" title="solidworks生成urdf"></a>solidworks生成urdf</h2><p><code>solidworks to urdf</code>安装后，如果在solidworks里找不到，就安装最新版的，不用管版本是否对应。</p>
<p>solidworks只生成的URDF文件，没有xacro文件. URDF文件做一些简单修改可保存为xacro，注意：</p>
<ol>
<li><code>joint</code>的 <code>type=&quot;fixed&quot;</code>，应当为<code>continuous</code></li>
<li><code>joint</code>的某些参数值错误，导致车加载差速模型后，运动错误</li>
</ol>
<h2 id="xacro"><a href="#xacro" class="headerlink" title="xacro"></a>xacro</h2><p>xacro里面的模型仍然是urdf模型，有如下变化：</p>
<ol>
<li>创建宏定义</li>
<li>文件包含</li>
<li>提供可编程接口:常量, 变量, 数学计算, 条件语句</li>
</ol>
<p>启动Gazebo时，机器人模型的tf关系不完整，即使<code>xacro</code>文件正确。还需要添加<code>joint_state_publisher</code> 和<code>robot_state_publisher</code></p>
<p>设置雷达时，看情况决定是否需要可视化<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sensor</span> <span class="attr">type</span>=<span class="string">&quot;ray&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lds_lfcd_sensor&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pose</span>&gt;</span>0 0 0 0 0 0<span class="tag">&lt;/<span class="name">pose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">visualize</span>&gt;</span>false<span class="tag">&lt;/<span class="name">visualize</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Gazebo默认的障碍物质量轻，车撞上之后会把障碍物推开。改变<code>density</code>选项为铁，则不会推动障碍物。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/04/27/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move_base_flex%20%E5%88%86%E6%9E%90/25610/">25610</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-04-27</time><div class="content"><p>void mbf_abstract_nav::AbstractPlannerExecution::run()</p>
<p>The main run method, a thread will execute this method. It contains the main planner execution loop.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PluginType&gt;</span><br><span class="line">AbstractPluginManager&lt;PluginType&gt;::<span class="built_in">AbstractPluginManager</span>(</span><br><span class="line">    <span class="keyword">const</span> std::string &amp;param_name,</span><br><span class="line">    <span class="keyword">const</span> loadPluginFunction &amp;loadPlugin,</span><br><span class="line">    <span class="keyword">const</span> initPluginFunction &amp;initPlugin</span><br><span class="line">)</span><br><span class="line">  : <span class="built_in">param_name_</span>(param_name), <span class="built_in">loadPlugin_</span>(loadPlugin), <span class="built_in">initPlugin_</span>(initPlugin)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">planner_plugin_manager_</span>(<span class="string">&quot;planners&quot;</span>,</span><br><span class="line">  boost::<span class="built_in">bind</span>(&amp;AbstractNavigationServer::loadPlannerPlugin, <span class="keyword">this</span>, _1),</span><br><span class="line">  boost::<span class="built_in">bind</span>(&amp;AbstractNavigationServer::initializePlannerPlugin, <span class="keyword">this</span>, _1, _2)),</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/04/25/C++/C++%20%20%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%AD%97%E7%9A%84%E7%B1%BB%E5%9E%8B/">数字的类型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-04-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E5%9F%BA%E7%A1%80/">C++ 基础</a></span><div class="content"><p>数字后面带个U，L，F的含义</p>
<ul>
<li>U表示该常数用无符号整型方式存储，相当于 unsigned int</li>
<li>L表示该常数用长整型方式存储，相当于 long</li>
<li>F表示该常数用浮点方式存储，相当于 float</li>
</ul>
<p>比如 <code>-1UL</code>, 其实是一个很大很大的数</p>
<h2 id="OpennCV的数据类型"><a href="#OpennCV的数据类型" class="headerlink" title="OpennCV的数据类型"></a>OpennCV的数据类型</h2><p>S = 有符号整型 U = 无符号整型 F = 浮点型</p>
<ul>
<li>CV_8U - 8位无符号整数（0…255）</li>
<li><p>CV_32F - 32位浮点数（-FLT_MAX…FLT_MAX，INF，NAN）</p>
</li>
<li><p>CV_8U - 8位无符号整数（0…255）</p>
</li>
<li><p>CV_8S - 8位有符号整数（-128…127）</p>
</li>
<li><p>CV_16U - 16位无符号整数（0…65535）</p>
</li>
<li><p>CV_16S - 16位有符号整数（-32768…32767）</p>
</li>
<li><p>CV_32S - 32位有符号整数（-2147483648…2147483647）</p>
</li>
<li><p>CV_32F - 32位浮点数（-FLT_MAX…FLT_MAX，INF，NAN）</p>
</li>
<li><p>CV_64F - 64位浮点数（-DBL_MAX…DBL_MAX，INF，NAN）</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/04/04/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/trimmer%E6%9C%BA%E5%88%B6-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%90%E5%9B%BE/">trimmer机制 - 移除重复子图</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-04-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>在<code>PoseGraph2D::HandleWorkQueue</code>里，<code>RunOptimization();</code>之后<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子图的裁剪，如果没有裁剪器就不裁剪</span></span><br><span class="line">   <span class="function">TrimmingHandle <span class="title">trimming_handle</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; trimmer : trimmers_) &#123;</span><br><span class="line">     trimmer-&gt;<span class="built_in">Trim</span>(&amp;trimming_handle);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 这里只有纯定位时才执行</span></span><br><span class="line"><span class="comment">// 裁剪器完成状态，删除裁剪器</span></span><br><span class="line">   trimmers_.<span class="built_in">erase</span>(</span><br><span class="line">       std::<span class="built_in">remove_if</span>(trimmers_.<span class="built_in">begin</span>(), trimmers_.<span class="built_in">end</span>(),</span><br><span class="line">                      [](std::unique_ptr&lt;PoseGraphTrimmer&gt;&amp; trimmer) &#123;</span><br><span class="line">                        <span class="keyword">return</span> trimmer-&gt;<span class="built_in">IsFinished</span>();</span><br><span class="line">                      &#125;),</span><br><span class="line">       trimmers_.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><br><code>trimmers_</code>的添加是 <code>PoseGraph2D</code>构造函数 —— <code>PoseGraph2D::AddTrimmer</code></p>
<p>先看构造函数部分<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options.<span class="built_in">has_overlapping_submaps_trimmer_2d</span>()  )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; trimmer_options = options.<span class="built_in">overlapping_submaps_trimmer_2d</span>();</span><br><span class="line">    <span class="built_in">AddTrimmer</span>(absl::make_unique&lt;OverlappingSubmapsTrimmer2D&gt;(</span><br><span class="line">        trimmer_options.<span class="built_in">fresh_submaps_count</span>(),</span><br><span class="line">        trimmer_options.<span class="built_in">min_covered_area</span>(),</span><br><span class="line">        trimmer_options.<span class="built_in">min_added_submaps_count</span>() )  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>三个参数:</p>
<ol>
<li>fresh_submaps_count = 2    最新的2个submaps</li>
<li>min_covered_area = 3.0     最小未被覆盖的面积</li>
<li>min_added_submaps_count = 5      代表在5个submaps之后才会进行该项操作，这个参数不实用，主要是上面两个</li>
</ol>
<p>Trims submaps that have less than <code>min_covered_cells_count</code> cells not overlapped by at least <code>fresh_submaps_count</code> submaps. 也就是说一些子图如果只有<code>min_covered_cells_count</code>个栅格没有被<code>fresh_submaps_count</code>个子图覆盖，那么这些子图被裁剪掉。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::AddTrimmer</span><span class="params">(std::unique_ptr&lt;PoseGraphTrimmer&gt; trimmer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// C++11 does not allow us to move a unique_ptr into a lambda.</span></span><br><span class="line">  PoseGraphTrimmer* <span class="keyword">const</span> trimmer_ptr = trimmer.<span class="built_in">release</span>();</span><br><span class="line">  <span class="built_in">AddWorkItem</span>([<span class="keyword">this</span>, trimmer_ptr]() <span class="built_in">LOCKS_EXCLUDED</span>(mutex_) &#123;</span><br><span class="line">    absl::MutexLock <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">    trimmers_.<span class="built_in">emplace_back</span>(trimmer_ptr);</span><br><span class="line">    <span class="keyword">return</span> WorkItem::Result::kDoNotRunOptimization;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类<code>PoseGraphTrimmer</code>的派生类有 <code>PureLocalizationTrimmer</code> 和 <code>OverlappingSubmapsTrimmer2D</code>。前者属于纯定位部分，这里不看。后者其实主要就实现了一个<code>Trim</code>函数。 </p>
<p>回头看<code>trimmers_.erase</code>这一句，发现<code>OverlappingSubmapsTrimmer2D::IsFinished()</code>永远返回 false，所以这一句只有纯定位时才会执行，建图不执行。 </p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/03/29/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/frozen%E8%BD%A8%E8%BF%B9%E7%9A%84%E7%89%B9%E7%82%B9/">frozen轨迹的特点</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>frozen轨迹的子图和节点不参与优化问题中的优化，也就是5个残差的计算。但是参与inter global约束的计算，也就是纯定位。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/03/04/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E9%9A%9C%E7%A2%8D%E7%BA%A6%E6%9D%9F%E5%92%8C%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8E%A8%E5%AF%BC/">障碍约束和雅格比矩阵的推导</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/">TEB算法</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E5%90%84%E7%B1%BB%E7%BA%A6%E6%9D%9F%E5%8F%8A%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5/">各类约束及雅格比矩阵</a></span><div class="content"><p>障碍约束定义的误差函数表示机器人到障碍的最小距离。 $ \min \textrm{penaltyBelow}( dist2point ) \cdot weight $. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VertexPose* bandpt = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> VertexPose*&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// calculateDistance(const PoseSE2&amp; current_pose, const Obstacle* obstacle) 计算机器人到障碍物的距离</span></span><br><span class="line"><span class="comment">// current_pose为当前机器人的位姿。</span></span><br><span class="line"><span class="keyword">double</span> dist = robot_model_-&gt;<span class="built_in">calculateDistance</span>(bandpt-&gt;<span class="built_in">pose</span>(), _measurement);</span><br><span class="line">_error[<span class="number">0</span>] = <span class="built_in">penaltyBoundFromBelow</span>(dist, cfg_-&gt;obstacles.min_obstacle_dist, cfg_-&gt;optim.penalty_epsilon);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cfg_-&gt;optim.obstacle_cost_exponent != <span class="number">1.0</span> &amp;&amp; cfg_-&gt;obstacles.min_obstacle_dist &gt; <span class="number">0.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  _error[<span class="number">0</span>] = cfg_-&gt;obstacles.min_obstacle_dist * std::<span class="built_in">pow</span>(_error[<span class="number">0</span>] / cfg_-&gt;obstacles.min_obstacle_dist, </span><br><span class="line">  										cfg_-&gt;optim.obstacle_cost_exponent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>obstacle_cost_exponent</code>和<code>min_obstacle_dist</code>的设置，一般都会进入if情况。 注意 max cost (before weighting) is the same as the straight line version and that all other costs are below the straight line (for positive exponent), so it may be necessary to increase weight_obstacle and/or the inflation_weight when using larger exponents.</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/03/04/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4%E7%BA%A6%E6%9D%9F%E5%92%8Ckinematics%E7%BA%A6%E6%9D%9F%E5%8F%8A%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8E%A8%E5%AF%BC/">时间约束和kinematics约束及雅格比矩阵的推导</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/">TEB算法</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E5%90%84%E7%B1%BB%E7%BA%A6%E6%9D%9F%E5%8F%8A%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5/">各类约束及雅格比矩阵</a></span><div class="content"><h2 id="时间约束"><a href="#时间约束" class="headerlink" title="时间约束"></a>时间约束</h2><p><code>EdgeTimeOptimal</code>类太简单了，误差函数 <code>_error[0] = timediff-&gt;dt();</code>，优化 <script type="math/tex">\Delta T_i</script>，那么对其求偏导，显然只有一个矩阵，一个元素 1 ： <code>_jacobianOplusXi( 0 , 0 ) = 1;</code></p>
<h2 id="kinematics-约束"><a href="#kinematics-约束" class="headerlink" title="kinematics 约束"></a>kinematics 约束</h2><p>两个误差方程，一个是 non-holonomic约束， ：<br><img src="https://s2.loli.net/2023/03/09/fA3hlesp26nZrN7.png" alt=""><br>初始配置<script type="math/tex">x_i</script>和方向<script type="math/tex">d_i,d_{i+1}</script>之间的角度<script type="math/tex">\theta _i</script> 必须等于配置<script type="math/tex">x_{i+1}</script>和方向<script type="math/tex">d_i,d_{i+1}</script>之间的夹角，即<script type="math/tex">\theta _i = \theta_{i+1}</script></p>
<p>根据二维叉积 A×B=|A| |B|⋅sinα 得到<br><img src="https://s2.loli.net/2023/03/09/XRLQ2BNg1Mu8VfE.png" alt=""><br>所以代码中的目标函数写成</p>
<script type="math/tex; mode=display">|(cos{\theta_1}+cos{\theta_2})(y_2-y_1) - (sin{\theta_1}+sin{\theta_2})(x_2-x_1) |</script><p>另一个是 positive-drive-direction约束</p>
<script type="math/tex; mode=display">-(x_2-x_1)cos{\theta_1} -(y_2-y_1)sin{\theta_1}</script><p>两个configure，所以两个雅格比，维度明显是 2x3，两个误差方程分别对(x, y, angle)求偏导，源码里的求导很简单，还不如速度约束的求导复杂，就不写过程了。</p>
<p>值得注意的是绝对值的求导结果会用<code>sign</code>函数表示。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/03/04/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E5%8A%A0%E9%80%9F%E5%BA%A6%E7%BA%A6%E6%9D%9F%E5%8F%8A%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8E%A8%E5%AF%BC/">加速度约束和雅格比矩阵的推导</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/">TEB算法</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E5%90%84%E7%B1%BB%E7%BA%A6%E6%9D%9F%E5%8F%8A%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5/">各类约束及雅格比矩阵</a></span><div class="content"><p>默认为5元边约束。 但是包含3个类：<code>EdgeAcceleration</code>, <code>EdgeAccelerationStart</code>, <code>EdgeAccelerationGoal</code>，后两个为3元边</p>
<p><script type="math/tex">\frac{error}{cost}</script> 向量的维度是2，第一个元素代表线加速度，第二个是角加速度。<br><code>EdgeAccelerationStart()</code> and <code>EdgeAccelerationGoal()</code> 用于边界值</p>
<p>加速度约束和速度约束类似，不过变成两段圆弧和角度差、两个时间差、两个线速度和角速度。两个线速度的差除以两个时间差之和就是加速度。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> vel1 = dist1 / dt1-&gt;<span class="built_in">dt</span>();</span><br><span class="line"><span class="keyword">double</span> vel2 = dist2 / dt2-&gt;<span class="built_in">dt</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> acc_lin  = (vel2 - vel1)*<span class="number">2</span> / ( dt1-&gt;<span class="built_in">dt</span>() + dt2-&gt;<span class="built_in">dt</span>() );</span><br><span class="line">_error[<span class="number">0</span>] = <span class="built_in">penaltyBoundToInterval</span>(acc_lin,cfg_-&gt;robot.acc_lim_x, cfg_-&gt;optim.penalty_epsilon);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> omega1 = angle_diff1 / dt1-&gt;<span class="built_in">dt</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> omega2 = angle_diff2 / dt2-&gt;<span class="built_in">dt</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> acc_rot  = (omega2 - omega1)*<span class="number">2</span> / ( dt1-&gt;<span class="built_in">dt</span>() + dt2-&gt;<span class="built_in">dt</span>() );</span><br><span class="line">_error[<span class="number">1</span>] = <span class="built_in">penaltyBoundToInterval</span>(acc_rot,cfg_-&gt;robot.acc_lim_theta, cfg_-&gt;optim.penalty_epsilon);</span><br></pre></td></tr></table></figure></p>
<h3 id="起点的加速度约束"><a href="#起点的加速度约束" class="headerlink" title="起点的加速度约束"></a>起点的加速度约束</h3><p>注意：起点加速度约束和终点加速度约束都是3元边。</p>
<p>对于起点的加速度约束，源码有以下变化:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInitialVelocity</span><span class="params">(<span class="keyword">const</span> geometry_msgs::Twist&amp; vel_start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_measurement = &amp;vel_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_ASSERT_MSG</span>(cfg_ &amp;&amp; _measurement, </span><br><span class="line"><span class="string">&quot;You must call setTebConfig() and setInitialVelocity() on EdgeAccelerationStart()&quot;</span>);</span><br><span class="line">vel1 = _measurement-&gt;linear.x;</span><br><span class="line">omega1 = _measurement-&gt;angular.z;</span><br></pre></td></tr></table></figure><br>其他全一样，对于终点的加速度约束，则是<code>vel2</code>和<code>omega2</code>换成了<code>_measurement</code>的成员。那么这个<code>_measurement</code>从何而来？</p>
<p>在<code>TebOptimalPlanner::plan</code>里有一段:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (start_vel)</span><br><span class="line">  <span class="built_in">setVelocityStart</span>(*start_vel);</span><br><span class="line"><span class="keyword">if</span> (free_goal_vel)</span><br><span class="line">  <span class="built_in">setVelocityGoalFree</span>();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  vel_goal_.first = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>setVelocityStart</code>给起始速度赋值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::pair&lt;bool, geometry_msgs::Twist&gt;  vel_start_;</span></span><br><span class="line"><span class="comment">// 注意vel_start_ 和 vel_start 不同</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TebOptimalPlanner::setVelocityStart</span><span class="params">(<span class="keyword">const</span> geometry_msgs::Twist&amp; vel_start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vel_start_.first = <span class="literal">true</span>;</span><br><span class="line">  vel_start_.second.linear.x = vel_start.linear.x;</span><br><span class="line">  vel_start_.second.linear.y = vel_start.linear.y;</span><br><span class="line">  vel_start_.second.angular.z = vel_start.angular.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后到了<code>AddEdgesAcceleration</code>里添加起始加速度约束，才用到<code>vel_start_</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vel_start_.first)</span><br><span class="line">&#123;</span><br><span class="line">  EdgeAccelerationStart* acceleration_edge = <span class="keyword">new</span> EdgeAccelerationStart;</span><br><span class="line">  acceleration_edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>,teb_.<span class="built_in">PoseVertex</span>(<span class="number">0</span>));</span><br><span class="line">  acceleration_edge-&gt;<span class="built_in">setVertex</span>(<span class="number">1</span>,teb_.<span class="built_in">PoseVertex</span>(<span class="number">1</span>));</span><br><span class="line">  acceleration_edge-&gt;<span class="built_in">setVertex</span>(<span class="number">2</span>,teb_.<span class="built_in">TimeDiffVertex</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="comment">// 这里就是上面的 setInitialVelocity, _measurement 就是 vel_start_.second</span></span><br><span class="line">  acceleration_edge-&gt;<span class="built_in">setInitialVelocity</span>(vel_start_.second);</span><br><span class="line">  acceleration_edge-&gt;<span class="built_in">setInformation</span>(information);</span><br><span class="line">  acceleration_edge-&gt;<span class="built_in">setTebConfig</span>(*cfg_);</span><br><span class="line">  optimizer_-&gt;<span class="built_in">addEdge</span>(acceleration_edge);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>AddEdgesAcceleration</code>然后添加普通的加速度约束，再就是终点的加速度约束，这里就奇怪了，相应的<code>setVelocityGoal</code>函数没有调用的地方，这里是<code>vel_goal_.second</code>唯一赋值的地方。即使<code>free_goal_vel</code>为false，也没有赋值，意思是终点的速度为0？</p>
<p>雅格比矩阵的推导可以参照速度约束的，不同的地方是这次把角度单独拿出来了，这样有了8个雅格比<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_jacobianOplus[<span class="number">0</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// conf1</span></span><br><span class="line">_jacobianOplus[<span class="number">1</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// conf2</span></span><br><span class="line">_jacobianOplus[<span class="number">2</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// conf3</span></span><br><span class="line">_jacobianOplus[<span class="number">3</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">// deltaT1</span></span><br><span class="line">_jacobianOplus[<span class="number">4</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">// deltaT2</span></span><br><span class="line">_jacobianOplus[<span class="number">5</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">// angle1</span></span><br><span class="line">_jacobianOplus[<span class="number">6</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">// angle2</span></span><br><span class="line">_jacobianOplus[<span class="number">7</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">// angle3</span></span><br></pre></td></tr></table></figure><br>既然拿出了角度，那么对<code>conf</code>的雅格比矩阵的维度就变成了 2x2，不是2x3。两个误差函数，一个是线速度的，一个是角速度的</p>
<p><font size="4" color="blue"> 代码中的 double aux0 = 2/sum_time_inv; 错了  </font> 应当是 <code>double aux0 = 2/sum_time;</code><br><img src="https://s2.loli.net/2023/03/04/UWQmsEB4AHIGSOr.png" alt="J[0](0,0)的推导过程"><br>其他项以此类推</p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/61/">61</a><a class="extend next" rel="next" href="/page/2/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2023 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>