<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">529</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">48</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/02/18/exLTfbM3uFOq5SV.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2022/05/19/7923/">7923</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-19</time><div class="content"></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/05/19/C++/Boost/(%E4%B8%83)%20R%E6%A0%91-%E7%A9%BA%E9%97%B4%E7%B4%A2%E5%BC%95/">(七) R树-空间索引</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/Boost/">Boost</a></span><div class="content"><p>R树是为了加快地理方面的计算，构建一颗R树，然后非常方便的往R树里添加矩形索引。</p>
<p>namespace bgi = bg::index;</p>
<p>using RTree = bgi::rtree<Value, bgi::quadratic<16, 4>&gt;;</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/05/19/C++/Boost/(%E5%85%AD)%20geometry/">(六) geometry</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/Boost/">Boost</a></span><div class="content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/assign.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/geometry/geometry.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/geometry/geometries/point_xy.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/geometry/geometries/linestring.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/geometry/geometries/box.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/geometry/geometries/ring.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/geometry/geometries/polygon.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/geometry/algorithms/transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> bg = boost::geometry;</span><br><span class="line"><span class="keyword">namespace</span> bgi = bg::index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Point = bg::model::point&lt;<span class="keyword">double</span>, <span class="number">2</span>, bg::cs::cartesian&gt;;</span><br><span class="line"><span class="keyword">using</span> Box = bg::model::box&lt;Point&gt;;</span><br><span class="line"><span class="keyword">using</span> Line = bg::model::linestring&lt;Point&gt;;</span><br><span class="line"><span class="comment">// 线段</span></span><br><span class="line"><span class="keyword">using</span> Segment = bg::model::segment&lt;Point&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;test_boost&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="function">Point <span class="title">pt0</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">pt1</span><span class="params">(<span class="number">200</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 点的间距</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;distance from pt0 to pt1: &quot;</span>&lt;&lt; bg::<span class="built_in">distance</span>(pt0, pt1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">Segment <span class="title">s1</span><span class="params">(Point(<span class="number">0</span>, <span class="number">100</span>), Point(<span class="number">100</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="function">Segment <span class="title">s2</span><span class="params">(Point(<span class="number">0</span>, <span class="number">0</span>), Point(<span class="number">120</span>, <span class="number">120</span>))</span></span>;</span><br><span class="line">    <span class="comment">// 点到线段的距离，垂足不一定在线段上</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;distance from pt0 to s1: &quot;</span> &lt;&lt; bg::<span class="built_in">distance</span>(pt0, s1) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 两线段是否相交</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is segment1 and segment2 intersect:  &quot;</span> &lt;&lt; bg::<span class="built_in">intersects</span>(s1, s2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    std::list&lt;Point&gt; points;</span><br><span class="line">    <span class="comment">// 两线段的交点</span></span><br><span class="line">    bg::<span class="built_in">intersection</span>(s1, s2, points);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : points)</span><br><span class="line">	cout &lt;&lt; bg::<span class="built_in">dsv</span>(p) &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断box是否相交</span></span><br><span class="line">    <span class="function">Box <span class="title">rc</span><span class="params">(Point(<span class="number">0</span>, <span class="number">0</span>), Point(<span class="number">200</span>, <span class="number">200</span>))</span></span>;</span><br><span class="line">    <span class="function">Box <span class="title">rc0</span><span class="params">(Point(<span class="number">250</span>, <span class="number">250</span>), Point(<span class="number">450</span>, <span class="number">450</span>))</span></span>;</span><br><span class="line">    <span class="function">Box <span class="title">rc1</span><span class="params">(Point(<span class="number">100</span>, <span class="number">100</span>), Point(<span class="number">300</span>, <span class="number">300</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rc and rc0 intersect:  &quot;</span> &lt;&lt; bg::<span class="built_in">intersects</span>(rc, rc0) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rc and rc1 intersect:  &quot;</span> &lt;&lt; bg::<span class="built_in">intersects</span>(rc, rc1) &lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求外接矩形Bounding Box</span></span><br><span class="line">    Line line = &#123; &#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">0</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>&#125; &#125;;</span><br><span class="line">	Box box;</span><br><span class="line">	bg::<span class="built_in">envelope</span>(line, box);</span><br><span class="line">	std::cout &lt;&lt; bg::<span class="built_in">dsv</span>(line) &lt;&lt; <span class="string">&quot;&#x27;s AABB is &quot;</span> &lt;&lt; bg::<span class="built_in">dsv</span>(box) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意直线的初始化和线段是不一样的</p>
<p>参考:<br><a target="_blank" rel="noopener" href="https://www.guyuehome.com/37135">SLAM本质剖析-Boost</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/iluopu/article/details/124034790">boost::geometry简介</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/05/18/C++/C++%20%20%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/find%20%E5%92%8C%20find_if,%20find_if_not/">find 和 find_if, find_if_not</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/">C++ 模板与STL</a></span><div class="content"><p>头文件： <code>#include &lt;algorithm&gt;</code></p>
<p>返回范围 <code>[first, last)</code> 中满足特定判别标准的首个元素:</p>
<ul>
<li><p>find:     搜索等于 value 的元素</p>
</li>
<li><p>find_if:    根据指定的查找规则，在指定区域内查找第一个符合该函数要求（使函数返回 true）的元素。如果查找成功，该迭代器指向的是查找到的那个元素；反之，如果查找失败，该迭代器的指向和 last 迭代器相同</p>
</li>
<li><p>find_if_not:    与find_if相反</p>
</li>
</ul>
<p>示例代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; score&#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it_1 = std::<span class="built_in">find</span>(score.<span class="built_in">begin</span>(), score.<span class="built_in">end</span>(), <span class="number">30</span> );</span><br><span class="line"><span class="keyword">if</span>(it_1 != score.<span class="built_in">end</span>() )</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt; <span class="string">&quot;found !&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">qDebug</span>()&lt;&lt; <span class="string">&quot;no found !&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it_2 = std::<span class="built_in">find_if</span>(score.<span class="built_in">begin</span>(), score.<span class="built_in">end</span>(), [](<span class="keyword">int</span>&amp; m)&#123;<span class="keyword">return</span> m&gt;<span class="number">20</span>;&#125;  );</span><br><span class="line"><span class="keyword">if</span>(it_2 != score.<span class="built_in">end</span>() )</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt; <span class="string">&quot;found: &quot;</span> &lt;&lt; *it_2;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">qDebug</span>()&lt;&lt; <span class="string">&quot;no found !&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>若作为算法一部分调用的函数的执行抛出异常，且 ExecutionPolicy 为标准策略之一，则调用 std::terminate 。对于任何其他 ExecutionPolicy ，行为是实现定义的。</li>
<li>若算法无法分配内存，则抛出 std::bad_alloc </li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/05/18/C++/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%92%8Catomic%E5%85%B3%E9%94%AE%E5%AD%97/">原子操作和atomic关键字</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span><div class="content"><p>std::atomic<int></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int v = 0;</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++)</span><br><span class="line">        ++v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(Test)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(Test)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v: &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只用简单的全局变量<code>int v = 0;</code>，结果一般不是20000。  换上<code>std::atomic&lt;int&gt; v(0);</code>，结果必为20000</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://zyfjeff.github.io/%E5%8D%9A%E5%AE%A2/doc/cpp/Effective-Model-Cpp/item40/">Item40 Use std::atomic for concurrency</a><br><a target="_blank" rel="noopener" href="https://www.huliujia.com/blog/df3c2e8a9ef77bd2ed0d83292778734eb395970c/">聊一聊原子操作</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/8638.html">C++11多线程编程详解</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/05/18/C++/C++%20%20%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/pre%E5%92%8Cnext/">pre和next</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/">C++ 模板与STL</a></span><div class="content"><h2 id="std-prev"><a href="#std-prev" class="headerlink" title="std::prev"></a>std::prev</h2><p>原型<code>template &lt;class BidirectionalIterator&gt;
    BidirectionalIterator prev (BidirectionalIterator it, typename iterator_traits&lt;BidirectionalIterator&gt;::difference_type n = 1);</code></p>
<p>该函数会返回一个距离 it 迭代器 n 个元素的新迭代器。当 n 为正数时，其返回的迭代器将位于 it 左侧；反之，当 n 为负数时，其返回的迭代器位于 it 右侧。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span>     <span class="comment">// std::next</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span>         <span class="comment">// std::list</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化一个 list 容器</span></span><br><span class="line">    std::list&lt;<span class="keyword">int</span>&gt; mylist&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    std::list&lt;<span class="keyword">int</span>&gt;::iterator it = mylist.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">//获取一个距离 it 迭代器 2 个元素的迭代器，由于 2 为正数，newit 位于 it 左侧</span></span><br><span class="line">    <span class="keyword">auto</span> newit = <span class="built_in">prev</span>(it, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;prev(it, 2) = &quot;</span> &lt;&lt; *newit &lt;&lt; endl;   <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//n为负数，newit 位于 it 右侧</span></span><br><span class="line">    it = mylist.<span class="built_in">begin</span>();</span><br><span class="line">    newit = <span class="built_in">prev</span>(it, <span class="number">-2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;prev(it, -2) = &quot;</span> &lt;&lt; *newit;   <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>prev()</code> 函数自身不会检验新迭代器的指向是否合理，需要我们自己来保证其合理性。</p>
<p><code>next()</code>函数和<code>prev()</code>函数恰好相反</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/05/17/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/pbstream_main%E7%9A%84%E4%BD%BF%E7%94%A8/">pbstream_main的使用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/">原理和配置</a></span><div class="content"><p>旧版本为<code>cartographer_pbstream</code></p>
<p>源码是<code>pbstream_main.cc</code>，又实际调用了<code>pbstream_info.cc</code> 和 <code>pbstream_migrate.cc</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  google::<span class="built_in">InitGoogleLogging</span>(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  FLAGS_logtostderr = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> std::string usage_message =</span><br><span class="line">      <span class="string">&quot;Swiss Army knife for pbstreams.\n\n&quot;</span></span><br><span class="line">      <span class="string">&quot;Currently supported subcommands are:\n&quot;</span></span><br><span class="line">      <span class="string">&quot;\tinfo    - Prints summary of pbstream.\n&quot;</span></span><br><span class="line">      <span class="string">&quot;\tmigrate - Migrates old pbstream (w/o header) to new pbstream format.&quot;</span>;</span><br><span class="line">  google::<span class="built_in">ParseCommandLineFlags</span>(&amp;argc, &amp;argv, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    google::<span class="built_in">SetUsageMessage</span>(usage_message);</span><br><span class="line">    google::<span class="built_in">ShowUsageWithFlagsRestrict</span>(argv[<span class="number">0</span>], <span class="string">&quot;pbstream_info_main&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">string</span>(argv[<span class="number">1</span>]) == <span class="string">&quot;info&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ::cartographer::io::<span class="built_in">pbstream_info</span>(argc, argv);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">string</span>(argv[<span class="number">1</span>]) == <span class="string">&quot;migrate&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ::cartographer::io::<span class="built_in">pbstream_migrate</span>(argc, argv);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他情况会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可执行文件在<code>carto_ws/install_isolated/bin</code></p>
<h2 id="pbstream-main-info"><a href="#pbstream-main-info" class="headerlink" title="pbstream_main info"></a>pbstream_main info</h2><p>终端执行<code>pbstream_main info</code>，调用<code>pbstream_info</code>：打印出<code>pbstream</code>文件的概况，路径支持环境变量。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./pbstream_main info <span class="variable">$MAPS</span>/file.pbstream</span><br></pre></td></tr></table></figure><br>结果的中间一大部分是采用的lua参数，如果不想显示这些参数，注释掉源码里的<code>LOG(INFO) &lt;&lt; &quot;Trajectory options: &quot; &lt;&lt; trajectory_options.DebugString();</code></p>
<p>结果如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Reading pbstream file from <span class="string">&#x27;/home/xiaoqiang/carto_ws/maps/file.pbstream&#x27;</span>...</span><br><span class="line">Header: format_version: 2</span><br><span class="line">Trajectory options: sensor_id &#123;</span><br><span class="line">  id: <span class="string">&quot;scan&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">sensor_id &#123;</span><br><span class="line">  <span class="built_in">type</span>: IMU</span><br><span class="line">  id: <span class="string">&quot;imu&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">sensor_id &#123;</span><br><span class="line">  <span class="built_in">type</span>: ODOMETRY</span><br><span class="line">  id: <span class="string">&quot;odom&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ......省略lua参数</span></span><br><span class="line">Trajectory id: 0 has <span class="comment">#nodes 9778 has #submaps 161</span></span><br><span class="line">SerializedData package contains <span class="comment">#node: 9778</span></span><br><span class="line">SerializedData package contains <span class="comment">#odometry_data: 49697</span></span><br><span class="line"></span><br><span class="line">SerializedData package contains <span class="comment">#submap: 161</span></span><br><span class="line">SerializedData package contains <span class="comment">#submap_2d: 161</span></span><br><span class="line">SerializedData package contains <span class="comment">#submap_2d_grid: 161</span></span><br><span class="line"></span><br><span class="line">SerializedData package contains <span class="comment">#submap_3d: 0</span></span><br><span class="line">SerializedData package contains <span class="comment">#submap_3d_high_resolution_hybrid_grid: 0</span></span><br><span class="line">SerializedData package contains <span class="comment">#trajectory_data: 1</span></span><br></pre></td></tr></table></figure><br>不要在最后加<code>-all_debug_strings=true</code>，否则打印出无穷无尽的内容，包括了栅格值和子图转换表等等。</p>
<h2 id="pbstream-main-migrate"><a href="#pbstream-main-migrate" class="headerlink" title="pbstream_main migrate"></a>pbstream_main migrate</h2><p>终端执行<code>pbstream_main migrate</code>，调用<code>pbstream_migrate</code>：把<code>pbstream</code>文件移植到新的子图格式。把未使用histogram的子图文件移植为包含histogram的子图格式。如果想在输出文件中排除未完成的子图，设置<code>--include_unfinished_submaps</code>为false</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/05/17/%E8%87%AA%E4%B8%BB%E6%8E%A2%E7%B4%A2/cartographer_frontier_detection/%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%E8%AE%B0%E5%BD%95/">代码修改记录</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%87%AA%E4%B8%BB%E6%8E%A2%E7%B4%A2/">自主探索</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%87%AA%E4%B8%BB%E6%8E%A2%E7%B4%A2/cartographer-frontier-detection/">cartographer_frontier_detection</a></span><div class="content"><p><code>node_main.cc</code>无修改。   <code>node.cc</code>只有细节不同，可以忽略</p>
<h2 id="map-builder-bridge-cc"><a href="#map-builder-bridge-cc" class="headerlink" title="map_builder_bridge.cc"></a>map_builder_bridge.cc</h2><p><code>MapBuilderBridge</code>类增加变量<code>std::atomic&lt;int&gt; optimizations_performed_;</code>，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MapBuilderBridge::<span class="built_in">MapBuilderBridge</span>(</span><br><span class="line">    <span class="keyword">const</span> NodeOptions&amp; node_options,</span><br><span class="line">    std::unique_ptr&lt;cartographer::mapping::MapBuilderInterface&gt; map_builder,</span><br><span class="line">    tf2_ros::Buffer* <span class="keyword">const</span> tf_buffer)</span><br><span class="line">    : <span class="built_in">node_options_</span>(node_options),</span><br><span class="line">      <span class="built_in">map_builder_</span>(std::<span class="built_in">move</span>(map_builder)),</span><br><span class="line">      <span class="built_in">tf_buffer_</span>(tf_buffer),</span><br><span class="line">      <span class="comment">// 增加</span></span><br><span class="line">      <span class="built_in">optimizations_performed_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">frontier_detector_</span>(<span class="keyword">static_cast</span>&lt;cartographer::mapping::PoseGraph*&gt;(</span><br><span class="line">          map_builder_-&gt;<span class="built_in">pose_graph</span>())  )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 增加</span></span><br><span class="line">  map_builder_-&gt;<span class="built_in">pose_graph</span>()-&gt;<span class="built_in">SetGlobalSlamOptimizationCallback</span>(</span><br><span class="line">      std::<span class="built_in">bind</span>(&amp;MapBuilderBridge::OnGlobalSlamResult, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个回调函数其实是把后端的那个同名变量传过来，因为优化次数统计是在后端</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MapBuilderBridge::OnGlobalSlamResult</span><span class="params">()</span> </span>&#123; optimizations_performed_++; &#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">MapBuilderBridge</span>() &#123; frontier_detector_.<span class="built_in">NotifyEnd</span>();  &#125;</span><br></pre></td></tr></table></figure>
<p><code>MapBuilderBridge::GetSubmapList()</code>中添加一行： <code>submap_list.optimizations_performed = optimizations_performed_;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MapBuilderBridge::OnLocalSlamResult</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">int</span> trajectory_id,   <span class="keyword">const</span> ::cartographer::common::Time time,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Rigid3d  local_pose,</span></span></span><br><span class="line"><span class="params"><span class="function">    ::cartographer::sensor::RangeData  range_data_in_local,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// 增加 InsertionResult</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::unique_ptr&lt;<span class="keyword">const</span> ::cartographer::mapping::</span></span></span><br><span class="line"><span class="params"><span class="function">                          TrajectoryBuilderInterface::InsertionResult&gt;&amp;  insertion_result )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::shared_ptr&lt;<span class="keyword">const</span> LocalTrajectoryData::LocalSlamData&gt; local_slam_data =</span><br><span class="line">      std::make_shared&lt;LocalTrajectoryData::LocalSlamData&gt;(</span><br><span class="line">          LocalTrajectoryData::LocalSlamData&#123;time, local_pose,</span><br><span class="line">                                             std::<span class="built_in">move</span>(range_data_in_local)&#125; );</span><br><span class="line">  <span class="function">absl::MutexLock <span class="title">lock</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  local_slam_data_[trajectory_id] = std::<span class="built_in">move</span>(local_slam_data);</span><br><span class="line">  <span class="comment">// 最关键，这里是唯一调用了 frontier_detector_ 函数的地方</span></span><br><span class="line">  <span class="keyword">if</span> (insertion_result)</span><br><span class="line">    frontier_detector_.<span class="built_in">HandleSubmapUpdates</span>( insertion_result-&gt;insertion_submap_ids);</span><br><span class="line">  <span class="comment">// frontier_detector_.publishUpdatedFrontiers();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>struct InsertionResult</code>增加了一个成员：<code>std::vector&lt;SubmapId&gt; insertion_submap_ids;</code></p>
<h2 id="offline-node-cc"><a href="#offline-node-cc" class="headerlink" title="offline_node.cc"></a>offline_node.cc</h2><p>去掉了<code>async_spinner.start();</code></p>
<p>增加3个变量<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> total_submap_updates;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> optimization_events;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> skipped_updates;</span><br></pre></td></tr></table></figure></p>
<h2 id="pose-graph-2d-h"><a href="#pose-graph-2d-h" class="headerlink" title="pose_graph_2d.h"></a>pose_graph_2d.h</h2><p><code>PoseGraph2D</code>类增加变量<code>std::atomic&lt;int&gt; optimizations_performed_;</code></p>
<p>函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">optimizations_performed</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> optimizations_performed_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="pose-graph-2d-cc"><a href="#pose-graph-2d-cc" class="headerlink" title="pose_graph_2d.cc"></a>pose_graph_2d.cc</h2><p><code>PoseGraph2D</code>构造函数增加<code>optimizations_performed_(0)</code></p>
<p><code>PoseGraph2D::AppendNode</code>的返回类型改为<code>std::pair&lt;NodeId, vector&lt;SubmapId&gt;</code>，原来是<code>NodeId</code>， 最后增加<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;SubmapId&gt; submap_ids;</span><br><span class="line"><span class="keyword">auto</span> submap_data_iter =</span><br><span class="line">  std::<span class="built_in">prev</span>(data_.submap_data.<span class="built_in">EndOfTrajectory</span>(trajectory_id),</span><br><span class="line">            insertion_submaps.<span class="built_in">size</span>()  );</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(insertion_submaps.<span class="built_in">size</span>()); ++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">CHECK_EQ</span>(submap_data_iter-&gt;data.submap, insertion_submaps.<span class="built_in">at</span>(i));</span><br><span class="line">	submap_ids.<span class="built_in">push_back</span>(submap_data_iter-&gt;id);</span><br><span class="line">	++submap_data_iter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;node_id, submap_ids&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>PoseGraph2D::RunOptimization</code>的最后增加<code>optimizations_performed_++;</code>，用于统计优化次数。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/05/16/%E8%87%AA%E4%B8%BB%E6%8E%A2%E7%B4%A2/cartographer_frontier_detection/%E8%AE%BA%E6%96%87%20Efficient%20Dense%20Frontier%20Detection%20for%202D%20Graph/">论文 Efficient Dense Frontier Detection for 2D Graph</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%87%AA%E4%B8%BB%E6%8E%A2%E7%B4%A2/">自主探索</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%87%AA%E4%B8%BB%E6%8E%A2%E7%B4%A2/cartographer-frontier-detection/">cartographer_frontier_detection</a></span><div class="content"><p><img src="https://s2.loli.net/2022/05/16/sA3XnlIBq5QHx7g.png" alt="原理图.png"></p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>从Yamauchi在1997年的论文开始，后来有了复杂的探索策略用于多个机器人的探索。</p>
<p>简单的frontier检测是在每次地图更新后，对整个地图进行边缘检测(edge detection)。但是这种方法对大规模地图不实用，而且构成的计算量也太大。</p>
<p>2014年，Keida 和 Kaminka提出两种方法：Wavefront Frontier Detector(WFD) 和  the Fast Frontier Detector (FFD). 都有一些缺点。FFD提出了<strong>活跃区域</strong>(active area)的概念，在地图上围绕机器人位置的一个边界框，限定了更新地图的最后scan。frontier的update step 由于限定在活跃区域而得到了加快。本论文提出的算法有类似的概念：<strong>活跃子图</strong>(active submaps)</p>
<p>loop closure对frontier检测的影响：为了返回正确的结果，frontier检测必须能处理loop closure引起的地图变化。这些地图变化不是只限于<strong>活跃区域</strong>，而是遍布整个地图。高效的frontier检测算法应该避免每次遍历时都要处理整个地图，而把算法限定在活跃区域又导致对loop closure不鲁棒。</p>
<p>Keidar and Kaminka 提出了针对Gmapping算法而实现的WFD-INC算法，本论文的算法则针对cartographer。Quin and Alempijevic提出两种frontier检测算法，一个就是限定在活跃区域的，另一个认为<strong>每个地图栅格的熵(entropy)只会随时间而减小</strong>。对于考虑了loop closure的完整地图来说，这种假设不正确，在loop closure时观察的区域会移动 and leave unexplored space in their wake. 但是对于每个子图来说，熵降低的假设基本正确，本论文正是利用了这一点。</p>
<p>Umari 提出了RRT算法进行稀疏的frontier检测，方式是在地图的空闲区域创建树，当算法扩展随机树穿越了frontier时，就会检测到单独的frontier点。但是算法在每次遍历时不要求重组全局地图，而且算法对loop closure不鲁棒，因为创建RRT树不是根据pose graph优化的结果，所以不能和cartographer搭配。<strong>RRT的frontier检测算法在窄通道和大地图的情况下出现多种问题。</strong></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>子图栅格的熵可认为是单调递减： 一旦进入<code>observed</code>状态，活跃子图(active submap)的栅格不会成为<code>unobserved</code></p>
<h2 id="frontier-detection"><a href="#frontier-detection" class="headerlink" title="frontier detection"></a>frontier detection</h2><script type="math/tex; mode=display">S^{si}_{k,j}$$ 是子图$$si$$中栅格(k,l)的占据概率

- Occupancy classification: 栅格的占据概率不是在frontier detection中直接使用的。

- 局部边界点(Local frontier point): 子图中未观测栅格的中心，这个栅格近邻一个空闲栅格。子图的局部边界(local frontier)是一系列的局部边界点。

- stabbing query: 对于一个给定的全局点，在给定的子图里寻找相应的栅格。具体说，对于子图 *si* 和全局点 $$p^g$$，寻找子图的栅格索引*(k, l)*，这个栅格在子图*si*对应的local坐标系的坐标是最接近 $$(T^{si}_{g})^{-1} \ p^g$$ 的栅格。`stabbing query test`的意思是检查栅格*(k ,l)*是未观测的栅格，如果是，测试通过了。

- 全局边界点(global frontier point): 未观测的全局地图栅格，它近邻一个空闲的全局地图栅格。valid全局边界点必须通过所有子图的stabbing query test。全局边界是给定时间的一系列valid全局边界点。

- perimeter: 全局或局部边界包含的边界点的个数。

<br>

### 处理子图的更新

算法1的6-10行，在子图层面使用普通的边界检测方法，而不是其他复杂的方法。原因有两个，(一) 由于子图大小受限制(参数 num_scans)和活跃子图只有2个，局部边界检测的时间复杂度不收全局地图或数据集规模的影响。 (二) 算法的 classification (line 6) and edge detection (lines 7– 9) 可以向量化，这样在CPU上可以有好的表现。论文的实现基于Eigen，使用 Eigen’s matrix block algebra and Hadamard products to vectorize thresholding, classification and Boolean logic for edge detection.

算法13行的stabbing query test，如果未通过，相应的子图会记录为 `hint` (Algorithm 2, line 5)，这样在未来的再次测试(算法3)可以运行快一些。

1. 已经完成的子图的栅格不再变化，因此对已完成的子图，没必要再检测**局部边界**

2. 处理子图更新的算法部分，假设从上次子图更新后没有发生后端优化，这样所有已完成子图的现有全局边界valid

3. 活跃子图的占据概率的熵一直下降，所以只有之前未观测的栅格变为已观测，没有反过来的情况。所以，子图的更新可能会遮盖住之前intersecting submaps的全局边界。在算法1的11-13行进行测试是否遮盖，方式是对全局边界点和活跃子图进行stabbing query test



- 已完成子图的bounding box保存在树数据结构里，可以快速query和给定bounding box相交的子图。论文使用Boost实现R树保存已完成子图的global axis-aligned bounding boxes。并不是所有子图的更新都要处理，不是最后子图的更新事件可以跳过。探索系统不要求针对每个scan都实时更新边界，只有每个子图完成时才使用探索算法。

- 处理后端优化：子图的位姿改变，算法3验证子图的全局bounding box和整个全局边界。每个子图的局部边界已经计算出了，所以只要重新把局部边界点转换到全局坐标系，而且需要测试新的全局边界点。


## 算法分析

### 鲁棒性和完整性



- 鲁棒性： 假设算法返回的全局边界点valid，两种情况：全局边界点是已观测的全局地图栅格；全局边界点邻近栅格不是空闲全局栅格。

第1种不可能，因为这样的全局边界点会通不过stabbing query。第2种是可能的但可能性很小。如果有多个子图的邻近栅格是占用的，合并的过程会导致邻近的全局地图栅格标记为占用而不是空闲，而全局边界点只邻近占用的全局地图栅格。之所以说可能性很小，是因为未观测栅格未被已观测栅格覆盖(这又会导致stabbing test失败)的可能性小的可以忽略。为了避免这种情况，stabbing query测式可以增加检查子图的邻近栅格的功能，而不是只检查单个栅格。这样不会增加时间复杂度。

### 算法复杂度

1. 处理子图的更新

算法1的第5行，在R树梨查找和更新的子图*si*相交的子图，时间复杂度是*O*(log|S| + |$$ S_{\cap si}$$|)。  S是所有子图，$$S_{\cap si}$$是与子图*si*相交的子图。这也包括了向R树插入已经完成子图的bounding box的时间复杂度。

算法6-10行，栅格的分类和原始查找局部边界点的算法复杂度是 $$ O(A(si)) $$， $$ A(si) $$是子图*si*的区域，也就是栅格个数。

算法2的第3行，对已更新子图的每个局部边界点，与相交子图进行stabbing query测试的算法复杂度为 $$ O(S_{\cap si}) $$，那么总的就是     $$ O(P(LF_{si}) \ S_{\cap si})</script><p>算法1的第11-15行，验证相交子图的全局边界，与他们的周长是线性关系，算法复杂度  <script type="math/tex">O(P(\bigcup_{sj\in {S_{\cap{si}}}} \  GF_{sj}))</script></p>
<p>所以处理更新子图的总算法复杂度为<br><img src="https://s2.loli.net/2022/05/20/BEtMOCVeiYw4nTh.png" alt=""></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/05/13/%E8%87%AA%E4%B8%BB%E6%8E%A2%E7%B4%A2/cartographer_frontier_detection/%E7%BC%96%E8%AF%91%20cartographer_frontier_detection/">编译 cartographer_frontier_detection</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%87%AA%E4%B8%BB%E6%8E%A2%E7%B4%A2/">自主探索</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%87%AA%E4%B8%BB%E6%8E%A2%E7%B4%A2/cartographer-frontier-detection/">cartographer_frontier_detection</a></span><div class="content"><p>这个作者是真懒，放到github就不管了，几个人在issue提出编译失败，他也不回复，我给他发邮件，他也不回复</p>
<p>删除<code>cartographer/cmake/modules/FindAbseil.cmake</code></p>
<p>我对<code>CMakeLists</code>进行了修改，主要是<code>absl</code>相关，比如<code>cartographer_frontier_detection\cartographer_frontier_detection\cartographer\CMakeLists.txt</code></p>
<p>将<code>find_package(Abseil REQUIRED)</code> 改为 <code>find_package(absl REQUIRED)</code></p>
<p><code>target_link_libraries($&#123;PROJECT_NAME&#125; PUBLIC $&#123;PROTOBUF_LIBRARY&#125; standalone_absl)</code>改为<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries($&#123;PROJECT_NAME&#125; <span class="keyword">PUBLIC</span> $&#123;PROTOBUF_LIBRARY&#125; </span><br><span class="line">  absl::algorithm</span><br><span class="line">  absl::base</span><br><span class="line">  absl::debugging</span><br><span class="line">  absl::flat_hash_map</span><br><span class="line">  absl::memory</span><br><span class="line">  absl::meta</span><br><span class="line">  absl::numeric</span><br><span class="line">  absl::str_format</span><br><span class="line">  absl::strings</span><br><span class="line">  absl::synchronization</span><br><span class="line">  absl::time</span><br><span class="line">  absl::utility </span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>最终仍然是这个报错<br><img src="https://s2.loli.net/2022/05/13/br317RsOhotmKIH.png" alt=""></p>
<p><br></p>
<p>然后将<code>cartographer-config.cmake.in</code>中的<code>find_package(Abseil $&#123;QUIET_OR_REQUIRED_OPTION&#125;)</code> 改为 <code>find_package(absl REQUIRED)</code>。 作者用<code>absl</code>库的一些函数替代了<code>carto::common</code>的函数，比如<code>absl::MutexLock</code>代替<code>carto::common::MutexLocker</code></p>
<p>如果是新安装的ubuntu，一般能编译通过了。如果之前已经装过cartographer了，<code>cartographer_rviz</code>会出问题，Rviz插件<code>Submaps</code>不正常。因为这次的插件和之前的安装的<code>Submaps</code>插件是不同的，终端会报错：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[/rviz] wants topic /submap_list to have datatype/md5sum [cartographer_ros_msgs/SubmapList/73b1e412208f0787050395996f6143db], but our version has [cartographer_ros_msgs/SubmapList/853a6fd3598626d65ab60752cc4a6117]. Dropping connection</span><br></pre></td></tr></table></figure><br>在Rviz里看不到地图，使用<code>rostopic echo</code>也看不到。 看上去这个报错的是<code>cartographer_ros_msgs</code>没有编译好，其实编译已经成功，问题是Rviz插件<br><img src="https://s2.loli.net/2022/05/14/koj1W7RISqzAVif.png" alt="14__11_06_09.png"><br>只要执行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/frontier_detection/devel_isolated/cartographer_ros_msgs/setup.zsh</span><br></pre></td></tr></table></figure><br>然后使用echo就能看到<code>submap_list</code>的消息了，但是Rviz插件仍然失败，所以应该把这个插件改名称和类型，相当于编译新插件</p>
<p>最终我在虚拟机上(刚装完ROS)运行成功了，红色的边界就是话题<code>frontier_marker</code><br><img src="https://s2.loli.net/2022/05/14/9q3B1stuDJn2rSl.png" alt=""></p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Baron-Lu/p/12468136.html">编译cartographer</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/53/">53</a><a class="extend next" rel="next" href="/page/2/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/02/18/exLTfbM3uFOq5SV.png)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>