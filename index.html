<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | Silent Assassin</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">465</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">45</span></a></div></div></div><nav id="nav" style="background-image: url(https://i.loli.net/2021/07/13/RCLw5Bx8aFPN74b.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Silent Assassin</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">Silent Assassin</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/25/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/cartographer%E7%9A%84%E7%BC%BA%E7%82%B9/">cartographer的缺点</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2021/08/25/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/cartographer%E7%9A%84%E7%BC%BA%E7%82%B9/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/24/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E6%9C%80%E5%90%8E%E9%98%B6%E6%AE%B5%20RunFinalOptimization/">最后阶段 RunFinalOptimization</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>现在返回到<code>node_main.cc</code>中的<code>Run</code>函数，还有一句<code>node.RunFinalOptimization();</code>，其实就是<code>MapBuilderBridge::RunFinalOptimization</code> —— <code>PoseGraph2D::RunFinalOptimization</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::RunFinalOptimization</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">  	<span class="comment">// 参数 max_num_final_iterations 默认 200</span></span><br><span class="line">    <span class="built_in">AddWorkItem</span>([<span class="keyword">this</span>]() <span class="built_in">LOCKS_EXCLUDED</span>(mutex_) &#123;</span><br><span class="line">      absl::MutexLock <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">      optimization_problem_-&gt;<span class="built_in">SetMaxNumIterations</span>(</span><br><span class="line">          options_.<span class="built_in">max_num_final_iterations</span>());</span><br><span class="line">      <span class="keyword">return</span> WorkItem::Result::kRunOptimization;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 参数 max_num_iterations， 默认 50</span></span><br><span class="line">    <span class="built_in">AddWorkItem</span>([<span class="keyword">this</span>]() <span class="built_in">LOCKS_EXCLUDED</span>(mutex_) &#123;</span><br><span class="line">      absl::MutexLock <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">      optimization_problem_-&gt;<span class="built_in">SetMaxNumIterations</span>(</span><br><span class="line">          options_.<span class="built_in">optimization_problem_options</span>()</span><br><span class="line">              .<span class="built_in">ceres_solver_options</span>()</span><br><span class="line">              .<span class="built_in">max_num_iterations</span>());</span><br><span class="line">      <span class="keyword">return</span> WorkItem::Result::kDoNotRunOptimization;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 也在 PoseGraph2D 析构里运行</span></span><br><span class="line">  <span class="built_in">WaitForAllComputations</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在建图结束之后会运行一个新的全局优化，不要求实时性，迭代次数多<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::WaitForAllComputations</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num_trajectory_nodes;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    num_trajectory_nodes = data_.num_trajectory_nodes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> num_finished_nodes_at_start =</span><br><span class="line">      constraint_builder_.<span class="built_in">GetNumFinishedNodes</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> report_progress = [<span class="keyword">this</span>, num_trajectory_nodes,</span><br><span class="line">                          num_finished_nodes_at_start]() &#123;</span><br><span class="line">    <span class="comment">// Log progress on nodes only when we are actually processing nodes.</span></span><br><span class="line">    <span class="keyword">if</span> (num_trajectory_nodes != num_finished_nodes_at_start) &#123;</span><br><span class="line">      std::ostringstream progress_info;</span><br><span class="line">      progress_info &lt;&lt; <span class="string">&quot;Optimizing: &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">1</span>)</span><br><span class="line">                    &lt;&lt; <span class="number">100.</span> *</span><br><span class="line">                           (constraint_builder_.<span class="built_in">GetNumFinishedNodes</span>() -</span><br><span class="line">                            num_finished_nodes_at_start) /</span><br><span class="line">                           (num_trajectory_nodes - num_finished_nodes_at_start)</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;%...&quot;</span>;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;\r\x1b[K&quot;</span> &lt;&lt; progress_info.<span class="built_in">str</span>() &lt;&lt; std::flush;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// First wait for the work queue to drain so that it&#x27;s safe to schedule</span></span><br><span class="line">  <span class="comment">// a WhenDone() callback.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> predicate = [<span class="keyword">this</span>]()</span><br><span class="line">                               <span class="built_in">EXCLUSIVE_LOCKS_REQUIRED</span>(work_queue_mutex_) &#123;</span><br><span class="line">                                 <span class="keyword">return</span> work_queue_ == <span class="literal">nullptr</span>;</span><br><span class="line">                               &#125;;</span><br><span class="line">    <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;work_queue_mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!work_queue_mutex_.<span class="built_in">AwaitWithTimeout</span>(</span><br><span class="line">        absl::<span class="built_in">Condition</span>(&amp;predicate),</span><br><span class="line">        absl::<span class="built_in">FromChrono</span>(common::<span class="built_in">FromSeconds</span>(<span class="number">1.</span>)))) &#123;</span><br><span class="line">      <span class="built_in">report_progress</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now wait for any pending constraint computations to finish.</span></span><br><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">bool</span> notification = <span class="literal">false</span>;</span><br><span class="line">  constraint_builder_.<span class="built_in">WhenDone</span>(</span><br><span class="line">      [<span class="keyword">this</span>,</span><br><span class="line">       &amp;notification](<span class="keyword">const</span> constraints::ConstraintBuilder2D::Result&amp; result)</span><br><span class="line">          <span class="built_in">LOCKS_EXCLUDED</span>(mutex_) &#123;</span><br><span class="line">            absl::MutexLock <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">            data_.constraints.<span class="built_in">insert</span>(data_.constraints.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>(),</span><br><span class="line">                                     result.<span class="built_in">end</span>());</span><br><span class="line">            notification = <span class="literal">true</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> predicate = [&amp;notification]() <span class="built_in">EXCLUSIVE_LOCKS_REQUIRED</span>(mutex_) &#123;</span><br><span class="line">    <span class="keyword">return</span> notification;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">while</span> (!mutex_.<span class="built_in">AwaitWithTimeout</span>(absl::<span class="built_in">Condition</span>(&amp;predicate),</span><br><span class="line">                                  absl::<span class="built_in">FromChrono</span>(common::<span class="built_in">FromSeconds</span>(<span class="number">1.</span>)))) &#123;</span><br><span class="line">    <span class="built_in">report_progress</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CHECK_EQ</span>(constraint_builder_.<span class="built_in">GetNumFinishedNodes</span>(), num_trajectory_nodes);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;\r\x1b[KOptimizing: Done.     &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/24/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8E%E7%AB%AF%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%203%20HandleWorkQueue%E5%92%8C%E4%BC%98%E5%8C%96/">后端的线程池 3 HandleWorkQueue和优化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>优化的具体实现在优化器<code>optimization_problem_</code>。将优化的结果采用回调的方式，返回到result中。<br>后端将数据加入到 <code>optimization_problem_</code> 的对应传感器队列中，并按时间排列。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::HandleWorkQueue</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> constraints::ConstraintBuilder2D::Result&amp;  result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  &#123;   <span class="comment">// 将新的约束添加到全局约束队列中</span></span><br><span class="line">    <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    data_.constraints.<span class="built_in">insert</span>(data_.constraints.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>(),</span><br><span class="line">                             result.<span class="built_in">end</span>() );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ceres 在这里</span></span><br><span class="line">  <span class="built_in">RunOptimization</span>();</span><br><span class="line">   			<span class="comment">// 以下是 省略 的内容</span></span><br><span class="line">  <span class="comment">//如果设置了全局优化回调函数，则进行调用</span></span><br><span class="line">  <span class="comment">//根据约束结果，更新轨迹间的链接关系</span></span><br><span class="line">  <span class="comment">// 优化完成后，累计节点清零</span></span><br><span class="line">  <span class="comment">// 计算相同轨迹的 inter_constraints_same_trajectory  </span></span><br><span class="line">  <span class="comment">// 计算不同轨迹的 inter_constraints_different_trajectory</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 优化结束后，重新开启任务队列，即继续执行</span></span><br><span class="line">  <span class="comment">// work_queue_里的 work_item</span></span><br><span class="line">  <span class="built_in">DrainWorkQueue</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="RunOptimization"><a href="#RunOptimization" class="headerlink" title="RunOptimization"></a>RunOptimization</h2><p>优化的实际就是成员变量<code>node_data_</code> 和 <code>submap_data_</code>，也就是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeSpec2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  common::Time time;</span><br><span class="line">  transform::Rigid2d  local_pose_2d;</span><br><span class="line">  transform::Rigid2d  global_pose_2d;</span><br><span class="line">  Eigen::Quaterniond  gravity_alignment;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubmapSpec2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  transform::Rigid2d  global_pose;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::RunOptimization</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (optimization_problem_-&gt;<span class="built_in">submap_data</span>().<span class="built_in">empty</span>() )</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// std::unique_ptr&lt;optimization::OptimizationProblem2D&gt; optimization_problem_;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// No other thread is accessing the optimization_problem_,</span></span><br><span class="line">  <span class="comment">// data_.constraints, data_.frozen_trajectories and data_.landmark_nodes</span></span><br><span class="line">  <span class="comment">// when executing Solve. </span></span><br><span class="line">  <span class="comment">// 调用优化，Ceres在这里面，由于耗时间，故没加锁，防止阻塞其他线程</span></span><br><span class="line">  optimization_problem_-&gt;<span class="built_in">Solve</span>(data_.constraints, </span><br><span class="line">    <span class="built_in">GetTrajectoryStates</span>(),  data_.landmark_nodes);</span><br></pre></td></tr></table></figure>
<p>将所有内部约束和外部约束合并在一起执行<code>Solve</code><br>遍历所有submap，建立参数块；遍历所有node，建立参数块。<br>根据约束，添加残差函数；<br>处理里程计问题，添加可能的残差；<br>求解返回结果;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">   <span class="comment">// 优化后所有的submap和node数据</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; submap_data = optimization_problem_-&gt;<span class="built_in">submap_data</span>();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; node_data = optimization_problem_-&gt;<span class="built_in">node_data</span>();</span><br><span class="line">  <span class="comment">/*  遍历所有优化后的轨迹的所有节点位姿  */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> trajectory_id : node_data.<span class="built_in">trajectory_ids</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; node : node_data.<span class="built_in">trajectory</span>(trajectory_id) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span>&amp; mutable_trajectory_node = data_.trajectory_nodes.<span class="built_in">at</span>(node.id);</span><br><span class="line">      <span class="comment">// 更新所有节点的 全局位姿</span></span><br><span class="line">      mutable_trajectory_node.global_pose =</span><br><span class="line">          transform::<span class="built_in">Embed3D</span>(node.data.global_pose_2d) *</span><br><span class="line">          transform::Rigid3d::<span class="built_in">Rotation</span>(</span><br><span class="line">              mutable_trajectory_node.constant_data-&gt;gravity_alignment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extrapolate all point cloud poses that were not included in the</span></span><br><span class="line">    <span class="comment">// &#x27;optimization_problem_&#x27; yet. 注意是已经加入tarjectory但是还没有进行优化的新Node</span></span><br><span class="line">    <span class="comment">// 由于使用采样器建立约束，有的node没有建立约束，其pose就不会被优化</span></span><br><span class="line">    <span class="comment">// 因此，要通过已经优化的位姿转换关系来修正所有的node</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子图的local到global的新的转移矩阵</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> local_to_new_global =</span><br><span class="line">        <span class="built_in">ComputeLocalToGlobalTransform</span>(submap_data, trajectory_id);</span><br><span class="line">        <span class="comment">// 旧的转移矩阵</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> local_to_old_global = <span class="built_in">ComputeLocalToGlobalTransform</span>(</span><br><span class="line">        data_.global_submap_poses_2d, trajectory_id);</span><br><span class="line">    <span class="keyword">const</span> transform::Rigid3d old_global_to_new_global =</span><br><span class="line">        local_to_new_global * local_to_old_global.<span class="built_in">inverse</span>();</span><br><span class="line">      <span class="comment">// 上次最后一个优化的节点</span></span><br><span class="line">    <span class="keyword">const</span> NodeId last_optimized_node_id =</span><br><span class="line">        std::<span class="built_in">prev</span>(node_data.<span class="built_in">EndOfTrajectory</span>(trajectory_id))-&gt;id;</span><br><span class="line">    <span class="keyword">auto</span> node_it =</span><br><span class="line">        std::<span class="built_in">next</span>(data_.trajectory_nodes.<span class="built_in">find</span>(last_optimized_node_id));</span><br><span class="line">     <span class="comment">// 后续未优化的节点的全局pose进行转移</span></span><br><span class="line">    <span class="keyword">for</span> (; node_it != data_.trajectory_nodes.<span class="built_in">EndOfTrajectory</span>(trajectory_id);</span><br><span class="line">         ++node_it)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// TrajectoryNode类型， 指针</span></span><br><span class="line">      <span class="keyword">auto</span>&amp; mutable_trajectory_node = data_.trajectory_nodes.<span class="built_in">at</span>(node_it-&gt;id);</span><br><span class="line">      修正 global_pose</span><br><span class="line">      mutable_trajectory_node.global_pose =</span><br><span class="line">          old_global_to_new_global * mutable_trajectory_node.global_pose;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新所有路标位姿</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; landmark : optimization_problem_-&gt;<span class="built_in">landmark_data</span>()) &#123;</span><br><span class="line">    data_.landmark_nodes[landmark.first].global_landmark_pose = landmark.second;</span><br><span class="line">  &#125;</span><br><span class="line">  data_.global_submap_poses_2d = submap_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化并非是实时，是在后台进行运行的，并且需要一定的时间。因此当完成优化时，前端输出结果已经对整个位姿图个数进行了增加。后面新加入的节点并未优化，所以返回优化的结果没有最新加入轨迹节点对应的结果。因此采用优化后结果中最后一个轨迹节点的位姿的转移矩阵，作为未参与优化轨迹节点的转移矩阵进行更新。</p>
<p>其中 <script type="math/tex">X</script> 为参与优化的节点，优化前位姿为 <script type="math/tex">X_{old}</script>，优化后的位姿为 <script type="math/tex">X_{new}</script>。而 <script type="math/tex">Y</script> 则为未参与优化的节点。</p>
<script type="math/tex; mode=display">T = X_{old}^{-1} * X_{new}$$     $$ Y_{new} = T * Y_{old}</script></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/21/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8E%E7%AB%AF%205%20%E8%AE%A1%E7%AE%97%E7%BA%A6%E6%9D%9F/">后端 5 计算约束</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstraintBuilder2D::ComputeConstraint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> SubmapId&amp; submap_id,  <span class="keyword">const</span> Submap2D* <span class="keyword">const</span> submap,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> NodeId&amp; node_id,  <span class="keyword">bool</span> match_full_submap,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> TrajectoryNode::Data* <span class="keyword">const</span>  constant_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> transform::Rigid2d&amp;  initial_relative_pose,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> SubmapScanMatcher&amp;   submap_scan_matcher,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;ConstraintBuilder2D::Constraint&gt;* constraint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(submap_scan_matcher.fast_correlative_scan_matcher);</span><br><span class="line">  <span class="comment">/*  node在local map坐标系的位姿 = </span></span><br><span class="line"><span class="comment">  子图在local map坐标系中的位姿 * node在子图的位姿*/</span></span><br><span class="line">  <span class="keyword">const</span> transform::Rigid2d  initial_pose =</span><br><span class="line">      <span class="built_in">ComputeSubmapPose</span>(*submap) * initial_relative_pose;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">float</span> score = <span class="number">0.</span>;</span><br><span class="line">  transform::Rigid2d pose_estimate = transform::Rigid2d::<span class="built_in">Identity</span>();</span><br></pre></td></tr></table></figure>
<p>整个函数是为了计算<code>constraint_transform</code>(submap i &lt;- node j) ，需要的参数有：</p>
<ul>
<li>节点 j 的<code>filtered_gravity_aligned_point_cloud</code></li>
<li>分支定界的初值 <code>initial_pose</code> (local map &lt;- node j)</li>
<li><code>Match()</code> 的结果 <code>pose_estimate</code> (local map &lt;- node j).</li>
<li><code>ComputeSubmapPose()</code>函数 (local map &lt;- submap i)</li>
</ul>
<p>Compute ‘pose_estimate’ in three stages:</p>
<ol>
<li>使用 fast correlative scan matcher 做 Fast estimate</li>
<li>Prune if the score is too low.</li>
<li>ceres Refine</li>
</ol>
<h2 id="匹配所有子图-或-局部子图"><a href="#匹配所有子图-或-局部子图" class="headerlink" title="匹配所有子图 或 局部子图"></a>匹配所有子图 或 局部子图</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配所有子图，对应 MaybeAddGlobalConstraint</span></span><br><span class="line"><span class="keyword">if</span> (match_full_submap)</span><br><span class="line">&#123;</span><br><span class="line">  kGlobalConstraintsSearchedMetric-&gt;<span class="built_in">Increment</span>();</span><br><span class="line">  <span class="keyword">if</span>( submap_scan_matcher.fast_correlative_scan_matcher-&gt;<span class="built_in">MatchFullSubmap</span>(</span><br><span class="line">          constant_data-&gt;filtered_gravity_aligned_point_cloud,</span><br><span class="line">          <span class="comment">// 参数为 global_localization_min_score</span></span><br><span class="line">          options_.<span class="built_in">global_localization_min_score</span>(), </span><br><span class="line">          &amp;score,  &amp;pose_estimate)  )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">CHECK_GT</span>(score, options_.<span class="built_in">global_localization_min_score</span>());</span><br><span class="line">    <span class="built_in">CHECK_GE</span>(node_id.trajectory_id, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">CHECK_GE</span>(submap_id.trajectory_id, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 最后记录下全局约束的次数和统计置信度</span></span><br><span class="line">    kGlobalConstraintsFoundMetric-&gt;<span class="built_in">Increment</span>();</span><br><span class="line">    kGlobalConstraintScoresMetric-&gt;<span class="built_in">Observe</span>(score);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匹配局部子图</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  kConstraintsSearchedMetric-&gt;<span class="built_in">Increment</span>();</span><br><span class="line">  <span class="keyword">if</span> (submap_scan_matcher.fast_correlative_scan_matcher-&gt;<span class="built_in">Match</span>(</span><br><span class="line">          initial_pose, constant_data-&gt;filtered_gravity_aligned_point_cloud,</span><br><span class="line">          <span class="comment">// 参数为 min_score</span></span><br><span class="line">          options_.<span class="built_in">min_score</span>(), </span><br><span class="line">          &amp;score, &amp;pose_estimate)  )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// We&#x27;ve reported a successful local match.</span></span><br><span class="line">    <span class="built_in">CHECK_GT</span>(score, options_.<span class="built_in">min_score</span>());</span><br><span class="line">    kConstraintsFoundMetric-&gt;<span class="built_in">Increment</span>();</span><br><span class="line">    kConstraintScoresMetric-&gt;<span class="built_in">Observe</span>(score);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  score_histogram_.<span class="built_in">Add</span>(score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分枝定界求出的位姿被称为 <strong>初始位姿 3</strong>，这个初始位姿3及其携带的点云作为输入，用于ceres与此子图进行优化匹配</p>
<p>在建立全局约束的时候，直接在一个超大的范围内进行分枝定界搜索，并不需要计算一个特殊的初始位姿2，而直接把初始位姿设置为地图limits的中心点，可以理解为map的中心点。 而且打分的参数也不同了。</p>
<p>全局约束的搜索窗口范围： [1e6 * limits_.resolution(), M_PI]，角度其实是±180°</p>
<h2 id="ceres-refine"><a href="#ceres-refine" class="headerlink" title="ceres refine"></a>ceres refine</h2><p>ceres优化匹配，得到更加准确的优化位置<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use the CSM estimate as both the initial and previous pose. </span></span><br><span class="line"><span class="comment">// This has the effect that, in the absence of better information, </span></span><br><span class="line"><span class="comment">// we prefer the original  CSM estimate.</span></span><br><span class="line">ceres::Solver::Summary  unused_summary;</span><br><span class="line"><span class="comment">// ceres更新pose_estimate，获得节点在local map中的最优位姿</span></span><br><span class="line">ceres_scan_matcher_.<span class="built_in">Match</span>(pose_estimate.<span class="built_in">translation</span>(), pose_estimate,</span><br><span class="line">                 constant_data-&gt;filtered_gravity_aligned_point_cloud,</span><br><span class="line">                *submap_scan_matcher.grid,  &amp;pose_estimate,</span><br><span class="line">                &amp;unused_summary);</span><br><span class="line"><span class="comment">// 计算得到node相对子图的位姿</span></span><br><span class="line"><span class="keyword">const</span> transform::Rigid2d constraint_transform = </span><br><span class="line">    <span class="built_in">ComputeSubmapPose</span>(*submap).<span class="built_in">inverse</span>() * pose_estimate;</span><br><span class="line">constraint-&gt;<span class="built_in">reset</span>(<span class="keyword">new</span> Constraint&#123;submap_id,</span><br><span class="line">       node_id,</span><br><span class="line">       &#123; transform::<span class="built_in">Embed3D</span>(constraint_transform),</span><br><span class="line">        options_.<span class="built_in">loop_closure_translation_weight</span>(),</span><br><span class="line">        options_.<span class="built_in">loop_closure_rotation_weight</span>() &#125;,</span><br><span class="line">       Constraint::INTER_SUBMAP&#125; );</span><br></pre></td></tr></table></figure><br>对于局部约束，<code>constraint_transform</code>并不是回环边，其实就是子图和节点的普通约束。 全局约束才构造回环边</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options_.<span class="built_in">log_matches</span>() )</span><br><span class="line">&#123;</span><br><span class="line">    std::ostringstream info;</span><br><span class="line">    info &lt;&lt; <span class="string">&quot;Node &quot;</span> &lt;&lt; node_id &lt;&lt; <span class="string">&quot; with &quot;</span></span><br><span class="line">         &lt;&lt; constant_data-&gt;filtered_gravity_aligned_point_cloud.<span class="built_in">size</span>()</span><br><span class="line">         &lt;&lt; <span class="string">&quot; points on submap &quot;</span> &lt;&lt; submap_id &lt;&lt; std::fixed;</span><br><span class="line">    <span class="keyword">if</span> (match_full_submap)</span><br><span class="line">         info &lt;&lt; <span class="string">&quot; matches&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">const</span> transform::Rigid2d difference =</span><br><span class="line">          initial_pose.<span class="built_in">inverse</span>() * pose_estimate;</span><br><span class="line">      info &lt;&lt; <span class="string">&quot; differs by translation &quot;</span> &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">2</span>)</span><br><span class="line">           &lt;&lt; difference.<span class="built_in">translation</span>().<span class="built_in">norm</span>() &lt;&lt; <span class="string">&quot; rotation &quot;</span></span><br><span class="line">           &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; std::<span class="built_in">abs</span>(difference.<span class="built_in">normalized_angle</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    info &lt;&lt; <span class="string">&quot; with score &quot;</span> &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; <span class="number">100.</span> * score &lt;&lt; <span class="string">&quot;%.&quot;</span>;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; info.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/20/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/%E6%80%9D%E8%80%83%E7%9A%84%E9%97%AE%E9%A2%98/">思考的问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/">原理和配置</a></span><div class="content"><p>子图插入scan结束时CPU升高</p>
<p>为什么要用线程池</p>
<p>To be sure there is a recent loop closure constraint, you can query <code>PoseGraphInterface::constraints()</code>, loop over all constraints and check if there is a recent one of type INTER that spans some time.</p>
<p>A simpler solution is to subscribe to the global slam callback <code>GlobalSlamOptimizationCallback</code> by setting <code>PoseGraphInterface::SetGlobalSlamOptimizationCallback</code>. This will call you back after Cartographer has searched for loop closures. It does not tell you if loop closures were found, it mostly tells you if the background loop closure search is keeping up or falls behind.</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/05/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/gmapping%E5%92%8CAMCL%E7%9A%84%E5%8C%BA%E5%88%AB/">gmapping和AMCL的区别</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/">amcl和粒子滤波</a></span><div class="content"><h2 id="粒子"><a href="#粒子" class="headerlink" title="粒子"></a>粒子</h2><p>AMCL的粒子只包括位姿和权重，需要大量的粒子才能较好描述机器人位姿。gmapping的粒子包括轨迹、地图、权重，粒子过多会占用很大的内存。</p>
<p>AMCL的粒子在初始化时，各粒子的位姿是不同的，是均值参数加高斯噪声； gmapping粒子初始化时，粒子的位姿都是相同的。 所以说AMCL更符合撒粒子的逻辑。</p>
<p>AMCL的粒子数不是固定的，有最小和最大粒子数。在定位过程中，KLD采样会动态减少粒子数；gmapping的粒子数一直是固定的。</p>
<p>AMCL的提议分布是运动模型，分布的特点是又扁又宽； gmapping的提议分布是运动模型又加入了最近的观测，分布特点是小的尖峰。</p>
<p>AMCL的粒子权重是似然域模型改变，gmapping是通过scan match</p>
<p>AMCL输出的位姿是所有粒子加权平均后的结果； gmapping是输出得分最高的粒子</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/02/C++/C++%20%20%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/emplace%E5%92%8Cemplace_back/">emplace 和 emplace_back</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/">C++ 模板与STL</a></span><div class="content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> string&amp; s) &#123;cout &lt;&lt; <span class="string">&quot;A construct &quot;</span> &lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A&amp; a) &#123;cout &lt;&lt;<span class="string">&quot;A copy&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::map&lt;<span class="keyword">int</span>, string&gt; m;</span><br><span class="line">    vector&lt;A&gt; v;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;  <span class="comment">// a1 构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">push_back</span>(a1);   <span class="comment">// a1 拷贝构造函数</span></span><br><span class="line">    v.<span class="built_in">emplace_back</span>(a1);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//先运行构造函数，后拷贝构造函数</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">A</span>(<span class="string">&quot;test&quot;</span>) );</span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="built_in">A</span>(<span class="string">&quot;test&quot;</span>) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v.push_back(&quot;test&quot;);  报错</span></span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="string">&quot;test&quot;</span>);   <span class="comment">// 隐式转换，只有拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;******************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于C++ 11里vector的<code>emplace_back</code>函数比较失望，都说提高了效率，其实他仅对于隐式转换的临时对象有效，对其他情况，和<code>push_back</code>没区别。  </p>
<p>map就只有<code>emplace</code>，机制也是一样的。</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://haoqchen.site/2020/01/17/emplace_back-vs-push_back/">emplace_back VS push_back</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/07/31/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8E%E7%AB%AF%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%201%20thread_pool%20%E5%92%8C%20task/">后端的线程池 1 thread_pool 和 task</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-31</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分不重要的成员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolInterface</span>;</span></span><br><span class="line">  <span class="function">State <span class="title">GetState</span><span class="params">()</span> <span class="title">LOCKS_EXCLUDED</span><span class="params">(mutex_)</span></span>;     <span class="comment">//返回本Task当前状态</span></span><br><span class="line">  <span class="comment">// 设置Task 执行的任务 （函数）</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetWorkItem</span><span class="params">(<span class="keyword">const</span> WorkItem&amp; work_item)</span></span>; </span><br><span class="line">  <span class="comment">// 给当前任务添加 依赖任务， 如当前任务为b，AddDependency(a)表示任务a依赖b </span></span><br><span class="line">  <span class="comment">// 把当前任务b，加入到依赖任务 a 的 dependent_tasks_ 列表</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddDependency</span><span class="params">(std::weak_ptr&lt;Task&gt; dependency)</span> <span class="title">LOCKS_EXCLUDED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 执行当前任务，比如当前任务为a，并更新依赖a的任务dependent_tasks_中所有任务状态</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Execute</span><span class="params">()</span> <span class="title">LOCKS_EXCLUDED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前任务进入线程待执行队列</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetThreadPool</span><span class="params">(ThreadPoolInterface* thread_pool)</span> <span class="title">LOCKS_EXCLUDED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前任务的依赖任务完成时候，当前任务状态随之改变</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OnDependenyCompleted</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">using</span>  WorkItem = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span>  <span class="title">State</span> &#123;</span> NEW, DISPATCHED, DEPENDENCIES_COMPLETED, RUNNING, COMPLETED &#125;;</span><br><span class="line">  <span class="comment">// 任务具体执行过程</span></span><br><span class="line">  WorkItem   work_item_ ;</span><br><span class="line">  <span class="comment">// 执行当前任务的线程池</span></span><br><span class="line">  ThreadPoolInterface*  thread_pool_to_notify_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="function">State   state_  <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span> </span>= NEW; <span class="comment">// 初始化状态为 NEW</span></span><br><span class="line">  <span class="comment">// 依赖当前任务的任务列表</span></span><br><span class="line">  <span class="function">std::set&lt;Task*&gt;  dependent_tasks_  <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Task类不是线程，可以理解为<strong>有状态和依赖的函数</strong>，核心的成员变量<code>work_item_</code>是仿函数，其返回类型void。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分不重要的成员</span></span><br><span class="line"><span class="comment">// 不明白为什么要先构造个抽象类，只有这一个派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> :</span> <span class="keyword">public</span> ThreadPoolInterface</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> 	<span class="comment">//初始化一个线程数量固定的线程池。</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> num_threads)</span></span>;</span><br><span class="line">  <span class="comment">// 添加想要ThreadPool执行的task，插入 tasks_not_ready_</span></span><br><span class="line">  <span class="comment">// 如果任务满足执行要求，直接插入task_queue_准备执行</span></span><br><span class="line">  <span class="function">std::weak_ptr&lt;Task&gt;  <span class="title">Schedule</span><span class="params">(std::unique_ptr&lt;Task&gt; task)</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> 	<span class="comment">//每个线程初始化时, 执行DoWork()函数. 与线程绑定</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">DoWork</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">NotifyDependenciesCompleted</span><span class="params">(Task* task)</span></span>;</span><br><span class="line">  <span class="comment">//running_只是一个监视哨, 只有线程池在running_状态时, 才能往work_queue_加入函数</span></span><br><span class="line">  <span class="keyword">bool</span> running_  = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// pool_就是一系列线程</span></span><br><span class="line">  std::vector&lt;std::thread&gt;  pool_ ;</span><br><span class="line">  <span class="comment">// 十分重要的任务队列</span></span><br><span class="line">  std::deque&lt;std::shared_ptr&lt;Task&gt;&gt;  task_queue_ ; </span><br><span class="line">  <span class="comment">//未准备好的 task，task可能有依赖还未完成</span></span><br><span class="line">  absl::flat_hash_map&lt;Task*, std::shared_ptr&lt;Task&gt;&gt;  tasks_not_ready_;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看构造函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="keyword">int</span> num_threads)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">absl::MutexLock  <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// 原来还是用了std::thread，还以为google连线程也是自己实现的</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != num_threads; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// std::vector&lt;std::thread&gt;   pool_;</span></span><br><span class="line">    pool_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]() &#123; ThreadPool::<span class="built_in">DoWork</span>(); &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>大致看<code>ThreadPool::DoWork()</code>，最后执行了<code>ThreadPoolInterface::Execute</code>，其实就是<code>Task::Execute</code>。 每个线程与DoWork()函数绑定,也就是线程在后台不断执行DoWork()函数</p>
<p>新的Task如果有依赖项，通过<code>Thread_pool::Schedule</code>添加到 <code>Thread_pool</code>的 <code>tasks_not_ready_</code>队列中。队列中的Task状态是变化的，等依赖项执行完成，Task状态变为<code>DEPENDENCIES_COMPLETED</code>，然后再插入<code>task_queue_</code>队列。最终所有Task都会插入<code>task_queue_</code>中，在<code>DoWork</code>中得到执行。 </p>
<p>如果该Task没有依赖，直接插入<code>task_queue_</code>，准备执行。</p>
<p>对任一个任务的状态转换顺序为：NEW—-&gt;DISPATCHED—-&gt;DEPENDENCIES_COMPLETED—-&gt;RUNNING—-&gt;COMPLETED</p>
<p><code>Thread_pool</code>通过固定数量的thread与<code>task_queue_</code>（待执行的task队列）执行函数绑定。Thread_pool 按照队列首尾顺序不断执行Task。</p>
<p><img src="https://i.loli.net/2021/07/31/biVycPTkQoaDOeB.png" alt="示意图"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/07/30/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8E%E7%AB%AF%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%202%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8Cwork_queue/">后端的线程池 2 线程池和work_queue</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>PoseGraph有一个线程池，配置一定数量的线程来执行优化任务。线程池在<code>MapBuilder</code>构造函数中创建，作为参数给<code>PoseGraph</code>对象，PoseGraph将其作为 <code>constraints::ConstraintBuilder2D</code>的初始化使用。每个线程执行 <code>ThreadPool::DoWork()</code>函数。 <code>DoWork()</code>函数会一直循环遍历一个<code>deque</code>队列中的Task任务，每次执行完一个Task，就会从队列弹出。  即<code>std::deque&lt;std::shared_ptr&lt;Task&gt; &gt;  task_queue_</code></p>
<p>这个<code>task_queue_</code>的添加任务追溯到线程池的<code>Schedule</code>函数，<code>Schedule</code>函数在<code>PoseGraph2D::AddWorkItem</code>和添加约束的函数里</p>
<p>每次收到SLAM需要的信息都会生成一个work，这个work都会保存到PoseGraph的<code>work_queue_</code>队列中，上面说的task通过<code>SetWorkItem</code>进一步执行<code>DrainWorkQueue</code>， 进而从 <code>work_queue_</code>中取出 WorkItem 执行。这些 WorkItem 是由pose_graph添加各种传感器数据和 Node的时候加入到该队列的，比如<code>AddImuData</code></p>
<h2 id="lambda-和-仿函数"><a href="#lambda-和-仿函数" class="headerlink" title="lambda 和 仿函数"></a>lambda 和 仿函数</h2><p>看<code>work_queue_</code>队列之前，先要搞清lambda 和 仿函数是怎么回事。</p>
<p>先看一个简单的仿函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// int是返回值类型，括号里是参数的类型</span></span><br><span class="line">std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">float</span>, <span class="keyword">float</span>)&gt; func = add;</span><br><span class="line">cout&lt;&lt; <span class="built_in">func</span>(<span class="number">2.4</span>, <span class="number">6.9</span>) &lt;&lt;endl;</span><br></pre></td></tr></table></figure></p>
<p>lambda表达式通常仅仅是仿函数的语法糖，可以直接转换为仿函数。[]中的任何内容都会转换为构造函数参数和仿函数对象的成员，而()中的参数将转换为仿函数operator()的参数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddWorkItem</span><span class="params">(std::function&lt;<span class="keyword">int</span>()&gt;&amp;  work_item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">work_item</span>() &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddImuData</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// []：默认不捕获任何变量</span></span><br><span class="line">	<span class="comment">// [=]：默认以值捕获所有变量</span></span><br><span class="line">	<span class="comment">// 其实可以用 auto</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>()&gt; func = [=]()&#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;input: &quot;</span>&lt;&lt; a &lt;&lt; <span class="string">&quot;  &quot;</span>&lt;&lt; b&lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//    std::function&lt;int(float,float)&gt; func2 = add;</span></span><br><span class="line">    <span class="built_in">AddWorkItem</span>( func );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 函数中调用</span></span><br><span class="line"><span class="built_in">AddImuData</span>(<span class="number">29</span>, <span class="number">7</span>);</span><br></pre></td></tr></table></figure><br>把cartographer中的函数做了修改，这样容易理解。 main 函数中调用<code>AddImuData</code>，我们要的是运行lambda表达式，假如<code>AddWorkItem</code>是空函数，那么不会有运行结果。<code>work_item()</code>才是实际的运行lambda表达式。 </p>
<h2 id="workqueue-机制"><a href="#workqueue-机制" class="headerlink" title="workqueue 机制"></a>work<em>queue</em> 机制</h2><p><code>PoseGraph2D</code>有16个成员函数调用了<code>AddWorkItem</code>，也就是加入了<code>work_queue_</code>队列。操作<code>work_queue_</code>的函数主要是<code>AddWorkItem</code> 和 <code>DrainWorkQueue</code></p>
<p>以<code>PoseGraph2D::AddImuData</code>为例:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::AddImuData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> trajectory_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> sensor::ImuData&amp; imu_data)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">AddWorkItem</span>( [=]() <span class="built_in">LOCKS_EXCLUDED</span>(mutex_)</span><br><span class="line">  &#123;</span><br><span class="line">    absl::MutexLock <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CanAddWorkItemModifying</span>(trajectory_id)) &#123;</span><br><span class="line">      optimization_problem_-&gt;<span class="built_in">AddImuData</span>(trajectory_id, imu_data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> WorkItem::Result::kDoNotRunOptimization;</span><br><span class="line">  &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>后面会看到<code>AddWorkItem</code>的参数是一个仿函数<code>std::function</code>。 <code>AddImuData</code>实际上就一句，也就是调用了<code>AddWorkItem</code>， 这里面的<code>AddWorkItem</code>的参数其实是把一个lambda表达式作为仿函数，这个仿函数的返回值是<code>WorkItem::Result</code>，实际是枚举值<code>kDoNotRunOptimization</code> 或者 <code>kRunOptimization</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个函数地址加入到一个工作队列中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::AddWorkItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::function&lt;WorkItem::Result()&gt;&amp; work_item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">absl::MutexLock  <span class="title">locker</span><span class="params">(&amp;work_queue_mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// 如果工作队列未被初始化，则先初始化，再打开启线程池，后台打开任务队列执行循环</span></span><br><span class="line">  <span class="comment">// 这也是唯一初始化 work_queue_ 的地方</span></span><br><span class="line">  <span class="comment">// std::unique_ptr&lt;WorkQueue&gt;  work_queue_</span></span><br><span class="line">  <span class="keyword">if</span> (work_queue_ == <span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    work_queue_ = absl::make_unique&lt;WorkQueue&gt;();</span><br><span class="line">    <span class="comment">// DrainWorkQueue函数加入到线程池</span></span><br><span class="line">    <span class="keyword">auto</span> task = absl::make_unique&lt;common::Task&gt;();</span><br><span class="line">    task-&gt;<span class="built_in">SetWorkItem</span>([<span class="keyword">this</span>]() &#123; <span class="built_in">DrainWorkQueue</span>(); &#125;);</span><br><span class="line">    thread_pool_-&gt;<span class="built_in">Schedule</span>(std::<span class="built_in">move</span>(task)  );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> now = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  work_queue_-&gt;<span class="built_in">push_back</span>(&#123;now, work_item&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>work_queue_</code>的类型是<code>std::unique_ptr&lt;WorkQueue&gt;</code>， <code>WorkQueue</code>是<code>WorkItem</code>的deque。根据上面的分析，<font color = blue size=4> 我们要想运行lambda表达式，要的是 work_item()</font>，但是这个函数里没看到，因为这里只有添加，是添加到<code>work_queue_</code>里了。实际的运行在<code>DrainWorkQueue</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::DrainWorkQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> process_work_queue = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">size_t</span> work_queue_size;</span><br><span class="line">  <span class="keyword">while</span> (process_work_queue)</span><br><span class="line">  &#123;</span><br><span class="line">    std::function&lt;WorkItem::<span class="built_in">Result</span>()&gt; work_item;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;work_queue_mutex_)</span></span>;</span><br><span class="line">      <span class="comment">// work_queue_ 队列中取出压栈的任务一个一个执行，直到为空</span></span><br><span class="line">      <span class="comment">// work_queue_ 为空, 说明thread_pool中DrainWorkQueue执行完,</span></span><br><span class="line">      <span class="comment">// 等待下一次addNode时候,再次执行thread_pool_-&gt;Schedule(task),再次执行.</span></span><br><span class="line">      <span class="keyword">if</span> (work_queue_-&gt;<span class="built_in">empty</span>())</span><br><span class="line">      &#123;</span><br><span class="line">        work_queue_.<span class="built_in">reset</span>();  <span class="comment">// 智能指针 reset</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取队列中最前的任务，这就是上面说的 work_item</span></span><br><span class="line">      work_item = work_queue_-&gt;<span class="built_in">front</span>().task;</span><br><span class="line">      work_queue_-&gt;<span class="built_in">pop_front</span>();</span><br><span class="line">      work_queue_size = work_queue_-&gt;<span class="built_in">size</span>();</span><br><span class="line">      kWorkQueueSizeMetric-&gt;<span class="built_in">Set</span>(work_queue_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里的 work_item()就是我们需要的 AddImuData里的lambda表达式</span></span><br><span class="line">    <span class="comment">//回头看lambda，可以发现返回值是 kDoNotRunOptimization</span></span><br><span class="line">    <span class="comment">// 执行工作任务后，返回的状态，赋值false或true给 process_work_queue</span></span><br><span class="line">    process_work_queue = <span class="built_in">work_item</span>() == WorkItem::Result::kDoNotRunOptimization;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 运行到这里，说明队列里运行的lambda表达式的返回值是 kRunOptimization</span></span><br><span class="line">  <span class="comment">// 实际上pop了好几个任务</span></span><br><span class="line">  <span class="comment">//  如果work_item()都不需要全局优化, 则直到work_queue_为空, 都不会执行优化</span></span><br><span class="line">  <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Remaining work items in queue: &quot;</span> &lt;&lt; work_queue_size;</span><br><span class="line">  <span class="comment">// We have to optimize again</span></span><br><span class="line">  constraint_builder_.<span class="built_in">WhenDone</span>(</span><br><span class="line">      [<span class="keyword">this</span>](<span class="keyword">const</span> constraints::ConstraintBuilder2D::Result&amp; result)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">HandleWorkQueue</span>(result);</span><br><span class="line">      &#125;  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面说了<code>PoseGraph2D</code>有16个成员函数调用了<code>AddWorkItem</code>，但是发现只有3个函数会返回<code>kRunOptimization</code>：<br><code>FinishTrajectory</code>, <code>RunFinalOptimization</code>和 <code>ComputeConstraintsForNode</code>。</p>
<p>16个里面最重要的当然是后端入口函数<code>PoseGraph2D::AddNode</code>，在它的<code>work_item</code>是<code>ComputeConstraintsForNode</code>， 在<code>ComputeConstraintsForNode</code>的最后部分：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options_.<span class="built_in">optimize_every_n_nodes</span>() &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">  num_nodes_since_last_loop_closure_ &gt; options_.<span class="built_in">optimize_every_n_nodes</span>() )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>  WorkItem::Result::kRunOptimization;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  WorkItem::Result::kDoNotRunOptimization;</span><br></pre></td></tr></table></figure><br>整个SLAM中实时进入任务队列的主要为<strong>计算约束</strong>，当加入节点数超过参数时，才进行一次优化。</p>
<h2 id="ConstraintBuilder2D-WhenDone"><a href="#ConstraintBuilder2D-WhenDone" class="headerlink" title="ConstraintBuilder2D::WhenDone"></a>ConstraintBuilder2D::WhenDone</h2><p>最后的<code>ConstraintBuilder2D::WhenDone</code>又用到了lambda表达式，又涉及到线程池，实际的后台优化是在<code>HandleWorkQueue</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Result 就是 vector&lt;Constraint&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstraintBuilder2D::WhenDone</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> std::function&lt;<span class="keyword">void</span>(<span class="keyword">const</span> ConstraintBuilder2D::Result&amp;)&gt;&amp; callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="built_in">CHECK</span>(when_done_ == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 成员 unique_ptr&lt;std::function&lt;void(const Result&amp;)&gt;&gt;   when_done_;</span></span><br><span class="line">  when_done_ = absl::make_unique&lt;std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> Result&amp;)&gt; &gt; (callback);</span><br><span class="line">  <span class="built_in">CHECK</span>(when_done_task_ != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 约束的计算结果通过回调进行回传</span></span><br><span class="line">  when_done_task_-&gt;<span class="built_in">SetWorkItem</span>([<span class="keyword">this</span>] &#123; <span class="built_in">RunWhenDoneCallback</span>(); &#125;);</span><br><span class="line">  thread_pool_-&gt;<span class="built_in">Schedule</span>(std::<span class="built_in">move</span>(when_done_task_));</span><br><span class="line">  when_done_task_ = absl::make_unique&lt;common::Task&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里实际就是处理<code>when_done_task_</code>，它是在<code>finish_node_task</code>执行完之后才执行的，内容就是<code>HandleWorkQueue</code></p>
<p>优化执行完毕时的回调函数<code>RunWhenDoneCallback</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstraintBuilder2D::RunWhenDoneCallback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Result result;</span><br><span class="line">  std::unique_ptr&lt;std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> Result&amp;)&gt;&gt; callback;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    <span class="built_in">CHECK</span>(when_done_ != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 将约束结果放入 result</span></span><br><span class="line">    <span class="comment">// MaybeAddConstraint 里添加 constraints_</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> std::unique_ptr&lt;Constraint&gt;&amp; constraint : constraints_)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (constraint == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">      result.<span class="built_in">push_back</span>(*constraint);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (options_.<span class="built_in">log_matches</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(INFO) &lt;&lt; constraints_.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; computations resulted in &quot;</span></span><br><span class="line">                &lt;&lt; result.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; additional constraints.&quot;</span>;</span><br><span class="line">      <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Score histogram:\n&quot;</span> &lt;&lt; score_histogram_.<span class="built_in">ToString</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    constraints_.<span class="built_in">clear</span>();</span><br><span class="line">    callback = std::<span class="built_in">move</span>(when_done_);</span><br><span class="line">    when_done_.<span class="built_in">reset</span>();</span><br><span class="line">    kQueueLengthMetric-&gt;<span class="built_in">Set</span>(constraints_.<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 我理解的 HandleWorkQueue 是在这里</span></span><br><span class="line">  (*callback)(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>scan match</code>的过程如下<br><img src="https://i.loli.net/2021/07/31/8qGxjrQ2ngBylNT.png" alt=""><br><code>AddImuData</code>等函数不是直接放到线程里运行的，进线程池的是<code>DrainWorkQueue</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/07/26/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/cartographer%E7%9A%84%E6%97%A5%E5%BF%97/">cartographer的日志</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/">原理和配置</a></span><div class="content"><p>Google glog是一个基于程序级记录日志信息的c++库，编程使用方式与c++的stream操作类似。 每个级别的日志除了输出到对应日志文件中，还输出到每个低级别日志文件中。默认ERROR和FATAL消息除了输出到日志文件中之外，还会输出到标准错误中</p>
<p>每个级别都对应有相应的日志文件，文件默认存放在临时文件中，Linux是 <code>/tmp</code>。运行cartographer之后，可以在<code>/tmp</code>里看到<br><img src="https://i.loli.net/2021/07/26/1xO5wh6FdBP4Mbc.png" alt=""></p>
<p>几个常用参数<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FLAGS_logtostderr = <span class="literal">true</span>; // 设置日志消息是否转到标准输出而不是日志文件</span><br><span class="line"></span><br><span class="line">FLAGS_alsologtostderr = <span class="literal">true</span>; // 设置日志消息除了日志文件之外是否去标准输出</span><br><span class="line"></span><br><span class="line">FLAGS_colorlogtostderr = <span class="literal">true</span>; // 设置记录到标准输出的颜色消息（如果终端支持）</span><br><span class="line"></span><br><span class="line">FLAGS_logbufsecs = ; // 设置可以缓冲日志的最大秒数，0指实时输出</span><br><span class="line"></span><br><span class="line">FLAGS_max_log_size = ; // 设置最大日志文件大小（以MB为单位）</span><br><span class="line"></span><br><span class="line">FLAGS_stop_logging_if_full_disk = <span class="literal">true</span>; // 设置是否在磁盘已满时避免日志记录到磁盘</span><br></pre></td></tr></table></figure></p>
<p>要自定义glog输出格式并不难，可以直接修改<code>logging.cc</code>文件中的<code>LogMessage::Init</code>函数</p>
<p><br></p>
<p>cartographer的大部分文件都可以直接使用<code>LOG(INFO)&lt;&lt;&quot;log&quot;;</code>这样的语句，因为都提前配置好了，但是最好重新指定日志路径。</p>
<ul>
<li><code>google::SetLogDestination(google::INFO, &quot;log/INFO_&quot;);</code>  // 设置特定级别的日志的输出目录和前缀。第一个参数为日志级别，第二个参数表示输出目录及日志文件名前缀</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glog/logging.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    google::<span class="built_in">InitGoogleLogging</span>(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// INFO</span></span><br><span class="line">    std::string str_info;</span><br><span class="line">    <span class="comment">// 文件名最后只能是   等级+下划线</span></span><br><span class="line">    str_info.<span class="built_in">append</span>(<span class="string">&quot;/home/user/log/INFO_&quot;</span>);</span><br><span class="line">    google::<span class="built_in">SetLogDestination</span>(google::INFO, str_info.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG</span>(INFO)&lt;&lt; <span class="string">&quot;The is a info!&quot;</span>;</span><br><span class="line">    <span class="comment">// WARNING</span></span><br><span class="line">    std::string str_warn;</span><br><span class="line">    str_warn.<span class="built_in">append</span>(<span class="string">&quot;/home/user/log/WARNING_&quot;</span>);</span><br><span class="line">    google::<span class="built_in">SetLogDestination</span>(google::WARNING, str_warn.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;The is a warning!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stop glog  可以没有</span></span><br><span class="line">    google::<span class="built_in">ShutdownGoogleLogging</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次运行cartographer后发现在自定义的路径里，INFO开头的日志文件每次都会新建，而INFO结尾的日志是最新运行得到的日志<br><img src="https://i.loli.net/2021/07/26/FBD5a21MecbpOI6.png" alt=""><br><img src="https://i.loli.net/2021/07/26/pm8qsza4KxV7BrQ.png" alt=""></p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/47/">47</a><a class="extend next" rel="next" href="/page/2/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/07/13/RCLw5Bx8aFPN74b.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2021 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>