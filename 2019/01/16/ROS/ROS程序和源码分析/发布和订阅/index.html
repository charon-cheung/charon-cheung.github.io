<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="发布和订阅"><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>发布和订阅 | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%80%85%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">发布者的回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E9%9C%80%E6%B1%82"><span class="toc-number">2.</span> <span class="toc-text">特殊需求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A9%E8%AE%A2%E9%98%85%E8%80%85%E5%81%9C%E6%AD%A2%E8%AE%A2%E9%98%85"><span class="toc-number">2.1.</span> <span class="toc-text">让订阅者停止订阅</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#queue-size%E5%92%8Cbuff-size"><span class="toc-number">3.</span> <span class="toc-text">queue_size和buff_size</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">654</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">52</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">发布和订阅</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-16</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2019/01/16/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2019/01/16/ROS/ROS程序和源码分析/发布和订阅/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">1.5k</span><span class="post-meta__separator">|</span><span>Reading time: 5 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>话题通信的媒介是消息，消息的产生和消费是解偶的，二者之间没有强行绑定的关系，ROS节点不在乎是谁在发布Topic，哪个节点在订阅Topic，它只关心topic的名字以及当前的消息类型时候和要求的匹配。所以说话题通信是<strong>多对多</strong>的方式</p>
<p>publisher注册时的消息类型,如果和发布时的消息类型不一致,编译不报错,运行报错</p>
<p>消息是以Boost共享指针的形式传输，我们可以存储它而又不需要复制数据。回调函数最常用的原型是这样的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> std_msgs::StringConstPtr&amp; str)</span></span></span><br></pre></td></tr></table></figure><br>其实它就是<code>void callback(const boost::shared_ptr&lt;std_msgs::String const&gt;&amp;);</code>，还有以下几种：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(boost::shared_ptr&lt;std_msgs::String <span class="keyword">const</span>&gt;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(std_msgs::StringConstPtr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(std_msgs::String::ConstPtr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> std_msgs::String&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(std_msgs::String)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> ros::MessageEvent&lt;std_msgs::String <span class="keyword">const</span>&gt;&amp;)</span></span>;</span><br></pre></td></tr></table></figure><br>MessageEvent类允许你在订阅的回调函数内获取信息的元数据。</p>
<p>其他常用的ros::Subscriber函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意： 只能判断话题是否发布，不能判断有没有发布消息</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> 	<span class="title">getNumPublishers</span> <span class="params">()</span> <span class="keyword">const</span>    <span class="comment">//获得连接订阅者的发布者个数</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> 	<span class="title">getTopic</span> <span class="params">()</span> <span class="keyword">const</span>	<span class="comment">//获得所订阅的话题</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> 	<span class="title">getNumSubscribers</span> <span class="params">()</span> <span class="keyword">const</span>　　<span class="comment">//获得连接发布者的订阅者个数</span></span></span><br></pre></td></tr></table></figure></p>
<p>订阅话题后，回调函数的参数类型必须是对应话题的消息类型，否则能订阅成功但不运行回调。</p>
<h2 id="发布者的回调函数"><a href="#发布者的回调函数" class="headerlink" title="发布者的回调函数"></a>发布者的回调函数</h2><p>用于检测是否有订阅者<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ros::Publisher pub = nh.advertise&lt;std_msgs::Int8&gt;(<span class="string">&quot;topic&quot;</span>, <span class="number">50</span>, connectCb,disconnectCb);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数如下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectCb</span><span class="params">(<span class="keyword">const</span> ros::SingleSubscriberPublisher&amp; pub)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;topic Name: %s&quot;</span>, pub.<span class="built_in">getTopic</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Subscriber Name: %s&quot;</span>, pub.<span class="built_in">getSubscriberName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disconnectCb</span><span class="params">(<span class="keyword">const</span> ros::SingleSubscriberPublisher&amp; pub)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;disconnectCb&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ROS的回调函数里定义<code>count</code>变量，居然报错<code>ambiguous</code>，看来以后最好不用<code>count</code>变量<br><img src="https://s2.loli.net/2021/12/27/Hrg9ENtqQsmKX7j.png" alt="image-20211227101811232"></p>
<h2 id="特殊需求"><a href="#特殊需求" class="headerlink" title="特殊需求"></a>特殊需求</h2><p>有时需要在订阅者的回调函数中发布消息,而且只发布一次,这时没必要用service混合topic,用static变量就可以做到:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ros::Publisher *pubPtr;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> published = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> std_msgs::Int8ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = msg-&gt;data;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;msg: %d&quot;</span>, num);</span><br><span class="line">    std_msgs::String str;</span><br><span class="line">    str.data = std::<span class="built_in">string</span>(<span class="built_in">to_string</span>(num) );</span><br><span class="line">    <span class="keyword">if</span>(!published &amp;&amp; num&gt;<span class="number">8</span>)   <span class="comment">// 在num&gt;8时发布一次,以后再也不发布</span></span><br><span class="line">    &#123;</span><br><span class="line">      pubPtr-&gt;<span class="built_in">publish</span>(str);</span><br><span class="line">      published = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv, <span class="string">&quot;Sub&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">    ros::Subscriber sub = nh.subscribe&lt;std_msgs::Int8&gt;(<span class="string">&quot;topic&quot;</span>,<span class="number">20</span>,callback);</span><br><span class="line">    ros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(<span class="string">&quot;new&quot;</span>,<span class="number">50</span>,<span class="literal">false</span>);</span><br><span class="line">    pubPtr = &amp;pub;</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="让订阅者停止订阅"><a href="#让订阅者停止订阅" class="headerlink" title="让订阅者停止订阅"></a>让订阅者停止订阅</h3><p>ROS官方有这么一段话：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function   subscribe() 　returns a Subscriber object that you must hold on to until you want to unsubscribe. When all copies of the Subscriber object go out of scope, this callback will automatically be unsubscribed from this topic.</span><br><span class="line"></span><br><span class="line">function  shutdown()   Unsubscribe the callback associated with this Subscriber.</span><br><span class="line">This method usually does not need to be explicitly called, as automatic shutdown happens when all copies of this Subscriber go out of scope</span><br><span class="line">This method overrides the automatic reference counted unsubscribe, and immediately unsubscribes the callback associated with this Subscriber</span><br></pre></td></tr></table></figure><br>根据说明，有以下三种方法：</p>
<ol>
<li><p>一般让订阅者停止订阅的方法是等<code>subscribe()</code>生成的订阅者对象出作用域．</p>
</li>
<li><p>另一种方法就是explicitly调用<code>shutdown()</code>，典型方法是声明订阅者对象为全局变量，在回调函数中满足某条件时，对此对象调用<code>shutdown()</code>，但这样会直接退出程序，并不好</p>
</li>
<li><p>第三种方法其实与第二种类似，声明一个bool全局变量ok，订阅时执行</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!ok)</span><br><span class="line">&#123;</span><br><span class="line">    ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在回调函数中满足某条件时，让ok=true</p>
<h2 id="queue-size和buff-size"><a href="#queue-size和buff-size" class="headerlink" title="queue_size和buff_size"></a>queue_size和buff_size</h2><p>发布者的原型是这样的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Publisher ros::NodeHandle::<span class="built_in">advertise</span>(<span class="keyword">const</span> std::string &amp; topic,</span><br><span class="line">    <span class="keyword">uint32_t</span>    queue_size,</span><br><span class="line">    <span class="keyword">bool</span>    latch = <span class="literal">false</span> </span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>queue_size    Maximum number of outgoing messages to be queued for delivery to subscribers。 消息队列是为了缓存发布节点发布的消息，一旦队列中消息的数量超过了queue_size，那么最先进入队列的（最老的）消息被舍弃。</li>
<li>latch (optional) If true, the last message published on this topic will be saved and sent to new subscribers when they connect</li>
</ul>
<p>订阅者<code>Subscriber ros::NodeHandle::subscribe</code>函数里也有一个<code>queue_size</code>： Number of incoming messages to queue up for processing，消息队列是为了缓存节点接收到的信息，一旦自己处理的速度过慢，接收到的消息数量超过了queue_size，那么最先进入队列的（最老的）消息会被舍弃。</p>
<p>机器人应用中难免会遇到运算起来很费时间的操作，比如图像的特征提取、点云的匹配等等。有时候，我们需要在ROS的Subscriber的Callback回调函数中进行这些费时的操作。如果我们要是没有取舍的对于每个消息都调用一次回调函数，那么势必会导致计算越来越不实时，很有可能当下在处理的还是几秒以前的数据，之前的消息被舍弃了。所以，如果我们想只处理最新的消息，实际上只需要把两个<code>queue_size</code>都设置成1，那么系统不会缓存数据，自然处理的就是最新的消息。</p>
<p><code>rospy</code>的订阅者还有个<code>buff_size</code>参数，要设置一个很大很大的数，这个缓冲区的大小是指消息队列使用的缓冲区物理内存空间大小。如果这个空间小于一个消息所需要的空间，比如消息是一副图片或者一帧点云，数据量超过了缓冲区的大小。这个时候为了保证通信不发生错误，就会触发网络通信的保护机制，TCP的Buffer会为你缓存消息。</p>
<p>但是roscpp里面没有<code>buff_size</code>参数，它获得 incoming message的大小，分配所需的缓冲区大小，然后一次读取整个incoming message</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37082966/article/details/97172729">queue_size和buff_size的理解</a><br><a target="_blank" rel="noopener" href="https://answers.ros.org/question/220502/image-subscriber-lag-despite-queue-1/">ROS anwser的解释</a></p>
</div></article><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/01/22/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/spin%E4%B8%8EspinOnce/"><i class="fa fa-chevron-left">  </i><span>spin与spinOnce</span></a></div><div class="next-post pull-right"><a href="/2019/01/16/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/ROS%E5%AE%9A%E6%97%B6%E5%99%A8/"><span>ROS定时器</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://charon-cheung.github.io/2019/01/16/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/';
  this.page.identifier = '2019/01/16/ROS/ROS程序和源码分析/发布和订阅/';
  this.page.title = '发布和订阅';
}
var d = document, s = d.createElement('script');
s.src = "https://" + '沉默杀手' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://沉默杀手.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2024 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>