<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">479</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">43</span></a></div></div></div><nav id="nav" style="background-image: url(https://i.loli.net/2021/07/13/RCLw5Bx8aFPN74b.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/09/14/SLAM%E5%B7%A5%E5%85%B7/gtsam/">gtsam</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SLAM%E5%B7%A5%E5%85%B7/">SLAM工具</a></span><div class="content"><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载gtsam源码:  <code>git clone https://bitbucket.org/gtborg/gtsam.git</code></p>
<p>依赖:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Boost &gt;= 1.43 (Ubuntu: sudo apt-get install libboost-all-dev)</span><br><span class="line">CMake &gt;= 3.0 (Ubuntu: sudo apt-get install cmake)</span><br></pre></td></tr></table></figure></p>
<p>安装可选的依赖:</p>
<ul>
<li>Intel Threaded Building Blocks (TBB)</li>
</ul>
<p><code>sudo apt-get install libtbb-dev</code></p>
<ul>
<li>Intel Math Kernel Library (MKL)</li>
</ul>
<p><code>https://software.intel.com/content/www/us/en/develop/articles/installing-intel-free-libs-and-python-apt-repo.html</code></p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/09/13/Linux%E5%9F%BA%E7%A1%80/curl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/">curl命令详解</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux%E5%9F%BA%E7%A1%80/">Linux基础</a></span><div class="content"><p>curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。</p>
<p><code>curl http://www.linux.com</code>执行后， www.linux.com 的html就会显示在屏幕上了，相当于下载之后再cat命令</p>
<p>使用linux的重定向功能保存<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://www.linux.com &gt;&gt; linux.html</span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/09/13/Linux%E5%9F%BA%E7%A1%80/ubuntu%E7%9A%84%E6%98%BE%E5%8D%A1%E5%8F%8A%E9%A9%B1%E5%8A%A8/">ubuntu的显卡及驱动</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux%E5%9F%BA%E7%A1%80/">Linux基础</a></span><div class="content"><p><code>ubuntu-drivers devices</code>查看显卡硬件型号，也就是其中的<code>model</code>。 如果同意安装推荐版本，那我们只需要终端输入：sudo ubuntu-drivers autoinstall 就可以自动安装了。<br>当然我们也可以使用 apt 命令安装自己想要安装的版本，比如我想安装 340 这个版本号的版本，终端输入：sudo apt install nvidia-340 就自动安装了。</p>
<p><code>lshw -numeric -C display | grep product</code>也可以查看电脑显卡的十六进制ID</p>
<h2 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h2><p>电脑装好好，启动一直失败，报错<code>failed to start User Manager for UID 121</code>，连文本界面都进不去，后来才知道是ubuntu下缺少显卡驱动</p>
<p>先完全卸载之前安装的显卡驱动</p>
<p>ppa源文件卸载：<code>sudo apt-get remove --purge nvidia*</code></p>
<p>runfile源文件卸载：<code>sudo ./NVIDIA-Linux-x86_64-384.59.run --uninstall</code></p>
<h3 id="ppa源驱动安装"><a href="#ppa源驱动安装" class="headerlink" title="ppa源驱动安装"></a>ppa源驱动安装</h3><p>先查询电脑最适合的显卡驱动版本，命令 <code>ubuntu-drivers devices</code>，这个命令不仅适用于显卡<br><img src="https://i.loli.net/2021/09/14/Lb1IQYFmkvJsa4U.png" alt=""></p>
<p>最佳显卡驱动版本为 nvidia-driver-435， 用命令行进行安装<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nvidia-driver-435 <span class="comment">#此处数字要对应上面查询到的版本号</span></span><br><span class="line">sudo apt-get install mesa-common-dev</span><br></pre></td></tr></table></figure><br>如果前面没有禁用secure boot，则在安装过程中会提示设置一个密码，在重启时需要输入密码验证以禁用secure boot，重启后会出现蓝屏，这时候不能直接选择continue, 而应该按下按键，选择Enroll MOK, 确认后在下一个选项中选择continue,接着输入安装驱动时设置的密码，开机。<br><img src="https://i.loli.net/2021/09/22/pXejaH6NSgfOhnm.png" alt=""><br>安装完成后重启，<code>nvidia-smi</code>命令显示驱动信息，若出现驱动版本，就是成功</p>
<h2 id="官网驱动下载"><a href="#官网驱动下载" class="headerlink" title="官网驱动下载"></a>官网驱动下载</h2><p>到 NVIDIA 的官网下载相应型号的驱动，<a target="_blank" rel="noopener" href="https://www.nvidia.com/Download/index.aspx">官网地址</a><br>操作系统那里，一定选择Linux 64-bit</p>
<p>需要先安装一些 NVIDIA 显卡依赖的软件，在终端依次执行如下命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --add-architecture i386</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install build-essential libc6:i386</span><br></pre></td></tr></table></figure><br>Ubuntu 系统默认安装好是使用的一个开源的驱动：<code>nouveau</code>，我们需要先禁用这个开源驱动，方法如下，依次执行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo bash -c <span class="string">&quot;echo blacklist nouveau &gt; /etc/modprobe.d/blacklist-nvidia-nouveau.conf&quot;</span></span><br><span class="line">sudo bash -c <span class="string">&quot;echo options nouveau modeset=0 &gt;&gt; /etc/modprobe.d/blacklist-nvidia-nouveau.conf&quot;</span></span><br></pre></td></tr></table></figure><br>重启一下系统，运行之前下载的驱动。可能会出现下面的信息：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The distribution-provided pre-install script failed!</span><br><span class="line">Are you sure you want to continue? -&gt; CONTINUE INSTALLATION</span><br><span class="line">Would you like to run the nvidia-xconfig utility? -&gt; YES</span><br></pre></td></tr></table></figure><br>安装完成后重启系统就可以点击软件列表中的 NVIDIA 的配置软件配置显卡驱动了，如果你遇到<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Unable to find suitable destination to install 32-bit compatibility libraries</span><br></pre></td></tr></table></figure><br>解决办法：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --add-architecture i386</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install libc6:i386</span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/30/%E6%BF%80%E5%85%89SLAM/%E9%9B%B7%E8%BE%BE/%E7%A6%BE%E8%B5%9B16%E7%BA%BF%E9%9B%B7%E8%BE%BE/">禾赛16线雷达</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/%E9%9B%B7%E8%BE%BE/">雷达</a></span><div class="content"><p>型号<code>PandarXT-16</code><br><a target="_blank" rel="noopener" href="https://github.com/HesaiTechnology/HesaiLidar_General_ROS">禾赛雷达的驱动</a></p>
<p>节点<code>/hesai/hesai_lidar</code>无订阅，发布两个话题:</p>
<ul>
<li>/hesai/pandar [sensor_msgs/PointCloud2]   被节点<code>data_pretreat_node</code>订阅</li>
<li>/hesai/pandar_packets [hesai_lidar/PandarScan]，无内容</li>
</ul>
<p><img src="https://s2.loli.net/2021/12/08/ihOLuyUYlV6mNvF.png" alt="禾赛雷达数据占用的带宽.png"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/25/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/cartographer%E7%9A%84%E7%BC%BA%E7%82%B9/">cartographer的缺点</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2021/08/25/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/cartographer%E7%9A%84%E7%BC%BA%E7%82%B9/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/24/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E6%9C%80%E5%90%8E%E9%98%B6%E6%AE%B5%20RunFinalOptimization/">最后阶段 RunFinalOptimization</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>现在返回到<code>node_main.cc</code>中的<code>Run</code>函数，还有一句<code>node.RunFinalOptimization();</code>，其实就是<code>MapBuilderBridge::RunFinalOptimization</code> —— <code>PoseGraph2D::RunFinalOptimization</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::RunFinalOptimization</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">  	<span class="comment">// 参数 max_num_final_iterations 默认 200</span></span><br><span class="line">    <span class="built_in">AddWorkItem</span>([<span class="keyword">this</span>]() <span class="built_in">LOCKS_EXCLUDED</span>(mutex_) &#123;</span><br><span class="line">      absl::MutexLock <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">      optimization_problem_-&gt;<span class="built_in">SetMaxNumIterations</span>(</span><br><span class="line">          options_.<span class="built_in">max_num_final_iterations</span>());</span><br><span class="line">      <span class="keyword">return</span> WorkItem::Result::kRunOptimization;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 参数 max_num_iterations， 默认 50</span></span><br><span class="line">    <span class="built_in">AddWorkItem</span>([<span class="keyword">this</span>]() <span class="built_in">LOCKS_EXCLUDED</span>(mutex_) &#123;</span><br><span class="line">      absl::MutexLock <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">      optimization_problem_-&gt;<span class="built_in">SetMaxNumIterations</span>(</span><br><span class="line">          options_.<span class="built_in">optimization_problem_options</span>()</span><br><span class="line">              .<span class="built_in">ceres_solver_options</span>()</span><br><span class="line">              .<span class="built_in">max_num_iterations</span>());</span><br><span class="line">      <span class="keyword">return</span> WorkItem::Result::kDoNotRunOptimization;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 也在 PoseGraph2D 析构里运行</span></span><br><span class="line">  <span class="built_in">WaitForAllComputations</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在建图结束之后会运行一个新的全局优化，不要求实时性，迭代次数多<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::WaitForAllComputations</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num_trajectory_nodes;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    num_trajectory_nodes = data_.num_trajectory_nodes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> num_finished_nodes_at_start =</span><br><span class="line">      constraint_builder_.<span class="built_in">GetNumFinishedNodes</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> report_progress = [<span class="keyword">this</span>, num_trajectory_nodes,</span><br><span class="line">                          num_finished_nodes_at_start]() &#123;</span><br><span class="line">    <span class="comment">// Log progress on nodes only when we are actually processing nodes.</span></span><br><span class="line">    <span class="keyword">if</span> (num_trajectory_nodes != num_finished_nodes_at_start) &#123;</span><br><span class="line">      std::ostringstream progress_info;</span><br><span class="line">      progress_info &lt;&lt; <span class="string">&quot;Optimizing: &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">1</span>)</span><br><span class="line">                    &lt;&lt; <span class="number">100.</span> *</span><br><span class="line">                           (constraint_builder_.<span class="built_in">GetNumFinishedNodes</span>() -</span><br><span class="line">                            num_finished_nodes_at_start) /</span><br><span class="line">                           (num_trajectory_nodes - num_finished_nodes_at_start)</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;%...&quot;</span>;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;\r\x1b[K&quot;</span> &lt;&lt; progress_info.<span class="built_in">str</span>() &lt;&lt; std::flush;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// First wait for the work queue to drain so that it&#x27;s safe to schedule</span></span><br><span class="line">  <span class="comment">// a WhenDone() callback.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> predicate = [<span class="keyword">this</span>]()</span><br><span class="line">                               <span class="built_in">EXCLUSIVE_LOCKS_REQUIRED</span>(work_queue_mutex_) &#123;</span><br><span class="line">                                 <span class="keyword">return</span> work_queue_ == <span class="literal">nullptr</span>;</span><br><span class="line">                               &#125;;</span><br><span class="line">    <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;work_queue_mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!work_queue_mutex_.<span class="built_in">AwaitWithTimeout</span>(</span><br><span class="line">        absl::<span class="built_in">Condition</span>(&amp;predicate),</span><br><span class="line">        absl::<span class="built_in">FromChrono</span>(common::<span class="built_in">FromSeconds</span>(<span class="number">1.</span>)))) &#123;</span><br><span class="line">      <span class="built_in">report_progress</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now wait for any pending constraint computations to finish.</span></span><br><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">bool</span> notification = <span class="literal">false</span>;</span><br><span class="line">  constraint_builder_.<span class="built_in">WhenDone</span>(</span><br><span class="line">      [<span class="keyword">this</span>,</span><br><span class="line">       &amp;notification](<span class="keyword">const</span> constraints::ConstraintBuilder2D::Result&amp; result)</span><br><span class="line">          <span class="built_in">LOCKS_EXCLUDED</span>(mutex_) &#123;</span><br><span class="line">            absl::MutexLock <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">            data_.constraints.<span class="built_in">insert</span>(data_.constraints.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>(),</span><br><span class="line">                                     result.<span class="built_in">end</span>());</span><br><span class="line">            notification = <span class="literal">true</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> predicate = [&amp;notification]() <span class="built_in">EXCLUSIVE_LOCKS_REQUIRED</span>(mutex_) &#123;</span><br><span class="line">    <span class="keyword">return</span> notification;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">while</span> (!mutex_.<span class="built_in">AwaitWithTimeout</span>(absl::<span class="built_in">Condition</span>(&amp;predicate),</span><br><span class="line">                                  absl::<span class="built_in">FromChrono</span>(common::<span class="built_in">FromSeconds</span>(<span class="number">1.</span>)))) &#123;</span><br><span class="line">    <span class="built_in">report_progress</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CHECK_EQ</span>(constraint_builder_.<span class="built_in">GetNumFinishedNodes</span>(), num_trajectory_nodes);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;\r\x1b[KOptimizing: Done.     &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/24/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8E%E7%AB%AF%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%203%20HandleWorkQueue%E5%92%8C%E4%BC%98%E5%8C%96/">后端的线程池 3 HandleWorkQueue和优化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>优化的具体实现在优化器<code>optimization_problem_</code>。将优化的结果采用回调的方式，返回到result中。<br>后端将数据加入到 <code>optimization_problem_</code> 的对应传感器队列中，并按时间排列。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::HandleWorkQueue</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> constraints::ConstraintBuilder2D::Result&amp;  result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  &#123;   <span class="comment">// 将新的约束添加到全局约束队列中</span></span><br><span class="line">    <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    data_.constraints.<span class="built_in">insert</span>(data_.constraints.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>(),</span><br><span class="line">                             result.<span class="built_in">end</span>() );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ceres 在这里</span></span><br><span class="line">  <span class="built_in">RunOptimization</span>();</span><br><span class="line">   			<span class="comment">// 以下是 省略 的内容</span></span><br><span class="line">  <span class="comment">//如果设置了全局优化回调函数，则进行调用</span></span><br><span class="line">  <span class="comment">//根据约束结果，更新轨迹间的链接关系</span></span><br><span class="line">  <span class="comment">// 优化完成后，累计节点清零</span></span><br><span class="line">  <span class="comment">// 计算相同轨迹的 inter_constraints_same_trajectory  </span></span><br><span class="line">  <span class="comment">// 计算不同轨迹的 inter_constraints_different_trajectory</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 优化结束后，重新开启任务队列，即继续执行</span></span><br><span class="line">  <span class="comment">// work_queue_里的 work_item</span></span><br><span class="line">  <span class="built_in">DrainWorkQueue</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="RunOptimization"><a href="#RunOptimization" class="headerlink" title="RunOptimization"></a>RunOptimization</h2><p>优化的实际就是成员变量<code>node_data_</code> 和 <code>submap_data_</code>，也就是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeSpec2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  common::Time time;</span><br><span class="line">  transform::Rigid2d  local_pose_2d;</span><br><span class="line">  transform::Rigid2d  global_pose_2d;</span><br><span class="line">  Eigen::Quaterniond  gravity_alignment;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubmapSpec2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  transform::Rigid2d  global_pose;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::RunOptimization</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (optimization_problem_-&gt;<span class="built_in">submap_data</span>().<span class="built_in">empty</span>() )</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// std::unique_ptr&lt;optimization::OptimizationProblem2D&gt; optimization_problem_;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// No other thread is accessing the optimization_problem_,</span></span><br><span class="line">  <span class="comment">// data_.constraints, data_.frozen_trajectories and data_.landmark_nodes</span></span><br><span class="line">  <span class="comment">// when executing Solve. </span></span><br><span class="line">  <span class="comment">// 调用优化，Ceres在这里面，由于耗时间，故没加锁，防止阻塞其他线程</span></span><br><span class="line">  optimization_problem_-&gt;<span class="built_in">Solve</span>(data_.constraints, </span><br><span class="line">    <span class="built_in">GetTrajectoryStates</span>(),  data_.landmark_nodes);</span><br></pre></td></tr></table></figure>
<p>将所有内部约束和外部约束合并在一起执行<code>Solve</code><br>遍历所有submap，建立参数块；遍历所有node，建立参数块。<br>根据约束，添加残差函数；<br>处理里程计问题，添加可能的残差；<br>求解返回结果;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">   <span class="comment">// 优化后所有的submap和node数据</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; submap_data = optimization_problem_-&gt;<span class="built_in">submap_data</span>();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; node_data = optimization_problem_-&gt;<span class="built_in">node_data</span>();</span><br><span class="line">  <span class="comment">/*  遍历所有优化后的轨迹的所有节点位姿  */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> trajectory_id : node_data.<span class="built_in">trajectory_ids</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; node : node_data.<span class="built_in">trajectory</span>(trajectory_id) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span>&amp; mutable_trajectory_node = data_.trajectory_nodes.<span class="built_in">at</span>(node.id);</span><br><span class="line">      <span class="comment">// 更新所有节点的 全局位姿</span></span><br><span class="line">      mutable_trajectory_node.global_pose =</span><br><span class="line">          transform::<span class="built_in">Embed3D</span>(node.data.global_pose_2d) *</span><br><span class="line">          transform::Rigid3d::<span class="built_in">Rotation</span>(</span><br><span class="line">              mutable_trajectory_node.constant_data-&gt;gravity_alignment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extrapolate all point cloud poses that were not included in the</span></span><br><span class="line">    <span class="comment">// &#x27;optimization_problem_&#x27; yet. 注意是已经加入tarjectory但是还没有进行优化的新Node</span></span><br><span class="line">    <span class="comment">// 由于使用采样器建立约束，有的node没有建立约束，其pose就不会被优化</span></span><br><span class="line">    <span class="comment">// 因此，要通过已经优化的位姿转换关系来修正所有的node</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子图的local到global的新的转移矩阵</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> local_to_new_global =</span><br><span class="line">        <span class="built_in">ComputeLocalToGlobalTransform</span>(submap_data, trajectory_id);</span><br><span class="line">        <span class="comment">// 旧的转移矩阵</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> local_to_old_global = <span class="built_in">ComputeLocalToGlobalTransform</span>(</span><br><span class="line">        data_.global_submap_poses_2d, trajectory_id);</span><br><span class="line">    <span class="keyword">const</span> transform::Rigid3d old_global_to_new_global =</span><br><span class="line">        local_to_new_global * local_to_old_global.<span class="built_in">inverse</span>();</span><br><span class="line">      <span class="comment">// 上次最后一个优化的节点</span></span><br><span class="line">    <span class="keyword">const</span> NodeId last_optimized_node_id =</span><br><span class="line">        std::<span class="built_in">prev</span>(node_data.<span class="built_in">EndOfTrajectory</span>(trajectory_id))-&gt;id;</span><br><span class="line">    <span class="keyword">auto</span> node_it =</span><br><span class="line">        std::<span class="built_in">next</span>(data_.trajectory_nodes.<span class="built_in">find</span>(last_optimized_node_id));</span><br><span class="line">     <span class="comment">// 后续未优化的节点的全局pose进行转移</span></span><br><span class="line">    <span class="keyword">for</span> (; node_it != data_.trajectory_nodes.<span class="built_in">EndOfTrajectory</span>(trajectory_id);</span><br><span class="line">         ++node_it)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// TrajectoryNode类型， 指针</span></span><br><span class="line">      <span class="keyword">auto</span>&amp; mutable_trajectory_node = data_.trajectory_nodes.<span class="built_in">at</span>(node_it-&gt;id);</span><br><span class="line">      修正 global_pose</span><br><span class="line">      mutable_trajectory_node.global_pose =</span><br><span class="line">          old_global_to_new_global * mutable_trajectory_node.global_pose;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新所有路标位姿</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; landmark : optimization_problem_-&gt;<span class="built_in">landmark_data</span>()) &#123;</span><br><span class="line">    data_.landmark_nodes[landmark.first].global_landmark_pose = landmark.second;</span><br><span class="line">  &#125;</span><br><span class="line">  data_.global_submap_poses_2d = submap_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化并非是实时，是在后台进行运行的，并且需要一定的时间。因此当完成优化时，前端输出结果已经对整个位姿图个数进行了增加。后面新加入的节点并未优化，所以返回优化的结果没有最新加入轨迹节点对应的结果。因此采用优化后结果中最后一个轨迹节点的位姿的转移矩阵，作为未参与优化轨迹节点的转移矩阵进行更新。</p>
<p>其中 <script type="math/tex">X</script> 为参与优化的节点，优化前位姿为 <script type="math/tex">X_{old}</script>，优化后的位姿为 <script type="math/tex">X_{new}</script>。而 <script type="math/tex">Y</script> 则为未参与优化的节点。</p>
<script type="math/tex; mode=display">T = X_{old}^{-1} * X_{new}$$     $$ Y_{new} = T * Y_{old}</script></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/21/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8E%E7%AB%AF%205%20%E8%AE%A1%E7%AE%97%E7%BA%A6%E6%9D%9F/">后端 5 计算约束</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstraintBuilder2D::ComputeConstraint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> SubmapId&amp; submap_id,  <span class="keyword">const</span> Submap2D* <span class="keyword">const</span> submap,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> NodeId&amp; node_id,  <span class="keyword">bool</span> match_full_submap,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> TrajectoryNode::Data* <span class="keyword">const</span>  constant_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> transform::Rigid2d&amp;  initial_relative_pose,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> SubmapScanMatcher&amp;   submap_scan_matcher,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;ConstraintBuilder2D::Constraint&gt;* constraint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(submap_scan_matcher.fast_correlative_scan_matcher);</span><br><span class="line">  <span class="comment">/*  node在local map坐标系的位姿 = </span></span><br><span class="line"><span class="comment">  子图在local map坐标系中的位姿 * node在子图的位姿*/</span></span><br><span class="line">  <span class="keyword">const</span> transform::Rigid2d  initial_pose =</span><br><span class="line">      <span class="built_in">ComputeSubmapPose</span>(*submap) * initial_relative_pose;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">float</span> score = <span class="number">0.</span>;</span><br><span class="line">  transform::Rigid2d pose_estimate = transform::Rigid2d::<span class="built_in">Identity</span>();</span><br></pre></td></tr></table></figure>
<p>整个函数是为了计算<code>constraint_transform</code>(submap i &lt;- node j) ，需要的参数有：</p>
<ul>
<li>节点 j 的<code>filtered_gravity_aligned_point_cloud</code></li>
<li>分支定界的初值 <code>initial_pose</code> (local map &lt;- node j)</li>
<li><code>Match()</code> 的结果 <code>pose_estimate</code> (local map &lt;- node j).</li>
<li><code>ComputeSubmapPose()</code>函数 (local map &lt;- submap i)</li>
</ul>
<p>Compute ‘pose_estimate’ in three stages:</p>
<ol>
<li>使用 fast correlative scan matcher 做 Fast estimate</li>
<li>Prune if the score is too low.</li>
<li>ceres Refine</li>
</ol>
<h2 id="匹配所有子图-或-局部子图"><a href="#匹配所有子图-或-局部子图" class="headerlink" title="匹配所有子图 或 局部子图"></a>匹配所有子图 或 局部子图</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配所有子图，对应 MaybeAddGlobalConstraint</span></span><br><span class="line"><span class="keyword">if</span> (match_full_submap)</span><br><span class="line">&#123;</span><br><span class="line">  kGlobalConstraintsSearchedMetric-&gt;<span class="built_in">Increment</span>();</span><br><span class="line">  <span class="keyword">if</span>( submap_scan_matcher.fast_correlative_scan_matcher-&gt;<span class="built_in">MatchFullSubmap</span>(</span><br><span class="line">          constant_data-&gt;filtered_gravity_aligned_point_cloud,</span><br><span class="line">          <span class="comment">// 参数为 global_localization_min_score</span></span><br><span class="line">          options_.<span class="built_in">global_localization_min_score</span>(), </span><br><span class="line">          &amp;score,  &amp;pose_estimate)  )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">CHECK_GT</span>(score, options_.<span class="built_in">global_localization_min_score</span>());</span><br><span class="line">    <span class="built_in">CHECK_GE</span>(node_id.trajectory_id, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">CHECK_GE</span>(submap_id.trajectory_id, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 最后记录下全局约束的次数和统计置信度</span></span><br><span class="line">    kGlobalConstraintsFoundMetric-&gt;<span class="built_in">Increment</span>();</span><br><span class="line">    kGlobalConstraintScoresMetric-&gt;<span class="built_in">Observe</span>(score);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匹配局部子图</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  kConstraintsSearchedMetric-&gt;<span class="built_in">Increment</span>();</span><br><span class="line">  <span class="keyword">if</span> (submap_scan_matcher.fast_correlative_scan_matcher-&gt;<span class="built_in">Match</span>(</span><br><span class="line">          initial_pose, constant_data-&gt;filtered_gravity_aligned_point_cloud,</span><br><span class="line">          <span class="comment">// 参数为 min_score</span></span><br><span class="line">          options_.<span class="built_in">min_score</span>(), </span><br><span class="line">          &amp;score, &amp;pose_estimate)  )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// We&#x27;ve reported a successful local match.</span></span><br><span class="line">    <span class="built_in">CHECK_GT</span>(score, options_.<span class="built_in">min_score</span>());</span><br><span class="line">    kConstraintsFoundMetric-&gt;<span class="built_in">Increment</span>();</span><br><span class="line">    kConstraintScoresMetric-&gt;<span class="built_in">Observe</span>(score);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  score_histogram_.<span class="built_in">Add</span>(score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分枝定界求出的位姿被称为 <strong>初始位姿 3</strong>，这个初始位姿3及其携带的点云作为输入，用于ceres与此子图进行优化匹配</p>
<p>在建立全局约束的时候，直接在一个超大的范围内进行分枝定界搜索，并不需要计算一个特殊的初始位姿2，而直接把初始位姿设置为地图limits的中心点，可以理解为map的中心点。 而且打分的参数也不同了。</p>
<p>全局约束的搜索窗口范围： [1e6 * limits_.resolution(), M_PI]，角度其实是±180°</p>
<h2 id="ceres-refine"><a href="#ceres-refine" class="headerlink" title="ceres refine"></a>ceres refine</h2><p>ceres优化匹配，得到更加准确的优化位置<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use the CSM estimate as both the initial and previous pose. </span></span><br><span class="line"><span class="comment">// This has the effect that, in the absence of better information, </span></span><br><span class="line"><span class="comment">// we prefer the original  CSM estimate.</span></span><br><span class="line">ceres::Solver::Summary  unused_summary;</span><br><span class="line"><span class="comment">// ceres更新pose_estimate，获得节点在local map中的最优位姿</span></span><br><span class="line">ceres_scan_matcher_.<span class="built_in">Match</span>(pose_estimate.<span class="built_in">translation</span>(), pose_estimate,</span><br><span class="line">                 constant_data-&gt;filtered_gravity_aligned_point_cloud,</span><br><span class="line">                *submap_scan_matcher.grid,  &amp;pose_estimate,</span><br><span class="line">                &amp;unused_summary);</span><br><span class="line"><span class="comment">// 计算得到node相对子图的位姿</span></span><br><span class="line"><span class="keyword">const</span> transform::Rigid2d constraint_transform = </span><br><span class="line">    <span class="built_in">ComputeSubmapPose</span>(*submap).<span class="built_in">inverse</span>() * pose_estimate;</span><br><span class="line">constraint-&gt;<span class="built_in">reset</span>(<span class="keyword">new</span> Constraint&#123;submap_id,</span><br><span class="line">       node_id,</span><br><span class="line">       &#123; transform::<span class="built_in">Embed3D</span>(constraint_transform),</span><br><span class="line">        options_.<span class="built_in">loop_closure_translation_weight</span>(),</span><br><span class="line">        options_.<span class="built_in">loop_closure_rotation_weight</span>() &#125;,</span><br><span class="line">       Constraint::INTER_SUBMAP&#125; );</span><br></pre></td></tr></table></figure><br>对于局部约束，<code>constraint_transform</code>并不是回环边，其实就是子图和节点的普通约束。 全局约束才构造回环边</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options_.<span class="built_in">log_matches</span>() )</span><br><span class="line">&#123;</span><br><span class="line">    std::ostringstream info;</span><br><span class="line">    info &lt;&lt; <span class="string">&quot;Node &quot;</span> &lt;&lt; node_id &lt;&lt; <span class="string">&quot; with &quot;</span></span><br><span class="line">         &lt;&lt; constant_data-&gt;filtered_gravity_aligned_point_cloud.<span class="built_in">size</span>()</span><br><span class="line">         &lt;&lt; <span class="string">&quot; points on submap &quot;</span> &lt;&lt; submap_id &lt;&lt; std::fixed;</span><br><span class="line">    <span class="keyword">if</span> (match_full_submap)</span><br><span class="line">         info &lt;&lt; <span class="string">&quot; matches&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">const</span> transform::Rigid2d difference =</span><br><span class="line">          initial_pose.<span class="built_in">inverse</span>() * pose_estimate;</span><br><span class="line">      info &lt;&lt; <span class="string">&quot; differs by translation &quot;</span> &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">2</span>)</span><br><span class="line">           &lt;&lt; difference.<span class="built_in">translation</span>().<span class="built_in">norm</span>() &lt;&lt; <span class="string">&quot; rotation &quot;</span></span><br><span class="line">           &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; std::<span class="built_in">abs</span>(difference.<span class="built_in">normalized_angle</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    info &lt;&lt; <span class="string">&quot; with score &quot;</span> &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; <span class="number">100.</span> * score &lt;&lt; <span class="string">&quot;%.&quot;</span>;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; info.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/20/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/%E6%80%9D%E8%80%83%E7%9A%84%E9%97%AE%E9%A2%98/">思考的问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/">原理和配置</a></span><div class="content"><p>子图插入scan结束时CPU升高</p>
<p>为什么要用线程池</p>
<p>To be sure there is a recent loop closure constraint, you can query <code>PoseGraphInterface::constraints()</code>, loop over all constraints and check if there is a recent one of type INTER that spans some time.</p>
<p>A simpler solution is to subscribe to the global slam callback <code>GlobalSlamOptimizationCallback</code> by setting <code>PoseGraphInterface::SetGlobalSlamOptimizationCallback</code>. This will call you back after Cartographer has searched for loop closures. It does not tell you if loop closures were found, it mostly tells you if the background loop closure search is keeping up or falls behind.</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/05/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/gmapping%E5%92%8CAMCL%E7%9A%84%E5%8C%BA%E5%88%AB/">gmapping和AMCL的区别</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/">amcl和粒子滤波</a></span><div class="content"><h2 id="粒子"><a href="#粒子" class="headerlink" title="粒子"></a>粒子</h2><p>AMCL的粒子只包括位姿和权重，需要大量的粒子才能较好描述机器人位姿。gmapping的粒子包括轨迹、地图、权重，粒子过多会占用很大的内存。</p>
<p>AMCL的粒子在初始化时，各粒子的位姿是不同的，是均值参数加高斯噪声； gmapping粒子初始化时，粒子的位姿都是相同的。 所以说AMCL更符合撒粒子的逻辑。</p>
<p>AMCL的粒子数不是固定的，有最小和最大粒子数。在定位过程中，KLD采样会动态减少粒子数；gmapping的粒子数一直是固定的。</p>
<p>AMCL的提议分布是运动模型，分布的特点是又扁又宽； gmapping的提议分布是运动模型又加入了最近的观测，分布特点是小的尖峰。</p>
<p>AMCL的粒子权重是似然域模型改变，gmapping是通过scan match</p>
<p>AMCL输出的位姿是所有粒子加权平均后的结果； gmapping是输出得分最高的粒子</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/5/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/48/">48</a><a class="extend next" rel="next" href="/page/7/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/07/13/RCLw5Bx8aFPN74b.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2021 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>