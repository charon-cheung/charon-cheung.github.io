<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">661</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">52</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/09/C++/C++%20%20%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">编程技巧</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E5%9F%BA%E7%A1%80/">C++ 基础</a></span><div class="content"><h2 id="对浮点数进行四舍五入"><a href="#对浮点数进行四舍五入" class="headerlink" title="对浮点数进行四舍五入"></a>对浮点数进行四舍五入</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEstimate</span><span class="params">(<span class="keyword">float</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in"><span class="keyword">int</span></span>(a + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="double-只取小数点后两位"><a href="#double-只取小数点后两位" class="headerlink" title="double 只取小数点后两位"></a>double 只取小数点后两位</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">0.2500000500001</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="built_in">floor</span>(d * <span class="number">10000.000f</span> + <span class="number">0.5</span>) / <span class="number">10000.000f</span>;</span><br></pre></td></tr></table></figure>
<h2 id="回调函数的降频功能"><a href="#回调函数的降频功能" class="headerlink" title="回调函数的降频功能"></a>回调函数的降频功能</h2><p>这是从gmapping里学的，cartographer里也有，但是更复杂了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> laser_count_ = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> throttle_scans_ = <span class="number">5</span>;  <span class="comment">// 自定义的值</span></span><br><span class="line">SlamGMapping::<span class="built_in">laserCallback</span>(<span class="keyword">const</span> sensor_msgs::LaserScan::ConstPtr&amp; scan)</span><br><span class="line">&#123;</span><br><span class="line">  laser_count_++;</span><br><span class="line">  <span class="keyword">if</span> ((laser_count_ % throttle_scans_) != <span class="number">0</span>)  <span class="comment">// 判断是否降频</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// ... 主要代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="在终端显示带颜色和风格的文字"><a href="#在终端显示带颜色和风格的文字" class="headerlink" title="在终端显示带颜色和风格的文字"></a>在终端显示带颜色和风格的文字</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// color指定颜色BLACK, RED, GREEN, YELLOW, BLUE, WHITE, option指定文字风格BOLD, REGULAR, UNDERLINE.</span></span><br><span class="line"><span class="keyword">const</span> std::string RESET = <span class="string">&quot;\033[0m&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> std::string BLACK = <span class="string">&quot;0m&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> std::string RED = <span class="string">&quot;1m&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> std::string GREEN = <span class="string">&quot;2m&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> std::string YELLOW = <span class="string">&quot;3m&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> std::string BLUE = <span class="string">&quot;4m&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> std::string WHITE = <span class="string">&quot;7m&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> std::string BOLD = <span class="string">&quot;\033[1;3&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> std::string REGULAR = <span class="string">&quot;\033[0;3&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> std::string UNDERLINE = <span class="string">&quot;\033[4;3&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> std::string BACKGROUND = <span class="string">&quot;\033[4&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">colouredString</span><span class="params">(std::string str, std::string colour, std::string option)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> time_now = ros::Time::<span class="built_in">now</span>().<span class="built_in">toSec</span>();</span><br><span class="line">  std::string time_string = std::<span class="built_in">to_string</span>(time_now);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + time_string + <span class="string">&quot;]: &quot;</span> + option + colour + str + RESET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生成极值"><a href="#生成极值" class="headerlink" title="生成极值"></a>生成极值</h2><p>C++11中，std::numeric_limits为模板类，在库编译平台提供基础算术类型的极值等属性信息，取代传统C语言，所采用的预处理常数。比较常用的使用是对于给定的基础类型用来判断在当前系统上的最大值、最小值。需包含<limits>头文件。</p>
<p><code>std::numeric_limits&lt;double&gt;::max();</code>的结果是一个很大的数字</p>
<h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><ul>
<li><p><code>hypot()</code>用来求三角形的斜边长，其原型为：<code>double hypot(double x, double y);</code>，需要<code>#include &lt;stdio.h&gt;</code></p>
</li>
<li><p><code>fabs</code>函数是求绝对值的函数，函数原型是<code>extern float fabs(float x)</code>，需要<code>#include &lt;math.h&gt;</code></p>
</li>
</ul>
<p>对double/float数据，一定要使用fabs函数。如果用了abs，就会出现bug，因为返回也是int</p>
<h2 id="反正切函数求角度"><a href="#反正切函数求角度" class="headerlink" title="反正切函数求角度"></a>反正切函数求角度</h2><p><code>atan2</code>返回给定的 X 及 Y 坐标值的反正切值。反正切的角度值等于 X 轴与通过原点和给定坐标点 (Y坐标, X坐标) 的直线之间的夹角。结果以弧度表示并介于<code>-pi</code>到<code>pi</code>之间（不包括<code>-pi</code>）。 </p>
<p>而<code>atan(a/b)</code>的取值范围介于<code>-pi/2</code>到<code>pi/2</code>之间，不包括±pi/2</p>
<h2 id="生成27个三维向量，每个可取-1-0-1，一共27种组合"><a href="#生成27个三维向量，每个可取-1-0-1，一共27种组合" class="headerlink" title="生成27个三维向量，每个可取-1,0,1，一共27种组合"></a>生成27个三维向量，每个可取-1,0,1，一共27种组合</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span> * <span class="number">3</span> * <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> a = (i / <span class="number">9</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = ((i % <span class="number">9</span>) / <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = ((i % <span class="number">9</span>) % <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">killNode</span><span class="params">(std::string nodeName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> status;</span><br><span class="line">  string cmd = <span class="string">&quot;rosnode kill &quot;</span>+nodeName;</span><br><span class="line">  status = <span class="built_in">system</span>(cmd.<span class="built_in">data</span>());</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">-1</span> == status)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// system func error</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))    <span class="comment">//返回一个非零值, 正常退出</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">ROS_INFO</span>(<span class="string">&quot;child process exit done: %d&quot;</span>, <span class="built_in">WEXITSTATUS</span>(status) );</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">WEXITSTATUS</span>(status);   <span class="comment">// rosnode kill done, exit status value</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">ROS_WARN</span>(<span class="string">&quot;child process exit abnormally&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">getCmdResult</span><span class="params">(<span class="keyword">const</span> string &amp;strCmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">10240</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  FILE *pf = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span>( (pf = <span class="built_in">popen</span>(strCmd.<span class="built_in">c_str</span>(), <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  string strResult;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">fgets</span>(buf, <span class="keyword">sizeof</span> buf, pf))</span><br><span class="line">  &#123;</span><br><span class="line">    strResult += buf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pclose</span>(pf);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> iSize =  strResult.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span>(iSize &gt; <span class="number">0</span> &amp;&amp; strResult[iSize - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)  <span class="comment">// linux</span></span><br><span class="line">  &#123;</span><br><span class="line">    strResult = strResult.<span class="built_in">substr</span>(<span class="number">0</span>, iSize - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ros::Time 转为年月日的string</span></span><br><span class="line"><span class="function">std::string <span class="title">stampToString</span><span class="params">(<span class="keyword">const</span> ros::Time&amp; stamp, <span class="keyword">const</span> std::string format=<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> output_size = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">char</span> output[output_size];</span><br><span class="line">  std::<span class="keyword">time_t</span> raw_time = <span class="keyword">static_cast</span>&lt;<span class="keyword">time_t</span>&gt;(stamp.sec);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">timeinfo</span> =</span> <span class="built_in">localtime</span>(&amp;raw_time);</span><br><span class="line">  std::<span class="built_in">strftime</span>(output, output_size, format.<span class="built_in">c_str</span>(), timeinfo);</span><br><span class="line">  std::stringstream ss; </span><br><span class="line">  ss &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">9</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; stamp.nsec;  </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> fractional_second_digits = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(output) + <span class="string">&quot;.&quot;</span> + ss.<span class="built_in">str</span>().<span class="built_in">substr</span>(<span class="number">0</span>, fractional_second_digits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tf2_ros::Buffer buff;</span><br><span class="line"><span class="function">tf2_ros::TransformListener <span class="title">listener</span><span class="params">(buff)</span></span>;</span><br><span class="line"></span><br><span class="line">geometry_msgs::PoseStamped  point_in, point_out;</span><br><span class="line">point_in.header.frame_id = <span class="string">&quot;laser_link&quot;</span>;</span><br><span class="line">point_in.header.stamp = ros::<span class="built_in">Time</span>(<span class="number">0</span>);</span><br><span class="line">point_in.pose =    <span class="comment">//赋值</span></span><br><span class="line"><span class="comment">// buff跟上面的使用一样， 返回的point_out是point_in在 parent坐标系 的坐标</span></span><br><span class="line">point_out = buff.<span class="built_in">transform</span>(point_in, point_out, <span class="string">&quot;map&quot;</span>, ros::<span class="built_in">Duration</span>(<span class="number">0.3</span>) );</span><br></pre></td></tr></table></figure>
<h2 id="获得Linux命令的结果"><a href="#获得Linux命令的结果" class="headerlink" title="获得Linux命令的结果"></a>获得Linux命令的结果</h2><p>比如输入<code>ls</code>，返回当前目录的文件名<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">getCmdResult</span><span class="params">(<span class="keyword">const</span> string &amp;strCmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">10240</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  FILE *pf = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span>( (pf = <span class="built_in">popen</span>(strCmd.<span class="built_in">c_str</span>(), <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  string strResult;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">fgets</span>(buf, <span class="keyword">sizeof</span> buf, pf))</span><br><span class="line">  &#123;</span><br><span class="line">    strResult += buf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pclose</span>(pf);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> iSize =  strResult.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span>(iSize &gt; <span class="number">0</span> &amp;&amp; strResult[iSize - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)  <span class="comment">// linux</span></span><br><span class="line">  &#123;</span><br><span class="line">    strResult = strResult.<span class="built_in">substr</span>(<span class="number">0</span>, iSize - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/18/%E7%9B%B8%E6%9C%BA/%E4%BB%8EROS%E9%85%8D%E7%BD%AErealsense%E7%9A%84%E5%8F%82%E6%95%B0/">从ROS配置realsense的参数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E7%9B%B8%E6%9C%BA/">相机</a></span><div class="content"><h2 id="使用json配置realsense的参数-非rosparam"><a href="#使用json配置realsense的参数-非rosparam" class="headerlink" title="使用json配置realsense的参数(非rosparam)"></a>使用json配置realsense的参数(非rosparam)</h2><p>今天使用realsense时，发现有个参数需要修改<br><img src="https://i.loli.net/2020/10/15/lWn3xzM1CiyZtQX.png" alt="Set Point.png"><br>这个参数可以修正因反光而导致的错误，也就是把稍微凸起的地面当做障碍物，适当减小这个参数可以实现。</p>
<p>这个界面在realsense viewer中，但问题是如何在ROS中做到，它在rosparam中没有对应的参数。查来查去，在github的issue里发现了解决方法。realsense已经提供了一种<code>visual preset</code>文件，其实是个json文件，可以对很多参数设置，而且realsense的launch文件中已经定义了json文件的路径，比如<code>rs_camera.launch</code>:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;json_file_path&quot;</span>      <span class="attr">default</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>realsense提供的所有json文件在<a target="_blank" rel="noopener" href="https://github.com/IntelRealSense/librealsense/wiki/D400-Series-Visual-Presets">这里</a>，我们需要的参数在<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/wiki/IntelRealSense/librealsense/d400_presets/DefaultPreset_D435.json">DefaultPreset_D435.json</a>，也就是第一个参数：<code>&quot;aux-param-autoexposure-setpoint&quot;: &quot;400&quot;</code>，修改它的值后，把json文件的路径填到上面launch参数那里，启动launch就可以实现了。不过不能动态调整参数。</p>
<h2 id="配置点云的滤波器"><a href="#配置点云的滤波器" class="headerlink" title="配置点云的滤波器"></a>配置点云的滤波器</h2><p><code>rs_camera.launch</code>的参数是比较全的，<code>demo_pointcloud.launch</code>比较少。</p>
<p>现在介绍<code>filters</code>这个参数，在launch中没有赋值:<code>&lt;arg name=&quot;filters&quot;  default=&quot;&quot;/&gt;</code></p>
<p>pointcloud: 点云话题是<code>/camera/depth/color/points</code>. 点云的texture可以在<code>rqt_reconfigure</code>里修改，或者用参数<code>pointcloud_texture_stream</code>和<code>pointcloud_texture_index</code>修改</p>
<p>The depth FOV and the texture FOV are not similar. By default, pointcloud is limited to the section of depth containing the texture. You can have a full depth to pointcloud, coloring the regions beyond the texture with zeros, by setting allow_no_texture_points to true.</p>
<p>可以配置的滤波器如下:</p>
<ul>
<li>disparity, convert depth to disparity before applying other filters and back.</li>
<li>spatial，filter the depth image spatially.</li>
<li>temporal，filter the depth image temporally.</li>
<li>hole_filling，apply hole-filling filter.</li>
<li>decimation，reduces depth scene complexity.</li>
</ul>
<p>所有滤波器的说明在<a target="_blank" rel="noopener" href="https://github.com/IntelRealSense/librealsense/blob/master/doc/post-processing-filters.md">这里</a></p>
<p>给参数<code>filters</code>赋值，必须有<code>pointcloud</code>，再增加滤波器，用逗号隔开。比如 <code>disparity,spatial,pointcloud</code></p>
<p>滤波器的相关的源码在<code>base_realsense_node.cpp</code></p>
<ul>
<li><p><code>BaseRealSenseNode::setupFilters()</code>, 读取参数<code>filters</code>，把所有滤波器名称都插入容器<code>_filters</code></p>
</li>
<li><p><code>BaseRealSenseNode::publishPointCloud()</code>, 发布滤波后的点云</p>
</li>
</ul>
<p>参考:<br><a target="_blank" rel="noopener" href="https://github.com/IntelRealSense/realsense-ros">realsense-ros 滤波器</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Dontla/article/details/103574458">CSDN Realsense D435 Post-processing filters</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/18/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/ROS%E7%89%88%E6%9C%AC%E4%B8%8D%E5%85%BC%E5%AE%B9%E4%BA%A7%E7%94%9F%E7%9A%84TransformListenerWrapper%E9%97%AE%E9%A2%98/">tf的疑难问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a></span><div class="content"><h2 id="ROS版本不兼容产生的TransformListenerWrapper问题"><a href="#ROS版本不兼容产生的TransformListenerWrapper问题" class="headerlink" title="ROS版本不兼容产生的TransformListenerWrapper问题"></a>ROS版本不兼容产生的TransformListenerWrapper问题</h2><p><code>AmclNode</code>类中有这样一段：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use a child class to get access to tf2::Buffer class inside of tf_</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TransformListenerWrapper</span> :</span> <span class="keyword">public</span> tf::TransformListener</span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> tf2_ros::Buffer &amp;<span class="title">getBuffer</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> tf2_buffer_;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这是Kinetic的版本，但是在Melodic里没有这一段了，这是ROS版本兼容问题，在Kinetic里用不了这个结构体了。搜索发现<code>getBuffer</code>只有在<code>AmclNode::runFromBag</code>里调用，因为平时不用bag仿真时测试AMCL，所以这句话可以注释掉。</p>
<h2 id="“map”-passed-to-lookupTransform-argument-target-frame-does-not-exist"><a href="#“map”-passed-to-lookupTransform-argument-target-frame-does-not-exist" class="headerlink" title="“map” passed to lookupTransform argument target_frame does not exist"></a>“map” passed to lookupTransform argument target_frame does not exist</h2><p>解决方法： 先加上<code>listener.waitForTransform</code>，再<code>lookupTransform</code></p>
<p>The listener’s buffer, which carries all information about recent transformation, is literally empty. Therefore, any transform which looks-up the buffer does not find the frames it needs. It is good practice to wait for some time after the listener has been created so that the buffer can fill up. But instead of just sleeping, tf use <code>waitForTransform</code></p>
<p>参考: <a target="_blank" rel="noopener" href="https://answers.ros.org/question/192570/tftransformlistenertransformpose-exception-target_frame-does-not-exist/"></a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/25/%E6%BF%80%E5%85%89SLAM/ICP%E5%92%8CNDT/csm%E5%8C%85%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%20(%E4%BA%8C)/">csm包的源码解读 (二)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/ICP%E5%92%8CNDT/">ICP和NDT</a></span><div class="content"><p><img src="https://i.loli.net/2020/09/25/6sJwMcTGiyY9Ztb.png" alt="smart algorithm.png"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/20/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E5%9D%90%E6%A0%87%E7%B3%BB%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/">坐标系空间转换</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a></span><div class="content"><p>机器人SLAM问题中涉及到平移和旋转，平移是在欧氏空间中，连续的平移变换只需要向量相加。 可是旋转是在非欧空间了，连续的旋转变换就是矩阵连续右乘</p>
<p>右手坐标系：x向前(roll)，y向左(pitch)，z向上(yaw)</p>
<h2 id="用矩阵表示绕某轴旋转"><a href="#用矩阵表示绕某轴旋转" class="headerlink" title="用矩阵表示绕某轴旋转"></a>用矩阵表示绕某轴旋转</h2><p><img src="https://s2.loli.net/2023/01/19/QRagYNKoc2x54GB.png" alt=""></p>
<h2 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h2><p>坐标系A变换到B，从坐标系B到坐标系A的旋转矩阵的每一列，都是{B}的坐标轴单位向量在{A}中的表示<br><img src="https://i.loli.net/2020/09/04/RuIYGCytabgMZDo.png" alt=""><br>旋转矩阵R是一个行列式为1的正交矩阵，而且行向量和列向量的长度都为1，所以它的转置就是它的逆，而逆矩阵就可以将坐标系旋转回来。<br>R的每一行就是{A}的坐标轴单位向量在{B}中的表示。<br>SO(n)是特殊正交群，这个集合由n维空间的旋转矩阵组成。  SO(3)指三维空间的旋转。<br><img src="https://i.loli.net/2020/09/04/RKUsCZrv76zDO4P.png" alt=""></p>
<h2 id="变换矩阵"><a href="#变换矩阵" class="headerlink" title="变换矩阵"></a>变换矩阵</h2><script type="math/tex; mode=display">T =\left[ \begin{matrix}   R & t \\   0 & 1 \\ \end{matrix}  \right]</script><p>左上角为旋转矩阵，右侧为平移向量，这种矩阵又称为特殊欧氏群</p>
<script type="math/tex; mode=display">SE(3) = \left \{T =\left[ \begin{matrix}   R & t \\   0 & 1 \\ \end{matrix}  \right] \in \mathbb{R}^{4\times4} \ | R\in SO(3), t\in \mathbb{R}^3  \right \}</script><p>逆矩阵的形式 <script type="math/tex">\left[ \begin{matrix}   R & t \\   0 & 1 \\ \end{matrix}  \right]^{-1} \ = \left[ \begin{matrix}   R^T & -R^Tt \\   0 & 1 \\ \end{matrix}  \right]</script></p>
<p>如果一个点的坐标是 <script type="math/tex">P(x,y,z)</script>，那么点作T变换后的坐标就写作 <script type="math/tex">R*P + t</script>，按齐次矩阵和坐标形式计算就可得到。</p>
<h2 id="Censi-公式"><a href="#Censi-公式" class="headerlink" title="Censi 公式"></a>Censi 公式</h2><p>我习惯用Censi论文的公式，还可以用<code>Grisetti</code>派系的<br><img src="https://i.loli.net/2020/09/20/hsubLed7priFZmS.jpg" alt="坐标系示意图.jpg"><br><img src="https://i.loli.net/2020/09/20/YzpFTi8yEwqHhf5.jpg" alt="圆加和圆减.jpg"><br><img src="https://i.loli.net/2020/09/20/WbSvxUlGwCHNzgF.png" alt=""></p>
<script type="math/tex; mode=display">\quad\quad\quad\quad\quad\quad \vec{a} \oplus \vec{b} = \vec{c}</script><p>$\quad\quad\quad\quad\quad\quad\quad\Downarrow$</p>
<script type="math/tex; mode=display">\begin{pmatrix} a_x \\ a_y \\ a_{\theta} \end{pmatrix} + \left[ \begin{matrix}   cos_{a_\theta} & -sin_{a_\theta} & 0 \\  sin_{a_\theta} & cos_{a_\theta} & 0 \\ 0 & 0 & 1\end{matrix}  \right] *  \begin{pmatrix} b_x \\ b_y \\ b_{\theta} \end{pmatrix} = \begin{pmatrix} c_x \\ c_y \\ c_{\theta} \end{pmatrix}</script><p>其实这里就是 <script type="math/tex">Rp + t</script> ，只是在二维平面，R就是绕Z轴旋转的旋转矩阵形式。</p>
<h2 id="左乘和右乘"><a href="#左乘和右乘" class="headerlink" title="左乘和右乘"></a>左乘和右乘</h2><p>左乘是行变换，右乘是列变换。这是因为习惯上来说，空间中的向量用列向量表示，用矩阵左乘列向量，就是把它在空间当中变换。</p>
<p>若绕静坐标系（世界坐标系）旋转，则左乘，也是<strong>变换矩阵 x 坐标矩阵</strong>。 在固定坐标系下，一个点 <script type="math/tex">p</script> 经过一个旋转矩阵<script type="math/tex">R_1</script>，再经过一个旋转 <script type="math/tex">R_2</script> ，总共旋转 <script type="math/tex">R_2 * R_1 * p</script>，这是左乘。 向量旋转中的右乘本没必要，甚至会引起人误解。</p>
<p>若是绕动态坐标系旋转（自身建立一个坐标系），则右乘，也就是<strong>坐标矩阵 x 变换矩阵</strong>。 </p>
<p>即左乘是相对于坐标值所在的坐标系（世界坐标系）下的三个坐标轴进行旋转变换，右乘则是以当前点为旋转中心，进行旋转变换。</p>
<font size="4" color="blue"> 车在全局坐标系中运动，这可以看做绕固定轴旋转的过程，是左乘矩阵  </font>

<p>具体去看文章： <a href="https://charon-cheung.github.io/2019/06/11/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E6%AC%A7%E6%8B%89%E8%A7%92%EF%BC%8C%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%EF%BC%8C%E6%97%8B%E8%BD%AC%E5%90%91%E9%87%8F%EF%BC%8C%E5%9B%9B%E5%85%83%E6%95%B0/#%E5%9B%9B%E5%85%83%E6%95%B0">欧拉角，旋转矩阵，旋转向量，四元数</a></p>
<p>图优化里的相对位姿是由右乘获得的，即节点 $X_i$ 和 $X_j$ 之间的相对位姿是</p>
<script type="math/tex; mode=display">Z_{ij} = X_i^{-1}*X_j</script><p>常用的公式 <script type="math/tex">P_c=R_c∗P_w+t_c</script> 是把点P从<script type="math/tex">w</script>坐标系转换到 <script type="math/tex">c</script> 坐标系，由于旋转时，两个坐标系原点还是重合的，我们说经过了平移后，平移向量 <script type="math/tex">t_c</script> 是从坐标系 <script type="math/tex">w</script>坐标系指向 <script type="math/tex">c</script> </p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://www.pianshen.com/article/17351558785/">cartographer中公式的推导</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/19/%E6%BF%80%E5%85%89SLAM/ICP%E5%92%8CNDT/laser_scan_matcher%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">laser_scan_matcher 源码解读</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/ICP%E5%92%8CNDT/">ICP和NDT</a></span><div class="content"><p>主要是<code>LaserScanMatcher</code>的构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;LaserScanMatcher&quot;</span>);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line"><span class="function">ros::NodeHandle <span class="title">nh_private</span><span class="params">(<span class="string">&quot;~&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">scan_tools::LaserScanMatcher <span class="title">laser_scan_matcher</span><span class="params">(nh, nh_private)</span></span>;</span><br><span class="line">ros::<span class="built_in">spin</span>();</span><br></pre></td></tr></table></figure></p>
<p>构造函数里初始化一系列参数，重点就是回调函数<code>scanCallback</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一帧scan, cache the tf from base to the scanner</span></span><br><span class="line"><span class="keyword">if</span> (!initialized_)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">createCache</span>(scan_msg);    <span class="comment">// caches the sin and cos of all angles</span></span><br><span class="line">  <span class="comment">// cache the static tf from base to laser</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">getBaseToLaserTf</span>(scan_msg-&gt;header.frame_id))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_WARN</span>(<span class="string">&quot;Skipping scan&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 保存scan数据到  LDP  prev_ldp_scan_;</span></span><br><span class="line">  <span class="built_in">laserScanToLDP</span>(scan_msg, prev_ldp_scan_);</span><br><span class="line">  last_icp_time_ = scan_msg-&gt;header.stamp;</span><br><span class="line">  initialized_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二帧及以后的scan</span></span><br><span class="line">index++;		<span class="comment">// static unsigned int index;</span></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;scan index: %d&quot;</span>, index);</span><br><span class="line">LDP  curr_ldp_scan;</span><br><span class="line"><span class="built_in">laserScanToLDP</span>(scan_msg, curr_ldp_scan);</span><br><span class="line"><span class="built_in">processScan</span>(curr_ldp_scan, scan_msg-&gt;header.stamp);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.loli.net/2020/09/20/VTNfbxGYmPqK3Li.png" alt="流程.png"></p>
<h2 id="公式计算"><a href="#公式计算" class="headerlink" title="公式计算"></a>公式计算</h2><h2 id="newKeyframeNeeded"><a href="#newKeyframeNeeded" class="headerlink" title="newKeyframeNeeded"></a>newKeyframeNeeded</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(tf::<span class="built_in">getYaw</span>(d.<span class="built_in">getRotation</span>())) &gt; kf_dist_angular_)</span><br><span class="line">   <span class="keyword">return</span>   <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">double</span> x = d.<span class="built_in">getOrigin</span>().<span class="built_in">getX</span>();</span><br><span class="line"><span class="keyword">double</span> y = d.<span class="built_in">getOrigin</span>().<span class="built_in">getY</span>();</span><br><span class="line"><span class="keyword">if</span> (x*x + y*y &gt; kf_dist_linear_sq_)</span><br><span class="line">   <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>优先判断相对旋转</p>
<p>调用是这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交换新旧frame, key frame 的意思应该是当前配准时的参考帧</span></span><br><span class="line"><span class="comment">// 这个在机器人一直走直线或原地旋转时很难发生</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">newKeyframeNeeded</span>(corr_ch))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// generate  a  keyframe</span></span><br><span class="line">	<span class="built_in">ld_free</span>(prev_ldp_scan_);</span><br><span class="line">	prev_ldp_scan_ = curr_ldp_scan;</span><br><span class="line">	<span class="comment">// 更新下一个时间段的 f2b_kf</span></span><br><span class="line">	f2b_kf_ = f2b_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>prev_ldp_scan_</code>之前是第一帧scan的数据，只有需要 key frame时，才会更新它，但在<code>processScan</code>开头又会把估计位姿和真值初始化为0。  如果没有达到运动阈值，<code>prev_ldp_scan_</code>还是第一帧scan，时间也是第一帧的时间，仍以第一帧为基准进行ICP配准</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/08/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6%E8%99%9A%E5%87%BD%E6%95%B0%20(%E4%BA%8C)%20/">深入探究虚函数 (二) 虚函数表vtbl和虚表指针vptr</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><p>虚函数表是通过一块内存来存储虚函数的地址，它实际是一个函数指针数组，每一个元素都是虚函数的指针，虚函数表的最后一个元素是一个空指针。假如虚函数类型为int，函数指针就是<code>int*</code>类型．<font color = orange size=4>虚函数表将被该类的所有对象共享，每个对象内部包含了一个虚表指针，指向虚函数表 </font></p>
<p>有虚函数的类的最开始部分就是虚指针，它指向虚函数表起始地址，类型为<code>int**</code>（如果虚函数类型int），表中存放虚函数的地址。通过这个指针可以获取到该类对象的所有虚函数，包括父类的。 </p>
<font color = blue size=4>在编译期，编译器完成了虚表的创建，而虚指针在构造函数期间被初始化 </font>

<p><strong>因为派生类会继承基类的虚函数表，</strong>所以通过虚函数表，我们就可以知道该类对象的父类，在转换的时候就可以用来判断对象有无继承关系。派生类中增加的虚函数，如果覆盖了基类的虚函数，虚函数表中会替换相应的基类虚函数，地址换成派生类的；如果没有覆盖基类的虚函数，就添加到原虚函数表后面，以空指针结尾． 所以说派生类的虚函数表中的函数地址不是连续的，基类的是连续的。</p>
<p>虚指针地址是否与this指针相同</p>
<p>类Base的虚表如下图：<br><img src="https://i.loli.net/2020/09/08/gjM4aP5xL8YQGDd.png" alt="Base.png"><br>如果派生类Derived没有覆盖基类的虚函数，它的虚函数表如下图：<br><img src="https://i.loli.net/2020/09/08/KUrxlAep59sbkqy.png" alt="2020-09-08_171319.png"></p>
<p>如果覆盖vFunc1，则替换Base的vFunc1；如果还定义了一个虚函数vFunc3，那么继续往虚函数表之后填，最后一个数组成员还是空指针</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.dzwspace.com/article/cpp-vtbl/">C++ 虚函数表</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/LF_2016/article/details/52311227">深入C++对象模型&amp;虚函数表</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/03/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%8F%91%E5%B8%83%E8%80%85%E7%9A%84latch%E6%9C%BA%E5%88%B6/">发布者的latch机制</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><p>这个就是最常用的advertise函数的最后一个参数，原型： <code>advertise (const std::string &amp;topic, uint32_t queue_size, bool latch=false)</code></p>
<p>是否锁存。某些话题并不是会以某个频率发布，比如<code>/map</code>这个topic，只有在初次订阅或者地图更新这两种情况下，才会向<code>/map</code>发布消息，这里就用到了锁存。</p>
<p>锁存的作用就是，将发布者最后一次发布的消息保存下来，然后把它自动发送给后来的订阅者。这种方式非常适合变动较慢、相对固定的数据（例如地图），然后只发布一次，相比于同样的消息不定的发布，锁存的方式既可以减少通信中对带宽的占用，也可以减少消息资源维护的开销。</p>
<p>查看gmapping中的函数<code>SlamGMapping::startLiveSlam()</code>，发现三个话题都是 latched：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">entropy_publisher_ = private_nh_.advertise&lt;std_msgs::Float64&gt;(<span class="string">&quot;entropy&quot;</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">sst_ = node_.advertise&lt;nav_msgs::OccupancyGrid&gt;(<span class="string">&quot;map&quot;</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">sstm_ = node_.advertise&lt;nav_msgs::MapMetaData&gt;(<span class="string">&quot;map_metadata&quot;</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p><code>latch=true</code>，发布消息一次或几次，然后设法阻塞程序(常常用spin()，这里只是阻塞，跟订阅无关)，订阅者仍然能收到阻塞之前发布的消息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ros::<span class="built_in">init</span>(argc,argv, <span class="string">&quot;Pub&quot;</span>);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">ros::Publisher pub_latch_true = nh.advertise&lt;std_msgs::Int8&gt;(<span class="string">&quot;topic_latch_true&quot;</span>, <span class="number">50</span>, <span class="literal">true</span>);</span><br><span class="line">ros::Publisher pub_latch_false = nh.advertise&lt;std_msgs::Int8&gt;(<span class="string">&quot;topic_latch_false&quot;</span>, <span class="number">50</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">std_msgs::Int8 msg;</span><br><span class="line">msg.data = <span class="number">2</span>;</span><br><span class="line">pub_latch_true.<span class="built_in">publish</span>(msg);</span><br><span class="line">pub_latch_false.<span class="built_in">publish</span>(msg);</span><br><span class="line"><span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line">  ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">  rate.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>运行程序后等一会，运行<code>rostopic echo topic_latch_false</code>，什么也没有。运行<code>rostopic echo topic_latch_true</code>，会收到<code>data=2</code>的消息。  即使先运行两个echo，再运行发布者，结果也是如此</p>
<p><code>bool Publisher::isLatched () const</code> 用于判断是否latch</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/03/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5/">协方差矩阵</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a></span><div class="content"><p>协方差可以表示两个变量的协同关系， 变化趋势是否一致。 <strong>相关性</strong>就是用X、Y的协方差除以X的标准差和Y的标准差。</p>
<p>我们机器人用到的向量是<code>(x,y,z, roll,pitch,yaw)</code>，协方差就是一个6x6的矩阵，对角线的元素为各个随机变量的方差，非对角线的元素就是两两随机变量之间的协方差。AMCL中所用的协方差矩阵，由于z,pitch,roll都是0，矩阵的第1,8和最后的元素，分别是x,y,yaw的方差。另外还有x和y的协方差</p>
<p>如果协方差矩阵是单位矩阵，那么就是标准的多元高斯分布。由于协方差矩阵是对称矩阵，所以可以做特征分解</p>
<script type="math/tex; mode=display">\Sigma = P\Lambda P^T</script><p>其实可以变成</p>
<script type="math/tex; mode=display">\Sigma = \left(U\Lambda^\frac{1}{2} \right)  \left(U\Lambda^\frac{1}{2}\right)^T = AA^T</script><p>因此任意一个协方差矩阵可以看做三维变换的结果，<font color = blue size=4>概率密度函数是由协方差矩阵的特征向量控制旋转，特征值控制尺度。 协方差矩阵就是根据这两项对标准高斯分布进行变换。 </font></p>
<p>AMCL中的<code>pf_ran_gaussian</code>函数是以对角线元素为标准差，生成一个高斯分布。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/03/PCL%E7%82%B9%E4%BA%91/%E5%85%AB%E5%8F%89%E6%A0%91%E5%9C%B0%E5%9B%BE/">点云地图和八叉树地图</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/PCL%E7%82%B9%E4%BA%91/">PCL点云</a></span><div class="content"><p>如果点云分布非常规整，是某个特定物体的点云模型，则应该使用Octree，因为很容易求解凸包并且点与点之间相对距离无需再次比对父节点和子节点，更加明晰，典型的例子是斯坦福的兔子。</p>
<p><code>lego_loam</code>建立的点云太稀疏，只能用于定位而不能导航。</p>
<p>用RGBD建立3D稠密点云图，并使用octomap进行压缩滤除地面信息。然后通过2D投影生成占据栅格地图最后利用costmap进行全局和局部路径规划导航实时避障，这又变成2D导航了</p>
<p>点云地图也有一些基于ICP或直接用八叉树地图的三维导航的方法，可以用于无人机在三维空间的导航。至于稀疏特征点地图，容易受光照和场景影响</p>
<p>点云地图: 无序,因为它的点都是无序的,无法坐标索引查询</p>
<p>八叉树地图特点</p>
<ul>
<li>稀疏: 不需要对空间进行稠密切分</li>
<li>结构化: 方块排列固定,切分为八份</li>
<li>非直接索引查询</li>
</ul>
<p>八叉树地图基于OctoTree，可以是多分辨率的地图<br><img src="https://i.loli.net/2020/09/03/1fKaz4ZpHdjEeRS.png" alt="八叉树"></p>
<p>Voxel Grid就像3D的占用地图，分辨率是固定的<br><img src="https://i.loli.net/2020/09/03/jHnJtO7UfkPmIRx.jpg" alt="VoxelGrid"></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/38/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/38/">38</a><span class="page-number current">39</span><a class="page-number" href="/page/40/">40</a><span class="space">&hellip;</span><a class="page-number" href="/page/67/">67</a><a class="extend next" rel="next" href="/page/40/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2023 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>