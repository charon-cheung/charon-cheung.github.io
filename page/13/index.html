<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/13/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-路径规划/代价地图/CostmapModel" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/CostmapModel/" class="article-date">
  <time class="dt-published" datetime="2020-11-15T12:12:58.000Z" itemprop="datePublished">2020-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a>►<a class="article-category-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/CostmapModel/">CostmapModel 判断是否碰撞</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><code>CostmapModel</code>类继承了<code>WorldModel</code>，能够获取点、连线、多边形轮廓的cost，是局部规划器与costmap间的一个桥梁。<strong>初始化在move_base的构造函数，</strong>一般如下使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//costmap_2d::Costmap2DROS*  planner_costmap_ros_</span></span><br><span class="line">world_model_ = <span class="keyword">new</span> base_local_planner::<span class="built_in">CostmapModel</span>(*(planner_costmap_ros_ -&gt;<span class="built_in">getCostmap</span>()) ); </span><br><span class="line">std::vector&lt;geometry_msgs::Point&gt; footprint = planner_costmap_ros_-&gt;<span class="built_in">getRobotFootprint</span>();</span><br><span class="line"><span class="keyword">double</span> footprint_cost = world_model_-&gt;<span class="built_in">footprintCost</span>(x_i, y_i, theta_i, footprint);</span><br></pre></td></tr></table></figure>
<p><code>CostmapModel</code>类帮助local planner在Costmap上进行计算, <code>footprintCost</code>, <code>lineCost</code>, <code>pointCost</code>三个类方法分别能通过Costmap计算出机器人足迹范围、两个cell连线、单个cell的代价，并将值返回给局部规划器。</p>
<p><code>footprintCost</code>函数是对footprint中的每个线段进行独立计算代价的。首先尝试获取线段的地图坐标，然后利用<code>lineCost</code>函数计算线段代价值，并用<code>footprint_cost</code>参数保存最大的线段代价值，最终如果正常，则返回的也是footprint_cost。只要有1个线段的代价值小于0，则直接返回-1。</p>
<p>返回值:</p>
<ul>
<li>-1.0 ：覆盖至少一个障碍cell</li>
<li>-2.0 ：覆盖至少一个未知cell</li>
<li>-3.0 ：不在地图上</li>
<li>其他: a positive value for traversable space</li>
</ul>
<p><strong>没有撞障碍时，返回值是 0。撞障碍基本都是 -1</strong></p>
<p><font color = blue size=4>函数中的内外接圆半径实际没有用，</font>对于多边形轮廓，是否需要修改？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">CostmapModel::footprintCost</span><span class="params">(<span class="keyword">const</span> geometry_msgs::Point&amp; position, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::vector&lt;geometry_msgs::Point&gt;&amp;  footprint,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">double</span> inscribed_radius,  <span class="keyword">double</span> circumscribed_radius )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//used to put things into grid coordinates</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cell_x, cell_y;</span><br><span class="line">    <span class="comment">//get the cell coord of the center point of the robot</span></span><br><span class="line">    <span class="keyword">if</span>(!costmap_.<span class="built_in">worldToMap</span>(position.x, position.y, cell_x, cell_y))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-3.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略  footprint的点少于3个，只取点位置的代价</span></span><br><span class="line">    <span class="keyword">if</span>(footprint.<span class="built_in">size</span>() &lt; <span class="number">3</span>)</span><br><span class="line">    &#123; ...... &#125;</span><br><span class="line">    <span class="comment">// 把足迹视为多边形，循环调用 lineCost 计算多边形各边的cell，注意首尾闭合，最后返回代价</span></span><br><span class="line">    <span class="comment">// 对于圆形底盘，按16边形处理</span></span><br><span class="line">    <span class="comment">// now we really have to lay down the footprint in the costmap grid</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> x0, x1, y0, y1;</span><br><span class="line">    <span class="keyword">double</span> line_cost = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">double</span> footprint_cost = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// we need to rasterize each line in the footprint</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; footprint.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//get the cell coord of the first point</span></span><br><span class="line">      <span class="keyword">if</span>(!costmap_.<span class="built_in">worldToMap</span>(footprint[i].x, footprint[i].y, x0, y0))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3.0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//get the cell coord of the second point</span></span><br><span class="line">      <span class="keyword">if</span>(!costmap_.<span class="built_in">worldToMap</span>(footprint[i + <span class="number">1</span>].x, footprint[i + <span class="number">1</span>].y, x1, y1))</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-3.0</span>;</span><br><span class="line"></span><br><span class="line">      line_cost = <span class="built_in">lineCost</span>(x0, x1, y0, y1);</span><br><span class="line">      footprint_cost = std::<span class="built_in">max</span>(line_cost, footprint_cost);</span><br><span class="line">      <span class="comment">//if there is an obstacle that hits the line, return false</span></span><br><span class="line">      <span class="keyword">if</span>(line_cost &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> line_cost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下是连接 footprint 的第一个和最后一个点</span></span><br><span class="line">    <span class="comment">//get the cell coord of the last point</span></span><br><span class="line">    <span class="keyword">if</span>(!costmap_.<span class="built_in">worldToMap</span>(footprint.<span class="built_in">back</span>().x, footprint.<span class="built_in">back</span>().y, x0, y0))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the cell coord of the first point</span></span><br><span class="line">    <span class="keyword">if</span>(!costmap_.<span class="built_in">worldToMap</span>(footprint.<span class="built_in">front</span>().x, footprint.<span class="built_in">front</span>().y, x1, y1))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3.0</span>;</span><br><span class="line"></span><br><span class="line">    line_cost = <span class="built_in">lineCost</span>(x0, x1, y0, y1);</span><br><span class="line">    footprint_cost = std::<span class="built_in">max</span>(line_cost, footprint_cost);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(line_cost &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> line_cost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if all line costs are legal, return that footprint is legal</span></span><br><span class="line">    <span class="keyword">return</span> footprint_cost;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>搜索发现有3个<code>lineCost</code>函数，<code>TrajectoryPlanner::lineCost</code>, <code>VoxelGridModel::lineCost</code>,  <code>CostmapModel::lineCost</code>。经过运行， <font color = blue size=4>发现调用的还是CostmapModel::lineCost </font></p>
<p>对于线段的代价计算函数lineCost，其实是对线段中的所有像素点（通过<code>bresenham</code>算法得到，不必深入研究）进行代价计算，如果像素点的代价为<code>LETHAL_OBSTACLE</code>或者<code>NO_INFORMATION</code>，则该点代价为-1。如果某个点的代价为-1，则该线段的代价也为-1，否则取所有点中最大的代价作为线段的代价</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return a positive cost for a legal line 或者负值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">CostmapModel::lineCost</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y0, <span class="keyword">int</span> y1)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> line_cost = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">double</span> point_cost = <span class="number">-1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>( LineIterator <span class="built_in">line</span>( x0, y0, x1, y1 ); line.<span class="built_in">isValid</span>(); line.<span class="built_in">advance</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">      point_cost = <span class="built_in">pointCost</span>( line.<span class="built_in">getX</span>(), line.<span class="built_in">getY</span>() );</span><br><span class="line">      <span class="keyword">if</span>(point_cost &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> point_cost;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(line_cost &lt; point_cost)</span><br><span class="line">        line_cost = point_cost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> line_cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">CostmapModel::pointCost</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> cost = costmap_.<span class="built_in">getCost</span>(x, y);</span><br><span class="line">    <span class="comment">//if the cell is in an obstacle the path is invalid</span></span><br><span class="line">    <span class="keyword">if</span>(cost == NO_INFORMATION)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">if</span>(cost == LETHAL_OBSTACLE)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Neo11111/article/details/104720103">CostmapModel::footprintCost</a><br><a target="_blank" rel="noopener" href="https://my.oschina.net/u/4324682/blog/3457091">ObstacleCostFunction类，继承自Trajectory类</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/CostmapModel/" data-id="ckr29d1d900kan8lm2gvq7a7z" data-title="CostmapModel 判断是否碰撞" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-激光SLAM/Cartographer/原理和配置/扩展建图 (一)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/15/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/%E6%89%A9%E5%B1%95%E5%BB%BA%E5%9B%BE%20(%E4%B8%80)/" class="article-date">
  <time class="dt-published" datetime="2020-11-15T12:10:53.000Z" itemprop="datePublished">2020-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a>►<a class="article-category-link" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a>►<a class="article-category-link" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/">原理和配置</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/15/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/%E6%89%A9%E5%B1%95%E5%BB%BA%E5%9B%BE%20(%E4%B8%80)/">扩展建图 (一)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>gmapping没有扩展或继续建图(resume mapping)的功能，它建的图就是一张图片。The occupancy grid对map的描述不包含state 以继续建图。要实现继续建图，必须保存所有的internal state. 目前可行的方案就是Cartographer。</p>
<p>纯定位程序运行时只在局部建图（保留固定数量的子图），随着机器人的运动和观测，新的子图会添加进来，旧的子图会被删除，就是只保留局部的地图数据。我的理解是保留局部数据越多，越多的数据与原有地图的数据进行回环检测就增多，这样会使计算量增加的同时也增加了误匹配的概率，使得整个系统不稳定，所以这里只进行定位，不用于建图(即地图的更新)</p>
<p>如何能在原有的地图上进行更新(因为很多环境是随时间变化的)? 目前没有人在开源的代码上实现这个功能，但是我认为其实是不难的，只要告诉给机器人一个准确的初始位置，可以通过landmark（apriltag、二维码等强特征，或者激光特征，最后可能加上人为评判），按照更新地图的思路来就可以了。代码实现可能与建图稍有不同，建图是0到1的过程，更新地图是1到1的过程，工程上更新地图的计算量应该要小于建图。</p>
<p>下面的扩展建图方案<strong>使用里程计，不使用IMU，</strong>我的机器人IMU没能获得重力加速度(9.8m²/s)</p>
<p>所用的<code>expand_map.launch</code>是这样的，<code>0.pbstream</code>是已经建好的一个地图，之后在它基础上扩展</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;cartographer_node&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;cartographer_ros&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">&quot;cartographer_node&quot;</span> <span class="attr">args</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">          -configuration_directory  $(find cartographer_ros)/configuration_files</span></span></span><br><span class="line"><span class="string"><span class="tag">          -configuration_basename   expand.lua</span></span></span><br><span class="line"><span class="string"><span class="tag">	  -load_state_filename  /home/user/carto_ws/maps/0.pbstream&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;scan&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/scan_rectified&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;odom&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/odom&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;cartographer_occupancy_grid_node&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;cartographer_ros&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">&quot;cartographer_occupancy_grid_node&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-resolution 0.05&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="已经建过图的地方再次建图时重影"><a href="#已经建过图的地方再次建图时重影" class="headerlink" title="已经建过图的地方再次建图时重影"></a>已经建过图的地方再次建图时重影</h3><p>扩展建图时，如果机器人又跑过了之前跑过的地方，地图会叠加到旧的地图上。这就要求机器人定位必须准确，否则新地图和旧的地图不匹配，产生重影<br><img src="https://i.loli.net/2021/04/27/niPbXHm1DTQokZR.png" alt="扩展建图中的重影"></p>
<h3 id="相似通道中建图时出现跳变"><a href="#相似通道中建图时出现跳变" class="headerlink" title="相似通道中建图时出现跳变"></a>相似通道中建图时出现跳变</h3><p>在相似环境下，很可能出现定位失败和建图错误。比如环境里有3个相似的通道，在已经有1个通道建图成功后，其他通道建图很容易失败，机器人位姿和地图栅格会跳到另一个通道<br><img src="https://i.loli.net/2021/04/27/W3hyE6g1IwdNxas.png" alt="3个通道"><br><img src="https://i.loli.net/2021/01/06/aBN5TzXkGErmIKL.gif" alt="建图出错的过程"></p>
<p>在纯定位模式，机器人在相似环境行走时，也会出现定位错误<br><img src="https://i.loli.net/2021/04/27/lzEgxapIh1X52HU.gif" alt="在已有地图中的严重定位错误"></p>
<h3 id="建图时的压缩现象"><a href="#建图时的压缩现象" class="headerlink" title="建图时的压缩现象"></a>建图时的压缩现象</h3><p>这种情况没有出现相似通道，如果说相似通道是横向的错误，这个就是纵向的。<br><img src="https://i.loli.net/2021/04/27/y8O2iQF5XGST4su.gif"></p>
<h3 id="扩展建过的地图逐渐消失"><a href="#扩展建过的地图逐渐消失" class="headerlink" title="扩展建过的地图逐渐消失"></a>扩展建过的地图逐渐消失</h3><p>这就是参数<code>max_submaps_to_keep</code>的作用了，把它改为40或50，但注意每次扩展建图不要走太远，否则子图会不够，还是会有消失的现象</p>
<br>

<p>还有综合以上错误的失败情况<br><img src="https://i.loli.net/2021/04/27/UV6r4pYvJWaQ5cl.gif" alt="典型失败的情况"></p>
<p>一直找不到相似环境建图失败的解决方法，偶然一次关掉后端优化模块，居然发现建图成功了。但是建图会不太精确，无法自动修正偏差。另外由于里程计的原因，走回已经建图的环境时，<code>scan match</code>会和之前的有偏差，看来没有后端还是不完善<br><img src="https://i.loli.net/2021/01/29/skE8T7nV5Uig9rO.png" alt="建图一圈有偏差"></p>
<h2 id="使用landmark"><a href="#使用landmark" class="headerlink" title="使用landmark"></a>使用landmark</h2><p>查了一些资料，决定使用二维码做landmark，参考<a target="_blank" rel="noopener" href="https://charon-cheung.github.io/2020/07/18/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/landmark%E7%9A%84%E4%BD%BF%E7%94%A8/#%E6%BA%90%E7%A0%81">landmark的使用</a>， 但是没有明显效果，错误情况依旧。而且发布二维码位姿的频率只有0.6Hz(电脑CPU性能不好)，建图时需要非常慢，会有很大误差。<br><a target="_blank" rel="noopener" href="https://youtu.be/61aRnlHGhfA">视频：加landmark开后端，仍然失败</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/15/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/%E6%89%A9%E5%B1%95%E5%BB%BA%E5%9B%BE%20(%E4%B8%80)/" data-id="ckr29d1e000mnn8lm70rpcqio" data-title="扩展建图 (一)" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-路径规划/姜歌机器人的注意事项" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%A7%9C%E6%AD%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" class="article-date">
  <time class="dt-published" datetime="2020-11-15T12:06:02.000Z" itemprop="datePublished">2020-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a>►<a class="article-category-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%85%B6%E4%BB%96/">其他</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%A7%9C%E6%AD%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/">公司机器人的注意事项</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://i.loli.net/2021/01/06/j3UclViE6BPLJuT.png" alt="机器人的坐标系.png"></p>
<ul>
<li><code>~/.ros/log/latest</code>:   仿真的日志</li>
<li><code>/tmp/latest</code>:         实际机器人的日志</li>
</ul>
<p>编译源码之前需要在<code>src</code>目录下执行 <code>sudo chmod 777 $(find . -name *.cfg)</code></p>
<table><tr><td bgcolor=yellow> /scan/header 和 /odom/header 的时间戳不能有明显差距，机器人最好是断电重启，远程关机容易导致二者差距达到十几秒
 </td></tr></table>

<h2 id="IMU"><a href="#IMU" class="headerlink" title="IMU"></a>IMU</h2><p>IMU话题是<code>/imu/data</code>，没有发布线加速度，全是0。正常的话，z应该是9.8左右</p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p><code>initialpose</code>话题由<code>tm_node</code>发布, AMCL订阅</p>
<h2 id="cmd-vel"><a href="#cmd-vel" class="headerlink" title="cmd_vel"></a>cmd_vel</h2><p>发布者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">queue_follow_node (http://beerobot-M818SE-8G:46147/)</span><br><span class="line">move_base (http://beerobot-M818SE-8G:36537/)</span><br><span class="line">nodelet_manager (http://beerobot-M818SE-8G:42043/)</span><br><span class="line">charge_node (http://beerobot-M818SE-8G:36827/)</span><br><span class="line">tm_node (http://beerobot-M818SE-8G:42809/)</span><br></pre></td></tr></table></figure>
<p><code>charge_node</code>不能关，否则不能行走</p>
<p>订阅者<code>nodelet_manager</code>和<code>stm_node</code></p>
<h2 id="battery-info"><a href="#battery-info" class="headerlink" title="battery_info"></a>battery_info</h2><p>充电中:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bstatus: 3 		<span class="comment"># 充电</span></span><br><span class="line">voltage: 76.0</span><br><span class="line">chargingV: 50.0</span><br><span class="line">chargingI: 7.6</span><br></pre></td></tr></table></figure>

<p>不充电:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bstatus: 0 		<span class="comment"># 未充电</span></span><br><span class="line">voltage: 72.0</span><br><span class="line">chargingV: 49.0</span><br><span class="line">chargingI: 0.0</span><br></pre></td></tr></table></figure>
<p><code>voltage</code>实际是电量百分比，<code>chargingI</code>是当前充电的电流</p>
<h2 id="emergency-info-话题"><a href="#emergency-info-话题" class="headerlink" title="emergency_info 话题"></a>emergency_info 话题</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">estop: False</span><br><span class="line">crash: True</span><br><span class="line">io_charge: True</span><br></pre></td></tr></table></figure>
<p>在急停状态，<code>estop</code>为True</p>
<h2 id="iPad-报错"><a href="#iPad-报错" class="headerlink" title="iPad 报错"></a>iPad 报错</h2><p>小车防撞条被撞到后，iPad会报错:<font size=4, color=orange> Crash Stop  </font>，这个有敏感度指标，可以降低，否则有时颠簸剧烈也会触发。触发防撞条后，需要先按下急停再松开才能恢复导航</p>
<p>iPad报错 <font size=4, color=orange> Location Loss</font>后，可能需要重新定位</p>
<h2 id="节点-obstacle-ray"><a href="#节点-obstacle-ray" class="headerlink" title="节点 obstacle_ray"></a>节点 obstacle_ray</h2><p>发布:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obstacle/PCloud [sensor_msgs/PointCloud2]</span><br><span class="line">obstacle/all_point [sensor_msgs/PointCloud2]</span><br><span class="line">obstacle/mid_point [sensor_msgs/PointCloud2]</span><br></pre></td></tr></table></figure>
<p>订阅<code>camera/depth/color/points</code>和<code>scan</code></p>
<p>机器人12.5万<br>充电桩7000<br>RCS系统20万</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%A7%9C%E6%AD%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" data-id="ckr29d17k006mn8lm9ffx9lpo" data-title="公司机器人的注意事项" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-路径规划/move_base 分析/机器人footprint的研究" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move_base%20%E5%88%86%E6%9E%90/%E6%9C%BA%E5%99%A8%E4%BA%BAfootprint%E7%9A%84%E7%A0%94%E7%A9%B6/" class="article-date">
  <time class="dt-published" datetime="2020-11-15T12:00:37.000Z" itemprop="datePublished">2020-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a>►<a class="article-category-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move-base%E5%88%86%E6%9E%90/">move_base分析</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move_base%20%E5%88%86%E6%9E%90/%E6%9C%BA%E5%99%A8%E4%BA%BAfootprint%E7%9A%84%E7%A0%94%E7%A9%B6/">机器人footprint的研究</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>目前所用的机器人模型是圆形, 在通用代价地图里定义:<code>robot_radius: 0.26</code>, 而不是<code>footprint</code>参数.  但是注意TEB里用的是Point类型.</p>
<p>指定<code>footprint</code>的数组元素时, 点如果太多, 可以换行。 <font color = blue size=3>机器人的轮廓可能是不规则的polygon, 但它的运动中心永远是(0,  0), 顺时针和逆时针规范都支持。 </font>这应该是局部坐标系决定的<br><img src="https://i.loli.net/2020/11/01/JTegObBvfoEYw5n.png" alt="footprint setting.png"></p>
<p>现在分析源码中对<code>footprint</code>参数的处理, <code>Costmap2DROS</code>的构造函数里有一句： <code>setUnpaddedRobotFootprint(makeFootprintFromParams(private_nh));</code>,  先看括号里的函数</p>
<h2 id="makeFootprintFromParams"><a href="#makeFootprintFromParams" class="headerlink" title="makeFootprintFromParams"></a>makeFootprintFromParams</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;geometry_msgs::Point&gt; <span class="title">makeFootprintFromParams</span><span class="params">(ros::NodeHandle&amp; nh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::string full_param_name;</span><br><span class="line">  std::string full_radius_param_name;</span><br><span class="line">  std::vector&lt;geometry_msgs::Point&gt; points;</span><br><span class="line">  <span class="comment">// 优先读footprint参数的值</span></span><br><span class="line">  <span class="keyword">if</span> (nh.<span class="built_in">searchParam</span>(<span class="string">&quot;footprint&quot;</span>,  full_param_name))</span><br><span class="line">  &#123;</span><br><span class="line">    XmlRpc::XmlRpcValue footprint_xmlrpc;</span><br><span class="line">    nh.<span class="built_in">getParam</span>(full_param_name,  footprint_xmlrpc);</span><br><span class="line">    <span class="keyword">if</span> (footprint_xmlrpc.<span class="built_in">getType</span>() == XmlRpc::XmlRpcValue::TypeString &amp;&amp;</span><br><span class="line">        footprint_xmlrpc != <span class="string">&quot;&quot;</span> &amp;&amp; footprint_xmlrpc != <span class="string">&quot;[]&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">makeFootprintFromString</span>(std::<span class="built_in">string</span>(footprint_xmlrpc),  points))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">writeFootprintToParam</span>(nh,  points);</span><br><span class="line">        <span class="keyword">return</span> points;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一般是这个, 因为我们定义的是数组</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (footprint_xmlrpc.<span class="built_in">getType</span>() == XmlRpc::XmlRpcValue::TypeArray)</span><br><span class="line">    &#123;</span><br><span class="line">      points = <span class="built_in">makeFootprintFromXMLRPC</span>(footprint_xmlrpc,  full_param_name);</span><br><span class="line">      <span class="built_in">writeFootprintToParam</span>(nh,  points);</span><br><span class="line">      <span class="keyword">return</span> points;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 没有 footprint再读robot_radius</span></span><br><span class="line">  <span class="keyword">if</span> (nh.<span class="built_in">searchParam</span>(<span class="string">&quot;robot_radius&quot;</span>,  full_radius_param_name))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">double</span> robot_radius;</span><br><span class="line">    nh.<span class="built_in">param</span>(full_radius_param_name,  robot_radius,  <span class="number">1.234</span>);</span><br><span class="line">    points = <span class="built_in">makeFootprintFromRadius</span>(robot_radius);</span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;robot_radius&quot;</span>,  robot_radius);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Else neither param was found anywhere this knows about,  so</span></span><br><span class="line">  <span class="comment">// defaults will come from dynamic_reconfigure stuff,  set in</span></span><br><span class="line">  <span class="comment">// cfg/Costmap2D.cfg and read in this file in reconfigureCB().</span></span><br><span class="line">  <span class="keyword">return</span> points;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数检查通用代价地图的yaml里是否定义了<code>footprint</code>和<code>robot_radius</code>参数。  <font color = blue size=3>前者优先, 如果<code>footprint</code>已经定义了, 就把它做轮廓, 不再处理<code>robot_radius</code>. </font> 我目前用的是<code>robot_radius</code>, 所以再看<code>makeFootprintFromRadius</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;geometry_msgs::Point&gt; <span class="title">makeFootprintFromRadius</span><span class="params">(<span class="keyword">double</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::vector&lt;geometry_msgs::Point&gt; points;</span><br><span class="line">  <span class="comment">// Loop over 16 angles around a circle making a point each time</span></span><br><span class="line">  <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line">  geometry_msgs::Point pt;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">double</span> angle = i * <span class="number">2</span> * M_PI / N;</span><br><span class="line">    pt.x = <span class="built_in">cos</span>(angle) * radius;</span><br><span class="line">    pt.y = <span class="built_in">sin</span>(angle) * radius;</span><br><span class="line"></span><br><span class="line">    points.<span class="built_in">push_back</span>(pt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> points;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这其实是把圆形处理成了一个正十六边形, 把顶点的坐标都放到容器里. 这个容器最终就是<code>setUnpaddedRobotFootprint</code>的参数。 打开rviz放大, 会看到它是一个十六边形。<br><img src="https://i.loli.net/2020/10/24/cU9vqX6PhMEYdp4.png" alt="正十六边形"></p>
<p>所以对于圆形轮廓机器人, 内接圆和外接圆的半径是不同的, 因为正十六边形的外接圆半径是内接圆半径的<strong>1.01959</strong>倍</p>
<h2 id="setUnpaddedRobotFootprint"><a href="#setUnpaddedRobotFootprint" class="headerlink" title="setUnpaddedRobotFootprint"></a>setUnpaddedRobotFootprint</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Costmap2DROS::setUnpaddedRobotFootprint</span><span class="params">(<span class="keyword">const</span> std::vector&lt;geometry_msgs::Point&gt;&amp; points)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  unpadded_footprint_ = points;</span><br><span class="line">  padded_footprint_ = points;</span><br><span class="line">  <span class="built_in">padFootprint</span>(padded_footprint_,  footprint_padding_);</span><br><span class="line"></span><br><span class="line">  layered_costmap_-&gt;<span class="built_in">setFootprint</span>(padded_footprint_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setUnpaddedRobotFootprint</code>主要是对<code>padded_footprint_</code>赋值, 和<code>setFootprint</code>函数</p>
<p><code>footprint_padding_</code>只用于<code>reconfigureCB</code>, 可以不看. <code>padFootprint</code>就是处理padding的情况, 但我们的<code>footprint_padding</code>参数为0,  所以也不看了.</p>
<p>当话题上收到footprint时, 回调函数会将接收到的footprint根据参数<code>footprint_padding_</code>的值进行<em>膨胀</em>, 得到<em>膨胀</em>后的 <code>padded_footprint_</code>, 传递给各级地图。</p>
<p>调用了这个函数的还有<code>setUnpaddedRobotFootprintRadius</code>回调函数 和 <code>setUnpaddedRobotFootprintPolygon</code>回调函数, 前者对应<code>footprint_radius</code>的<strong>参数值</strong>做的话题,  后者对应<code>footprint_topic</code>的<strong>参数值</strong>做的话题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayeredCostmap::setFootprint</span><span class="params">(<span class="keyword">const</span> std::vector&lt;geometry_msgs::Point&gt;&amp; footprint_spec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  footprint_ = footprint_spec;</span><br><span class="line">  costmap_2d::<span class="built_in">calculateMinAndMaxDistances</span>(footprint_spec,  inscribed_radius_,  circumscribed_radius_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (vector&lt;boost::shared_ptr&lt;Layer&gt; &gt;::iterator plugin = plugins_.<span class="built_in">begin</span>(); </span><br><span class="line">    plugin != plugins_.<span class="built_in">end</span>();  ++plugin)</span><br><span class="line">  &#123;</span><br><span class="line">    (*plugin)-&gt;<span class="built_in">onFootprintChanged</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>calculateMinAndMaxDistances</code>很重要, 它可求得<code>robot_inscribed_radius_: 0.255004</code> 和 <code>robot_circumscribed_radius: 0.26</code></p>
<p>这里的plugin就是全局和局部代价地图里定义的<code>plugins</code>成员, 别忘了MoveBase里有两个代价地图, 对plugin的添加在<code>Costmap2DROS</code>的构造函数里. </p>
<p>每一层都调用了<code>onFootprintChanged</code>, 但是<strong>只有膨胀层覆盖了基类函数</strong>, 也就是<code>InflationLayer::onFootprintChanged()</code>, 这个在另一篇文章分析. 其它层没有覆盖, 还是调用的Layer类的空函数<code>virtual void onFootprintChanged() &#123;&#125;</code></p>
<p>机器人轮廓之所以能在导航时也行走, 原因在<code>updateMap</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Costmap2DROS::updateMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!stop_updates_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// get pose in global frame of costmap</span></span><br><span class="line">    tf::Stamped &lt; tf::Pose &gt; pose;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getRobotPose</span> (pose))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">double</span> x = pose.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>(), </span><br><span class="line">             y = pose.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(), </span><br><span class="line">             yaw = tf::<span class="built_in">getYaw</span>(pose.<span class="built_in">getRotation</span>());</span><br><span class="line"></span><br><span class="line">      layered_costmap_-&gt;<span class="built_in">updateMap</span>(x,  y,  yaw);</span><br><span class="line"></span><br><span class="line">      geometry_msgs::PolygonStamped footprint;</span><br><span class="line">      footprint.header.frame_id = global_frame_;</span><br><span class="line">      footprint.header.stamp = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">      <span class="built_in">transformFootprint</span>(x,  y,  yaw,  padded_footprint_,  footprint);</span><br><span class="line">      footprint_pub_.<span class="built_in">publish</span>(footprint);</span><br><span class="line"></span><br><span class="line">      initialized_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑不复杂, <code>padded_footprint_</code>就是上面的十六变形的Point容器, <code>transformFootprint</code>是更新机器人行走时的轮廓, 原理和里程计解算类似.</p>
<p><code>footprint_pub_</code>发布的话题就是<code>/move_base/local_costmap/footprint</code></p>
<h2 id="相关话题-不是参数"><a href="#相关话题-不是参数" class="headerlink" title="相关话题 (不是参数)"></a>相关话题 (不是参数)</h2><p><code>footprint</code>, 类型<code>geometry_msgs/Polygon</code>, 由<code>move_base</code>订阅, 但没有发布者。</p>
<p><code>/move_base/global_costmap/footprint</code>和<code>/move_base/local_costmap/footprint</code>话题是机器人轮廓, 可以直接获得。</p>
<h2 id="Padding机制"><a href="#Padding机制" class="headerlink" title="Padding机制"></a>Padding机制</h2><p>Padding机制为机器人和障碍物之间提供了额外的距离,  打开<code>rqt_reconfigure</code>调整<strong>全局</strong>代价地图的参数<code>footprint_padding</code>, 膨胀层和障碍层会变化, 效果和调整参数<code>inflation_radius</code>和<code>cost_scaling_factor</code>相同。</p>
<p>调整<strong>局部</strong>代价地图的<code>footprint_padding</code>, <strong>机器人轮廓会成比例放大和缩小</strong>。 如果确实需要改变这个参数, 两个代价地图的都要改变。</p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=sCpVcY2a8G8&feature=youtu.be">调整的过程</a></p>
<h2 id="话题-footprint-radius-和-polygon-footprint"><a href="#话题-footprint-radius-和-polygon-footprint" class="headerlink" title="话题 footprint_radius 和 polygon_footprint"></a>话题 footprint_radius 和 polygon_footprint</h2><p>这个和padding是不同的机制, <strong>用话题的方式在线更改机器人的轮廓</strong>, 适用于机器人更换货架而导致轮廓改变的情况。<br>原因在源码中的这一段, <code>footprint_radius</code>是自己加的, 注意全局和局部代价地图的相应话题都只发布一次</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private_nh.<span class="built_in">param</span>(topic_param, topic, std::<span class="built_in">string</span>(<span class="string">&quot;footprint&quot;</span>));</span><br><span class="line"></span><br><span class="line">footprint_sub_ = private_nh.<span class="built_in">subscribe</span>(topic, <span class="number">1</span>, &amp;Costmap2DROS::setUnpaddedRobotFootprintPolygon,  <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">private_nh.<span class="built_in">param</span>(<span class="string">&quot;footprint_radius&quot;</span>, footprint_radius_topic_, std::<span class="built_in">string</span>(<span class="string">&quot;footprint_radius&quot;</span>));</span><br><span class="line"></span><br><span class="line">radius_sub_ = private_nh.<span class="built_in">subscribe</span>(footprint_radius_topic_, <span class="number">1</span>, &amp;Costmap2DROS::setUnpaddedRobotFootprintRadius,  <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>两个回调函数都是调用函数<code>setUnpaddedRobotFootprint</code>, 对于<code>radius</code>的情况, 也就是圆形底盘, 还是把圆按正十六边形处理。</p>
<p>可以用命令测试，现实中由调度端实现：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rostopic pub -1 /move_base/local_costmap/footprint_radius std_msgs/Float32 <span class="string">&#x27;0.34&#x27;</span></span><br><span class="line">rostopic pub -1 /move_base/global_costmap/footprint_radius std_msgs/Float32 <span class="string">&#x27;0.34&#x27;</span></span><br><span class="line"></span><br><span class="line">rostopic pub -1 /move_base/local_costmap/polygon_footprint geometry_msgs/Polygon <span class="string">&#x27;[ [-0.3,  0.3],  [0.3, 0.3],  [0.3, -0.3],  [-0.3, -0.3] ]&#x27;</span></span><br><span class="line">rostopic pub -1 /move_base/global_costmap/polygon_footprint geometry_msgs/Polygon <span class="string">&#x27;[ [-0.3,  0.3],  [0.3, 0.3],  [0.3, -0.3],  [-0.3, -0.3] ]&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="TEB中的处理"><a href="#TEB中的处理" class="headerlink" title="TEB中的处理"></a>TEB中的处理</h2><p><code>footprint</code>是多边形, 每增加一条边, 就会增加TEB计算时间。设置和通用代价地图里相同</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>: <span class="string">&quot;polygon&quot;</span>   </span><br><span class="line">vertices: [[-0.26,0], [-0.240209, 0.099498], [-0.183848,0.240209], [0,0.26], [0.099498,0.240209], [0.5662,0.240209], [0.5662,-0.240209], [0.099498,-0.240209], [0,-0.26], [-0.183848,-0.240209], [-0.240209, -0.099498] ]</span><br></pre></td></tr></table></figure>

<h2 id="内切圆半径和外切圆半径的计算原理"><a href="#内切圆半径和外切圆半径的计算原理" class="headerlink" title="内切圆半径和外切圆半径的计算原理"></a>内切圆半径和外切圆半径的计算原理</h2><p>计算<code>footprint</code>的内切圆半径和外切圆半径, 用到点到线段的距离, 计算方法是两个向量的点积等于一个向量在另一个向量的投影乘以另一个向量的模</p>
<p>点到线段的三种情况如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  作用：计算点到线段的距离</span></span><br><span class="line"><span class="comment">*  参数：pX, pY 是中心点坐标</span></span><br><span class="line"><span class="comment">*  x0, y0, x1, y2 线段两端的坐标, 求点到线段的距离</span></span><br><span class="line"><span class="comment">*  用向量点乘 来计算</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distanceToLine</span><span class="params">(<span class="keyword">double</span> pX,  <span class="keyword">double</span> pY,  <span class="keyword">double</span> x0,  <span class="keyword">double</span> y0,  <span class="keyword">double</span> x1,  <span class="keyword">double</span> y1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> A = pX - x0; <span class="comment">//向量AP的x值</span></span><br><span class="line">  <span class="keyword">double</span> B = pY - y0; <span class="comment">//向量AP 的y中</span></span><br><span class="line">  <span class="keyword">double</span> C = x1 - x0; <span class="comment">//向量AB的x值</span></span><br><span class="line">  <span class="keyword">double</span> D = y1 - y0; <span class="comment">//向量AB的y值</span></span><br><span class="line">  <span class="comment">//向量AP与向量AB的点积</span></span><br><span class="line">  <span class="keyword">double</span> dot = A * C + B * D;</span><br><span class="line">  <span class="comment">//向量AB的模的平方</span></span><br><span class="line">  <span class="keyword">double</span> len_sq = C * C + D * D;</span><br><span class="line">  <span class="comment">//r 的值</span></span><br><span class="line">  <span class="keyword">double</span> param = dot / len_sq;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">double</span> xx,  yy;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (param &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    xx = x0;</span><br><span class="line">    yy = y0;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (param &gt; <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    xx = x1;</span><br><span class="line">    yy = y1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//向量AC=r*向量AB</span></span><br><span class="line">    xx = x0 + param * C;</span><br><span class="line">    yy = y0 + param * D;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//计算AC的距离即可</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">distance</span>(pX,  pY,  xx,  yy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>robot_radius为0.26时, 16边形的顶点坐标如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">x:0.260000,   y:0.000000</span><br><span class="line">x:0.240209,   y:0.099498</span><br><span class="line">x:0.183848,   y:0.183848</span><br><span class="line">x:0.099498,   y:0.240209</span><br><span class="line">x:0.000000,   y:0.260000</span><br><span class="line">x:-0.099498,  y:0.240209</span><br><span class="line">x:-0.183848,  y:0.183848</span><br><span class="line">x:-0.240209,  y:0.099498</span><br><span class="line">x:-0.260000,  y:0.000000</span><br><span class="line">x:-0.240209,  y:-0.099498</span><br><span class="line">x:-0.183848,  y:-0.183848</span><br><span class="line">x:-0.099498,  y:-0.240209</span><br><span class="line">x:-0.000000,  y:-0.260000</span><br><span class="line">x:0.099498,   y:-0.240209</span><br><span class="line">x:0.183848,   y:-0.183848</span><br><span class="line">x:0.240209,   y:-0.099498</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move_base%20%E5%88%86%E6%9E%90/%E6%9C%BA%E5%99%A8%E4%BA%BAfootprint%E7%9A%84%E7%A0%94%E7%A9%B6/" data-id="ckr29d1d800k5n8lm6g7zcr1v" data-title="机器人footprint的研究" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-路径规划/move_base 分析/导航相关的节点和动态库之间的关系" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move_base%20%E5%88%86%E6%9E%90/%E5%AF%BC%E8%88%AA%E7%9B%B8%E5%85%B3%E7%9A%84%E8%8A%82%E7%82%B9%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/" class="article-date">
  <time class="dt-published" datetime="2020-11-15T11:59:37.000Z" itemprop="datePublished">2020-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a>►<a class="article-category-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move-base%E5%88%86%E6%9E%90/">move_base分析</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move_base%20%E5%88%86%E6%9E%90/%E5%AF%BC%E8%88%AA%E7%9B%B8%E5%85%B3%E7%9A%84%E8%8A%82%E7%82%B9%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/">导航相关的节点和动态库之间的关系</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>注意<code>devel/lib</code>里的so文件权限是<code>rwxrwxr-x</code>，<code>install/lib</code>里的so文件权限是<code>rw-r--r--</code></p>
<p>节点move_base由很多库链接,一部分是<code>/opt/ros/kinetic</code>目录的ROS基本库文件,另一部分是<code>/usr/lib/x86_64-linux-gnu</code>的系统库文件,除此之外的重要库文件只有:</p>
<ul>
<li>  libmove_base.so</li>
<li>  libbase_local_planner.so</li>
<li>  libcostmap_2d.so</li>
<li>  libvoxel_grid.so</li>
<li>libteb_local_planner.so</li>
</ul>
<p>同理,<code>libmove_base.so</code>的重要链接库:</p>
<ul>
<li>  libbase_local_planner.so</li>
<li>  libcostmap_2d.so</li>
<li>  libvoxel_grid.so</li>
</ul>
<p>依次检查其他库文件,由于<code>base_local_planner</code>一般不修改,所以重要的其实就是<code>libmove_base.so</code>, <code>libcostmap_2d.so</code>, <code>libvoxel_grid.so</code></p>
<h2 id="libteb-local-planner-so"><a href="#libteb-local-planner-so" class="headerlink" title="libteb_local_planner.so"></a>libteb_local_planner.so</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">add_library( teb_local_planner</span><br><span class="line"></span><br><span class="line">   src/timed_elastic_band.cpp</span><br><span class="line">   src/optimal_planner.cpp</span><br><span class="line">   src/obstacles.cpp</span><br><span class="line">   src/visualization.cpp</span><br><span class="line">   src/recovery_behaviors.cpp</span><br><span class="line">   src/teb_config.cpp</span><br><span class="line">   src/homotopy_class_planner.cpp</span><br><span class="line">   src/teb_local_planner_ros.cpp</span><br><span class="line">   src/graph_search.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>更新teb算法的so文件，不能只更新<code>libteb_local_planner.so</code>，而是包含以下文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libbase_local_planner.so libmove_base.so libcostmap_2d.so libvoxel_grid.so liblayers.so libteb_local_planner.so</span><br></pre></td></tr></table></figure>

<p><br><br><br><code>libcostmap_2d.so</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add_library(  costmap_2d</span><br><span class="line"></span><br><span class="line">  src/array_parser.cpp</span><br><span class="line">  src/costmap_2d.cpp</span><br><span class="line">  src/observation_buffer.cpp</span><br><span class="line">  src/layer.cpp</span><br><span class="line">  src/layered_costmap.cpp</span><br><span class="line">  src/costmap_2d_ros.cpp</span><br><span class="line">  src/costmap_2d_publisher.cpp</span><br><span class="line">  src/costmap_math.cpp</span><br><span class="line">  src/footprint.cpp</span><br><span class="line">  src/costmap_layer.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<p><br><br><br><code>liblayers.so</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add_library( layers  </span><br><span class="line"></span><br><span class="line">  plugins/inflation_layer.cpp</span><br><span class="line">  plugins/obstacle_layer.cpp</span><br><span class="line">  plugins/static_layer.cpp</span><br><span class="line">  plugins/voxel_layer.cpp</span><br><span class="line">  src/observation_buffer.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move_base%20%E5%88%86%E6%9E%90/%E5%AF%BC%E8%88%AA%E7%9B%B8%E5%85%B3%E7%9A%84%E8%8A%82%E7%82%B9%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/" data-id="ckr29d1d400jvn8lma0go758h" data-title="导航相关的节点和动态库之间的关系" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-路径规划/代价地图/代价地图3  代价值和机器人轮廓的关系" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE3%20%20%E4%BB%A3%E4%BB%B7%E5%80%BC%E5%92%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BD%AE%E5%BB%93%E7%9A%84%E5%85%B3%E7%B3%BB/" class="article-date">
  <time class="dt-published" datetime="2020-11-15T11:58:05.000Z" itemprop="datePublished">2020-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a>►<a class="article-category-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE3%20%20%E4%BB%A3%E4%BB%B7%E5%80%BC%E5%92%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BD%AE%E5%BB%93%E7%9A%84%E5%85%B3%E7%B3%BB/">代价地图(三) 代价值和机器人轮廓的关系</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>costmap中，机器人需要避开区域包括3类：</p>
<ol>
<li><p>静态地图中的障碍物，适合描述整个静态场景的静止障碍物信息，如墙面、固定不动的桌柜等，gmapping或其他slam方法建图过程中在栅格地图中记录的障碍物信息StaticLayer，一旦在costmap中加入static_map,即使地图中的障碍物后来移走了，该区域在costmap中依然存在，机器人仍然会避开该区域。</p>
</li>
<li><p>传感器观察到的障碍物，适合描述运动的障碍物，如行人、小车、移动位置的桌椅等。通过传感器激光（或者其他的rgbd摄像头、声纳…）实时扫描到的障碍物信息ObstacleLayer。这一块障碍物信息是不断变化的，对于运动小车的实时避障是很有帮助的。</p>
</li>
<li><p>自定义障碍物，禁止行驶区域，如果想在地图中设定一块区域，要求机器人禁止通过，则需要自己定义一个障碍物层</p>
</li>
</ol>
<p><code>costmap_2d</code>这个包主要负责根据传感器的信息建立和更新二维或三维的地图。ROS的地图（costmap）采用网格（grid）的形式，每个网格的值从<code>0~255</code>，分为三种状态：占用（有障碍物）、无用（空闲的）、未知。</p>
<p><img src="https://live.staticflickr.com/65535/49064396812_0edb383561_b.jpg" alt="机器人的代价值与距离关系图"></p>
<p>上图共分为五个部分:（下面的红色框图是机器人的轮廓，旁边的黑框是上图的映射位置）</p>
<ol>
<li>Lethal（致命的）:机器人的中心与该网格的中心重合，此时机器人必然与障碍物冲突。枚举值254</li>
<li>Inscribed（内切）：网格的外切圆与机器人的轮廓内切，此时机器人也必然与障碍物冲突。 枚举值253</li>
<li>Possibly circumscribed（外切）：网格的外切圆与机器人的轮廓外切，此时机器人相当于靠在障碍物附近，所以不一定冲突。</li>
<li>Freespace（自由空间）：没有障碍物的空间。枚举值0</li>
<li>Unknown（未知）：未知的空间。 枚举值255</li>
</ol>
<p>代价的计算公式:<br><img src="https://i.loli.net/2019/11/14/ITzx3Yg6As1EmDu.png"><br>这里的253是<code>costmap_2d::INSCRIBED_INFLATED_OBSTACLE</code>，<code>ROS Wiki</code>说这个宏是254，我反复检查其实是253，Wiki错了</p>
<p>可以看出增大比例因子反而会降低代价</p>
<br>

<p><img src="https://i.loli.net/2020/11/01/qzrJhU1VK3D7RLI.png"><br>二维costmap地图示例如图上所示。红色单元表示代价地图中的障碍物，蓝色单元表示由机器人内切半径来计算膨胀的障碍物，红色多边形表示机器人的垂直投影（footprint），浅灰色代表已知且未被占用的区域，深灰色代表未知区域。为了避免机器人与障碍碰撞，机器人的垂直投影（footprint）不能与红色单元相交，机器人的中心不能穿过蓝色单元</p>
<p><code>Inflation</code> is the process of propagating cost values out from occupied cells that decrease with distance. 定义了5个具体的值衡量机器人的状态</p>
<p><img src="https://i.loli.net/2020/11/01/I79j3x5FytE8ePY.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> NO_INFORMATION = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> LETHAL_OBSTACLE = <span class="number">254</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> INSCRIBED_INFLATED_OBSTACLE = <span class="number">253</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> FREE_SPACE = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>注意252和127没有定义</p>
<br>

<ul>
<li><p><code>cost_lethal</code> 代价值254，机器人中心在一个cell里，这肯定发生碰撞</p>
</li>
<li><p><code>cost_inscribed</code> 代价值253，机器人中心所在的cell与障碍物的距离小于机器人的内切圆半径，还是肯定碰撞，cell的代价值大于等于<code>inscribed cost</code></p>
</li>
<li><p><code>cost_possibly_circumscribed</code> 使用机器人的外接圆半径作为 <strong>cutoff distance</strong>. 机器人中心所在cell到障碍物距离小于机器人外切圆半径，但是大于内切圆半径。 如果机器人中心所在的cell大于等于这个值，是否碰撞要取决于机器人的朝向</p>
</li>
</ul>
<p><strong>possibly</strong>这个词表示不一定真是一个obstacle cell，而是用户自定义一个代价值的情况。比如，如果用户想让机器人应对避开一段特定的区域，应当向那段区域的代价地图插入自定义的代价值，而不考虑任何障碍物。</p>
<p>尽管128也在上图中，但真实的代价值受内切圆半径和外接圆半径的影响，对于源码在<code>InflationLayer::computeCost</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @brief  Given a distance, compute a cost.</span></span><br><span class="line"><span class="comment"> * @param  distance The distance from an obstacle in cells</span></span><br><span class="line"><span class="comment"> * @return A cost value for the distance */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">computeCost</span><span class="params">(<span class="keyword">double</span> distance)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> cost = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (distance == <span class="number">0</span>)</span><br><span class="line">    cost = LETHAL_OBSTACLE;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (distance * resolution_ &lt;= inscribed_radius_)</span><br><span class="line">    cost = INSCRIBED_INFLATED_OBSTACLE;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// make sure cost falls off by Euclidean distance</span></span><br><span class="line">    <span class="keyword">double</span> euclidean_distance = distance * resolution_;</span><br><span class="line">    <span class="keyword">double</span> factor = <span class="built_in">exp</span>(<span class="number">-1.0</span> * weight_ * (euclidean_distance - inscribed_radius_));</span><br><span class="line">    cost = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)((INSCRIBED_INFLATED_OBSTACLE - <span class="number">1</span>) * factor);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="障碍层-膨胀层"><a href="#障碍层-膨胀层" class="headerlink" title="障碍层  膨胀层"></a>障碍层  膨胀层</h2><p>Obstacle Map Layer：障碍层，用于动态的记录传感器感知到的障碍物信息。</p>
<p>Inflation Layer：膨胀层，在以上两层地图上进行膨胀（向外扩张），以避免机器人的撞上障碍物。膨胀是一个从占用cell向外传播代价的过程，距离cell越远代价越小，膨胀层会把障碍物代价膨胀直到该半径为止</p>
<ul>
<li>cost_scaling_factor: 膨胀过程中应用到代价值的比例因子，代价地图中到实际障碍物距离，默认10  <strong>在内切圆半径到膨胀半径之间的所有cell</strong>  可以使用如下公式来计算膨胀代价：<br><code>exp(-1.0 * cost_scaling_factor * (distance_from_obstacle - inscribed_radius)) * (costmap_2d::INSCRIBED_INFLATED_OBSTACLE - 1) </code><br>所以在上面的图里，代价值从252-127是按这个公式减小。</li>
</ul>
<p><img src="https://i.loli.net/2020/11/06/rS6ov8nGOR32iZw.png" alt="内切圆半径0.255，不同代价系数对应的代价曲线"></p>
<ul>
<li>inflation_radius:膨胀半径，膨胀层会把障碍物代价膨胀直到该半径为止，一般将该值设置为机器人底盘的直径大小。如果机器人经常撞到障碍物就需要增大该值，若经常无法通过狭窄地方就减小该值。</li>
</ul>
<p><img src="https://i.loli.net/2020/11/03/bygjtSlNdmzBYqJ.png" alt="增大膨胀半径 cost_scaling_factor=0.7"><br><img src="https://i.loli.net/2020/11/03/g1pjA7ioTEcwlZG.png" alt="cost_scaling_factor=65"><br><img src="https://i.loli.net/2020/11/03/CJtobcx9YniNFRK.png" alt="cost_scaling_factor=1"><br><img src="https://i.loli.net/2020/11/03/jpzMG6ZHhNxvQEd.png" alt="cost_scaling_factor=25"><br><img src="https://i.loli.net/2020/11/03/9IDVZ5aY1WPOFjE.png" alt="默认cost_scaling_factor=10"></p>
<p>减小<code>cost_scaling_factor</code>，使代价值增大，rviz里的膨胀层变为红色。还可以查看话题<code>/move_base/local_ctmap/costmap_updates</code>，会发现一些数值变大</p>
<p><strong>全局代价地图一般膨胀较多，使机器人转弯顺利。</strong> 但是局部代价可以不用膨胀层，这是因为TEB已有障碍物膨胀功能。  <font color = blue size=4>增大<code>cost_scaling_factor</code>和减小膨胀半径可以使机器人容易进窄通道，但一般是调整TEB，这两个参数不修改。</font></p>
<br>

<p>添加了静态层、障碍层、膨胀层的代价地图是这样的：<br><img src="https://i.loli.net/2020/11/01/aGEMh27qtwVm5PB.png" alt="11-01__172228"></p>
<p>如果代价地图不添加膨胀层，结果是这样：<br><img src="https://i.loli.net/2020/11/01/i3o4MFUwGJhOLZY.png" alt="11-01__172326"></p>
<p>但是加不加障碍层，看上去没有变化， <strong>目前无法在rviz里直接可视化每一层</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE3%20%20%E4%BB%A3%E4%BB%B7%E5%80%BC%E5%92%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BD%AE%E5%BB%93%E7%9A%84%E5%85%B3%E7%B3%BB/" data-id="ckr29d1db00khn8lm5ncb9drp" data-title="代价地图(三) 代价值和机器人轮廓的关系" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ROS/ROS机器人/stage的使用心得" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/15/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/stage%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/" class="article-date">
  <time class="dt-published" datetime="2020-11-15T11:55:10.000Z" itemprop="datePublished">2020-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ROS/">ROS</a>►<a class="article-category-link" href="/categories/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/">ROS机器人</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/15/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/stage%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/">stage的使用心得</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>stage的使用心得</p>
<p>Stage can simulate noisy odometry</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun stage_ros stageros /opt/ros/melodic/share/stage_ros/world/willow-erratic.world </span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/15/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/stage%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/" data-id="ckr29d1aj00den8lmdovncbro" data-title="stage的使用心得" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Matlab/将多个函数曲线在同一张图显示" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/15/Matlab/%E5%B0%86%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0%E6%9B%B2%E7%BA%BF%E5%9C%A8%E5%90%8C%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%98%BE%E7%A4%BA/" class="article-date">
  <time class="dt-published" datetime="2020-11-15T11:55:04.000Z" itemprop="datePublished">2020-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Matlab/">Matlab</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/15/Matlab/%E5%B0%86%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0%E6%9B%B2%E7%BA%BF%E5%9C%A8%E5%90%8C%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%98%BE%E7%A4%BA/">将多个函数曲线在同一张图显示</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">x=0:0.01:4;  % x从1到4，绘图采样间隔为0.01</span><br><span class="line">y1=252*exp(-10*(x-radius));</span><br><span class="line">y1=10*x+3;</span><br><span class="line">y2=exp(2*x);</span><br><span class="line">y3=sin(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plot(x,y1,<span class="string">&#x27;o-&#x27;</span>,<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);   %画出图形</span><br><span class="line">hold on;  	%继续画图</span><br><span class="line">plot(x,y2,<span class="string">&#x27;s-&#x27;</span>,<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>);</span><br><span class="line">hold on;  	%继续画图</span><br><span class="line">plot(x,y3,<span class="string">&#x27;*-&#x27;</span>,<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line"></span><br><span class="line">grid on;     % 添加网格，这是用默认的最小标度画出的网格</span><br><span class="line">axis([-5 10 -10 50]);     % x轴的范围是[-5, 10], y轴范围[-10,50]</span><br><span class="line"></span><br><span class="line">xlabel(<span class="string">&#x27;时间&#x27;</span>);     %设置X轴含义：时间</span><br><span class="line">ylabel(<span class="string">&#x27;目标&#x27;</span>);   %设置X轴含义：零件数</span><br><span class="line"></span><br><span class="line">legend(<span class="string">&#x27;y1&#x27;</span>,<span class="string">&#x27;y2&#x27;</span>,<span class="string">&#x27;y3&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>一个图中画多个曲线记得使用hold on，否则之前画的曲线将会被覆盖掉！</p>
<p>标识号曲线有两种方法：(1)通过不同的颜色；(2)通过不同的线形；   </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">颜色          定义符  </span><br><span class="line"></span><br><span class="line">红色          R（red）</span><br><span class="line"></span><br><span class="line">绿色          G(green)</span><br><span class="line"></span><br><span class="line">兰色          b(blue)</span><br><span class="line"></span><br><span class="line">青色          c(cyan)</span><br><span class="line"></span><br><span class="line">品红          M(magenta)</span><br><span class="line"></span><br><span class="line">黄色          y(yellow)</span><br><span class="line"></span><br><span class="line">黑色          k(black)</span><br><span class="line"></span><br><span class="line">白色          w(white)</span><br></pre></td></tr></table></figure>


<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">线形            符号</span><br><span class="line"></span><br><span class="line">实线             -</span><br><span class="line"></span><br><span class="line">圈圈             o</span><br><span class="line"></span><br><span class="line">星星             *</span><br><span class="line"></span><br><span class="line">正方形           s</span><br><span class="line"></span><br><span class="line">正六角星         h</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/15/Matlab/%E5%B0%86%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0%E6%9B%B2%E7%BA%BF%E5%9C%A8%E5%90%8C%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%98%BE%E7%A4%BA/" data-id="ckr29d150000tn8lmcw9t7iu8" data-title="将多个函数曲线在同一张图显示" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ROS/ROS Kinetic知识/常用的tf命令" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/15/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/%E5%B8%B8%E7%94%A8%E7%9A%84tf%E5%91%BD%E4%BB%A4/" class="article-date">
  <time class="dt-published" datetime="2020-11-15T11:54:58.000Z" itemprop="datePublished">2020-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ROS/">ROS</a>►<a class="article-category-link" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/15/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/%E5%B8%B8%E7%94%A8%E7%9A%84tf%E5%91%BD%E4%BB%A4/">常用的tf命令</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>rosrun tf view_frames</li>
</ol>
<p>当启动ROS程序后，如果想查看存在的所有坐标系转换关系，可以使用命令<code>rosrun tf view_frames</code>，结果会在当前目录生成pdf文件：<br><img src="https://c2.staticflickr.com/8/7850/46490602034_1924870de3_b.jpg"><br>顺便说一下，打开pdf的命令为<code>evince frames.pdf</code></p>
<ol start="2">
<li>rosrun rqt_tf_tree rqt_tf_tree</li>
</ol>
<p>跟上一个命令差不多，区别是直接打开一个pdf文件，但不会保存</p>
<p>在仿真环境下，使用<code>rostopic hz tf</code>，发现tf的频率是40Hz左右，这个数值是各个tf变化叠加的结果，使用<code>rqt_tf_tree</code>可以看到<br><img src="https://i.loli.net/2020/11/01/ZdnNrFjezJoAtay.png" alt="11-01__105511.png"></p>
<p>有些转换可能显示average rate有数值，但是buffer 和 recent transform都是0，这种其实没有发生tf，所以不能算数。</p>
<br>
左上角还有一个`clear buffer`按钮，`Buffer length`会清零
`Buffer length`表示`tf buffer`中有几秒的数据可使用，`rqt_tf_tree`中是10秒，`view frames`大约5秒


<ol start="3">
<li>tf_echo</li>
</ol>
<p>本命令用来查看两个坐标系之间的实时转换，需要5秒钟：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun tf tf_echo /turtle1 /turtle2  　//turtle1是parent坐标系, turtle2是child</span><br></pre></td></tr></table></figure>
<p><img src="https://c2.staticflickr.com/8/7834/40261688443_57d3ca29b1_b.jpg"></p>
<ol start="4">
<li>rqt_tf_tree</li>
</ol>
<p><code>rosrun rqt_tf_tree rqt_tf_tree</code>显示一个带界面的tf图显示工具，不必等待，然后可以另存为svg,png等格式<br>结果发现刷新按钮不好用，当tf树改变后，刷新有时没有改变显示，有时工具无法响应了</p>
<ol start="5">
<li>launch文件中的应用</li>
</ol>
<p>如果要让两个坐标系建立转换关系，常常在launch文件中添加</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">args</span>=<span class="string">&quot;-0.24 0 0.295 1.571 0 -1.571 /base_link /camera 10&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;tf&quot;</span> <span class="attr">name</span>=<span class="string">&quot;base_link_to_camera&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个节点就是以<code>base_link</code>为parent坐标系，向<code>camera</code>转换的欧拉角形式。前三个参数是x,y,z三个方向的位移，之后的三个参数是yaw,pitch,roll，然后是parent坐标系和child坐标系，最后是隔多长时间发送一次变换，一般取100(ms)。另一种形式就是四元数形式，也就是将第4~6参数换为qx,qy,qz,qw。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/15/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/%E5%B8%B8%E7%94%A8%E7%9A%84tf%E5%91%BD%E4%BB%A4/" data-id="ckr29d1a200cdn8lm4squ1wsj" data-title="常用的tf命令" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ROS/ROS Kinetic知识/tf_prefix和多机器人的应用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/15/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/tf_prefix%E5%92%8C%E5%A4%9A%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%BA%94%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2020-11-15T11:54:53.000Z" itemprop="datePublished">2020-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/ROS/">ROS</a>►<a class="article-category-link" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/15/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/tf_prefix%E5%92%8C%E5%A4%9A%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%BA%94%E7%94%A8/">tf_prefix和多机器人的应用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>为了支持多个“相似”的机器人，tf使用tf_prefix参数。没有tf_prefix参数，帧名<code>base_link</code>将解析为<code>/base_link</code></p>
<p>如果tf_prefix参数设置为<code>robot1</code>，<code>base_link</code>将解析为<code>/robot1/base_link</code>。这在运行多机器人时是最有用的，否则这些机器人将在其frame_ids中具有名称冲突。</p>
<p>源码其实很简单:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">getPrefixParam</span><span class="params">(ros::NodeHandle &amp; nh)</span>\</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::string param; </span><br><span class="line">   <span class="keyword">if</span> (!nh.<span class="built_in">searchParam</span>(<span class="string">&quot;tf_prefix&quot;</span>, param)) </span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; </span><br><span class="line">   </span><br><span class="line">   std::string return_val;</span><br><span class="line">   nh.<span class="built_in">getParam</span>(param, return_val);</span><br><span class="line">   <span class="keyword">return</span> return_val;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>一般用法是:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span> <span class="attr">ns</span>=<span class="string">&quot;robot_1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;tf_prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;robot_1&quot;</span>/&gt;</span></span><br><span class="line">  ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>tf2不再支持<code>tf_prefix</code>. <code>my_frame</code>和<code>/my_frame</code>是不同的坐标系名称, tf2不接受以<code>/</code>开头的坐标系名称,否则会报<code>tf2::InvalidArgument exception</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/15/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/tf_prefix%E5%92%8C%E5%A4%9A%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%BA%94%E7%94%A8/" data-id="ckr29d19n00bsn8lmaotd4gvl" data-title="tf_prefix和多机器人的应用" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/12/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/14/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C/Boost/">Boost</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/C-%E5%9F%BA%E7%A1%80/">C++ 基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/C-%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/">C++ 模板与STL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux%E5%9F%BA%E7%A1%80/">Linux基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Matlab/">Matlab</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PCL%E7%82%B9%E4%BA%91/">PCL点云</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ROS/">ROS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/">ROS机器人</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ROS/rviz%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/">rviz深入研究</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ROS/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA/">机器人导航</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/SLAM%E5%B7%A5%E5%85%B7/">SLAM工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Valgrind%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">Valgrind和内存管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Wireshark/">Wireshark</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/cmake-qmake/">cmake/qmake</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%97%E4%BA%AC%E5%AF%BC%E8%88%AA%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98/">南京导航程序的疑难问题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/">常用工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/">原理和配置</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/ICP/">ICP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/">amcl和粒子滤波</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/gmapping/">gmapping</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/">卡尔曼滤波</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/%E5%8F%8D%E5%85%89%E6%9D%BF/">反光板</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC/">算法推导</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/%E9%9B%B7%E8%BE%BE/">雷达</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/">第三方库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%84%9A%E6%9C%AC/">脚本</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%A7%86%E8%A7%89SLAM/">视觉SLAM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/">TEB算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/costmap-converter/">costmap converter</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move-base%E5%88%86%E6%9E%90/">move_base分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%85%A8%E5%B1%80%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/">全局路径算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%9F%BA%E4%BA%8Erealsense%E6%89%AB%E6%8F%8F%E7%82%B9%E4%BA%91%E7%9A%84%E4%BD%8E%E7%9F%AE%E9%81%BF%E9%9A%9C/">基于realsense扫描点云的低矮避障</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%A4%A7%E8%BD%AE%E5%BB%93%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%AF%BC%E8%88%AA/">大轮廓机器人的导航</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/">面试笔试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/web%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">web服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%91%84%E5%83%8F%E5%A4%B4/" rel="tag">摄像头</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95/" rel="tag">编译调试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/" rel="tag">面试笔试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/web%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">web服务器</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">内存管理</a> <a href="/tags/%E6%91%84%E5%83%8F%E5%A4%B4/" style="font-size: 15px;">摄像头</a> <a href="/tags/%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95/" style="font-size: 20px;">编译调试</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/" style="font-size: 10px;">面试笔试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/13/%E6%BF%80%E5%85%89SLAM/%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC/%E9%AB%98%E6%96%AF%E7%89%9B%E9%A1%BF%E6%B3%95/">17747</a>
          </li>
        
          <li>
            <a href="/2021/07/13/%E6%BF%80%E5%85%89SLAM/%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC/%E7%89%9B%E9%A1%BF%E6%B3%95/">牛顿法</a>
          </li>
        
          <li>
            <a href="/2021/07/12/%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/ROS/">ROS</a>
          </li>
        
          <li>
            <a href="/2021/07/12/%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/">算法</a>
          </li>
        
          <li>
            <a href="/2021/07/07/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/AddAccumulatedRangeData%E5%87%BD%E6%95%B0(3)/">AddAccumulatedRangeData函数(3) 加入位姿估计器和插入子图</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>