<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">598</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">56</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/09/18/hCro9MUd6JjRe1Q.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2022/05/07/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E7%BB%93%E6%9D%9F%E8%BD%A8%E8%BF%B9%20FinishTrajectoryUnderLock/">结束轨迹 FinishTrajectoryUnderLock</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p><code>node_main.cc</code>中的<code>Run</code>函数最后：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">::ros::<span class="built_in">spin</span>();</span><br><span class="line"><span class="comment">// 终止所有轨迹</span></span><br><span class="line">node.<span class="built_in">FinishAllTrajectories</span>();</span><br><span class="line">node.<span class="built_in">RunFinalOptimization</span>();</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Node::FinishAllTrajectories</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  carto::<span class="function">common::MutexLocker <span class="title">lock</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry : is_active_trajectory_) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> trajectory_id = entry.first;</span><br><span class="line">    <span class="comment">// 已经lock了，所以叫做 FinishTrajectoryUnderLock</span></span><br><span class="line">    <span class="keyword">if</span> (entry.second) &#123;</span><br><span class="line">      <span class="built_in">CHECK_EQ</span>(<span class="built_in">FinishTrajectoryUnderLock</span>(trajectory_id).code,</span><br><span class="line">               cartographer_ros_msgs::StatusCode::OK);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// offline_node.cc 中定义</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Node::FinishTrajectory</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> trajectory_id)</span> </span>&#123;</span><br><span class="line">  carto::<span class="function">common::MutexLocker <span class="title">lock</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">FinishTrajectoryUnderLock</span>(trajectory_id).code ==</span><br><span class="line">         cartographer_ros_msgs::StatusCode::OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有就是<code>finish_trajectory</code>服务的回调函数， 3个函数实际都调用<code>FinishTrajectoryUnderLock</code></p>
<p><br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cartographer_ros_msgs::StatusResponse <span class="title">Node::FinishTrajectoryUnderLock</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">int</span> trajectory_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cartographer_ros_msgs::StatusResponse status_response;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// First, check if we can actually finish the trajectory</span></span><br><span class="line">  <span class="comment">// trajectory_id 是否属于正在结束的轨迹集合，如果是 FROZEN 则返回</span></span><br><span class="line">  <span class="keyword">if</span> (map_builder_bridge_.<span class="built_in">GetFrozenTrajectoryIds</span>().<span class="built_in">count</span>(trajectory_id)) &#123;</span><br><span class="line">    <span class="keyword">const</span> std::string error =</span><br><span class="line">        <span class="string">&quot;Trajectory &quot;</span> + std::<span class="built_in">to_string</span>(trajectory_id) + <span class="string">&quot; is frozen.&quot;</span>;</span><br><span class="line">    <span class="built_in">LOG</span>(ERROR) &lt;&lt; error;</span><br><span class="line">    status_response.code = cartographer_ros_msgs::StatusCode::INVALID_ARGUMENT;</span><br><span class="line">    status_response.message = error;</span><br><span class="line">    <span class="keyword">return</span> status_response;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// trajectory_id 是否是 ACTIVE状态</span></span><br><span class="line">  <span class="keyword">if</span> (is_active_trajectory_.<span class="built_in">count</span>(trajectory_id) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> std::string error =</span><br><span class="line">        <span class="string">&quot;Trajectory &quot;</span> + std::<span class="built_in">to_string</span>(trajectory_id) + <span class="string">&quot; is not created yet.&quot;</span>;</span><br><span class="line">    <span class="built_in">LOG</span>(ERROR) &lt;&lt; error;</span><br><span class="line">    status_response.code = cartographer_ros_msgs::StatusCode::NOT_FOUND;</span><br><span class="line">    status_response.message = error;</span><br><span class="line">    <span class="keyword">return</span> status_response;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// trajectory_id 是否已经 finish</span></span><br><span class="line">  <span class="keyword">if</span> (!is_active_trajectory_[trajectory_id]) &#123;</span><br><span class="line">    <span class="keyword">const</span> std::string error = <span class="string">&quot;Trajectory &quot;</span> + std::<span class="built_in">to_string</span>(trajectory_id) +</span><br><span class="line">                              <span class="string">&quot; has already been finished.&quot;</span>;</span><br><span class="line">    <span class="built_in">LOG</span>(ERROR) &lt;&lt; error;</span><br><span class="line">    status_response.code =</span><br><span class="line">        cartographer_ros_msgs::StatusCode::RESOURCE_EXHAUSTED;</span><br><span class="line">    status_response.message = error;</span><br><span class="line">    <span class="keyword">return</span> status_response;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Shutdown the subscribers of this trajectory.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry : subscribers_[trajectory_id]) &#123;</span><br><span class="line">    entry.subscriber.<span class="built_in">shutdown</span>();</span><br><span class="line">    subscribed_topics_.<span class="built_in">erase</span>(entry.topic);</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Shutdown the subscriber of [&quot;</span> &lt;&lt; entry.topic &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CHECK_EQ</span>(subscribers_.<span class="built_in">erase</span>(trajectory_id), <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">CHECK</span>(is_active_trajectory_.<span class="built_in">at</span>(trajectory_id));</span><br><span class="line">  </span><br><span class="line">  map_builder_bridge_.<span class="built_in">FinishTrajectory</span>(trajectory_id);</span><br><span class="line">  is_active_trajectory_[trajectory_id] = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> std::string message =</span><br><span class="line">      <span class="string">&quot;Finished trajectory &quot;</span> + std::<span class="built_in">to_string</span>(trajectory_id) + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">  status_response.code = cartographer_ros_msgs::StatusCode::OK;</span><br><span class="line">  status_response.message = message;</span><br><span class="line">  <span class="keyword">return</span> status_response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>StatusResponse</code>不正常的<code>code</code>是<code>INVALID_ARGUMENT</code>,  <code>NOT_FOUND</code>,  <code>RESOURCE_EXHAUSTED</code>, 只有<code>OK</code>是正常的</p>
<p>其中的关键函数就是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MapBuilderBridge::FinishTrajectory</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> trajectory_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Finishing trajectory with ID &#x27;&quot;</span> &lt;&lt; trajectory_id &lt;&lt; <span class="string">&quot;&#x27;...&quot;</span>;</span><br><span class="line">  <span class="comment">// Make sure there is a trajectory with &#x27;trajectory_id&#x27;.</span></span><br><span class="line">  <span class="built_in">CHECK_EQ</span>(sensor_bridges_.<span class="built_in">count</span>(trajectory_id), <span class="number">1</span>);</span><br><span class="line">  map_builder_-&gt;<span class="built_in">FinishTrajectory</span>(trajectory_id);</span><br><span class="line">  sensor_bridges_.<span class="built_in">erase</span>(trajectory_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再看这个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MapBuilder::FinishTrajectory</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> trajectory_id)</span> </span>&#123;</span><br><span class="line">  sensor_collator_-&gt;<span class="built_in">FinishTrajectory</span>(trajectory_id);</span><br><span class="line">  pose_graph_-&gt;<span class="built_in">FinishTrajectory</span>(trajectory_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>sensor_collator_</code>就是<code>Collator::FinishTrajectory</code> 或者 <code>TrajectoryCollator::FinishTrajectory</code>，不用关注。</p>
<p>然后重要的是后端的同名函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::FinishTrajectory</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> trajectory_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">AddWorkItem</span>([<span class="keyword">this</span>, trajectory_id]() <span class="built_in">LOCKS_EXCLUDED</span>(mutex_)</span><br><span class="line">  &#123;</span><br><span class="line">    absl::MutexLock  <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">    <span class="built_in">CHECK</span>(!<span class="built_in">IsTrajectoryFinished</span>(trajectory_id));   <span class="comment">// 不能是已结束</span></span><br><span class="line">    data_.trajectories_state[trajectory_id].state = TrajectoryState::FINISHED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; submap : data_.submap_data.<span class="built_in">trajectory</span>(trajectory_id)) &#123;</span><br><span class="line">      data_.submap_data.<span class="built_in">at</span>(submap.id).state = SubmapState::kFinished;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> WorkItem::Result::kRunOptimization;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里又是全局优化的标志<code>kRunOptimization</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/05/07/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/map_builder_server.cc/">map_builder_server.cc</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p><code>map_builder_server.cc</code>中注册了一大堆回调函数，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server_builder.RegisterHandler&lt;handlers::GetLocalToGlobalTransformHandler&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// get_local_to_global_transform_handler.cc 文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetLocalToGlobalTransformHandler::OnRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> proto::GetLocalToGlobalTransformRequest&amp; request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> response = absl::make_unique&lt;proto::GetLocalToGlobalTransformResponse&gt;();</span><br><span class="line">  <span class="keyword">auto</span> local_to_global =</span><br><span class="line">      GetContext&lt;MapBuilderContextInterface&gt;()</span><br><span class="line">          -&gt;<span class="built_in">map_builder</span>()</span><br><span class="line">          .<span class="built_in">pose_graph</span>()</span><br><span class="line">          -&gt;<span class="built_in">GetLocalToGlobalTransform</span>(request.<span class="built_in">trajectory_id</span>());</span><br><span class="line">  *response-&gt;<span class="built_in">mutable_local_to_global</span>() = transform::<span class="built_in">ToProto</span>(local_to_global);</span><br><span class="line">  <span class="built_in">Send</span>(std::<span class="built_in">move</span>(response));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>GetLocalToGlobalTransform</code>可用于获取local坐标系的原点<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">transform::Rigid3d <span class="title">PoseGraph2D::GetLocalToGlobalTransform</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">int</span> trajectory_id)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ComputeLocalToGlobalTransform</span>(data_.global_submap_poses_2d,</span><br><span class="line">                                       trajectory_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样的还有 <code>PoseGraph2D::GetAllSubmapPoses</code>,  <code>PoseGraph2D::GetTrajectoryStates</code>,  <code>PoseGraph2D::GetTrajectoryNodePoses</code>,  <code>PoseGraph2D::GetLandmarkPoses()</code>,  <code>PoseGraph2D::constraints()</code>等等</p>
<p><code>cartographer\cartographer\cloud\internal\handlers</code>目录有一堆文件，每个文件只定义了一个对应的回调函数，这个回调函数只在<code>map_builder_server.cc</code>中调用，最终是运行<code>cartographer_grpc_server</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/05/04/%E8%87%AA%E4%B8%BB%E6%8E%A2%E7%B4%A2/frontier-based%20exploration/3.%20FrontierSearch/">3. FrontierSearch算法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%87%AA%E4%B8%BB%E6%8E%A2%E7%B4%A2/">自主探索</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%87%AA%E4%B8%BB%E6%8E%A2%E7%B4%A2/frontier-based-exploration/">frontier-based exploration</a></span><div class="content"><p>先找到离机器人所在栅格最近的空闲栅格，其索引为<code>idx</code>，再找它周围的4个邻居，分两种情况处理：</p>
<ol>
<li><p>如果是未访问的空闲栅格<code>nbr</code>，标记为已访问，插入<code>队列A</code>。依次递推，找出<code>nbr</code>的4个邻居，再把未访问的空闲栅格加入<code>队列A</code></p>
</li>
<li><p>如果这个4个邻居里有<code>frontier cell</code>(<strong>未被访问，NO_INFORMATION而且至少有1个邻居是空闲栅格</strong>)，再检查这个<code>frontier cell</code>的8个邻居是否也有<code>frontier</code>，依次递推，从一个<code>frontier</code>寻找新的<code>frontier</code>，把所有<code>frontier</code>的个数和坐标记下来，求出形心坐标和机器人到每个<code>frontier</code>的距离<code>distance</code>，并逐次更新<code>min_distance</code>参数。 把符合条件的<code>frontier</code>加入列表<code>frontier_list</code>，对其中的<code>frontier</code>按照cost进行从小到大排序，最后返回<code>frontier_list</code>。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2022/05/05/stvjAN3TM6rpF1e.png" alt="示意图.png"><br>中间的紫色栅格是开始栅格<code>idx</code>，它的邻居1,2,3,4都是空闲栅格.从1开始寻找它的4个邻居，其中包括了5，1没有邻居是frontier。在下次循环处理2，它的邻居里也有5，这里就用到了访问标记，否则就会把5添加到<code>队列A</code>两次。 在访问4的邻居里就会找到<code>frontier</code>，寻找<code>frontier</code>时会用到另一个访问标记，逻辑也是一样的。</p>
<p>在上层的<code>explore.cpp</code>里寻找<code>frontier</code>时，找到的是cost最小的<code>frontier</code>，因为返回的<code>frontier_list</code>已经排好序。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/05/03/%E8%87%AA%E4%B8%BB%E6%8E%A2%E7%B4%A2/frontier-based%20exploration/1.%20%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/">论文解读：A Frontier-Based Approach for Autonomous Exploration</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%87%AA%E4%B8%BB%E6%8E%A2%E7%B4%A2/">自主探索</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%87%AA%E4%B8%BB%E6%8E%A2%E7%B4%A2/frontier-based-exploration/">frontier-based exploration</a></span><div class="content"><p>这篇论文是1997年的，相当老了，而且感觉讲的不够详细，重点还是看代码，代码其实也很简单。论文中的evidence grid相当于现在的概率栅格，网格地图的原理、导航方法、声呐传感器的部分可以不看，实际需要看的部分少了很多。</p>
<p>论文的contribution在于： 基于frontiers的概念提出新的探索方法以及如何检测到frontiers，frontiers是已知的无障碍区域与未知区域的边界区域。探索方法是核心方法是：移动到frontiers，以获得环境的大部分新的信息</p>
<p>论文把地图中的cell分为三类(先验概率0.5，与现在的栅格地图逻辑一样)：</p>
<ul>
<li>open: 占据概率 &lt; 0.5</li>
<li>unknown: 占据概率 = 0.5</li>
<li>occupied: 占据概率 &gt; 0.5</li>
</ul>
<p>论文发现frontiers的方法是借鉴了计算机视觉中的 edge detection and region extraction.  未知cell周围的空闲cell被标记为 <code>frontier edge cell</code>. Adjacent edge cells are grouped into frontier regions.</p>
<p>任何超出最小值(大致为机器人尺寸)的<code>frontier region</code>才被认为是 <code>frontier</code>，它的centroid(形心，代码上可供选择的模式还有最近点和中点)会发布出来。 当机器人达到目标时，这个目标的位姿加入到<strong>已访问frontiers列表</strong>。</p>
<p>如果机器人无法向目标移动，经过一定时间，机器人会认为目标是无法到达的，这个目标点会加入<strong>不可达到的frontiers列表</strong>。然后向最近的尚未访问的frontier探索，找最近的边界目标以深度优先的方式进行探索。但是我看代码里是breadth first search</p>
<p>在探索过程中没有涉及到信息熵的概念，当然也不会去考虑如何平衡开发 <code>exploitation</code> 和 <code>exploration</code>之间的关系</p>
<p>代码中发布的是frontier区域形心，是发现的<code>各个frontier的坐标之和 / frontier个数</code>，这是近似求法。三角形矩形求形心可以这样，但多边形的形心不是这样的<br><img src="https://s2.loli.net/2022/05/05/QR4qmWxPCi17wfz.png" alt=""></p>
<p>可改进之处</p>
<ul>
<li>寻找frontier的算法不够快，递推过程会统计重复栅格</li>
<li>计算形心的方法或者发布其他位置的frontier，因为有时发布的形心太接近障碍物</li>
</ul>
<p>参考： <a target="_blank" rel="noopener" href="http://wiki.ros.org/frontier_exploration">frontier_exploration</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/05/03/%E8%87%AA%E4%B8%BB%E6%8E%A2%E7%B4%A2/frontier-based%20exploration/2.%20explore.cpp/">(二) explore.cpp</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%87%AA%E4%B8%BB%E6%8E%A2%E7%B4%A2/">自主探索</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%87%AA%E4%B8%BB%E6%8E%A2%E7%B4%A2/frontier-based-exploration/">frontier-based exploration</a></span><div class="content"><p>使用<code>m-explore</code>包，这是在<code>frontier_exploration</code>包基础上进行的修改。可以用<code>sudo apt install ros-$&#123;ROS_DISTRO&#125;-explore-lite</code>安装。需要同时运行cartographer和move_base</p>
<p><code>greedy frontier-based exploration</code>. robot will greedily explore its environment until no frontiers could be found. 速度发送到<code>move_base</code></p>
<p>不创建自己的costmap，节点订阅话题<code>map</code>（<code>nav_msgs/OccupancyGrid</code>类型，可配置），也可以是<code>move_base/global_costmap/costmap</code>。<br>如果是后者， 需要设置 <code>track_unknown_space</code>为 true</p>
<p>Node can do frontier filtering and can operate even on non-inflated maps. Goal blacklisting allows to deal with places inaccessible for robot</p>
<p>使用 move_base costmap 的好处是inflation可以处理非常小的unexplorable frontiers. 如果使用SLAM发布的raw map，应当设置 <code>min_frontier_size</code> to some reasonable number to deal with the small frontiers</p>
<p>发布话题<code>frontiers</code> (visualization_msgs/MarkerArray)，Each frontier is visualized by frontier points in blue and with a small sphere, which visualize the cost of the frontiers (costlier frontiers will have smaller spheres).</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li><p>progress_timeout: 时间以秒为单位。当机器人在 progress_timeout 没有任何进展时，当前目标将被放弃</p>
</li>
<li><p>potential_scale (double, default: 1e-3): 用于加权边界。这个乘法参数影响前沿权重的前沿潜在分量（到前沿的距离）. Used for weighting frontiers. This multiplicative parameter affects frontier potential component of the frontier weight (distance to frontier).</p>
</li>
<li><p>orientation_scale (double, default: 0): 用于加权边界。这个乘法参数影响前沿权重的前沿方向分量。此参数目前不执行任何操作，仅用于向前兼容. Used for weighting frontiers. This multiplicative parameter affects frontier orientation component of the frontier weight. This parameter does currently nothing and is provided solely for forward compatibility.</p>
</li>
<li><p>gain_scale (double, default: 1.0): 用于加权边界。这个乘法参数影响边界权重（边界大小）的边界增益分量. Used for weighting frontiers. This multiplicative parameter affects frontier gain component of the frontier weight (frontier size)</p>
</li>
<li><p>min_frontier_size (double, default: 0.5): 将边界视为探索目标的边界的最小值. Minimum size of the frontier to consider the frontier as the exploration goal. </p>
</li>
</ul>
<p>在Rviz使用<code>Point</code>按钮Prescribe一个封闭的polygon，在终端看指导</p>
<p> <code>frontier_cost</code> = <code>potential_scale * min_distance * 代价地图的分辨率 - gain_scale * frontier个数 * 代价地图的分辨率</code></p>
<h2 id="visualizeFrontiers"><a href="#visualizeFrontiers" class="headerlink" title="visualizeFrontiers"></a>visualizeFrontiers</h2><p>逻辑比较简单，关键部分如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weighted frontiers are always sorted</span></span><br><span class="line"><span class="keyword">double</span> min_cost = frontiers.<span class="built_in">empty</span>() ? <span class="number">0.</span> : frontiers.<span class="built_in">front</span>().cost;</span><br><span class="line">  ......</span><br><span class="line">m.pose.position = frontier.initial;</span><br><span class="line"><span class="comment">// scale frontier according to its cost (costier frontiers will be smaller)</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 默认的尺寸太大了，这里考虑降低 scale</span></span><br><span class="line"><span class="keyword">double</span> scale = std::<span class="built_in">min</span>(std::<span class="built_in">abs</span>(min_cost * <span class="number">0.4</span> / frontier.cost), <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="黑名单机制"><a href="#黑名单机制" class="headerlink" title="黑名单机制"></a>黑名单机制</h2><p>主要在于变量<code>std::vector&lt;geometry_msgs::Point&gt;  frontier_blacklist_</code>，由于<code>reachedGoal</code>被注释掉了，添加黑名单的地方只有：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(goal_fail_flag==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  frontier_blacklist_.<span class="built_in">push_back</span>(target_position);</span><br><span class="line">  <span class="built_in">ROS_DEBUG</span>(<span class="string">&quot;Adding current goal to black list&quot;</span>);</span><br><span class="line">  <span class="built_in">makePlan</span>();</span><br><span class="line">  goal_fail_flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>向黑名单添加目标位置，然后重新<code>makePlan</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Explore::goalOnBlacklist</span><span class="params">(<span class="keyword">const</span> geometry_msgs::Point&amp; goal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">size_t</span> tolerace = <span class="number">5</span>;</span><br><span class="line">  costmap_2d::Costmap2D* costmap2d = costmap_client_.<span class="built_in">getCostmap</span>();</span><br><span class="line">  <span class="comment">// check if a goal is on the blacklist for goals that we&#x27;re pursuing</span></span><br><span class="line">  <span class="comment">// 黑名单的frontier_goal 是否有一个与目前的 frontier十分接近</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; frontier_goal : frontier_blacklist_) &#123;</span><br><span class="line">    <span class="keyword">double</span> x_diff = <span class="built_in">fabs</span>(goal.x - frontier_goal.x);</span><br><span class="line">    <span class="keyword">double</span> y_diff = <span class="built_in">fabs</span>(goal.y - frontier_goal.y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x_diff &lt; tolerace * costmap2d-&gt;<span class="built_in">getResolution</span>() &amp;&amp;</span><br><span class="line">        y_diff &lt; tolerace * costmap2d-&gt;<span class="built_in">getResolution</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>visualizeFrontiers</code>中对接近黑名单的frontier做了红色显示<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">goalOnBlacklist</span>(frontier.centroid)) &#123;</span><br><span class="line">  m.color = red;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  m.color = blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></p>
<h2 id="发布探索goal"><a href="#发布探索goal" class="headerlink" title="发布探索goal"></a>发布探索goal</h2><p>核心的就是这几句：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三个设置的参数</span></span><br><span class="line">search_ = frontier_exploration::<span class="built_in">FrontierSearch</span>(costmap_client_.<span class="built_in">getCostmap</span>(),</span><br><span class="line">                                                 potential_scale_, gain_scale_,</span><br><span class="line">                                                 min_frontier_size);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">auto</span> pose = costmap_client_.<span class="built_in">getRobotPose</span>();</span><br><span class="line"><span class="comment">// get Frontiers sorted according to cost  返回类型std::vector&lt;Frontier&gt;</span></span><br><span class="line"><span class="keyword">auto</span> frontiers = search_.<span class="built_in">searchFrom</span>(pose.position);</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 这里可以改为 frontier-&gt;middle</span></span><br><span class="line">geometry_msgs::Point target_position = frontier-&gt;centroid;</span><br></pre></td></tr></table></figure><br>最后没有使用MoveBase的sendGoal，而是发布话题<code>explore_goal</code>，订阅者在<code>manager.cpp</code></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>start</code>和<code>stop</code>函数比较简单。</p>
<p>参考：<br><a target="_blank" rel="noopener" href="http://wiki.ros.org/explore_lite">explore_lite</a><br><a target="_blank" rel="noopener" href="https://github.com/adipandas/indoor_bot">indoor_bot</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/04/30/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/metrics%E6%9C%BA%E5%88%B6/">metrics机制</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>若要启用metrics机制，必须在launch文件里添加参数<code>-collect_metrics true</code>，这个本质也是gflag</p>
<p>源码的顺序如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node.cc中</span></span><br><span class="line"><span class="keyword">if</span> (collect_metrics)</span><br><span class="line">&#123;</span><br><span class="line">  metrics_registry_ = absl::make_unique&lt;metrics::FamilyFactory&gt;();</span><br><span class="line">  carto::metrics::<span class="built_in">RegisterAllMetrics</span>(metrics_registry_.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// register.cc中定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterAllMetrics</span><span class="params">(FamilyFactory* registry)</span> </span>&#123;</span><br><span class="line">  mapping::constraints::ConstraintBuilder2D::<span class="built_in">RegisterMetrics</span>(registry);</span><br><span class="line">  mapping::<span class="built_in">GlobalTrajectoryBuilderRegisterMetrics</span>(registry);</span><br><span class="line">  mapping::LocalTrajectoryBuilder2D::<span class="built_in">RegisterMetrics</span>(registry);</span><br><span class="line">  mapping::PoseGraph2D::<span class="built_in">RegisterMetrics</span>(registry);</span><br><span class="line">  sensor::TrajectoryCollator::<span class="built_in">RegisterMetrics</span>(registry);</span><br><span class="line">  <span class="comment">// 不需要可以注释掉</span></span><br><span class="line">  mapping::constraints::ConstraintBuilder3D::<span class="built_in">RegisterMetrics</span>(registry);</span><br><span class="line">  mapping::LocalTrajectoryBuilder3D::<span class="built_in">RegisterMetrics</span>(registry);</span><br><span class="line">  mapping::PoseGraph3D::<span class="built_in">RegisterMetrics</span>(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上所有<code>RegisterMetrics</code>在<code>local_trajectory_builder_2d.cc</code>,  <code>pose_graph_2d.cc</code>,  <code>constraint_builder_2d.cc</code>(排除3D情况)定义了所有metrics参数</p>
<p><br></p>
<p>以<code>kLocalSlamCpuRealTimeRatio</code>为例进行说明， 在<code>local_trajectory_builder_2d.cc</code>开始部分的声明：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span>* kLocalSlamCpuRealTimeRatio = metrics::Gauge::<span class="built_in">Null</span>();`</span><br></pre></td></tr></table></figure></p>
<p>然后在<code>LocalTrajectoryBuilder2D::RegisterMetrics</code>中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>* cpu_real_time_ratio = family_factory-&gt;<span class="built_in">NewGaugeFamily</span>(</span><br><span class="line">      <span class="string">&quot;mapping_2d_local_trajectory_builder_cpu_real_time_ratio&quot;</span>,</span><br><span class="line">      <span class="string">&quot;sensor duration / cpu duration.&quot;</span>);</span><br><span class="line"></span><br><span class="line">kLocalSlamCpuRealTimeRatio = cpu_real_time_ratio-&gt;<span class="built_in">Add</span>(&#123;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>最后是赋值部分<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (last_thread_cpu_time_seconds_.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> thread_cpu_duration_seconds =</span><br><span class="line">        thread_cpu_time_seconds - last_thread_cpu_time_seconds_.<span class="built_in">value</span>();</span><br><span class="line">    <span class="keyword">if</span> (sensor_duration.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">      kLocalSlamCpuRealTimeRatio-&gt;<span class="built_in">Set</span>(</span><br><span class="line">          common::<span class="built_in">ToSeconds</span>(sensor_duration.<span class="built_in">value</span>()) / thread_cpu_duration_seconds );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想查看metrics，只能<code>rosservice call /read_metrics &quot;&#123;&#125;&quot;</code>，内容太多了，主要是<code>mapping_constraints_constraint_builder_2d_scores</code></p>
<font size="4" color="blue"> 模仿源码，可以根据自己的需要添加 metrics  </font>


<p>如果不需要3D的metrics，可以到<code>ConstraintBuilder3D::RegisterMetrics</code>,  <code>LocalTrajectoryBuilder3D::RegisterMetrics</code>,  <code>PoseGraph3D::RegisterMetrics</code>中return</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/04/28/%E8%8B%B1%E8%AF%AD/batman%20%E5%8D%95%E8%AF%8D/">batman 单词</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%8B%B1%E8%AF%AD/">英语</a></span><div class="content"><ul>
<li>deadbeat &emsp;&emsp;&emsp;   老赖，游手好闲者</li>
<li>Don’t take it too hard &emsp;&emsp;&emsp; (受到打击后)别太难过，别放在心上</li>
<li>way to go &emsp;&emsp;&emsp;  表示对他人的贊同、興奮</li>
<li>hatchet man  &emsp;&emsp;&emsp;  受雇的打手, 职业杀手</li>
<li>we are rolling  &emsp;&emsp;&emsp;  相机开拍了</li>
<li>dead wrong  &emsp;&emsp;&emsp; 大错特错</li>
<li>mouthy &emsp;&emsp;&emsp;  喜欢说很多话，而且是以粗鲁的方式</li>
<li>gun barrel  &emsp;&emsp;&emsp;  枪管</li>
<li>reek &emsp;&emsp;&emsp;  发出臭味， reeking of imported cologne</li>
<li>small-time  &emsp;&emsp;&emsp; 不起眼的，不很成功的</li>
<li>sneaky pete  &emsp;&emsp;&emsp; （美国俚语）劣质的或廉价的烈性酒</li>
<li>milk and honey   &emsp;&emsp;&emsp;  丰富的享受    land of milk and honey  富饶的地方</li>
<li>hilt  &emsp;&emsp;&emsp;  刀柄</li>
<li>hapless  &emsp;&emsp;&emsp;  不幸运的；不愉快的</li>
<li>adversary  &emsp;&emsp;&emsp; 对手</li>
<li>squabble  &emsp;&emsp;&emsp;  争吵</li>
<li>gimmick   &emsp;&emsp;&emsp;    花招，华而不实的东西</li>
<li>neat and tidy   &emsp;&emsp;&emsp; 干净整洁</li>
<li>point-blank &emsp;&emsp;&emsp; 近距离平射的, 直截了当的</li>
<li>incantation &emsp;&emsp;&emsp; 咒语</li>
<li>coin toss  &emsp;&emsp;&emsp;   抛硬币</li>
<li>goofy  &emsp;&emsp;&emsp;  愚蠢的，古怪的</li>
<li>light sb up   &emsp;&emsp;&emsp;  To cause someone to become noticeably excited or animated.</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/04/21/SLAM%E5%B7%A5%E5%85%B7/ceres%202%20%E4%BD%BF%E7%94%A8/">Ceres(二) 使用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SLAM%E5%B7%A5%E5%85%B7/">SLAM工具</a></span><div class="content"><p>头文件只有一个<code>&quot;ceres/ceres.h&quot;</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ceres/ceres.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ceres::AutoDiffCostFunction;</span><br><span class="line"><span class="keyword">using</span> ceres::CostFunction;</span><br><span class="line"><span class="keyword">using</span> ceres::Problem;</span><br><span class="line"><span class="keyword">using</span> ceres::Solver;</span><br><span class="line"><span class="keyword">using</span> ceres::Solve;</span><br></pre></td></tr></table></figure><br><br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Functor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> x, T* residual)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		residual[<span class="number">0</span>] = <span class="number">10.0</span> - x[<span class="number">0</span>];</span><br><span class="line">		residual[<span class="number">1</span>] = <span class="number">3.0</span> - x[<span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 直接让第2维度为0，优化后的x[1]还是初值2</span></span><br><span class="line">		<span class="comment">// residual[1] = T(0.0);</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的变量为二维的<script type="math/tex">(x_0, x_1)</script>，目标函数为<code>10.0-x</code>和<code>3.0-x</code></p>
<p>如果这里不写10.0而是10，就会报错。 Ceres中没有int，只接受double</p>
<p>对于<code>residual[1] = T(0.0);</code>的情况，如果不加<code>T</code>，编译就会报错<font size="4" color="orange"> error: no match for ‘operator=’ (operand types are ‘ceres::Jet<double, 2>’ and ‘double’)  </font>. Jet类型是ceres内置类型，我们要把double转成Jet类型，也就是<code>T(0.0)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">TestLocalParam</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* x, <span class="keyword">const</span> T* delta, T* x_plus_delta)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">		x_plus_delta[<span class="number">0</span>] = x[<span class="number">0</span>] + <span class="number">0.4</span> * delta[<span class="number">0</span>];</span><br><span class="line">		x_plus_delta[<span class="number">1</span>] = x[<span class="number">1</span>] + <span class="number">0.4</span> * delta[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>CostFunctor</code>的<code>operator</code>就是计算残差，不带平方项，平方是ceres自动添加，相当于最小二乘的函数 f</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// double x = 0.5;</span></span><br><span class="line"><span class="keyword">double</span> x[] = &#123;<span class="number">0.5</span>, <span class="number">2.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">Problem problem;</span><br><span class="line"></span><br><span class="line">problem.<span class="built_in">AddParameterBlock</span>(x, <span class="number">2</span>, </span><br><span class="line">  (<span class="keyword">new</span> ceres::AutoDiffLocalParameterization</span><br><span class="line">  	<span class="comment">// 真正的维度是2， 参与优化的维度是1</span></span><br><span class="line">  	&lt;TestLocalParam, <span class="number">2</span>, <span class="number">1</span>&gt; ())</span><br><span class="line">	);</span><br><span class="line"><span class="comment">// AddParameterBlock 修改之后，无论下面的AutoDiffCostFunction参数是多少，只优化第1维度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 残差的维度，参数的维度</span></span><br><span class="line"><span class="comment">// 如果此时是 2,1. 报错</span></span><br><span class="line">CostFunction* cost_func = <span class="keyword">new</span> AutoDiffCostFunction&lt;Functor, <span class="number">2</span>, <span class="number">2</span>&gt;(<span class="keyword">new</span> Functor);</span><br><span class="line"><span class="comment">// 参数：CostFunction，可选的LossFunction，将CostFunction连接到一组参数块</span></span><br><span class="line">problem.<span class="built_in">AddResidualBlock</span>(cost_func, <span class="literal">nullptr</span>, x);</span><br></pre></td></tr></table></figure>
<p>创建最小二乘问题，可以使用<code>Problem::AddResidualBlock()</code>和<code>Problem::AddParameterBlock()</code>。 可以使用<code>Problem::AddParameterBlock()</code>显式添加参数块，这将导致额外的正确性检查; 然而，如果参数块不存在，<code>Problem::AddResidualBlock()</code>会隐式添加参数块。</p>
<p><code>AddParameterBlock()</code>显式地向Problem添加了一个参数块。它还允许用户将LocalParameterization对象与参数块关联起来。</p>
<p><code>AddResidualBlock</code>默认会先调用<code>AddParameterBlock</code>，一般不用后者。</p>
<p>损失函数<code>LossFunction</code>，给异常值做限定，如果是nullptr，该项的代价就是残差的平方范数</p>
<p>代价函数携带关于它所期望的参数块大小的信息。函数检查这些参数是否与parameter_blocks中列出的参数块的大小匹配。如果检测到不匹配，程序将中止。</p>
<h2 id="Solver"><a href="#Solver" class="headerlink" title="Solver"></a>Solver</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  Solver::Options  option;</span><br><span class="line">  option.minimizer_progress_to_stdout = <span class="literal">true</span>;</span><br><span class="line">  option.linear_solver_type = ceres::SPARSE_NORMAL_CHOLESKY;</span><br><span class="line"></span><br><span class="line">  Solver::Summary summary;</span><br><span class="line">  <span class="built_in">Solve</span>(option, &amp;problem, &amp;summary);</span><br><span class="line">  </span><br><span class="line">  std::cout &lt;&lt; summary.<span class="built_in">BriefReport</span>() &lt;&lt; std::endl&lt;&lt;std::endl;</span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; summary.FullReport() &lt;&lt; std::endl&lt;&lt;std::endl;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; &quot;initial x: &quot; &lt;&lt; initial_x &lt;&lt;&quot;   x: &quot;&lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line">  std::cout &lt;&lt;<span class="string">&quot;x[0]: &quot;</span>&lt;&lt; x[<span class="number">0</span>] &lt;&lt;<span class="string">&quot;   x[1]: &quot;</span>&lt;&lt; x[<span class="number">1</span>]&lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优先选用自动微分算法，某些情况可能需要用到解析微分算法，尽量避免数值微分算法。</p>
<h2 id="曲线拟合"><a href="#曲线拟合" class="headerlink" title="曲线拟合"></a>曲线拟合</h2><p>使用曲线拟合的例子，已知N个数据 <script type="math/tex">(x_i, y_i)</script>，它们符合曲线 <script type="math/tex">e^{(ax^2 + bx + c)}</script>，通过曲线拟合求a, b, c</p>
<p>跟上面的例子不同，这次目标函数为 <script type="math/tex">y-e^{(ax^2 + bx + c)}</script>，残差维度为3(未知a,b,c)</p>
<p>CMake配置如下<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">find_package(OpenCV REQUIRED)</span><br><span class="line">INCLUDE_DIRECTORIES(<span class="variable">$&#123;OpenCV_DIRS&#125;</span>)</span><br><span class="line"></span><br><span class="line">target_link_libraries(node_2</span><br><span class="line">   <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">   <span class="variable">$&#123;CERES_LIBRARIES&#125;</span></span><br><span class="line">   <span class="variable">$&#123;OpenCV_LIBS&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>先生成带有高斯噪声的数据<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真实值</span></span><br><span class="line"><span class="keyword">double</span> a =<span class="number">1.0</span>, b=<span class="number">2.0</span>, c=<span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">int</span> N = <span class="number">240</span>;  <span class="comment">// 数据数量</span></span><br><span class="line"><span class="keyword">double</span> w_sigma = <span class="number">1.0</span>;  <span class="comment">// 高斯标准差</span></span><br><span class="line">cv::RNG  rng;</span><br><span class="line"><span class="comment">// abc的初值</span></span><br><span class="line"><span class="keyword">double</span> abc[<span class="number">3</span>]  = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">double</span>&gt; x_data, y_data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i =<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">double</span> x = i/<span class="number">100.0</span>;</span><br><span class="line">  x_data.<span class="built_in">push_back</span>(x);</span><br><span class="line">  y_data.<span class="built_in">push_back</span>(<span class="built_in">exp</span>(a*x*x + b*x + c) + rng.<span class="built_in">gaussian</span>(w_sigma)  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>高斯噪声的产生： <code>cv::RNG  rng;  rng.gaussian(w_sigma)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Functor</span>&#123;</span></span><br><span class="line">    <span class="built_in">Functor</span>(<span class="keyword">double</span> x, <span class="keyword">double</span> y):</span><br><span class="line">    <span class="built_in">m_x</span>(x), <span class="built_in">m_y</span>(y) &#123;    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">// 开始我是这么写的，没弄清残差的维度</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">const</span> T* <span class="keyword">const</span> a, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">const</span> T* <span class="keyword">const</span> b, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">const</span> T* <span class="keyword">const</span> c, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          T* residual)</span>  <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        residual[<span class="number">0</span>] = m_y - <span class="built_in">exp</span>(a[<span class="number">0</span>] * m_x * m_x + b[<span class="number">0</span>] * m_x + c[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 因为要传入数据(x,y)， 所以要定义两个成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">const</span> T* <span class="keyword">const</span> abc, T* residual)</span>  <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        residual[<span class="number">0</span>] = m_y - <span class="built_in">exp</span>(abc[<span class="number">0</span>] * m_x * m_x + abc[<span class="number">1</span>] * m_x + abc[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> m_x, m_y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为自变量x是一维的，而不是向量，所以残差只计算一维 <code>residual[0]</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Problem problem;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">  &#123;</span><br><span class="line">  	<span class="comment">// 残差维度， 所估计变量的维度</span></span><br><span class="line">    CostFunction* cost_func = <span class="keyword">new</span> AutoDiffCostFunction&lt;Functor,<span class="number">1</span>,<span class="number">3</span>&gt;(<span class="keyword">new</span> <span class="built_in">Functor</span>(x_data[i], y_data[i]) );</span><br><span class="line">    problem.<span class="built_in">AddResidualBlock</span>(cost_func, <span class="literal">nullptr</span>, abc);</span><br><span class="line">  &#125;</span><br><span class="line">  Solver::Options option;</span><br><span class="line">  option.minimizer_progress_to_stdout = <span class="literal">true</span>;</span><br><span class="line">  option.linear_solver_type = ceres::SPARSE_NORMAL_CHOLESKY;</span><br><span class="line"></span><br><span class="line">  Solver::Summary summary;</span><br><span class="line">  <span class="built_in">Solve</span>(option, &amp;problem, &amp;summary);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; summary.<span class="built_in">BriefReport</span>() &lt;&lt; endl &lt;&lt;endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a: &quot;</span>&lt;&lt; abc[<span class="number">0</span>] &lt;&lt;<span class="string">&quot;  b: &quot;</span>&lt;&lt; abc[<span class="number">1</span>]&lt;&lt; <span class="string">&quot;  c: &quot;</span>&lt;&lt; abc[<span class="number">2</span>] &lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>参考：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/vivian187/p/15331181.html">Curve Fitting(曲线拟合)</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/vivian187/p/15394000.html">Problem类</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/04/18/%E6%BF%80%E5%85%89SLAM/Hector/">Hector</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/%E5%85%B6%E4%BB%96/">其他</a></span><div class="content"><p>hector利用了激光雷达的高速扫描频率，没有闭环检测，建图时机器人速度需要很慢，但在机器人快速转弯时容易发生错误，原因在于优化算法容易陷入局部最小值。</p>
<p>论文的新颖点在于scanMatch使用<strong>高斯牛顿法</strong>以及<strong>多分辨率地图</strong></p>
<p><img src="https://s2.loli.net/2022/04/18/BJeNV18bKDCqHEn.png" alt="对向量求导.png"></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>hector的计算太慢了，只进行扫描匹配的操作就要花费大概0.1秒钟，这就导致即使雷达频率再高，hector也处理不过来</li>
<li>hector的地图不能自动更改大小，地图的大小在初始化之后始终是固定的</li>
<li>适用于非光滑线性逼近的地图梯度∇M(Si(ε))，这意味着不能保证局部二次收敛到最小，但该算法在实践中精度较高。</li>
</ol>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/tiancailx/article/details/113522899">李想对hector的分析</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dlutjwh/p/10962026.html">论文阅读：hector_slam</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/04/15/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/cartographer_grpc_server%E7%9A%84%E9%85%8D%E7%BD%AE/">cartographer_grpc_server的使用和配置</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/">原理和配置</a></span><div class="content"><p>使用gRPC与云端结合：cartographer使用Protobuf数据传输协议，所以可以使用gRPC（也是谷歌的），可以通过云端运行cartographer算法，最典型的例子就是多机器人在一张已知地图上进行导航，在一个远程的强大centralized localization server运行 multi-trajectories Cartographer</p>
<p>方案：一台机器运行local optimization，另一台运行 global optimization</p>
<p>Cloud-based mapping ，using a gRPC streaming connection between local and global SLAM to propagate sensor data and local SLAM updates, which does not support ACKs and resending, hence this is not going to work over spotty WiFi.<br><img src="https://s2.loli.net/2022/04/15/luS9ofiMEh5c2mR.png" alt=""></p>
<p>先安装<code>protobuf</code>和<code>ceres</code></p>
<h2 id="安装-grpc"><a href="#安装-grpc" class="headerlink" title="安装 grpc"></a>安装 grpc</h2><p>一开始下载<code>grpc</code>后进行编译，结果报错：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CMake Warning at cmake/abseil-cpp.cmake:30 (message):</span><br><span class="line">  gRPC_ABSL_PROVIDER is <span class="string">&quot;module&quot;</span> but ABSL_ROOT_DIR is wrong</span><br><span class="line">Call Stack (most recent call first):</span><br><span class="line">  CMakeLists.txt:188 (include)</span><br></pre></td></tr></table></figure><br>这说明第三方库没准备好，最好按如下步骤：</p>
<p>如果只想下载指定版本的，如以版本<code>1.27.3</code>为例，可改成如下语句：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b v1<span class="number">.27</span><span class="number">.0</span> https:<span class="comment">//github.com/grpc/grpc.git</span></span><br></pre></td></tr></table></figure><br>上列操作成功完成后，gRPC 源码的第三方依赖目录 <code>third_party</code> 实际是空的，需通过下列步骤拉取依赖的第三方。切换到 grpc 目录，下载 grpc 第三方依赖到本地：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init</span><br></pre></td></tr></table></figure><br>grpc依赖的第三方库有点多，如果不借助<code>git submodule</code>，手工一个个下载不太容易。其中的<code>bloaty</code>库很大。</p>
<p>注意，gRPC 要求 <code>CMake 3.5.1</code> 或以上版本的CMake，否则会报错 CMake 3.5.1 or higher is required </p>
<p>编译：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cmake -DgRPC_SSL_PROVIDER=package ..</span><br><span class="line">make -j8</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">cmake  -DgRPC_INSTALL=ON -DgRPC_ZLIB_PROVIDER=package -DgRPC_CARES_PROVIDER=package -DgRPC_PROTOBUF_PROVIDER=package -DgRPC_SSL_PROVIDER=package -DgRPC_ABSL_PROVIDER=package ..</span><br><span class="line">make -j8</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">cmake  -DgRPC_INSTALL=ON -DBUILD_SHARED_LIBS=ON -DgRPC_ZLIB_PROVIDER=package -DgRPC_CARES_PROVIDER=package -DgRPC_PROTOBUF_PROVIDER=package -DgRPC_SSL_PROVIDER=package -DgRPC_ABSL_PROVIDER=package ..</span><br><span class="line">make -j8</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p>
<h2 id="CMake配置"><a href="#CMake配置" class="headerlink" title="CMake配置"></a>CMake配置</h2><p>在包含<code>option(BUILD_GRPC &quot;build Cartographer gRPC support&quot; false)</code>的3个<code>CMakeLists</code>修改为true。 最好再添加 <code>set(BUILD_GRPC true)</code>，以及C++14的支持  <code>set(CMAKE_CXX_STANDARD 14)</code></p>
<h2 id="lua配置"><a href="#lua配置" class="headerlink" title="lua配置"></a>lua配置</h2><p><code>backpack_2d_server.lua</code>如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">&quot;map_builder_server.lua&quot;</span></span><br><span class="line"></span><br><span class="line">MAP_BUILDER_SERVER.map_builder.use_trajectory_builder_2d = <span class="keyword">true</span></span><br><span class="line"><span class="keyword">return</span> MAP_BUILDER_SERVER</span><br></pre></td></tr></table></figure></p>
<p><code>map_builder_server.lua</code>如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">&quot;map_builder.lua&quot;</span></span><br><span class="line"></span><br><span class="line">MAP_BUILDER_SERVER = &#123;</span><br><span class="line">  map_builder = MAP_BUILDER,</span><br><span class="line">  num_event_threads = <span class="number">4</span>,</span><br><span class="line">  num_grpc_threads = <span class="number">4</span>,</span><br><span class="line">  --- 我的修改</span><br><span class="line">  server_address = <span class="string">&quot;192.168.0.105:50051&quot;</span>,</span><br><span class="line">  uplink_server_address = <span class="string">&quot;&quot;</span>,</span><br><span class="line">  upload_batch_size = <span class="number">100</span>,</span><br><span class="line">  enable_ssl_encryption = <span class="keyword">false</span>,</span><br><span class="line">  enable_google_auth = <span class="keyword">false</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="运行数据集"><a href="#运行数据集" class="headerlink" title="运行数据集"></a>运行数据集</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch cartographer_ros grpc_demo_backpack_2d.launch bag_filename:=/home/user/cartographer/dataset/cartographer_paper_deutsches_museum.bag</span><br></pre></td></tr></table></figure>
<p>这是在一台机上运行客户端和服务端<br><img src="https://s2.loli.net/2022/08/21/thAPe3QlsTKYyRc.png" alt=""><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;/use_sim_time&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">textfile</span>=<span class="string">&quot;$(find cartographer_ros)/urdf/backpack_2d.urdf&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 服务端 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;cartographer_grpc_server&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;cartographer_ros&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">&quot;cartographer_grpc_server.sh&quot;</span> <span class="attr">args</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">          -configuration_directory $(find cartographer_ros)/configuration_files</span></span></span><br><span class="line"><span class="string"><span class="tag">          -configuration_basename backpack_2d_server.lua&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 客户端 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;cartographer_grpc_node&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;cartographer_ros&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">&quot;cartographer_grpc_node&quot;</span> <span class="attr">args</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">    -client_id CLIENT_ID</span></span></span><br><span class="line"><span class="string"><span class="tag">          -configuration_directory $(find cartographer_ros)/configuration_files</span></span></span><br><span class="line"><span class="string"><span class="tag">          -configuration_basename backpack_2d.lua&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;echoes&quot;</span> <span class="attr">to</span>=<span class="string">&quot;horizontal_laser_2d&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;playbag&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rosbag&quot;</span> <span class="attr">type</span>=<span class="string">&quot;play&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">args</span>=<span class="string">&quot;--clock $(arg bag_filename)&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">args</span>=<span class="string">&quot;-d $(find cartographer_ros)/configuration_files/demo_2d.rviz&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><br>就是<code>CLIENT_ID</code>，无需设置为数字。</p>
<h2 id="真实运行"><a href="#真实运行" class="headerlink" title="真实运行"></a>真实运行</h2><ul>
<li>把客户端上的<code>ROS_MASTER_URI</code>设置为服务端的IP</li>
<li>rviz放在服务端。</li>
<li>服务端的终端刷新日志，客户端不刷新</li>
<li>网络不能差，否则服务端刷新慢。</li>
<li>连接成功后，关服务端，客户端也会终止。连接成功后，关客户端，服务端停止刷新；再启动客户端，服务端继续更新。</li>
</ul>
<p>客户端<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;cartographer_grpc_node&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;cartographer_ros&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">&quot;cartographer_grpc_node&quot;</span> <span class="attr">args</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">      -client_id CLIENT_ID</span></span></span><br><span class="line"><span class="string"><span class="tag">      -server_address 192.168.1.213:50051</span></span></span><br><span class="line"><span class="string"><span class="tag">          -configuration_directory $(find cartographer_ros)/configuration_files</span></span></span><br><span class="line"><span class="string"><span class="tag">          -configuration_basename backpack_2d.lua&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;/scan&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/sick_tim551_scan&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;/odom&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/odometry/filtered&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>服务端<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;cartographer_grpc_server&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;cartographer_ros&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">&quot;cartographer_grpc_server.sh&quot;</span> <span class="attr">args</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">          -configuration_directory $(find cartographer_ros)/configuration_files</span></span></span><br><span class="line"><span class="string"><span class="tag">          -configuration_basename backpack_2d_server.lua&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">args</span>=<span class="string">&quot;-d $(find cartographer_ros)/configuration_files/demo_2d.rviz&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="纯定位"><a href="#纯定位" class="headerlink" title="纯定位"></a>纯定位</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;cartographer_grpc_node&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;cartographer_ros&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">&quot;cartographer_grpc_node&quot;</span> <span class="attr">args</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        -client_id CLIENT_ID</span></span></span><br><span class="line"><span class="string"><span class="tag">        -configuration_directory $(find cartographer_ros)/configuration_files</span></span></span><br><span class="line"><span class="string"><span class="tag">        -configuration_basename backpack_2d_localization.lua</span></span></span><br><span class="line"><span class="string"><span class="tag">        -load_state_filename $(arg load_state_filename)&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;echoes&quot;</span> <span class="attr">to</span>=<span class="string">&quot;horizontal_laser_2d&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/windxf/article/details/108868236">运行cartographer的gRPC demo</a><br><a target="_blank" rel="noopener" href="http://txgcwm.github.io/blog/2014/03/26/ubuntuxia-an-zhuang-c-aresku/">Ubuntu下安装c-ares库</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/8/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/60/">60</a><a class="extend next" rel="next" href="/page/10/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/09/18/hCro9MUd6JjRe1Q.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>