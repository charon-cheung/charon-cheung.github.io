<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | Silent Assassin</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">444</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">48</span></a></div></div></div><nav id="nav" style="background-image: url(https://i.loli.net/2021/07/13/RCLw5Bx8aFPN74b.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Silent Assassin</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">Silent Assassin</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/12/04/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%9F%BA%E4%BA%8Erealsense%E6%89%AB%E6%8F%8F%E7%82%B9%E4%BA%91%E7%9A%84%E4%BD%8E%E7%9F%AE%E9%81%BF%E9%9A%9C/1.%20%E5%88%9D%E6%AD%A5%E9%85%8D%E7%BD%AE%E5%92%8C%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/">(一) 初步配置和发现的问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%9F%BA%E4%BA%8Erealsense%E6%89%AB%E6%8F%8F%E7%82%B9%E4%BA%91%E7%9A%84%E4%BD%8E%E7%9F%AE%E9%81%BF%E9%9A%9C/">基于realsense扫描点云的低矮避障</a></span><div class="content"><p>为了能扫描到低处的障碍，相机的安装也是个问题，realsense435与地面呈一定角度，也就是相机需要低着头，这跟相机的FOV有关，FOV当然是越大越好。在机器人静止状态下，根据rviz中的原始点云情况调试。如果低头太多，等看到低处障碍时，车已经离得太近，躲避不开；如果低头少或者相机平视前方，车近处的障碍看不到，无法避障。</p>
<p>realsense需要加滤波片，其他相机不清楚<br><img src="https://i.loli.net/2021/06/08/fQJGilwkKbeqTPg.png" alt="原始点云的扫描情况"></p>
<p><img src="https://i.loli.net/2021/06/08/eD9oLa21vK8MhOI.png" alt="机器人, 相机坐标系和障碍.png"></p>
<p><img src="https://i.loli.net/2020/12/23/L8HBIJea2sgFhvE.png" alt="相机坐标系和点云的关系"></p>
<h2 id="代价地图的配置"><a href="#代价地图的配置" class="headerlink" title="代价地图的配置"></a>代价地图的配置</h2><p>通用代价地图的障碍层需要这样设置<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">obstacles:</span><br><span class="line"> enabled: <span class="literal">true</span></span><br><span class="line"> obstacle_range: 2.0</span><br><span class="line"> raytrace_range: 5.0</span><br><span class="line"> track_unknown_space: <span class="literal">true</span></span><br><span class="line"> combination_method: 1</span><br><span class="line"> <span class="comment"># 传感器种类, data_type只能是 LaserScan  PointCloud  PointCloud2</span></span><br><span class="line"> observation_sources: laser_scan_sensor  pointcloud2_sensor</span><br><span class="line"> laser_scan_sensor: </span><br><span class="line">    data_type: LaserScan</span><br><span class="line">    topic: /scan</span><br><span class="line">    marking: <span class="literal">true</span></span><br><span class="line">    clearing: <span class="literal">true</span></span><br><span class="line">    max_obstacle_height: 1.0</span><br><span class="line">    min_obstacle_height: -1.0</span><br><span class="line"></span><br><span class="line"> pointcloud2_sensor:</span><br><span class="line">    topic:          /obstacles_cloud</span><br><span class="line">    data_type:      PointCloud2</span><br><span class="line">    sensor_frame:   <span class="string">&quot;camera_depth_optical_frame&quot;</span></span><br><span class="line">    obstacle_range: 5.0</span><br><span class="line">    raytrace_range: 5.0</span><br><span class="line">    observation_persistence: 20.0</span><br><span class="line">    marking:        <span class="literal">true</span></span><br><span class="line">    clearing:       <span class="literal">true</span> </span><br><span class="line">    min_obstacle_height: -1.0</span><br><span class="line">    max_obstacle_height: 1.0</span><br></pre></td></tr></table></figure></p>
<p>如果雷达和相机扫描到同一个障碍物，代价地图里不会膨胀两次，这就是<code>combination_method</code>的作用，配置中为1，取的是较大值，源码如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObstacleLayer::updateCosts</span><span class="params">(costmap_2d::Costmap2D&amp; master_grid, </span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> min_i, <span class="keyword">int</span> min_j, <span class="keyword">int</span> max_i, <span class="keyword">int</span> max_j )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!enabled_)   <span class="keyword">return</span>;</span><br><span class="line">     <span class="comment">// 参数 footprint_clearing_enabled</span></span><br><span class="line">  <span class="keyword">if</span> (footprint_clearing_enabled_)</span><br><span class="line">  	<span class="comment">// 获得机器人轮廓内的cells，然后赋值为 costmap_2d::FREE_SPACE</span></span><br><span class="line">    <span class="built_in">setConvexPolygonCost</span>(transformed_footprint_, costmap_2d::FREE_SPACE);</span><br><span class="line">    <span class="comment">// 选择参数值</span></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (combination_method_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">// Overwrite</span></span><br><span class="line">      <span class="built_in">updateWithOverwrite</span>(master_grid, min_i, min_j, max_i, max_j);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">// Maximum</span></span><br><span class="line">      <span class="built_in">updateWithMax</span>(master_grid, min_i, min_j, max_i, max_j);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:  <span class="comment">// Nothing</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数在<code>LayeredCostmap::updateMap</code>里调用</p>
<p><font color = blue size=4>注意: </font> 点云障碍作为PointCloud2类型加入代价地图时，点云程序必须给发布的点云消息加时间戳，时间戳也要更新，否则无法成功加入到代价地图，也就是点云的障碍在代价地图里没有膨胀</p>
<h2 id="外参标定"><a href="#外参标定" class="headerlink" title="外参标定"></a>外参标定</h2><p><strong>这里只是粗糙标定</strong></p>
<p>因为相机和雷达有tf关系，realsense生成的点云和雷达生成的scan开始是没有对齐的，比如机器人面对墙壁时，scan是紧贴墙壁的，但点云距离墙有一点距离<br><img src="https://i.loli.net/2021/06/08/h7SZ8csf3kdierV.png" alt="2021-06-08_101907.png"></p>
<p>如果雷达扫描出错，点云也会跟着出错，结果出现很多不应存在的障碍<br><img src="https://i.loli.net/2021/06/08/T34hGDneAbHq6rW.png" alt="2021-06-08_101916.png"></p>
<p><img src="https://i.loli.net/2021/06/08/W2jkeTLJCYRKdP3.png" alt="2021-06-08_101852.png"></p>
<p>tf体系中，<code>base_link</code>是parent，<code>laser_link</code>和<code>camera_link</code>都是child，二者的关系不能直接修改。    我们需要修改的是<code>tf.launch</code>中的<code>base_link</code>和<code>camera_link</code>的关系。所有的机器人都要更新<code>tf.launch</code>，最好确定一下是否每台的参数都一样</p>
<p>在上面的墙壁扫描结果中，经过rviz中的测量，相机的点云和雷达点云在z方向差0.2米。对齐之后，扫描结果正常，导航效果明显提高</p>
<h2 id="初步调整参数"><a href="#初步调整参数" class="headerlink" title="初步调整参数"></a>初步调整参数</h2><p>测试发现越低的障碍越容易碰撞，等时间达到 <code>observation_persistence</code> 会从代价地图清除所有障碍</p>
<p>机器人的速度比较快，由于规划频率、代价地图更新频率、加速度约束、CostmapConverter频率等等因素，很难及时停下，采取以下措施:</p>
<ul>
<li>降低膨胀半径为 0.9</li>
<li>增大costmap_converter_rate 为 8</li>
<li>增大局部地图的更新和发布频率 <code>update_frequency</code>  和  <code>publish_frequency</code></li>
<li>增大全局地图的更新和发布频率 <code>update_frequency</code>  和  <code>publish_frequency</code></li>
</ul>
<p>一帧一帧观察导航的过程，发现点云的识别和加入代价地图并不慢，但是<font color = blue size=4>局部和全局路径的规划较慢 ，从代价地图生成点云障碍到改变全局路径，车已经走了至少0.5米，局部路径就更滞后了。</font> 因此适当加大全局和局部路径的规划频率。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">base_global_planner: <span class="string">&quot;global_planner/GlobalPlanner&quot;</span></span><br><span class="line">planner_frequency: 5.0    <span class="comment"># 之前是 0.05 </span></span><br><span class="line">planner_patience: 2.0</span><br></pre></td></tr></table></figure></p>
<table><tr><td bgcolor=yellow> 以上加大频率的做法都会加大CPU占用 </td></tr></table>


<h2 id="导航的问题"><a href="#导航的问题" class="headerlink" title="导航的问题"></a>导航的问题</h2><ul>
<li><p>从远处快速接近低处障碍时，小车不能停下来</p>
</li>
<li><p>初步优化后，在通道内，小车仍然以慢速行走</p>
</li>
<li><p>对于通道内的低处障碍，经常避障失败</p>
</li>
<li><p>避障时的速度波动，使小车卡顿</p>
</li>
</ul>
<h3 id="原因和可能的优化"><a href="#原因和可能的优化" class="headerlink" title="原因和可能的优化"></a>原因和可能的优化</h3><ul>
<li><p>相机扫描到点云的最大距离约1.8m，不利于及时刹车。在小车速度很快时，甚至扫描不到障碍</p>
</li>
<li><p>比较罕见的情况：相机FOV小，当小车快速接近障碍时，没有产生点云，一般是从障碍旁边走过。最好换一个视野和扫描距离更大的相机</p>
</li>
<li><p>对低矮避障时，局部路径明显偏离全局路径，问题在全局路径的转换和<code>Homoplanner</code>的选择</p>
</li>
<li><p>CPU性能不足</p>
</li>
<li><p>比较罕见的情况： <code>costmap_converter</code>有时不能及时转换出障碍，结果TEB不认为代价地图中的点云是障碍；有时又把代价地图中的点云障碍转换得更大</p>
</li>
</ul>
<h2 id="点云的问题"><a href="#点云的问题" class="headerlink" title="点云的问题"></a>点云的问题</h2><p>点云程序的误检测，或者因为雷达出错而造成的不存在的障碍</p>
<ul>
<li>点云不稳定，来回摇晃，经过的地方都在代价地图中形成了障碍，结果障碍太大使导航失败</li>
</ul>
<p><img src="https://i.loli.net/2021/06/08/wSV3dPMmKOoktGT.gif" alt="点云抖动.gif"><br><img src="https://i.loli.net/2021/01/12/QUZnRPGXHlMeVCo.png" alt="1"></p>
<p><img src="https://i.loli.net/2021/01/12/8I5jJ1DzG2BQSKn.png" alt="2"></p>
<ul>
<li>在阳光下严重误检测，产生大量不存在的障碍</li>
</ul>
<p><img src="https://i.loli.net/2021/06/08/7YXTHKUge2bOiWr.gif" alt="阳光.gif"></p>
<ul>
<li>没有经过shadow filter，使点云阴影形成障碍</li>
</ul>
<p><img src="https://i.loli.net/2020/12/21/XKURAlhe3uEvQDC.png" alt="点云影子产生障碍 1"></p>
<p><img src="https://i.loli.net/2020/12/21/pj16sirAZumzvDO.png" alt="点云影子产生障碍 2"></p>
<ul>
<li>其他不应存在的障碍</li>
</ul>
<p>多台车每次到这里都会发现这个障碍，但是看现实环境又什么都没有<br><img src="https://i.loli.net/2021/02/19/YkEb28QDmXJzUjN.png" alt="每次都出现的不明障碍.png"><br><img src="https://i.loli.net/2021/02/19/Uv7N8bZPsBkCSGp.png" alt="原始点云.png"><br>看来原始点云就有，还是需要处理，可以用滤波，在原始launch中 <code>&lt;arg name=&quot;filters&quot;    value=&quot;decimation&quot;  /&gt;</code></p>
<p>还有这种，好像是雷达运动畸变导致的点云也出错，也可能是点云本身问题<br><img src="https://i.loli.net/2021/06/08/JsIRxZ4qKpjUYBD.gif" alt="大量不应存在的点云"></p>
<p>点云出现在墙另一边<br><img src="https://i.loli.net/2020/12/14/TUoFJ693pj4qDSZ.png" alt=""></p>
<ul>
<li>点云障碍无法自动请除</li>
</ul>
<p>虽然在yaml里设置了<code>observation_persistence</code>，但发现代价地图里的点云障碍会长时间保留，早已超过了配置的值<br><img src="https://i.loli.net/2020/12/18/cg5yEqoRZuPX31H.png" alt="之前的点云障碍不会自动清除"><br>雷达导航没有这个现象，因为雷达扫描的范围很大，马上就清除了。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/12/03/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%A4%A7%E8%BD%AE%E5%BB%93%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%AF%BC%E8%88%AA/(%E4%BA%94)%20%E5%AF%BC%E8%88%AA%E7%9A%84%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/">(五) 导航的其他问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%A4%A7%E8%BD%AE%E5%BB%93%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%AF%BC%E8%88%AA/">大轮廓机器人的导航</a></span><div class="content"><h2 id="尾部撞障碍"><a href="#尾部撞障碍" class="headerlink" title="尾部撞障碍"></a>尾部撞障碍</h2><p><img src="https://i.loli.net/2020/11/30/8D6iYKqEWo3QCGJ.png" alt="尾部潜在的碰撞.png"><br>车的局部路径明显偏离全局路径，其实是目标点太贴近障碍了，如果按全局路径，尾部就会撞。即使按局部路径，走了一点后还是可能撞，但是<code>isFeasible</code>判断的路径点不够多，所以不会报警。  这其实是全局路径规划的不好</p>
<h2 id="禁止后，导致局部路径需要后退时动不了"><a href="#禁止后，导致局部路径需要后退时动不了" class="headerlink" title="禁止后，导致局部路径需要后退时动不了"></a>禁止后，导致局部路径需要后退时动不了</h2><p><img src="https://i.loli.net/2020/11/30/CBGmwdihu7leQVo.png" alt="无法后退1.png"><br><img src="https://i.loli.net/2020/11/30/T6Nf3R4OeYZGU1g.png" alt="无法后退2.png"></p>
<h2 id="路径点杂乱"><a href="#路径点杂乱" class="headerlink" title="路径点杂乱"></a>路径点杂乱</h2><p>这个很难复现<br><img src="https://i.loli.net/2020/11/30/dDxbKJmkIPoaNZQ.png" alt="路径点杂乱.png"><br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=ETORdzBcT0w">video</a></p>
<p><code>HomotopyClassPlanner::plan</code>中的最后部分修改如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TebOptimalPlannerPtr best_teb_ptr = <span class="built_in">selectBestTeb</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(best_teb_ptr-&gt;<span class="built_in">teb</span>().<span class="built_in">sizePoses</span>()&gt;<span class="number">40</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><br>结果发现有时有效，有时到终点附近会move_base的<code>gotPlan</code>一直失败，一直到恢复行为然后Abort，最后停的位置和终点已经很接近，但<code>gotPlan</code>却规划不出来。看来这么修改还是太浅了。</p>
<h2 id="恢复行为时仍在行走"><a href="#恢复行为时仍在行走" class="headerlink" title="恢复行为时仍在行走"></a>恢复行为时仍在行走</h2><p>一个典型的日志:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[10:59:26.877] (): Received move_base goal (x: 1.533, y: 4.569, yaw deg: -177, yaw rad: -3.10)</span><br><span class="line">[10:59:44.914 - WARN] (): Robot <span class="keyword">in</span> controlling, but can<span class="string">&#x27;t get new global plan</span></span><br><span class="line"><span class="string">[10:59:44.991] (): move_base_recovery,state machine is CLEARING, Executing behavior 0 of 2</span></span><br><span class="line"><span class="string">[10:59:47.024 - WARN] (): two valid global plan time gap is too long: 0.032124</span></span><br><span class="line"><span class="string">[10:59:47.057] (): move_base_recovery,state machine is CLEARING, Executing behavior 1 of 2</span></span><br><span class="line"><span class="string">[10:59:49.079 - WARN] (): two valid global plan time gap is too long: 0.018764</span></span><br><span class="line"><span class="string">[10:59:49.091 - ERROR] (): Aborting because a valid plan could not be found. Even after executing all recovery behaviors</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[11:02:20.791] (): Received move_base goal (x: 2.740, y: 4.620, yaw deg: -179, yaw rad: -3.14)</span></span><br><span class="line"><span class="string">[11:02:22.799 - WARN] (): Robot in controlling, but can&#x27;</span>t get new global plan</span><br><span class="line">[11:02:22.833] (): move_base_recovery,state machine is CLEARING, Executing behavior 0 of 2</span><br><span class="line">[11:02:24.970 - WARN] (): Robot <span class="keyword">in</span> controlling, but can<span class="string">&#x27;t get new global plan</span></span><br><span class="line"><span class="string">[11:02:25.015] (): move_base_recovery,state machine is CLEARING, Executing behavior 0 of 2</span></span><br><span class="line"><span class="string">[11:02:28.076 - WARN] (): Robot in controlling, but can&#x27;</span>t get new global plan</span><br><span class="line">[11:02:28.089] (): move_base_recovery,state machine is CLEARING, Executing behavior 0 of 2</span><br><span class="line">[11:02:30.123 - WARN] (): two valid global plan time gap is too long: 0.032326</span><br><span class="line">[11:02:30.156] (): move_base_recovery,state machine is CLEARING, Executing behavior 1 of 2</span><br><span class="line">[11:02:32.671 - WARN] (): Robot <span class="keyword">in</span> controlling, but can<span class="string">&#x27;t get new global plan</span></span><br><span class="line"><span class="string">[11:02:32.694] (): move_base_recovery,state machine is CLEARING, Executing behavior 0 of 2</span></span><br><span class="line"><span class="string">[11:02:34.728 - WARN] (): two valid global plan time gap is too long: 0.028351</span></span><br><span class="line"><span class="string">[11:02:34.762] (): move_base_recovery,state machine is CLEARING, Executing behavior 1 of 2</span></span><br><span class="line"><span class="string">[11:02:37.029 - WARN] (): Robot in controlling, but can&#x27;</span>t get new global plan</span><br><span class="line">[11:02:37.119] (): move_base_recovery,state machine is CLEARING, Executing behavior 0 of 2</span><br><span class="line">[11:02:39.153 - WARN] (): two valid global plan time gap is too long: 0.033766</span><br><span class="line">[11:02:39.186] (): move_base_recovery,state machine is CLEARING, Executing behavior 1 of 2</span><br><span class="line">[11:02:41.187 - WARN] (): two valid global plan time gap is too long: 0.001234</span><br><span class="line">[11:02:41.219 - ERROR] (): Aborting because a valid plan could not be found. Even after executing all recovery behaviors</span><br></pre></td></tr></table></figure></p>
<p>这其实对应<code>makePlan</code>失败的两种情况，在<code>move_base</code>中搜索<code>solution for issue #523</code>可发现，一个的state是<code>CONTROLLING</code>，一个是<code>PLANNING</code>。都添加了<code>publishZeroVelocity</code>禁止小车再移动，但是小车还是会移动，结果撞障碍。 这个现象在仿真中没有出现过。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/12/01/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%A4%A7%E8%BD%AE%E5%BB%93%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%AF%BC%E8%88%AA/(%E4%B8%89)%20%E6%8C%AF%E8%8D%A1%E9%97%AE%E9%A2%98/">(三) 振荡问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%A4%A7%E8%BD%AE%E5%BB%93%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%AF%BC%E8%88%AA/">大轮廓机器人的导航</a></span><div class="content"><p>车到目标附近，有时以很小角速度旋转，一定时间后才到达。如果无法到达，一般是目标的位姿不好，车相当于钻一个狭窄的地方，很容易触发TEB的振荡机制。首先通过试验保证目标点合适，其次适当增加<code>xy_goal_tolerance</code>和<code>yaw_goal_tolerance</code>。由于实际要求的朝向不是0就是π，所以不会有车中心到达位置，但车尾会撞障碍的情况。</p>
<p>修改TEB参数:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 减小后，recently_oscillated 容易是false</span></span><br><span class="line">oscillation_recovery_min_duration: 5</span><br><span class="line">oscillation_v_eps: 0.1</span><br><span class="line">oscillation_omega_eps: 0.1</span><br><span class="line">oscillation_filter_duration: 6</span><br></pre></td></tr></table></figure></p>
<p>在源码中的部分<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> oscillating = failure_detector_.<span class="built_in">isOscillating</span>();</span><br><span class="line"><span class="comment">// 距离上次振荡过了多久，若小于配置值(10秒)，说明最近也振荡了</span></span><br><span class="line"><span class="keyword">bool</span> recently_oscillated = (ros::Time::<span class="built_in">now</span>()-time_last_oscillation_).<span class="built_in">toSec</span>() &lt; </span><br><span class="line">			cfg_.recovery.oscillation_recovery_min_duration;</span><br><span class="line"><span class="comment">// 如果现在是振荡状态</span></span><br><span class="line"><span class="keyword">if</span> (oscillating)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!recently_oscillated)    <span class="comment">//  最近的状态不是振荡</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// save current turning direction</span></span><br><span class="line">        <span class="comment">// 以下其实都是对 last_preferred_rotdir_ 赋值</span></span><br><span class="line">        <span class="keyword">if</span> (robot_vel_.angular.z &gt; <span class="number">0</span>)</span><br><span class="line">            last_preferred_rotdir_ = RotType::left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last_preferred_rotdir_ = RotType::right;</span><br><span class="line">        <span class="built_in">ROS_WARN</span>(<span class="string">&quot;TebLocalPlannerROS: possible oscillation (of the robot </span></span><br><span class="line"><span class="string">            or its local plan) detected. Activating recovery strategy </span></span><br><span class="line"><span class="string">            (prefer current turning direction during optimization) &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    time_last_oscillation_ = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 对 prefer_rotdir_ 赋值，最终影响 AddEdgesPreferRotDir</span></span><br><span class="line">    planner_-&gt;<span class="built_in">setPreferredTurningDir</span>(last_preferred_rotdir_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>减小<code>oscillation_recovery_min_duration</code>后，在源码中会容易更新<code>last_preferred_rotdir_</code>，原来是转过了目标点后接着转，现在是转过了以后会朝反方向调整。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/30/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move_base%20%E5%88%86%E6%9E%90/move_base%E5%8F%82%E6%95%B0/">move_base参数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move-base%E5%88%86%E6%9E%90/">move_base分析</a></span><div class="content"><ul>
<li><p>base_global_planner: 指定全局规划器</p>
</li>
<li><p>base_local_planner: 指定局部规划器</p>
</li>
<li><p>global_costmap/robot_base_frame: 指定局部坐标系，一般是base_link或base_footprint</p>
</li>
<li><p>global_costmap/global_frame: 指定全局坐标系，一般是odom，也可以是map</p>
</li>
<li><p>planner_frequency</p>
</li>
<li><p>controller_frequency</p>
</li>
<li><p>planner_patience: 默认5</p>
</li>
<li><p>controller_patience</p>
</li>
<li><p>max_planning_retries: 默认-1，源码里转成无符号，变成了很大的数，其实就是不考虑</p>
</li>
<li><p>oscillation_timeout</p>
</li>
<li><p>oscillation_distance</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/30/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move_base%20%E5%88%86%E6%9E%90/move_base%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%20planService%E5%92%8CmakePlan%E5%87%BD%E6%95%B0/">move_base分析（五） planService和makePlan函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move-base%E5%88%86%E6%9E%90/">move_base分析</a></span><div class="content"><p>move_base源码没有获取机器人当前位姿的地方，这属于局部路径算法的范畴。只能获得全局目标的位姿</p>
<h2 id="bool-MoveBase-makePlan-const-geometry-msgs-PoseStamped-amp-goal-vector-amp-plan"><a href="#bool-MoveBase-makePlan-const-geometry-msgs-PoseStamped-amp-goal-vector-amp-plan" class="headerlink" title="bool MoveBase::makePlan(const geometry_msgs::PoseStamped&amp; goal, vector&amp; plan)"></a>bool MoveBase::makePlan(const geometry_msgs::PoseStamped&amp; goal, vector<geometry_msgs::PoseStamped>&amp; plan)</h2><p>此函数只在一个地方被调用,就是<code>planThread()</code>线程被唤醒之后开始规划路径<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boost::unique_lock&lt;costmap_2d::Costmap2D::<span class="keyword">mutex_t</span>&gt; <span class="title">lock</span><span class="params">(*(planner_costmap_ros_-&gt;getCostmap()-&gt;getMutex() ))</span></span>;</span><br><span class="line">plan.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">if</span>(planner_costmap_ros_ == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    log.<span class="built_in">error</span>(<span class="string">&quot;Planner costmap ROS is NULL, unable to create global plan&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//get the starting pose of the robot</span></span><br><span class="line">tf::Stamped&lt;tf::Pose&gt; global_pose;</span><br><span class="line"><span class="keyword">if</span>(!planner_costmap_ros_-&gt;<span class="built_in">getRobotPose</span>(global_pose)) &#123;</span><br><span class="line">    log.<span class="built_in">warn</span>(<span class="string">&quot;Unable to get starting pose of robot, unable to create global plan&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">geometry_msgs::PoseStamped start;</span><br><span class="line">tf::<span class="built_in">poseStampedTFToMsg</span>(global_pose, start);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里就是 GlobalPlanner::makePlan 了</span></span><br><span class="line"><span class="keyword">if</span>(!planner_-&gt;<span class="built_in">makePlan</span>(start, goal, plan) || plan.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="built_in">ROS_WARN</span>(<span class="string">&quot;[move_base] Failed to find a  plan to point (%.2f, %.2f)&quot;</span>, </span><br><span class="line">    	goal.pose.position.x, goal.pose.position.y);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><br>代码并不复杂， 最后实际就进入<code>bool GlobalPlanner::makePlan(const geometry_msgs::PoseStamped&amp; start, const geometry_msgs::PoseStamped&amp; goal, double tolerance, std::vector&lt;geometry_msgs::PoseStamped&gt;&amp; plan)</code></p>
<p>这里要参考<a href="">全局路径规划(二) makePlan</a></p>
<p><br></p>
<h2 id="MoveBase-planService-nav-msgs-GetPlan-Request-amp-req-nav-msgs-GetPlan-Response-amp-resp"><a href="#MoveBase-planService-nav-msgs-GetPlan-Request-amp-req-nav-msgs-GetPlan-Response-amp-resp" class="headerlink" title="MoveBase::planService(nav_msgs::GetPlan::Request &amp;req, nav_msgs::GetPlan::Response &amp;resp)"></a>MoveBase::planService(nav_msgs::GetPlan::Request &amp;req, nav_msgs::GetPlan::Response &amp;resp)</h2><p>req参数包含了起点和目标信息，这个服务回调函数的的核心是<code>planner_-&gt;makePlan</code></p>
<ol>
<li><p>move_base server必须在inactive状态，否则不向下执行</p>
</li>
<li><p>判断<code>global planner</code>的costmap是否存在;若req给定机器人初始位姿则使用,否则使用<code>getRobotPose</code>获得机器人所在位置做初始位姿</p>
</li>
<li><p>调用<code>clearCostmapWindows</code>完成对机器人区域的clear， clear_radius由参数设置</p>
</li>
<li><p>调用 <code>if(!planner_-&gt;makePlan(start, req.goal, global_plan) || global_plan.empty())</code> 这是完成plan计算的核心部分。判断这个调用是否成功，如果失败，则在目标区域附近搜索，多次更改req.goal的值，并重新调用makePlan;新的goal如下图:<br><img src="https://i.loli.net/2019/10/28/x4Pzn5QegGfu89s.png" alt=""></p>
</li>
</ol>
<p>各个可能位置之间的水平和竖直间距和<code>req.tolerance</code>正相关</p>
<p>如果还是失败，则此次路径规划无解。如果成功,直接break循环,把原来无法达到的目标点插入<code>global_plan</code>容器的最后,<code>local planner</code>一般会从新的目标点导航到原目标点.</p>
<ol>
<li>将<code>global_plan</code>拷贝到resp.plan</li>
</ol>
<h2 id="MoveBase-clearCostmapWindows-double-size-x-double-size-y"><a href="#MoveBase-clearCostmapWindows-double-size-x-double-size-y" class="headerlink" title="MoveBase::clearCostmapWindows(double size_x, double size_y)"></a>MoveBase::clearCostmapWindows(double size_x, double size_y)</h2><p><code>planService·</code>用到了<code>clearCostmapWindows</code>函数，它只被调用了这一次，过程如下：</p>
<ul>
<li>通过<code>planner_costmap_ros_-&gt;getRobotPose(global_pose);</code>  获取在全局地图的global_pose</li>
<li><p>以这个点为中心，找到以size_x和size_y为边长的矩形的四个顶点</p>
</li>
<li><p><code>调用planner_costmap_ros_-&gt;getCostmap()-&gt;setConvexPolygonCost(clear_poly, costmap_2d::FREE_SPACE);</code>完成对机器人所在区域的clear工作</p>
</li>
<li><p>以上同样的操作在<code>controller_costmap_ros</code>上也操作一遍，这样globa costmap 和local costmap都已经在机器人所在的区域完成clear工作</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/28/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%A4%A7%E8%BD%AE%E5%BB%93%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%AF%BC%E8%88%AA/(%E5%9B%9B)%20%E8%BF%87%E7%8B%AD%E7%AA%84%E9%80%9A%E9%81%93/">(四) 过狭窄通道</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%A4%A7%E8%BD%AE%E5%BB%93%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%AF%BC%E8%88%AA/">大轮廓机器人的导航</a></span><div class="content"><p>一次不好的，耗时长的过窄通道的日志:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Received move_base goal (x: 4.484, y: 8.203, yaw deg: -21, yaw rad: -0.38)</span><br><span class="line">[17:41:22.046 - WARN]:    possible oscillation (of the robot or its <span class="built_in">local</span> plan) detected. Activating recovery strategy (prefer current turning direction during optimization)</span><br><span class="line">[17:41:24.303 - WARN]:  trajectory is not feasible. Resetting planner.. </span><br><span class="line">[17:41:27.391 - WARN]:  trajectory is not feasible. Resetting planner.. </span><br><span class="line">[17:41:31.970 - WARN]:  trajectory is not feasible. Resetting planner.. </span><br><span class="line">[17:41:34.071]:  oscillation recovery disabled/expired</span><br><span class="line">[17:41:34.465]: 有后退的速度, vx: -0.172953 !</span><br><span class="line">[17:41:34.574]: 有后退的速度, vx: -0.195332 !</span><br><span class="line">[17:41:37.918]: 有后退的速度, vx: -0.156334 !</span><br><span class="line">[17:41:38.069]: 有后退的速度, vx: -0.203136 !</span><br><span class="line">[17:41:38.235]: 有后退的速度, vx: -0.179589 !</span><br><span class="line">[17:41:38.452]: 有后退的速度, vx: -0.109154 !</span><br><span class="line">[17:41:52.074 - WARN]:    possible oscillation (of the robot or its <span class="built_in">local</span> plan) detected.</span><br><span class="line">     Activating recovery strategy (prefer current turning direction during optimization)</span><br><span class="line">[17:42:02.706]: 有后退的速度, vx: -0.154251 !</span><br><span class="line">[17:42:02.837]: 有后退的速度, vx: -0.186464 !</span><br><span class="line">[17:42:03.106]: 有后退的速度, vx: -0.167378 !</span><br><span class="line">[17:42:03.179]: 有后退的速度, vx: -0.120713 !</span><br><span class="line">[17:42:03.244]: 有后退的速度, vx: -0.120622 !</span><br><span class="line">[17:42:03.355]: 有后退的速度, vx: -0.132594 !</span><br><span class="line">[17:42:15.661]: TebLocalPlannerROS GOAL Reached !</span><br></pre></td></tr></table></figure></p>
<h2 id="后退速度"><a href="#后退速度" class="headerlink" title="后退速度"></a>后退速度</h2><p>一开始无论怎么调参数也过不了窄通道，后来发现如果手动控制后退，一般能成功导航，于是想到了允许后退速度。从日志就能看出机器人发生了振荡，现实中是机器人不断地小幅前进后退。虽然最后也能通过，但是这样花的时间太长了。</p>
<p>日志发现机器人在进狭窄处之前会执行大量小的后退速度，受参数<code>max_vel_x_backwards</code>影响，多数在0.1以下。于是在后退的同时，使用手动控制后退，不断测试后退的速度，发现提高后，穿过窄通道的时间明显减少，于是<code>max_vel_x_backwards</code>改为0.25</p>
<p><code>saturateVelocity</code>本来屏蔽了后退速度，vx&lt;0时置为0，我几经测试，改成置为<code>-0.15</code></p>
<h2 id="min-obstacle-dist"><a href="#min-obstacle-dist" class="headerlink" title="min_obstacle_dist"></a>min_obstacle_dist</h2><p>开始，狭窄通道总是进不去，后来发现是<code>min_obstacle_dist</code>被外切圆半径更新，造成<code>inflation_dist</code>小于它，影响了<code>AddEdgesObstacles</code>中的添加约束，所以导航失败。<br><img src="https://i.loli.net/2020/10/27/FLcSnbozViCH61j.png" alt="TEB算法，车不向前移动.png"></p>
<p>把<code>min_obstacle_dist</code>提高到机器人外接圆半径以上，可以防止机器人离墙太近，但是对于狭窄通道的情况，反而应该设置的很小，甚至设置为0</p>
<p>修改参数<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">max_vel_x_backwards: 0.25  <span class="comment"># 原来是0.11</span></span><br><span class="line">min_obs_dist: 0.03</span><br><span class="line">inflation_dist: 0.3</span><br><span class="line"></span><br><span class="line">/move_base/max_planning_retries = -1</span><br><span class="line">/move_base/planner_patience = 2</span><br></pre></td></tr></table></figure><br><code>penalty_epsilon</code>参数是对机器人到达速度限制前会产生一定的惩罚，让其提前减速达到缓冲的效果。最好把<code>max_vel_x_backwards</code>减小到<code>penalty_epsilon</code>的值，这两个默认都是0.1，但是如果减小到0.1，就会出现上面的问题了。</p>
<p><br></p>
<p>另外参数<code>feasibility_check_no_poses</code>不能太大，最多5，减小到2也可以。 因为optimizer可能不完全收敛，infeasible的情况可能是因为潜在的小的障碍碰撞，但这在未来可以获得纠正，尤其是有后退速度的情况下，所以设置太大导致的失败不一定有参考价值。</p>
<p>狭窄环境中，调试要慎重。局部规划可能拒绝一个<code>infeasible trajectory</code>，但全局规划会认为全局路径是feasible，结果就是机器人stucked。 如果禁止了后退速度，会经常出现not feasible，尤其是在cluttered环境</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/28/Linux%E5%9F%BA%E7%A1%80/crontab%E5%92%8C%E6%96%87%E4%BB%B6%E6%89%80%E6%9C%89%E8%80%85/">crontab和文件所有者</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux%E5%9F%BA%E7%A1%80/">Linux基础</a></span><div class="content"><p>chown(change owner)命令: 改变文件拥有者，拥有者必须在<code>/etc/passwd</code>中<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R  username folder</span><br><span class="line">sudo chown  username file</span><br></pre></td></tr></table></figure></p>
<p><code>chgrp</code>改变文件所属用户组，要改变成为的用户组名称，必须在<code>/etc/group</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-R] 用户组名称 dirname/filename</span><br></pre></td></tr></table></figure></p>
<h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2><p>Ubuntu上的服务名称是cron不是crond，所以启动crontab的命令应该是： <code>sudo service cron start</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crontab -l   <span class="comment"># 查看当前的crontab任务</span></span><br><span class="line">crontab -e   <span class="comment"># 编辑crontab任务</span></span><br><span class="line">crontab -h  </span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/25/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/%E9%9A%9C%E7%A2%8D%E5%B1%821%20%20%E9%85%8D%E7%BD%AE%E5%92%8C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">障碍层 (一) 配置和常见问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content"><p>障碍层地图通过订阅传感器话题，将传感器输出的障碍物信息存进buffer（剔除过高、过远的点），在本层地图上将观测到的点云标记为障碍物，将传感器到点云的连线上的点标记为<code>FREE_SPACE</code>。最后在bound范围内，将本层地图合并到主地图上。</p>
<h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><p>通用代价地图中的障碍层常常是这样设置的:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">obstacles:</span><br><span class="line"> enabled: <span class="literal">true</span></span><br><span class="line"> obstacle_range: 2.0</span><br><span class="line"> raytrace_range: 5.0</span><br><span class="line"> track_unknown_space: <span class="literal">true</span></span><br><span class="line"> combination_method: 1</span><br><span class="line"> observation_sources: laser_scan_sensor pointcloud2_sensor</span><br><span class="line"> laser_scan_sensor:</span><br><span class="line">    data_type: LaserScan</span><br><span class="line">    topic: /scan</span><br><span class="line">    marking: <span class="literal">true</span></span><br><span class="line">    clearing: <span class="literal">true</span></span><br><span class="line">    max_obstacle_height: 1.0</span><br><span class="line">    min_obstacle_height: -1.0</span><br><span class="line"></span><br><span class="line"> pointcloud2_sensor:</span><br><span class="line">    topic:          /people_cloud</span><br><span class="line">    data_type:      PointCloud2</span><br><span class="line">    sensor_frame:   <span class="string">&quot;/base_link&quot;</span></span><br><span class="line">    obstacle_range: 5.0</span><br><span class="line">    raytrace_range: 5.0</span><br><span class="line">    observation_persistence: 5.0</span><br><span class="line">    marking:        <span class="literal">true</span></span><br><span class="line">    clearing:       <span class="literal">true</span></span><br><span class="line">    min_obstacle_height: 0.0</span><br><span class="line">    max_obstacle_height: 2.0</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>observation_persistence: 2.0.  如果设置为0，代价地图只考虑最近的观测数据</p>
</li>
<li><p>max_obstacle_height:  默认2，单位米。插入代价地图的障碍物的最大高度，应当比机器人高度稍微高一点，应该是用于有机械臂的情况。设置为大于全局<code>max_obstacle_height</code>参数的值将会失效，设置为小于全局<code>max_obstacle_height</code>的值将过滤掉传感器上大于该高度以的点。</p>
</li>
<li><p>min_obstacle_height: 传感器读数的最小高度（以米为单位）视为有效。通常设置为地面高度。</p>
</li>
<li><p>obstacle_range: 设置机器人检测障碍物的最大范围，意思是说超过该范围的障碍物，并不进行检测，只有靠近到该范围内才把该障碍物当作影响路径规划和移动的障碍物</p>
</li>
<li><p>raytrace_range: 在机器人移动过程中，实时清除代价地图上的障碍物的最大范围，更新可自由移动的空间数据。假如设置该值为3米，那么就意味着在3米内的障碍物，本来开始时是有的，但是本次检测却没有了，那么就需要在代价地图上来更新，将旧障碍物的空间标记为可以自由移动的空间</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/05/13/jehHtE1IFTVZmRB.png" alt="障碍层加载过程.png"><br>障碍层所用的参数：<a target="_blank" rel="noopener" href="http://wiki.ros.org/costmap_2d/hydro/obstacles">obstacles params</a></p>
<h2 id="局部代价地图中无法清除不在视野的障碍"><a href="#局部代价地图中无法清除不在视野的障碍" class="headerlink" title="局部代价地图中无法清除不在视野的障碍"></a>局部代价地图中无法清除不在视野的障碍</h2><p>costmap raytraces to clear out obstacles. 障碍物要想从地图上清除，它所占据的空间必须被新的观测看到。但是参数<code>observation_persistence</code>常常无效。</p>
<p><code>last_updated_</code> is updated on every new cloud that needs to be added to the buffer. <code>purgeStaleObservations</code>函数 checks the cloud’s time stamp with <code>last_updated_</code>. When we stop publishing a point cloud <code>last_updated_</code> will never be updated. Hence the observations will not time-out and remain in the <code>observation_list_</code>.  This may result in the following warning, when the robot drives away from the clouds in <code>observation_list_</code>:   <font size =4 color = orange> Sensor origin at (x, y) is out of map bounds. The costmap cannot raytrace for it  </font></p>
 <font color = orange size=4> 只适用于ROS2的navigation</font>

<p>将文件<code>observation_buffer.cpp</code>中的函数<code>purgeStaleObservations</code>中的<code>last_updated_</code>改为<code>nh_-&gt;now()</code>，会影响共享库<code>liblayers.so</code> 和 <code>libcostmap_2d.so</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nav2_util::<span class="function">LifecycleNode::SharedPtr  nh</span></span><br><span class="line"><span class="function"><span class="title">last_updated_</span><span class="params">(nh-&gt;now())</span></span></span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/25/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move_base%20%E5%88%86%E6%9E%90/move_base%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%80%BB%E7%BB%93/">move_base启动失败的总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move-base%E5%88%86%E6%9E%90/">move_base分析</a></span><div class="content"><p>启动<code>move_base</code>失败的原因一般是某一层加载失败</p>
<ol>
<li><p>从RCS下发narrow way layer文件，导致yaml文件不规范，使move_base启动失败</p>
</li>
<li><p>one way layer更新</p>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/24/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%A4%A7%E8%BD%AE%E5%BB%93%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%AF%BC%E8%88%AA/(%E4%BA%8C)%20%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%9C%A8%E8%B5%B7%E7%82%B9%E6%88%96%E7%BB%88%E7%82%B9%E8%BD%AC%E5%90%91%E8%80%8C%E5%AF%BC%E8%88%AA%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/">(二) 机器人在起点或终点转向而导航失败的问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%A4%A7%E8%BD%AE%E5%BB%93%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%AF%BC%E8%88%AA/">大轮廓机器人的导航</a></span><div class="content"><p>机器人的外接圆半径为0.65m，环境中的通道为1.3m，也就是说机器人不可能不撞障碍而转180°，这是TEB和move_base源码无法解决的</p>
<p>调度端发出的目标点的朝向不是0就是π。</p>
<h2 id="起点转向问题"><a href="#起点转向问题" class="headerlink" title="起点转向问题"></a>起点转向问题</h2><p>黑色是全局路径，这样规划是必然的。在A处旋转就会撞，显然需要改变的是全局路径。<br><img src="https://i.loli.net/2021/06/02/hIRE7Hsr9tXuApj.png" alt="起点转向的情况"><br>规划时如下，出现一堆杂乱的路径点，这显然不是我们希望的。结果机器人会在自己附近乱动，现实中<font color = blue size=4> 机器人不应该有”奇怪”的行为 </font><br><img src="https://i.loli.net/2020/12/06/LdhcVxnbPUmMyk7.png" alt="实际的规划情况"></p>
<p><font color = blue size=4>除了窄通道的情况 (此时没有了机器人对开问题)，我们尽量不要让机器人出现后退。</font>所以大车在其他环境都应该一直向前开。</p>
<p>改变全局路径，同时要保证不能倒退，容易想到单通道的使用。但是单通道的参数在yaml里先规定好了，所以问题就变成了动态改变单通道的朝向，机器人朝哪边，单通道的方向就改成哪边。<strong>每台车的单通道是属于自己的，A车改了单通道的朝向并不影响B车的导航。</strong> 当然这里还有两台大车对开的问题，实际中在调度端尽量避免这种情况，而且大车比较少，如果两台车绕远避开也可以接受。</p>
<p>改变单通道朝向放到<code>MoveBase::makePlan</code>，这里是move_base的全局路径入口，最后进入global planner的<code>makePlan</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">one_way_layer = <span class="keyword">new</span> <span class="built_in">OneWayDrivingLayer</span>();</span><br><span class="line">ros::NodeHandle m_nh;   <span class="comment">// NodeHandle 可以放心增加，源码里也不止一个</span></span><br><span class="line">one_way_layer-&gt;<span class="built_in">loadAreaFromYaml</span>(&amp;m_nh ,<span class="string">&quot;/move_base/global_costmap/one_way_layer/one_way_layer&quot;</span>);</span><br><span class="line"><span class="comment">// 获取当前机器人所在的单通道的参数</span></span><br><span class="line">std::vector&lt;geometry_msgs::Point&gt; polygon = one_way_layer-&gt;<span class="built_in">FindOneWayArea</span>(start);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(polygon.<span class="built_in">size</span>()&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  costmap_2d::Costmap2D *costmap = planner_costmap_ros_-&gt;<span class="built_in">getCostmap</span>();</span><br><span class="line">  <span class="comment">// 改变朝向， yaw 是当前的机器人朝向</span></span><br><span class="line">  one_way_layer-&gt;<span class="built_in">setCellInfo</span>(*costmap, polygon, yaw, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">  	costmap-&gt;<span class="built_in">getSizeInCellsX</span>(), costmap-&gt;<span class="built_in">getSizeInCellsY</span>());</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;机器人所在的单通道:&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">ROS_INFO_ONCE</span>(<span class="string">&quot;机器人不在任何单通道&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;polygon.<span class="built_in">size</span>();i++)</span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;x: %.2f, y: %.2f&quot;</span>, polygon.<span class="built_in">at</span>(i).x,  polygon.<span class="built_in">at</span>(i).y );</span><br></pre></td></tr></table></figure><br>这样A到B1的路径就没问题了，绕远是可接受的。但是到B2的问题没解决，还是要转向</p>
<h2 id="终点转向问题"><a href="#终点转向问题" class="headerlink" title="终点转向问题"></a>终点转向问题</h2><p>终点转向的情况如下，A到B1没什么问题，但到B2时就会有旋转碰撞的情况。<br><img src="https://i.loli.net/2021/06/02/1MypqL3KUJkm5w9.png" alt="终点转向的情况"><br>因为终点的朝向不是0就是π，车在通道内行走时的朝向也在0或π左右，所以只需要在车的x y坐标到达目标点的tolerance时，判断目标点的朝向和车的朝向相差 0或π (包含angle tolerance)就认为到达了目标。这样要改的就是TEB代码了，也就是更低一层的代码，具体是改<code>if(position_reanched_)</code>的部分</p>
<p>比如希望位置到达，朝向未到达时，如果和目标的朝向差在 <code>3~3.14</code>或<code>-3.14~-3</code>或<code>-0.14~0.14</code>，就按导航成功。</p>
<p>但是有时日志是这样的:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">angle diff: 2.972916</span><br><span class="line">angle diff: 2.972916</span><br><span class="line">angle diff: 2.872829</span><br><span class="line"><span class="comment"># 一段时间的调整， 没有向差值为π的方向调整</span></span><br><span class="line">angle diff: 0.058993</span><br><span class="line">angle diff: 0.047184</span><br></pre></td></tr></table></figure><br>到达位置时，朝向不在希望的范围内，结果TEB会让小车反方向调整朝向，这样又得转180°。 所以总结出调整的机制如下：<br><img src="https://i.loli.net/2020/12/06/HIlFsUO7R8AiBuL.png" alt="调整机制.png"></p>
<p>在机器人到达终点瞬间，机器人会想转180°，此时rviz可能会出现一堆杂乱的路径点，然后报警<code>trajectory is not feasible. Resetting planner..</code>，虽然机器人很快即停止，但最好还是防止这些杂乱的点规划. 到达位置后，无论角度差多少都执行<code>clearPlanner()</code>，这样最后还是显示一些，但明显减少，这是<code>transformed_plan</code>造成的<br><img src="https://i.loli.net/2021/06/02/HkDlY2cpNwQ6V1g.png" alt="终点避免了转向"><br>如果本次导航失败或路径不好，也会出现一大堆TebPose缠绕，在下一次导航时，它们可能还在，要消除就需要<code>clearPlanner();</code></p>
<p><br></p>
<p>最后，如果不在拣货点停靠，也就是不在通道内，也是有目标点的，此时的朝向是±90°。这样的区域不会设置单通道，所以不会出现机器人到目标点的朝向差了180°的情况。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/8/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/45/">45</a><a class="extend next" rel="next" href="/page/10/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/07/13/RCLw5Bx8aFPN74b.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>