<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">653</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">50</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/24/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E6%9C%80%E5%90%8E%E9%98%B6%E6%AE%B5%20RunFinalOptimization/">最后阶段 RunFinalOptimization</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>现在返回到最初的<code>node_main.cc</code>中的<code>Run</code>函数，还有一句<code>node.RunFinalOptimization();</code>，所有轨迹结束时，再执行一次全局优化。  其实就是<code>MapBuilderBridge::RunFinalOptimization</code> —— <code>PoseGraph2D::RunFinalOptimization</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::RunFinalOptimization</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">  	<span class="comment">// 参数 max_num_final_iterations 默认 200</span></span><br><span class="line">    <span class="comment">// 优化标志</span></span><br><span class="line">    <span class="built_in">AddWorkItem</span>([<span class="keyword">this</span>]() <span class="built_in">LOCKS_EXCLUDED</span>(mutex_) &#123;</span><br><span class="line">      absl::MutexLock <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">      optimization_problem_-&gt;<span class="built_in">SetMaxNumIterations</span>(</span><br><span class="line">          options_.<span class="built_in">max_num_final_iterations</span>());</span><br><span class="line">      <span class="keyword">return</span> WorkItem::Result::kRunOptimization;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 参数 max_num_iterations， 默认 50</span></span><br><span class="line">    <span class="comment">// 不优化标志</span></span><br><span class="line">    <span class="built_in">AddWorkItem</span>([<span class="keyword">this</span>]() <span class="built_in">LOCKS_EXCLUDED</span>(mutex_) &#123;</span><br><span class="line">      absl::MutexLock <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">      optimization_problem_-&gt;<span class="built_in">SetMaxNumIterations</span>(</span><br><span class="line">          options_.<span class="built_in">optimization_problem_options</span>()</span><br><span class="line">              .<span class="built_in">ceres_solver_options</span>()</span><br><span class="line">              .<span class="built_in">max_num_iterations</span>());</span><br><span class="line">      <span class="keyword">return</span> WorkItem::Result::kDoNotRunOptimization;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 另一个调用地方在 PoseGraph2D 析构</span></span><br><span class="line">  <span class="built_in">WaitForAllComputations</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在建图结束之后会运行一个新的全局优化，不要求实时性，迭代次数多<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::WaitForAllComputations</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num_trajectory_nodes;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    num_trajectory_nodes = data_.num_trajectory_nodes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> num_finished_nodes_at_start =</span><br><span class="line">      constraint_builder_.<span class="built_in">GetNumFinishedNodes</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> report_progress = [<span class="keyword">this</span>, num_trajectory_nodes,</span><br><span class="line">                          num_finished_nodes_at_start]() &#123;</span><br><span class="line">    <span class="comment">// Log progress on nodes only when we are actually processing nodes.</span></span><br><span class="line">    <span class="keyword">if</span> (num_trajectory_nodes != num_finished_nodes_at_start) &#123;</span><br><span class="line">      std::ostringstream progress_info;</span><br><span class="line">      progress_info &lt;&lt; <span class="string">&quot;Optimizing: &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">1</span>)</span><br><span class="line">                    &lt;&lt; <span class="number">100.</span> *</span><br><span class="line">                           (constraint_builder_.<span class="built_in">GetNumFinishedNodes</span>() -</span><br><span class="line">                            num_finished_nodes_at_start) /</span><br><span class="line">                           (num_trajectory_nodes - num_finished_nodes_at_start)</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;%...&quot;</span>;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;\r\x1b[K&quot;</span> &lt;&lt; progress_info.<span class="built_in">str</span>() &lt;&lt; std::flush;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><code>num_finished_nodes_at_start</code>表示此时已经优化的节点数，假设为 10</p>
</li>
<li><p><code>GetNumFinishedNodes</code>返回当前已经优化的节点数，假设为 11，也就是这个函数开始后，优化了1个节点</p>
</li>
<li><p><code>num_trajectory_nodes</code>，轨迹的总节点数</p>
</li>
</ul>
<p><code>progress_info</code> 输出的是  <script type="math/tex">\frac{11 -10} {100 - 10} \times 100</script></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// First wait for the work queue to drain so that it&#x27;s safe to schedule</span></span><br><span class="line">  <span class="comment">// a WhenDone() callback.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> predicate = [<span class="keyword">this</span>]()</span><br><span class="line">                               <span class="built_in">EXCLUSIVE_LOCKS_REQUIRED</span>(work_queue_mutex_) &#123;</span><br><span class="line">                                 <span class="keyword">return</span> work_queue_ == <span class="literal">nullptr</span>;</span><br><span class="line">                               &#125;;</span><br><span class="line">    <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;work_queue_mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!work_queue_mutex_.<span class="built_in">AwaitWithTimeout</span>(</span><br><span class="line">        absl::<span class="built_in">Condition</span>(&amp;predicate),</span><br><span class="line">        absl::<span class="built_in">FromChrono</span>(common::<span class="built_in">FromSeconds</span>(<span class="number">1.</span>)))) &#123;</span><br><span class="line">      <span class="built_in">report_progress</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now wait for any pending constraint computations to finish.</span></span><br><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">bool</span> notification = <span class="literal">false</span>;</span><br><span class="line">  constraint_builder_.<span class="built_in">WhenDone</span>(</span><br><span class="line">      [<span class="keyword">this</span>,</span><br><span class="line">       &amp;notification](<span class="keyword">const</span> constraints::ConstraintBuilder2D::Result&amp; result)</span><br><span class="line">          <span class="built_in">LOCKS_EXCLUDED</span>(mutex_) &#123;</span><br><span class="line">            absl::MutexLock <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">            data_.constraints.<span class="built_in">insert</span>(data_.constraints.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>(),</span><br><span class="line">                                     result.<span class="built_in">end</span>());</span><br><span class="line">            notification = <span class="literal">true</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> predicate = [&amp;notification]() <span class="built_in">EXCLUSIVE_LOCKS_REQUIRED</span>(mutex_) &#123;</span><br><span class="line">    <span class="keyword">return</span> notification;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">while</span> (!mutex_.<span class="built_in">AwaitWithTimeout</span>(absl::<span class="built_in">Condition</span>(&amp;predicate),</span><br><span class="line">                                  absl::<span class="built_in">FromChrono</span>(common::<span class="built_in">FromSeconds</span>(<span class="number">1.</span>)))) &#123;</span><br><span class="line">    <span class="built_in">report_progress</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CHECK_EQ</span>(constraint_builder_.<span class="built_in">GetNumFinishedNodes</span>(), num_trajectory_nodes);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;\r\x1b[KOptimizing: Done.     &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是把ceres的迭代次数设置为200，其他部分其实不用太深入研究了。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/24/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8E%E7%AB%AF%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%203%20HandleWorkQueue%E5%92%8C%E4%BC%98%E5%8C%96/">后端的线程池 3 HandleWorkQueue和优化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>优化的具体实现在优化器<code>optimization_problem_</code>。将优化的结果采用回调的方式，返回到result中。<br>后端将数据加入到 <code>optimization_problem_</code> 的对应传感器队列中，并按时间排列。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::HandleWorkQueue</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> constraints::ConstraintBuilder2D::Result&amp;  result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  &#123;   <span class="comment">// 将新的约束添加到全局约束队列中</span></span><br><span class="line">    <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    data_.constraints.<span class="built_in">insert</span>(data_.constraints.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>(),</span><br><span class="line">                             result.<span class="built_in">end</span>() );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ceres 在这里</span></span><br><span class="line">  <span class="built_in">RunOptimization</span>();</span><br><span class="line">   			<span class="comment">// 以下是 省略 的内容</span></span><br><span class="line">  <span class="comment">//如果设置了全局优化回调函数，则进行调用</span></span><br><span class="line">  <span class="comment">//根据约束结果，更新轨迹间的链接关系</span></span><br><span class="line">  <span class="comment">// 优化完成后，累计节点清零</span></span><br><span class="line">  <span class="comment">// 计算相同轨迹的 inter_constraints_same_trajectory  </span></span><br><span class="line">  <span class="comment">// 计算不同轨迹的 inter_constraints_different_trajectory</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 优化结束后，重新开启任务队列，即继续执行</span></span><br><span class="line">  <span class="comment">// work_queue_里的 work_item</span></span><br><span class="line">  <span class="built_in">DrainWorkQueue</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="RunOptimization"><a href="#RunOptimization" class="headerlink" title="RunOptimization"></a>RunOptimization</h2><p>优化的实际就是成员变量<code>node_data_</code> 和 <code>submap_data_</code>，也就是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeSpec2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  common::Time time;</span><br><span class="line">  transform::Rigid2d  local_pose_2d;</span><br><span class="line">  transform::Rigid2d  global_pose_2d;</span><br><span class="line">  Eigen::Quaterniond  gravity_alignment;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubmapSpec2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  transform::Rigid2d  global_pose;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::RunOptimization</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (optimization_problem_-&gt;<span class="built_in">submap_data</span>().<span class="built_in">empty</span>() )</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// std::unique_ptr&lt;optimization::OptimizationProblem2D&gt; optimization_problem_;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// No other thread is accessing the optimization_problem_,</span></span><br><span class="line">  <span class="comment">// data_.constraints, data_.frozen_trajectories and data_.landmark_nodes</span></span><br><span class="line">  <span class="comment">// when executing Solve. </span></span><br><span class="line">  <span class="comment">// 调用优化，Ceres在这里面，由于耗时间，故没加锁，防止阻塞其他线程</span></span><br><span class="line">  optimization_problem_-&gt;<span class="built_in">Solve</span>(data_.constraints, </span><br><span class="line">    <span class="built_in">GetTrajectoryStates</span>(),  data_.landmark_nodes);</span><br></pre></td></tr></table></figure>
<p>将所有内部约束和外部约束合并在一起执行<code>Solve</code><br>遍历所有submap，建立参数块；遍历所有node，建立参数块。<br>根据约束，添加残差函数；<br>处理里程计问题，添加可能的残差；<br>求解返回结果;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">   <span class="comment">// 优化后所有的submap和node数据</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; submap_data = optimization_problem_-&gt;<span class="built_in">submap_data</span>();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; node_data = optimization_problem_-&gt;<span class="built_in">node_data</span>();</span><br><span class="line">  <span class="comment">/*  遍历所有优化后的轨迹的所有节点位姿  */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> trajectory_id : node_data.<span class="built_in">trajectory_ids</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; node : node_data.<span class="built_in">trajectory</span>(trajectory_id) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span>&amp; mutable_trajectory_node = data_.trajectory_nodes.<span class="built_in">at</span>(node.id);</span><br><span class="line">      <span class="comment">// 更新所有节点的 全局位姿</span></span><br><span class="line">      mutable_trajectory_node.global_pose =</span><br><span class="line">          transform::<span class="built_in">Embed3D</span>(node.data.global_pose_2d) *</span><br><span class="line">          transform::Rigid3d::<span class="built_in">Rotation</span>(</span><br><span class="line">              mutable_trajectory_node.constant_data-&gt;gravity_alignment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extrapolate all point cloud poses that were not included in the</span></span><br><span class="line">    <span class="comment">// &#x27;optimization_problem_&#x27; yet. 注意是已经加入tarjectory但是还没有进行优化的新Node</span></span><br><span class="line">    <span class="comment">// 由于使用采样器建立约束，有的node没有建立约束，其pose就不会被优化</span></span><br><span class="line">    <span class="comment">// 因此，要通过已经优化的位姿转换关系来修正所有的node</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子图的local到global的新的转移矩阵</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> local_to_new_global =</span><br><span class="line">        <span class="built_in">ComputeLocalToGlobalTransform</span>(submap_data, trajectory_id);</span><br><span class="line">        <span class="comment">// 旧的转移矩阵</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> local_to_old_global = <span class="built_in">ComputeLocalToGlobalTransform</span>(</span><br><span class="line">        data_.global_submap_poses_2d, trajectory_id);</span><br><span class="line">    <span class="keyword">const</span> transform::Rigid3d old_global_to_new_global =</span><br><span class="line">        local_to_new_global * local_to_old_global.<span class="built_in">inverse</span>();</span><br><span class="line">      <span class="comment">// 上次最后一个优化的节点</span></span><br><span class="line">    <span class="keyword">const</span> NodeId last_optimized_node_id =</span><br><span class="line">        std::<span class="built_in">prev</span>(node_data.<span class="built_in">EndOfTrajectory</span>(trajectory_id))-&gt;id;</span><br><span class="line">    <span class="keyword">auto</span> node_it =</span><br><span class="line">        std::<span class="built_in">next</span>(data_.trajectory_nodes.<span class="built_in">find</span>(last_optimized_node_id));</span><br><span class="line">     <span class="comment">// 后续未优化的节点的全局pose进行转移</span></span><br><span class="line">    <span class="keyword">for</span> (; node_it != data_.trajectory_nodes.<span class="built_in">EndOfTrajectory</span>(trajectory_id);</span><br><span class="line">         ++node_it)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// TrajectoryNode类型， 指针</span></span><br><span class="line">      <span class="keyword">auto</span>&amp; mutable_trajectory_node = data_.trajectory_nodes.<span class="built_in">at</span>(node_it-&gt;id);</span><br><span class="line">      修正 global_pose</span><br><span class="line">      mutable_trajectory_node.global_pose =</span><br><span class="line">          old_global_to_new_global * mutable_trajectory_node.global_pose;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新所有路标位姿</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; landmark : optimization_problem_-&gt;<span class="built_in">landmark_data</span>()) &#123;</span><br><span class="line">    data_.landmark_nodes[landmark.first].global_landmark_pose = landmark.second;</span><br><span class="line">  &#125;</span><br><span class="line">  data_.global_submap_poses_2d = submap_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化并非是实时，是在后台进行运行的，并且需要一定的时间。因此当完成优化时，前端输出结果已经对整个位姿图个数进行了增加。后面新加入的节点并未优化，所以返回优化的结果没有最新加入轨迹节点对应的结果。因此采用优化后结果中最后一个轨迹节点的位姿的转移矩阵，作为未参与优化轨迹节点的转移矩阵进行更新。</p>
<p>其中 <script type="math/tex">X</script> 为参与优化的节点，优化前位姿为 <script type="math/tex">X_{old}</script>，优化后的位姿为 <script type="math/tex">X_{new}</script>。而 <script type="math/tex">Y</script> 则为未参与优化的节点。</p>
<script type="math/tex; mode=display">T = X_{old}^{-1} * X_{new}</script><script type="math/tex; mode=display">Y_{new} = T * Y_{old}</script></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/21/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8E%E7%AB%AF%205%20%E8%AE%A1%E7%AE%97%E7%BA%A6%E6%9D%9F/">后端 5 计算约束</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>我的理解是，求inter约束也是一个 scan to map 的过程，找到和点云最相似的不同时间的子图，也就是找回环。其实是和<code>lidar_localization</code>的后端用NDT找关键帧的匹配是类似的，但是cartographer是点云和栅格地图匹配，不像点云匹配那样直观，分支定界的score就像NDT匹配的score，不过前者越大越好，后者越小越好。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstraintBuilder2D::ComputeConstraint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> SubmapId&amp; submap_id,  <span class="keyword">const</span> Submap2D* <span class="keyword">const</span> submap,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> NodeId&amp; node_id,  <span class="keyword">bool</span> match_full_submap,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> TrajectoryNode::Data* <span class="keyword">const</span>  constant_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> transform::Rigid2d&amp;  initial_relative_pose,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> SubmapScanMatcher&amp;   submap_scan_matcher,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;ConstraintBuilder2D::Constraint&gt;* constraint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(submap_scan_matcher.fast_correlative_scan_matcher);</span><br><span class="line">  <span class="comment">/*  node在local坐标系的位姿 = 子图在local坐标系中的位姿 * node在子图的位姿*/</span></span><br><span class="line">  <span class="keyword">const</span> transform::Rigid2d  initial_pose =</span><br><span class="line">      <span class="built_in">ComputeSubmapPose</span>(*submap) * initial_relative_pose;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">float</span> score = <span class="number">0.</span>;</span><br><span class="line">  transform::Rigid2d pose_estimate = transform::Rigid2d::<span class="built_in">Identity</span>();</span><br></pre></td></tr></table></figure>
<p>整个函数是为了计算<code>constraint_transform</code>(节点 j 和子图 i的关系) ，需要的参数有：</p>
<ul>
<li>节点 j 的<code>filtered_gravity_aligned_point_cloud</code></li>
<li>分支定界的初值 <code>initial_pose</code> (节点 j 在local map坐标系的坐标)</li>
<li><code>Match()</code> 的结果 <code>pose_estimate</code> (节点 j 在local map坐标系的坐标).</li>
<li><code>ComputeSubmapPose()</code>函数 (local map坐标系转到子图 i 坐标系)</li>
</ul>
<p>计算<code>pose_estimate</code>的三步:</p>
<ol>
<li>使用 fast correlative scan matcher 做 Fast estimate</li>
<li>Prune if the score is too low.</li>
<li>ceres Refine</li>
</ol>
<h2 id="匹配所有子图-或-局部子图"><a href="#匹配所有子图-或-局部子图" class="headerlink" title="匹配所有子图 或 局部子图"></a>匹配所有子图 或 局部子图</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配所有子图，对应 MaybeAddGlobalConstraint</span></span><br><span class="line"><span class="keyword">if</span> (match_full_submap)</span><br><span class="line">&#123;</span><br><span class="line">  kGlobalConstraintsSearchedMetric-&gt;<span class="built_in">Increment</span>();</span><br><span class="line">  <span class="keyword">if</span>( submap_scan_matcher.fast_correlative_scan_matcher-&gt;<span class="built_in">MatchFullSubmap</span>(</span><br><span class="line">          constant_data-&gt;filtered_gravity_aligned_point_cloud,</span><br><span class="line">          <span class="comment">// 参数为 global_localization_min_score</span></span><br><span class="line">          options_.<span class="built_in">global_localization_min_score</span>(), </span><br><span class="line">          &amp;score,  &amp;pose_estimate)  )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">CHECK_GT</span>(score, options_.<span class="built_in">global_localization_min_score</span>());</span><br><span class="line">    <span class="built_in">CHECK_GE</span>(node_id.trajectory_id, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">CHECK_GE</span>(submap_id.trajectory_id, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 最后记录下全局约束的次数和统计置信度</span></span><br><span class="line">    kGlobalConstraintsFoundMetric-&gt;<span class="built_in">Increment</span>();</span><br><span class="line">    kGlobalConstraintScoresMetric-&gt;<span class="built_in">Observe</span>(score);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匹配局部子图</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  kConstraintsSearchedMetric-&gt;<span class="built_in">Increment</span>();</span><br><span class="line">  <span class="keyword">if</span> (submap_scan_matcher.fast_correlative_scan_matcher-&gt;<span class="built_in">Match</span>(</span><br><span class="line">          initial_pose, constant_data-&gt;filtered_gravity_aligned_point_cloud,</span><br><span class="line">          <span class="comment">// 参数为 min_score</span></span><br><span class="line">          options_.<span class="built_in">min_score</span>(), </span><br><span class="line">          &amp;score, &amp;pose_estimate)  )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">CHECK_GT</span>(score, options_.<span class="built_in">min_score</span>());</span><br><span class="line">    kConstraintsFoundMetric-&gt;<span class="built_in">Increment</span>();</span><br><span class="line">    kConstraintScoresMetric-&gt;<span class="built_in">Observe</span>(score);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  score_histogram_.<span class="built_in">Add</span>(score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分枝定界求出的位姿被称为 <strong>初始位姿 3</strong>，这个初始位姿3及其携带的点云作为输入，用于ceres与此子图进行优化匹配</p>
<p>在建立全局约束的时候，直接在一个超大的范围内进行分枝定界搜索，并不需要计算一个特殊的初始位姿2，而直接把初始位姿设置为地图limits的中心点，可以理解为map的中心点。 而且打分的参数也不同了。</p>
<p>全局约束的搜索窗口范围： <code>[1e6 * limits_.resolution(), M_PI]</code>，角度其实是±180°</p>
<h2 id="ceres-refine"><a href="#ceres-refine" class="headerlink" title="ceres refine"></a>ceres refine</h2><p>ceres优化匹配，得到更加准确的优化位置<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use the CSM estimate as both the initial and previous pose. </span></span><br><span class="line"><span class="comment">// This has the effect that, in the absence of better information, </span></span><br><span class="line"><span class="comment">// we prefer the original  CSM estimate.</span></span><br><span class="line">ceres::Solver::Summary  unused_summary;</span><br><span class="line"><span class="comment">// ceres更新pose_estimate，获得节点在local map中的最优位姿</span></span><br><span class="line">ceres_scan_matcher_.<span class="built_in">Match</span>(pose_estimate.<span class="built_in">translation</span>(), pose_estimate,</span><br><span class="line">                 constant_data-&gt;filtered_gravity_aligned_point_cloud,</span><br><span class="line">                *submap_scan_matcher.grid,  &amp;pose_estimate,</span><br><span class="line">                &amp;unused_summary);</span><br><span class="line"><span class="comment">// 计算得到node相对子图的位姿</span></span><br><span class="line"><span class="keyword">const</span> transform::Rigid2d constraint_transform = </span><br><span class="line">    <span class="built_in">ComputeSubmapPose</span>(*submap).<span class="built_in">inverse</span>() * pose_estimate;</span><br><span class="line">constraint-&gt;<span class="built_in">reset</span>(<span class="keyword">new</span> Constraint&#123;submap_id,</span><br><span class="line">       node_id,</span><br><span class="line">       &#123; transform::<span class="built_in">Embed3D</span>(constraint_transform),</span><br><span class="line">        options_.<span class="built_in">loop_closure_translation_weight</span>(),</span><br><span class="line">        options_.<span class="built_in">loop_closure_rotation_weight</span>() &#125;,</span><br><span class="line">       Constraint::INTER_SUBMAP&#125; );</span><br></pre></td></tr></table></figure><br>对于局部约束，<code>constraint_transform</code>并不是回环边，其实就是子图和节点的普通约束。 全局约束才构造回环边</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options_.<span class="built_in">log_matches</span>() )</span><br><span class="line">&#123;</span><br><span class="line">    std::ostringstream info;</span><br><span class="line">    info &lt;&lt; <span class="string">&quot;Node &quot;</span> &lt;&lt; node_id &lt;&lt; <span class="string">&quot; with &quot;</span></span><br><span class="line">         &lt;&lt; constant_data-&gt;filtered_gravity_aligned_point_cloud.<span class="built_in">size</span>()</span><br><span class="line">         &lt;&lt; <span class="string">&quot; points on submap &quot;</span> &lt;&lt; submap_id &lt;&lt; std::fixed;</span><br><span class="line">    <span class="keyword">if</span> (match_full_submap)</span><br><span class="line">         info &lt;&lt; <span class="string">&quot; matches&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">const</span> transform::Rigid2d difference =</span><br><span class="line">          initial_pose.<span class="built_in">inverse</span>() * pose_estimate;</span><br><span class="line">      info &lt;&lt; <span class="string">&quot; differs by translation &quot;</span> &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">2</span>)</span><br><span class="line">           &lt;&lt; difference.<span class="built_in">translation</span>().<span class="built_in">norm</span>() &lt;&lt; <span class="string">&quot; rotation &quot;</span></span><br><span class="line">           &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; std::<span class="built_in">abs</span>(difference.<span class="built_in">normalized_angle</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    info &lt;&lt; <span class="string">&quot; with score &quot;</span> &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; <span class="number">100.</span> * score &lt;&lt; <span class="string">&quot;%.&quot;</span>;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; info.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/20/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/%E6%80%9D%E8%80%83%E7%9A%84%E9%97%AE%E9%A2%98/">思考的问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/">原理和配置</a></span><div class="content"><ul>
<li><p>为何子图插入scan结束时CPU升高</p>
</li>
<li><p>为什么要用线程池</p>
</li>
<li><p>To be sure there is a recent loop closure constraint, you can query <code>PoseGraphInterface::constraints()</code>, loop over all constraints and check if there is a recent one of type INTER that spans some time.</p>
</li>
<li><p>A simpler solution is to subscribe to the global slam callback <code>GlobalSlamOptimizationCallback</code> by setting <code>PoseGraphInterface::SetGlobalSlamOptimizationCallback</code>. This will call you back after Cartographer has searched for loop closures. It does not tell you if loop closures were found, it mostly tells you if the background loop closure search is keeping up or falls behind.</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/05/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/gmapping%E5%92%8CAMCL%E7%9A%84%E5%8C%BA%E5%88%AB/">gmapping和AMCL的区别</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/">amcl和粒子滤波</a></span><div class="content"><h2 id="粒子"><a href="#粒子" class="headerlink" title="粒子"></a>粒子</h2><p>AMCL的粒子只包括位姿和权重，需要大量的粒子才能较好描述机器人位姿。gmapping的粒子包括轨迹、地图、权重，粒子过多会占用很大的内存。</p>
<p>AMCL的粒子在初始化时，各粒子的位姿是不同的，是均值参数加高斯噪声； gmapping粒子初始化时，粒子的位姿都是相同的。 所以说AMCL更符合撒粒子的逻辑。</p>
<p>AMCL的粒子数不是固定的，有最小和最大粒子数。在定位过程中，KLD采样会动态减少粒子数；gmapping的粒子数一直是固定的。</p>
<p>AMCL的提议分布是运动模型，分布的特点是又扁又宽； gmapping的提议分布是运动模型又加入了最近的观测，分布特点是小的尖峰。</p>
<p>AMCL的粒子权重是似然域模型改变，gmapping是通过scan match</p>
<p>AMCL输出的位姿是所有粒子加权平均后的结果； gmapping是输出得分最高的粒子</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/02/C++/C++%20%20%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/emplace%E5%92%8Cemplace_back/">emplace 和 emplace_back</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/">C++ 模板与STL</a></span><div class="content"><p>常见用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    v.<span class="built_in">emplace_back</span>();</span><br><span class="line">    <span class="keyword">auto</span>&amp; num = v.<span class="built_in">back</span>();</span><br><span class="line">    num = i;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt; <span class="string">&quot;size: &quot;</span>&lt;&lt;v.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot;  v.back: &quot;</span>&lt;&lt;v.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size:  1   v.back:  0</span><br><span class="line">size:  2   v.back:  1</span><br><span class="line">size:  3   v.back:  2</span><br><span class="line">size:  4   v.back:  3</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> string&amp; s) &#123;cout &lt;&lt; <span class="string">&quot;A construct &quot;</span> &lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A&amp; a) &#123;cout &lt;&lt;<span class="string">&quot;A copy&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::map&lt;<span class="keyword">int</span>, string&gt; m;</span><br><span class="line">    vector&lt;A&gt; v;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;  <span class="comment">// a1 构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">push_back</span>(a1);   <span class="comment">// a1 拷贝构造函数</span></span><br><span class="line">    v.<span class="built_in">emplace_back</span>(a1);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//先运行构造函数，后拷贝构造函数</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">A</span>(<span class="string">&quot;test&quot;</span>) );</span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="built_in">A</span>(<span class="string">&quot;test&quot;</span>) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v.push_back(&quot;test&quot;);  报错</span></span><br><span class="line">    <span class="comment">// 这个才是真正的用途</span></span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="string">&quot;test&quot;</span>);   <span class="comment">// 隐式转换，只有拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;******************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于C++ 11里vector的<code>emplace_back</code>函数比较失望，都说提高了效率，其实它仅对于元素做隐式转换的情况有效，此时没有产生临时对象。对其他情况，和<code>push_back</code>没区别。  </p>
<p>这里用到的c++11特性<strong>完美转发</strong>：将接收下来的参数原样完美地传递给对象的构造函数，这带来另一个方便性就是即使是构造函数声明为 <code>explicit</code> 它还是可以正常工作，因为它不存在临时变量和隐式转换。</p>
<h2 id="map-emplace"><a href="#map-emplace" class="headerlink" title="map::emplace"></a>map::emplace</h2><p>map就只有<code>emplace</code>，机制也是一样的。元素是直接构建的，既不复制也不移动，仅当键不存在时才插入。<br>但是map有个问题：emplace 方法把它接收到的所有的参数都一起转发给 <code>pair</code> 的构造函数。但是对于一个 <code>pair</code> 来说，它既需要构造它的 key 又需要构造它的 value。如果我们按照之前普通的语法使用变参模板的话，则它是无法区分哪些参数用来构造 key, 哪些用来构造 value的。 比如下面的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法区分哪个参数用来构造 key 哪些用来构造 value</span></span><br><span class="line"><span class="comment">// 有可能是 std::string s(&quot;hello&quot;, 1), std::complex&lt;double&gt; cpx(2) </span></span><br><span class="line"><span class="comment">// 也有可能是 std::string s(&quot;hello&quot;), std::complex&lt;double&gt; cpx(1, 2)</span></span><br><span class="line">std::map&lt;std::string, std::complex&lt;<span class="keyword">double</span>&gt;&gt; scp;</span><br><span class="line">scp.<span class="built_in">emplace</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">1</span>, <span class="number">2</span>); </span><br></pre></td></tr></table></figure><br>考虑使用可以接受异构、变长参数的 tuple 来对参数进行分组。再使用 C++11 提供的一个特殊类型 <code>piecewise_construct_t</code> 来帮助它们找到各自正确的构造函数了。<code>std::piecewise_construct_t</code> 是一个空类，全局变量 <code>std::piecewise_construct</code> 就是该类型的一个变量。</p>
<p><code>std::piecewise_construct</code>作为构造 pair 对象的第一个参数传递，以选择构造函数形式，通过将两个元组对象的元素转发给它们各自的构造函数来构造其成员。即第一个 tuple 作为 key，第二个 tuple 作为 value。 使用 <code>forward_as_tuple</code>，该函数会构造一个 tuple 并转发给 pair。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 想对于 map 避免临时变量的构造的话，就需要构建两个 tuple</span></span><br><span class="line">std::map&lt;std::string, std::complex&lt;<span class="keyword">double</span>&gt;&gt; scp;</span><br><span class="line">scp.<span class="built_in">emplace</span>(std::piecewise_construct, <span class="comment">// 此常量值作为构造 pair 对象的第一个参数传递，以选择构造函数形式，通过将两个元组对象的元素转发给它们各自的构造函数来构造其成员。</span></span><br><span class="line">    std::forward_as_tuple(<span class="string">&quot;hello&quot;</span>), <span class="comment">// 该函数会构造一个 tuple 并转发给 pair 构造，并存储在 first 字段</span></span><br><span class="line">    std::forward_as_tuple(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">//该函数会构造一个 tuple 并转发给 pair 构造，存储在 second 字段</span></span><br></pre></td></tr></table></figure>
<p>cartographer中的代码就是这样<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::map&lt;int, ::cartographer::mapping::PoseExtrapolator&gt;  extrapolators_;</span></span><br><span class="line">  <span class="comment">// PoseExtrapolator的构造函数有2个参数：common::Duration   pose_queue_duration,</span></span><br><span class="line">                                  <span class="comment">//      double   imu_gravity_time_constant</span></span><br><span class="line">  extrapolators_.<span class="built_in">emplace</span>(</span><br><span class="line">      std::piecewise_construct, </span><br><span class="line">      std::forward_as_tuple(trajectory_id),</span><br><span class="line">      std::forward_as_tuple(</span><br><span class="line">          ::cartographer::common::<span class="built_in">FromSeconds</span>(kExtrapolationEstimationTimeSec),</span><br><span class="line">          gravity_time_constant)  );</span><br></pre></td></tr></table></figure></p>
<h2 id="无参的emplace-back"><a href="#无参的emplace-back" class="headerlink" title="无参的emplace_back"></a>无参的emplace_back</h2><p>还有一种使用无参的<code>vector::emplace_back()</code> 或者 <code>deque::emplace_back()</code>，下面是从cartographer中学来的代码，确实有一定技巧<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    vector&lt;std::unique_ptr&lt;A&gt; &gt; dd;</span><br><span class="line">    dd.<span class="built_in">emplace_back</span>();</span><br><span class="line">    <span class="comment">// 注意这里的 size 也是1</span></span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;capacity: &quot;</span>&lt;&lt; dd.<span class="built_in">capacity</span>() &lt;&lt;<span class="string">&quot; size: &quot;</span>&lt;&lt; dd.<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; dd.at(0)-&gt;getValue() &lt;&lt;endl;  这里运行会崩溃</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span>*  a1 = &amp;dd.<span class="built_in">back</span>();  <span class="comment">// 这个是 unique_ptr</span></span><br><span class="line">    a1-&gt;<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">5</span>) );  <span class="comment">// 不能再用=，unique_ptr不能复制</span></span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;capacity: &quot;</span>&lt;&lt; dd.<span class="built_in">capacity</span>() &lt;&lt;<span class="string">&quot; size: &quot;</span>&lt;&lt; dd.<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; dd.<span class="built_in">at</span>(<span class="number">0</span>)-&gt;<span class="built_in">getValue</span>() &lt;&lt;endl;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">capacity: 1 size: 1</span><br><span class="line">A construct </span><br><span class="line">capacity: 1 size: 1</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://haoqchen.site/2020/01/17/emplace_back-vs-push_back/">emplace_back VS push_back</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/07/31/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8E%E7%AB%AF%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%201%20thread_pool%20%E5%92%8C%20task/">后端的线程池 1 thread_pool 和 task</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-31</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分不重要的成员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolInterface</span>;</span></span><br><span class="line">  <span class="function">State <span class="title">GetState</span><span class="params">()</span> <span class="title">LOCKS_EXCLUDED</span><span class="params">(mutex_)</span></span>;     <span class="comment">//返回本Task当前状态</span></span><br><span class="line">  <span class="comment">// 设置Task 执行的任务 （函数）</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetWorkItem</span><span class="params">(<span class="keyword">const</span> WorkItem&amp; work_item)</span></span>; </span><br><span class="line">  <span class="comment">// 给当前任务添加 依赖任务， 如当前任务为b，AddDependency(a)表示任务a依赖b </span></span><br><span class="line">  <span class="comment">// 把当前任务b，加入到依赖任务 a 的 dependent_tasks_ 列表</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddDependency</span><span class="params">(std::weak_ptr&lt;Task&gt; dependency)</span> <span class="title">LOCKS_EXCLUDED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 执行当前任务，比如当前任务为a，并更新依赖a的任务dependent_tasks_中所有任务状态</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Execute</span><span class="params">()</span> <span class="title">LOCKS_EXCLUDED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前任务进入线程待执行队列</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetThreadPool</span><span class="params">(ThreadPoolInterface* thread_pool)</span> <span class="title">LOCKS_EXCLUDED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前任务的依赖任务完成时候，当前任务状态随之改变</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OnDependenyCompleted</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">using</span>  WorkItem = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span>  <span class="title">State</span> &#123;</span> NEW, DISPATCHED, DEPENDENCIES_COMPLETED, RUNNING, COMPLETED &#125;;</span><br><span class="line">  <span class="comment">// 任务具体执行过程</span></span><br><span class="line">  WorkItem   work_item_ ;</span><br><span class="line">  <span class="comment">// 执行当前任务的线程池</span></span><br><span class="line">  ThreadPoolInterface*  thread_pool_to_notify_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="function">State   state_  <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span> </span>= NEW; <span class="comment">// 初始化状态为 NEW</span></span><br><span class="line">  <span class="comment">// 依赖当前任务的任务列表</span></span><br><span class="line">  <span class="function">std::set&lt;Task*&gt;  dependent_tasks_  <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Task类不是线程，可以理解为<strong>有状态和依赖的函数</strong>，核心的成员变量<code>work_item_</code>是仿函数，其返回类型void。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分不重要的成员</span></span><br><span class="line"><span class="comment">// 不明白为什么要先构造个抽象类，只有这一个派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> :</span> <span class="keyword">public</span> ThreadPoolInterface</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> 	<span class="comment">//初始化一个线程数量固定的线程池。</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> num_threads)</span></span>;</span><br><span class="line">  <span class="comment">// 添加想要ThreadPool执行的task，插入 tasks_not_ready_</span></span><br><span class="line">  <span class="comment">// 如果任务满足执行要求，直接插入task_queue_准备执行</span></span><br><span class="line">  <span class="function">std::weak_ptr&lt;Task&gt;  <span class="title">Schedule</span><span class="params">(std::unique_ptr&lt;Task&gt; task)</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> 	<span class="comment">//每个线程初始化时, 执行DoWork()函数. 与线程绑定</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">DoWork</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">NotifyDependenciesCompleted</span><span class="params">(Task* task)</span></span>;</span><br><span class="line">  <span class="comment">//running_只是一个监视哨, 只有线程池在running_状态时, 才能往work_queue_加入函数</span></span><br><span class="line">  <span class="keyword">bool</span> running_  = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// pool_就是一系列线程</span></span><br><span class="line">  std::vector&lt;std::thread&gt;  pool_ ;</span><br><span class="line">  <span class="comment">// 十分重要的任务队列</span></span><br><span class="line">  std::deque&lt;std::shared_ptr&lt;Task&gt;&gt;  task_queue_ ; </span><br><span class="line">  <span class="comment">//未准备好的 task，task可能有依赖还未完成</span></span><br><span class="line">  absl::flat_hash_map&lt;Task*, std::shared_ptr&lt;Task&gt;&gt;  tasks_not_ready_;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看构造函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="keyword">int</span> num_threads)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">absl::MutexLock  <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// 原来还是用了std::thread，还以为google连线程也是自己实现的</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != num_threads; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// std::vector&lt;std::thread&gt;   pool_;</span></span><br><span class="line">    pool_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]() &#123; ThreadPool::<span class="built_in">DoWork</span>(); &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>大致看<code>ThreadPool::DoWork()</code>，最后执行了<code>ThreadPoolInterface::Execute</code>，其实就是<code>Task::Execute</code>。 每个线程与DoWork()函数绑定,也就是线程在后台不断执行DoWork()函数</p>
<p>新的Task如果有依赖项，通过<code>Thread_pool::Schedule</code>添加到 <code>Thread_pool</code>的 <code>tasks_not_ready_</code>队列中。队列中的Task状态是变化的，等依赖项执行完成，Task状态变为<code>DEPENDENCIES_COMPLETED</code>，然后再插入<code>task_queue_</code>队列。最终所有Task都会插入<code>task_queue_</code>中，在<code>DoWork</code>中得到执行。 </p>
<p>如果该Task没有依赖，直接插入<code>task_queue_</code>，准备执行。</p>
<p>对任一个任务的状态转换顺序为：NEW—-&gt;DISPATCHED—-&gt;DEPENDENCIES_COMPLETED—-&gt;RUNNING—-&gt;COMPLETED</p>
<p><code>Thread_pool</code>通过固定数量的thread与<code>task_queue_</code>（待执行的task队列）执行函数绑定。Thread_pool 按照队列首尾顺序不断执行Task。</p>
<p><img src="https://i.loli.net/2021/07/31/biVycPTkQoaDOeB.png" alt="示意图"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/07/30/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8E%E7%AB%AF%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%202%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8Cwork_queue/">后端的线程池 2 线程池和work_queue</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p><code>cartographer_ros</code>节点main函数所在的称为main线程，其它的称后台线程。<code>PoseGrapher::AddNode</code>在main线程，但计算两种约束、优化全局位姿都在后台线程。</p>
<p>PoseGraph有一个线程池，配置一定数量的线程来执行优化任务。线程池在<code>MapBuilder</code>构造函数中创建，作为参数给<code>PoseGraph</code>对象，PoseGraph将其作为 <code>constraints::ConstraintBuilder2D</code>的初始化使用。每个线程执行 <code>ThreadPool::DoWork()</code>函数。 <code>DoWork()</code>函数会一直循环遍历一个<code>deque</code>队列中的Task任务，每次执行完一个Task，就会从队列弹出。  即<code>std::deque&lt;std::shared_ptr&lt;Task&gt; &gt;  task_queue_</code></p>
<p>这个<code>task_queue_</code>的添加任务追溯到线程池的<code>Schedule</code>函数，<code>Schedule</code>函数在<code>PoseGraph2D::AddWorkItem</code>和添加约束的函数里</p>
<p>每次收到SLAM需要的信息都会生成一个work，这个work都会保存到PoseGraph的<code>work_queue_</code>队列中，上面说的task通过<code>SetWorkItem</code>进一步执行<code>DrainWorkQueue</code>， 进而从 <code>work_queue_</code>中取出 WorkItem 执行。这些 WorkItem 是由pose_graph添加各种传感器数据和 Node的时候加入到该队列的，比如<code>AddImuData</code></p>
<h2 id="lambda-和-仿函数"><a href="#lambda-和-仿函数" class="headerlink" title="lambda 和 仿函数"></a>lambda 和 仿函数</h2><p>看<code>work_queue_</code>队列之前，先要搞清lambda 和 仿函数是怎么回事。</p>
<p>先看一个简单的仿函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// int是返回值类型，括号里是参数的类型</span></span><br><span class="line">std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">float</span>, <span class="keyword">float</span>)&gt; func = add;</span><br><span class="line">cout&lt;&lt; <span class="built_in">func</span>(<span class="number">2.4</span>, <span class="number">6.9</span>) &lt;&lt;endl;</span><br></pre></td></tr></table></figure></p>
<p>lambda表达式通常仅仅是仿函数的语法糖，可以直接转换为仿函数。[]中的任何内容都会转换为构造函数参数和仿函数对象的成员，而()中的参数将转换为仿函数operator()的参数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddWorkItem</span><span class="params">(std::function&lt;<span class="keyword">int</span>()&gt;&amp;  work_item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">work_item</span>() &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddImuData</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// []：默认不捕获任何变量</span></span><br><span class="line">	<span class="comment">// [=]：默认以值捕获所有变量</span></span><br><span class="line">	<span class="comment">// 其实可以用 auto</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>()&gt; func = [=]()&#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;input: &quot;</span>&lt;&lt; a &lt;&lt; <span class="string">&quot;  &quot;</span>&lt;&lt; b&lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//    std::function&lt;int(float,float)&gt; func2 = add;</span></span><br><span class="line">    <span class="built_in">AddWorkItem</span>( func );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 函数中调用</span></span><br><span class="line"><span class="built_in">AddImuData</span>(<span class="number">29</span>, <span class="number">7</span>);</span><br></pre></td></tr></table></figure><br>把cartographer中的函数做了修改，这样容易理解。 main 函数中调用<code>AddImuData</code>，我们要的是运行lambda表达式，假如<code>AddWorkItem</code>是空函数，那么不会有运行结果。<code>work_item()</code>才是实际的运行lambda表达式。 </p>
<h2 id="workqueue-机制"><a href="#workqueue-机制" class="headerlink" title="workqueue 机制"></a>work<em>queue</em> 机制</h2><p><code>PoseGraph2D</code>有16个成员函数调用了<code>AddWorkItem</code>，也就是加入了<code>work_queue_</code>队列。操作<code>work_queue_</code>的函数主要是<code>AddWorkItem</code> 和 <code>DrainWorkQueue</code></p>
<p>以<code>PoseGraph2D::AddImuData</code>为例:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::AddImuData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> trajectory_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> sensor::ImuData&amp; imu_data)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">AddWorkItem</span>( [=]() <span class="built_in">LOCKS_EXCLUDED</span>(mutex_)</span><br><span class="line">  &#123;</span><br><span class="line">    absl::MutexLock <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CanAddWorkItemModifying</span>(trajectory_id)) &#123;</span><br><span class="line">      optimization_problem_-&gt;<span class="built_in">AddImuData</span>(trajectory_id, imu_data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> WorkItem::Result::kDoNotRunOptimization;</span><br><span class="line">  &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>后面会看到<code>AddWorkItem</code>的参数是一个仿函数<code>std::function</code>。 <code>AddImuData</code>实际上就一句，也就是调用了<code>AddWorkItem</code>， 这里面的<code>AddWorkItem</code>的参数其实是把一个lambda表达式作为仿函数，这个仿函数的返回值是<code>WorkItem::Result</code>，实际是枚举值<code>kDoNotRunOptimization</code> 或者 <code>kRunOptimization</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个函数地址加入到一个工作队列中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::AddWorkItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::function&lt;WorkItem::Result()&gt;&amp; work_item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">absl::MutexLock  <span class="title">locker</span><span class="params">(&amp;work_queue_mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// 如果工作队列未被初始化，则先初始化，再打开启线程池，后台打开任务队列执行循环</span></span><br><span class="line">  <span class="comment">// 这也是唯一初始化 work_queue_ 的地方</span></span><br><span class="line">  <span class="comment">// std::unique_ptr&lt;WorkQueue&gt;  work_queue_</span></span><br><span class="line">  <span class="keyword">if</span> (work_queue_ == <span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    work_queue_ = absl::make_unique&lt;WorkQueue&gt;();</span><br><span class="line">    <span class="comment">// DrainWorkQueue函数加入到线程池</span></span><br><span class="line">    <span class="keyword">auto</span> task = absl::make_unique&lt;common::Task&gt;();</span><br><span class="line">    task-&gt;<span class="built_in">SetWorkItem</span>([<span class="keyword">this</span>]() &#123; <span class="built_in">DrainWorkQueue</span>(); &#125;);</span><br><span class="line">    thread_pool_-&gt;<span class="built_in">Schedule</span>(std::<span class="built_in">move</span>(task)  );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> now = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  work_queue_-&gt;<span class="built_in">push_back</span>(&#123;now, work_item&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>work_queue_</code>的类型是<code>std::unique_ptr&lt;WorkQueue&gt;</code>， <code>WorkQueue</code>是<code>WorkItem</code>的deque。根据上面的分析，<font color = blue size=4> 我们要想运行lambda表达式，要的是 work_item()</font>，但是这个函数里没看到，因为这里只有添加，是添加到<code>work_queue_</code>里了。实际的运行在<code>DrainWorkQueue</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::DrainWorkQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> process_work_queue = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">size_t</span> work_queue_size;</span><br><span class="line">  <span class="keyword">while</span> (process_work_queue)</span><br><span class="line">  &#123;</span><br><span class="line">    std::function&lt;WorkItem::<span class="built_in">Result</span>()&gt; work_item;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;work_queue_mutex_)</span></span>;</span><br><span class="line">      <span class="comment">// work_queue_ 队列中取出压栈的任务一个一个执行，直到为空</span></span><br><span class="line">      <span class="comment">// work_queue_ 为空, 说明thread_pool中DrainWorkQueue执行完,</span></span><br><span class="line">      <span class="comment">// 等待下一次addNode时候,再次执行thread_pool_-&gt;Schedule(task),再次执行.</span></span><br><span class="line">      <span class="keyword">if</span> (work_queue_-&gt;<span class="built_in">empty</span>())</span><br><span class="line">      &#123;</span><br><span class="line">        work_queue_.<span class="built_in">reset</span>();  <span class="comment">// 智能指针 reset</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取队列中最前的任务，这就是上面说的 work_item</span></span><br><span class="line">      work_item = work_queue_-&gt;<span class="built_in">front</span>().task;</span><br><span class="line">      work_queue_-&gt;<span class="built_in">pop_front</span>();</span><br><span class="line">      work_queue_size = work_queue_-&gt;<span class="built_in">size</span>();</span><br><span class="line">      kWorkQueueSizeMetric-&gt;<span class="built_in">Set</span>(work_queue_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里的 work_item()就是我们需要的 AddImuData里的lambda表达式</span></span><br><span class="line">    <span class="comment">//回头看lambda，可以发现返回值是 kDoNotRunOptimization</span></span><br><span class="line">    <span class="comment">// 执行工作任务后，返回的状态，赋值false或true给 process_work_queue</span></span><br><span class="line">    process_work_queue = <span class="built_in">work_item</span>() == WorkItem::Result::kDoNotRunOptimization;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 运行到这里，说明队列里运行的lambda表达式的返回值是 kRunOptimization</span></span><br><span class="line">  <span class="comment">// 实际上pop了好几个任务</span></span><br><span class="line">  <span class="comment">//  如果work_item()都不需要全局优化, 则直到work_queue_为空, 都不会执行优化</span></span><br><span class="line">  <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Remaining work items in queue: &quot;</span> &lt;&lt; work_queue_size;</span><br><span class="line">  <span class="comment">// We have to optimize again</span></span><br><span class="line">  constraint_builder_.<span class="built_in">WhenDone</span>(</span><br><span class="line">      [<span class="keyword">this</span>](<span class="keyword">const</span> constraints::ConstraintBuilder2D::Result&amp; result)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">HandleWorkQueue</span>(result);</span><br><span class="line">      &#125;  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面说了<code>PoseGraph2D</code>有16个成员函数调用了<code>AddWorkItem</code>，但是发现只有3个函数会返回<code>kRunOptimization</code>：<br><code>FinishTrajectory</code>, <code>RunFinalOptimization</code>和 <code>ComputeConstraintsForNode</code>。</p>
<p>16个里面最重要的当然是后端入口函数<code>PoseGraph2D::AddNode</code>，在它的<code>work_item</code>是<code>ComputeConstraintsForNode</code>， 在<code>ComputeConstraintsForNode</code>的最后部分：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options_.<span class="built_in">optimize_every_n_nodes</span>() &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">  num_nodes_since_last_loop_closure_ &gt; options_.<span class="built_in">optimize_every_n_nodes</span>() )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>  WorkItem::Result::kRunOptimization;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  WorkItem::Result::kDoNotRunOptimization;</span><br></pre></td></tr></table></figure><br>整个SLAM中实时进入任务队列的主要为<strong>计算约束</strong>，当加入节点数超过参数时，才进行一次优化。</p>
<h2 id="ConstraintBuilder2D-WhenDone"><a href="#ConstraintBuilder2D-WhenDone" class="headerlink" title="ConstraintBuilder2D::WhenDone"></a>ConstraintBuilder2D::WhenDone</h2><p>最后的<code>ConstraintBuilder2D::WhenDone</code>又用到了lambda表达式，又涉及到线程池，实际的后台优化是在<code>HandleWorkQueue</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Result 就是 vector&lt;Constraint&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstraintBuilder2D::WhenDone</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> std::function&lt;<span class="keyword">void</span>(<span class="keyword">const</span> ConstraintBuilder2D::Result&amp;)&gt;&amp; callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="built_in">CHECK</span>(when_done_ == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 成员 unique_ptr&lt;std::function&lt;void(const Result&amp;)&gt;&gt;   when_done_;</span></span><br><span class="line">  when_done_ = absl::make_unique&lt;std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> Result&amp;)&gt; &gt; (callback);</span><br><span class="line">  <span class="built_in">CHECK</span>(when_done_task_ != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 约束的计算结果通过回调进行回传</span></span><br><span class="line">  when_done_task_-&gt;<span class="built_in">SetWorkItem</span>([<span class="keyword">this</span>] &#123; <span class="built_in">RunWhenDoneCallback</span>(); &#125;);</span><br><span class="line">  thread_pool_-&gt;<span class="built_in">Schedule</span>(std::<span class="built_in">move</span>(when_done_task_));</span><br><span class="line">  when_done_task_ = absl::make_unique&lt;common::Task&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里实际就是处理<code>when_done_task_</code>，它是在<code>finish_node_task</code>执行完之后才执行的，内容就是<code>HandleWorkQueue</code></p>
<p>优化执行完毕时的回调函数<code>RunWhenDoneCallback</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstraintBuilder2D::RunWhenDoneCallback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Result result;</span><br><span class="line">  std::unique_ptr&lt;std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> Result&amp;)&gt;&gt; callback;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    <span class="built_in">CHECK</span>(when_done_ != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 将约束结果放入 result</span></span><br><span class="line">    <span class="comment">// MaybeAddConstraint 里添加 constraints_</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> std::unique_ptr&lt;Constraint&gt;&amp; constraint : constraints_)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (constraint == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">      result.<span class="built_in">push_back</span>(*constraint);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (options_.<span class="built_in">log_matches</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(INFO) &lt;&lt; constraints_.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; computations resulted in &quot;</span></span><br><span class="line">                &lt;&lt; result.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; additional constraints.&quot;</span>;</span><br><span class="line">      <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Score histogram:\n&quot;</span> &lt;&lt; score_histogram_.<span class="built_in">ToString</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    constraints_.<span class="built_in">clear</span>();</span><br><span class="line">    callback = std::<span class="built_in">move</span>(when_done_);</span><br><span class="line">    when_done_.<span class="built_in">reset</span>();</span><br><span class="line">    kQueueLengthMetric-&gt;<span class="built_in">Set</span>(constraints_.<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 我理解的 HandleWorkQueue 是在这里</span></span><br><span class="line">  (*callback)(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>scan match</code>的过程如下<br><img src="https://i.loli.net/2021/07/31/8qGxjrQ2ngBylNT.png" alt=""><br><code>AddImuData</code>等函数不是直接放到线程里运行的，进线程池的是<code>DrainWorkQueue</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/07/26/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/cartographer%E7%9A%84%E6%97%A5%E5%BF%97/">cartographer的gflag和glog日志</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/">原理和配置</a></span><div class="content"><h2 id="gflag"><a href="#gflag" class="headerlink" title="gflag"></a>gflag</h2><p><img src="https://s2.loli.net/2022/03/19/ZjlsqPvr4Xkug5z.png" alt="CHECK宏.png"><br><code>先看DEFINE</code>宏，有三个宏：flag的名称，flag的默认值，help字符串。如何查看help信息呢，在执行可执行文件时加上–help选项即可，但是如果要显示help信息，代码里需要调用接口<code>gflags::ParseCommandLineFlags(&amp;argc, &amp;argv, true)</code></p>
<p>gflags支持的变量类型如下：</p>
<ul>
<li>DEFINE_bool: 布尔类型</li>
<li>DEFINE_int32: 32-bit 整型</li>
<li>DEFINE_int64: 64-bit 整型</li>
<li>DEFINE_uint64: 无符号 64-bit 整型</li>
<li>DEFINE_double: double</li>
<li>DEFINE_string: C++ string</li>
</ul>
<p>在程序中使用flag，对于DEFINE过的flag我们可以像使用普通变量那样读写它，只需加一个<code>FLAGS_</code>前缀即可，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FLAGS_is_handsome)</span><br><span class="line">    FLAGS_is_handsome = <span class="literal">false</span>; </span><br><span class="line">std::cout &lt;&lt; FLAGS_hobby &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">DEFINE_string</span>(configuration_directory, <span class="string">&quot;&quot;</span>,</span><br><span class="line">              <span class="string">&quot;First directory in which configuration files are searched, &quot;</span></span><br><span class="line">              <span class="string">&quot;second is always the Cartographer installation to allow &quot;</span></span><br><span class="line">              <span class="string">&quot;including files from there.&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CHECK_EQ(x,y)    ==</span><br><span class="line">CHECK_NE(x,y)    =</span><br><span class="line">CHECK_LE(x,y)    &lt;=</span><br><span class="line">CHECK_LT(x,y)    &lt;</span><br><span class="line">CHECK_GE(x,y)    &gt;=</span><br><span class="line">CHECK_GT(x,y)    &gt;</span><br></pre></td></tr></table></figure>
<h2 id="glog"><a href="#glog" class="headerlink" title="glog"></a>glog</h2><p>Google glog是一个基于程序级记录日志信息的c++库，编程使用方式与c++的stream操作类似。 每个级别的日志除了输出到对应日志文件中，还输出到每个低级别日志文件中。默认ERROR和FATAL消息除了输出到日志文件中之外，还会输出到标准错误中<br><img src="https://s2.loli.net/2022/03/19/9qURfx4E81uTaSb.png" alt="在CMakeLists中的配置.png"><br>每个级别都对应有相应的日志文件，文件默认存放在临时文件中，Linux是 <code>/tmp</code>。运行cartographer之后，可以在<code>/tmp</code>里看到<br><img src="https://i.loli.net/2021/07/26/1xO5wh6FdBP4Mbc.png" alt=""></p>
<p>glog的库文件都在<code>/usr/lib/x86_64-linux-gnu</code></p>
<h2 id="自定义cartographer的日志格式"><a href="#自定义cartographer的日志格式" class="headerlink" title="自定义cartographer的日志格式"></a>自定义cartographer的日志格式</h2><p><code>glog</code>的明显缺点就是配置输出格式不方便，还要修改源码的<code>logging.cc</code>，重新编译。我下载<code>glog 0.5.0</code>后，修改logging.cc文件再编译安装，结果导致cartographer报错，<code>ScopedRosLogSink::send</code>没有链接，应当是和现有的glog造成了冲突，然后一直解决不了。</p>
<p>然后尝试在<code>ros_log_sink.cc</code>中添加函数，就是把<code>::google::LogSink::ToString</code>重新定义到<code>ros_log_sink.cc</code>，这样避开glog的链接问题。头文件当然也要添加这个成员函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">ScopedRosLogSink::ToString</span><span class="params">(<span class="keyword">const</span> ::google::LogSeverity severity, <span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">int</span> line,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">const</span> struct ::tm* tm_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">const</span> <span class="keyword">char</span>* message, <span class="keyword">size_t</span> message_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">ostringstream <span class="title">stream</span><span class="params">(string(message, message_len))</span></span>;</span><br><span class="line">  stream.<span class="built_in">fill</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  stream &lt;&lt; <span class="string">&#x27;[&#x27;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="number">1</span>+tm_time-&gt;tm_mon</span><br><span class="line">         &lt;&lt; <span class="string">&#x27;_&#x27;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tm_time-&gt;tm_mday</span><br><span class="line">         &lt;&lt; <span class="string">&quot;  &quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tm_time-&gt;tm_hour &lt;&lt; <span class="string">&#x27;:&#x27;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tm_time-&gt;tm_min &lt;&lt; <span class="string">&#x27;:&#x27;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tm_time-&gt;tm_sec &lt;&lt; <span class="string">&quot;  &quot;</span></span><br><span class="line">         &lt;&lt; file &lt;&lt; <span class="string">&quot;: &quot;</span>  &lt;&lt; line &lt;&lt; <span class="string">&quot;] &quot;</span>;</span><br><span class="line"></span><br><span class="line">  stream &lt;&lt; <span class="built_in">string</span>(message, message_len);</span><br><span class="line">  <span class="keyword">return</span> stream.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>tm_time</code>只精确到秒，这样日志就不能精确到毫秒了，不过目前还不需要。<code>ScopedRosLogSink::send</code>的开头改为<code>ToString</code>函数。这样改完后，日志格式可能还不是想要的<br><img src="https://s2.loli.net/2022/04/21/6HSV8jluRnNh1tk.png" alt="默认日志格式.png"><br>后来才发现原来cartographer的日志格式是把glog的格式和ROS的格式融合一起了，所以修改环境变量如下<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ROSCONSOLE_FORMAT=<span class="string">&#x27;[$&#123;message&#125;&#x27;</span></span><br></pre></td></tr></table></figure><br><img src="https://s2.loli.net/2022/04/21/b9D67wG32xFNEWR.png" alt="修改后的日志.png"></p>
<h2 id="几个常用参数"><a href="#几个常用参数" class="headerlink" title="几个常用参数"></a>几个常用参数</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FLAGS_logtostderr = <span class="literal">true</span>; // 设置日志消息是否转到标准输出而不是日志文件</span><br><span class="line"></span><br><span class="line">FLAGS_alsologtostderr = <span class="literal">true</span>; // 设置日志消息除了日志文件之外是否去标准输出</span><br><span class="line"></span><br><span class="line">FLAGS_colorlogtostderr = <span class="literal">true</span>; // 设置记录到标准输出的颜色消息（如果终端支持）</span><br><span class="line"></span><br><span class="line">FLAGS_logbufsecs = ; // 设置可以缓冲日志的最大秒数，0指实时输出</span><br><span class="line"></span><br><span class="line">FLAGS_max_log_size = ; // 设置最大日志文件大小（以MB为单位）</span><br><span class="line"></span><br><span class="line">FLAGS_stop_logging_if_full_disk = <span class="literal">true</span>; // 设置是否在磁盘已满时避免日志记录到磁盘</span><br></pre></td></tr></table></figure>
<p>cartographer的大部分文件都可以直接使用<code>LOG(INFO)&lt;&lt;&quot;log&quot;;</code>这样的语句，因为都提前配置好了，但是最好重新指定日志路径。</p>
<ul>
<li><code>google::SetLogDestination(google::INFO, &quot;log/INFO_&quot;);</code>  // 设置特定级别的日志的输出目录和前缀。第一个参数为日志级别，第二个参数表示输出目录及日志文件名前缀</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glog/logging.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    google::<span class="built_in">InitGoogleLogging</span>(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// INFO</span></span><br><span class="line">    std::string str_info;</span><br><span class="line">    <span class="comment">// 文件名最后只能是   等级+下划线</span></span><br><span class="line">    str_info.<span class="built_in">append</span>(<span class="string">&quot;/home/user/log/INFO_&quot;</span>);</span><br><span class="line">    google::<span class="built_in">SetLogDestination</span>(google::INFO, str_info.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG</span>(INFO)&lt;&lt; <span class="string">&quot;The is a info!&quot;</span>;</span><br><span class="line">    <span class="comment">// WARNING</span></span><br><span class="line">    std::string str_warn;</span><br><span class="line">    str_warn.<span class="built_in">append</span>(<span class="string">&quot;/home/user/log/WARNING_&quot;</span>);</span><br><span class="line">    google::<span class="built_in">SetLogDestination</span>(google::WARNING, str_warn.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;The is a warning!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stop glog  可以没有</span></span><br><span class="line">    google::<span class="built_in">ShutdownGoogleLogging</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次运行cartographer后发现在自定义的路径里，INFO开头的日志文件每次都会新建，而INFO结尾的日志是最新运行得到的日志<br><img src="https://i.loli.net/2021/07/26/FBD5a21MecbpOI6.png" alt=""><br><img src="https://i.loli.net/2021/07/26/pm8qsza4KxV7BrQ.png" alt=""></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/07/26/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8E%E7%AB%AF%204%20%E8%AE%A1%E7%AE%97%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/">后端 4 计算约束的准备工作</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>接上一篇，看两次计算约束的函数 <code>ComputeConstraint</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据指定的 nodeid 和 submapid 计算其约束</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::ComputeConstraint</span><span class="params">(<span class="keyword">const</span> NodeId&amp; node_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">const</span> SubmapId&amp; submap_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span>  maybe_add_local_constraint = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">bool</span>  maybe_add_global_constraint = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span>  TrajectoryNode::Data*  constant_data;</span><br><span class="line">  <span class="keyword">const</span>  Submap2D* submap;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    <span class="built_in">CHECK</span>(data_.submap_data.<span class="built_in">at</span>(submap_id).state == SubmapState::kFinished);</span><br><span class="line">    <span class="keyword">if</span> (!data_.submap_data.<span class="built_in">at</span>(submap_id).submap-&gt;<span class="built_in">insertion_finished</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Uplink server only receives grids when they are finished,</span></span><br><span class="line">      <span class="comment">// so skip constraint search before that.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取两个id最新的那个时刻</span></span><br><span class="line">    <span class="keyword">const</span> common::Time  node_time = <span class="built_in">GetLatestNodeTime</span>(node_id, submap_id);</span><br><span class="line">    <span class="keyword">const</span> common::Time  last_connection_time =</span><br><span class="line">        data_.trajectory_connectivity_state.<span class="built_in">LastConnectionTime</span>(</span><br><span class="line">            node_id.trajectory_id,  submap_id.trajectory_id );</span><br><span class="line">    <span class="comment">// 如果节点与submap在同一轨迹内或者距离上次全局约束时间较短，则计算局部约束</span></span><br><span class="line">    <span class="keyword">if</span> (node_id.trajectory_id == submap_id.trajectory_id ||</span><br><span class="line">        node_time &lt;</span><br><span class="line">            last_connection_time +</span><br><span class="line">                common::<span class="built_in">FromSeconds</span>(</span><br><span class="line">                    options_.<span class="built_in">global_constraint_search_after_n_seconds</span>()) )</span><br><span class="line">    &#123;</span><br><span class="line">        maybe_add_local_constraint = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不在同一轨迹内，一定间隔计算全局约束</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (global_localization_samplers_[node_id.trajectory_id]-&gt;<span class="built_in">Pulse</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        maybe_add_global_constraint = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    constant_data = data_.trajectory_nodes.<span class="built_in">at</span>(node_id).constant_data.<span class="built_in">get</span>();</span><br><span class="line">    submap = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> Submap2D*&gt;(</span><br><span class="line">        data_.submap_data.<span class="built_in">at</span>(submap_id).submap.<span class="built_in">get</span>()  );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>建图模式，节点与submap在同一轨迹内 或者 存在一个最近的全局约束把节点的轨迹和子图的轨迹连接起来时，使用<code>local search window</code>计算<strong>局部约束</strong>；</p>
</li>
<li><p>纯定位模式，节点与submap不在同一轨迹，使用<strong>全局搜索窗口</strong>计算约束(对整体子图进行回环检测) 。纯定位进行慢，主要就是 <code>global_constraint_search_after_n_seconds</code> 较大导致，迟迟不能确认<code>maybe_add_global_constraint</code>为true</p>
</li>
</ul>
<p>local约束在求解时，搜索窗口小，有初值;   &emsp;&emsp;  global约束在求解时，搜索窗口大，没有初值。 <font color = blue size=4> 记住二者都是计算 Constraint::INTER_SUBMAP </font> </p>
<p><img src="https://i.loli.net/2021/08/21/UaK7k6HD1pSANBy.png" alt=""></p>
<h2 id="准备计算局部和全局约束"><a href="#准备计算局部和全局约束" class="headerlink" title="准备计算局部和全局约束"></a>准备计算局部和全局约束</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (maybe_add_local_constraint)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> transform::Rigid2d  initial_relative_pose =</span><br><span class="line">      optimization_problem_-&gt;<span class="built_in">submap_data</span>()</span><br><span class="line">          .<span class="built_in">at</span>(submap_id)</span><br><span class="line">          .global_pose.<span class="built_in">inverse</span>() *</span><br><span class="line">      optimization_problem_-&gt;<span class="built_in">node_data</span>().<span class="built_in">at</span>(node_id).global_pose_2d;</span><br><span class="line">  <span class="comment">// 添加局部约束，进行闭环匹配，更新相对位置</span></span><br><span class="line">  constraint_builder_.<span class="built_in">MaybeAddConstraint</span>(</span><br><span class="line">      submap_id, submap, node_id, constant_data, initial_relative_pose);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 添加全局约束</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (maybe_add_global_constraint)</span><br><span class="line">  constraint_builder_.<span class="built_in">MaybeAddGlobalConstraint</span>(</span><br><span class="line">      submap_id, submap, node_id, constant_data);</span><br></pre></td></tr></table></figure>
<p>前端得到节点相对于世界的位姿，也可以得到某个子图的世界位姿，因此得到这个节点相对于这个子图的相对位姿，把这个位姿称为 <strong>初始位姿 1</strong>。  之所以要用世界坐标系作为桥梁，是因为子图和这个节点并不一定在在同一条轨迹坐标系中(local map坐标系)</p>
<p>这里主要是<code>ConstraintBuilder2D</code>类的两个函数:  <code>MaybeAddConstraint</code> 和 <code>MaybeAddGlobalConstraint</code>，它们只有细微不同，前者的开头有这样两句：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (initial_relative_pose.<span class="built_in">translation</span>().<span class="built_in">norm</span>() &gt;</span><br><span class="line">      options_.<span class="built_in">max_constraint_distance</span>()  )</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><br>然后就是其中调用的<code>ConstraintBuilder2D::ComputeConstraint</code>不同，局部约束的是  <code>ComputeConstraint(submap_id, submap, node_id, false, constant_data, initial_relative_pose, *scan_matcher, constraint);</code></p>
<p>全局约束的是 <code>ComputeConstraint( submap_id, submap, node_id, true, constant_data, transform::Rigid2d::Identity(),  *scan_matcher, constraint);</code>，也就是 <code>match full submap</code></p>
<h2 id="局部约束"><a href="#局部约束" class="headerlink" title="局部约束"></a>局部约束</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstraintBuilder2D::MaybeAddConstraint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> SubmapId&amp; submap_id,  <span class="keyword">const</span> Submap2D* <span class="keyword">const</span> submap,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> NodeId&amp; node_id, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> TrajectoryNode::Data* <span class="keyword">const</span> constant_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> transform::Rigid2d&amp; initial_relative_pose)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 参数  max_constraint_distance</span></span><br><span class="line">  <span class="comment">// 初始位姿 1 的模不能太大</span></span><br><span class="line">  <span class="comment">// 约束并非无限制距离，若子图和节点的距离太远，则无需考虑约束</span></span><br><span class="line">  <span class="keyword">if</span> (initial_relative_pose.<span class="built_in">translation</span>().<span class="built_in">norm</span>() &gt;</span><br><span class="line">      options_.<span class="built_in">max_constraint_distance</span>() )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">/* 这是 ConstraintBuilder2D类 唯一使用采样器的地方</span></span><br><span class="line"><span class="comment">  ratio 默认 0.3， 参数 sampling_ratio</span></span><br><span class="line"><span class="comment">  sampling_ratio越小， Pulse()返回的false越多，更容易return*/</span></span><br><span class="line">  <span class="keyword">if</span> (!sampler_.<span class="built_in">Pulse</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// std::unique_ptr&lt;std::function&lt;void(const Result&amp;)&gt;&gt;  when_done_;</span></span><br><span class="line">  <span class="keyword">if</span> (when_done_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING)</span><br><span class="line">        &lt;&lt; <span class="string">&quot;MaybeAddConstraint was called while WhenDone was scheduled.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  constraints_.<span class="built_in">emplace_back</span>();  <span class="comment">// 添加空元素</span></span><br><span class="line">  kQueueLengthMetric-&gt;<span class="built_in">Set</span>(constraints_.<span class="built_in">size</span>()  );</span><br><span class="line">  <span class="comment">// 指针指向，对最后一个元素赋值</span></span><br><span class="line">  <span class="keyword">auto</span>* <span class="keyword">const</span> constraint = &amp;constraints_.<span class="built_in">back</span>();</span><br><span class="line">  <span class="comment">// fast time scan matcher 在这里</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>* scan_matcher = </span><br><span class="line">      <span class="built_in">DispatchScanMatcherConstruction</span>(submap_id, submap-&gt;<span class="built_in">grid</span>()  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数<code>max_constraint_distance</code>很重要，如果建图回到同一位置，但没有出现回环，可能是因为过程中的累计误差过大了，大于这个参数，导致没有求 inter 约束。</p>
<h3 id="DispatchScanMatcherConstruction"><a href="#DispatchScanMatcherConstruction" class="headerlink" title="DispatchScanMatcherConstruction"></a>DispatchScanMatcherConstruction</h3><p>针对某一个<code>submap_id</code>的submap构建一个扫描匹配器,先看返回类型<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubmapScanMatcher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">const</span> Grid2D* grid = <span class="literal">nullptr</span>;</span><br><span class="line">  std::unique_ptr&lt;scan_matching::FastCorrelativeScanMatcher2D&gt;</span><br><span class="line">      fast_correlative_scan_matcher;</span><br><span class="line">  <span class="comment">// 线程池用的 Task</span></span><br><span class="line">  std::weak_ptr&lt;common::Task&gt;  creation_task_handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> ConstraintBuilder2D::SubmapScanMatcher*</span></span><br><span class="line"><span class="function"><span class="title">ConstraintBuilder2D::DispatchScanMatcherConstruction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> SubmapId&amp; submap_id,  <span class="keyword">const</span> Grid2D* <span class="keyword">const</span> grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(grid);</span><br><span class="line">  <span class="keyword">if</span> (submap_scan_matchers_.<span class="built_in">count</span>(submap_id) != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> &amp;submap_scan_matchers_.<span class="built_in">at</span>(submap_id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Map of dispatched or constructed scan matchers by &#x27;submap_id&#x27;</span></span><br><span class="line">  <span class="comment">// std::map&lt;SubmapId, SubmapScanMatcher&gt;  submap_scan_matchers_</span></span><br><span class="line">  <span class="keyword">auto</span>&amp; submap_scan_matcher = submap_scan_matchers_[submap_id];</span><br><span class="line">  <span class="comment">// 下面都是成员赋值</span></span><br><span class="line">  submap_scan_matcher.grid = grid;</span><br><span class="line">  <span class="keyword">auto</span>&amp; scan_matcher_options = options_.<span class="built_in">fast_correlative_scan_matcher_options</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> scan_matcher_task = absl::make_unique&lt;common::Task&gt;();</span><br><span class="line">  <span class="comment">// 这里也是 work_item 机制</span></span><br><span class="line">  scan_matcher_task-&gt;<span class="built_in">SetWorkItem</span>(</span><br><span class="line">      [&amp;submap_scan_matcher, &amp;scan_matcher_options]() &#123;</span><br><span class="line">        submap_scan_matcher.fast_correlative_scan_matcher =</span><br><span class="line">            absl::make_unique&lt;scan_matching::FastCorrelativeScanMatcher2D&gt;(</span><br><span class="line">                *submap_scan_matcher.grid, scan_matcher_options);</span><br><span class="line">      &#125; );</span><br><span class="line"></span><br><span class="line">  submap_scan_matcher.creation_task_handle = </span><br><span class="line">      thread_pool_-&gt;<span class="built_in">Schedule</span>(std::<span class="built_in">move</span>(scan_matcher_task));</span><br><span class="line">  <span class="keyword">return</span> &amp;submap_scan_matchers_.<span class="built_in">at</span>(submap_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是构造了<code>scan_matcher_task</code>的 <code>work_item</code>，返回 <code>scan_matcher</code>。 </p>
<p>继续看<code>MaybeAddConstraint</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 线程池</span></span><br><span class="line"><span class="keyword">auto</span> constraint_task = absl::make_unique&lt;common::Task&gt;();</span><br><span class="line">constraint_task-&gt;<span class="built_in">SetWorkItem</span>([=]() <span class="built_in">LOCKS_EXCLUDED</span>(mutex_)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">ComputeConstraint</span>(submap_id, submap, node_id, <span class="literal">false</span>, <span class="comment">/* match */</span></span><br><span class="line">                    constant_data, initial_relative_pose, *scan_matcher,</span><br><span class="line">                    constraint);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// constraint_task 依赖 scan_matcher_task</span></span><br><span class="line">constraint_task-&gt;<span class="built_in">AddDependency</span>(scan_matcher-&gt;creation_task_handle);</span><br><span class="line"><span class="keyword">auto</span> constraint_task_handle =</span><br><span class="line">    thread_pool_-&gt;<span class="built_in">Schedule</span>(std::<span class="built_in">move</span>(constraint_task));</span><br><span class="line"><span class="comment">// finish_node_task_ 依赖 constraint_task</span></span><br><span class="line">finish_node_task_-&gt;<span class="built_in">AddDependency</span>(constraint_task_handle);</span><br></pre></td></tr></table></figure><br>其实<code>MaybeAddConstraint</code>做的就是下面的工作，接下来的重点就是 <code>ConstraintBuilder2D::ComputeConstraint</code><br><img src="https://i.loli.net/2021/08/22/DRiJrzEsXdaYKx6.png" alt=""></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/26/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><span class="page-number current">27</span><a class="page-number" href="/page/28/">28</a><span class="space">&hellip;</span><a class="page-number" href="/page/66/">66</a><a class="extend next" rel="next" href="/page/28/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2024 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>