<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">497</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">45</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/02/18/exLTfbM3uFOq5SV.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/22/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ROS%E5%B8%B8%E7%94%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3/">ROS常用的核心接口</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><h2 id="ros-start"><a href="#ros-start" class="headerlink" title="ros::start ()"></a>ros::start ()</h2><p>Actually starts the internals of the node (spins up threads, starts the network polling and xmlrpc loops, connects to internal subscriptions like /clock, starts internal service servers, etc.). </p>
<h2 id="ros-shutdown"><a href="#ros-shutdown" class="headerlink" title="ros::shutdown()"></a>ros::shutdown()</h2><p>关闭节点并且从主节点登出，会终结所有的订阅、发布、服务，连<code>ROS_INFO</code>也不能再用。一般不用调用此函数，当所有的<strong>NodeHandle</strong>销毁时，就会自动关闭节点。默认的roscpp也会安装<code>SIGINT</code>句柄用来检测<code>Ctrl-C</code>，并自动为你关闭节点。</p>
<h2 id="ros-waitForShutdown"><a href="#ros-waitForShutdown" class="headerlink" title="ros::waitForShutdown ()"></a>ros::waitForShutdown ()</h2><p>等待节点关闭，无论时通过<code>Ctrl-C</code>还是<code>ros::shutdown()</code></p>
<h2 id="ros-isShuttingDown"><a href="#ros-isShuttingDown" class="headerlink" title="ros::isShuttingDown()"></a>ros::isShuttingDown()</h2><p>一旦<code>ros::shutdown()</code>被调用（注意是刚开始调用，而不是调用完毕）就返回true。一般建议用ros::ok()，特殊情况可以用ros::isShuttingDown()</p>
<h2 id="ros-NodeHandle"><a href="#ros-NodeHandle" class="headerlink" title="ros::NodeHandle"></a>ros::NodeHandle</h2><p>获取节点的句柄，<code>ros::init</code>是初始化节点，这个是启动节点。<br>如果不想通过对象的生命周期来管理节点的开始和结束，可以通过<code>ros::start()</code>和<code>ros::shutdown()</code>来自己管理节点。</p>
<h2 id="ros-ok"><a href="#ros-ok" class="headerlink" title="ros::ok()"></a>ros::ok()</h2><p>判断是否退出节点，如果返回false，说明可能发生了以下事件</p>
<ul>
<li>调用了<code>ros::shutdown()</code></li>
<li>被另一同名节点踢出ROS网络</li>
<li>节点中的所有<code>ros::NodeHandles</code>都已经被销毁</li>
</ul>
<h3 id="ROS-INFO"><a href="#ROS-INFO" class="headerlink" title="ROS_INFO"></a>ROS_INFO</h3><p>ROS_INFO不能直接输出<code>std::string</code>，应该这样用:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string s;</span><br><span class="line"><span class="built_in">ROS_INFO</span>(s.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure></p>
<h3 id="ros-Rate"><a href="#ros-Rate" class="headerlink" title="ros::Rate"></a>ros::Rate</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line">    ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">    rate.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rate类的构造函数参数是频率，不是时间。rate(10)对应时间间隔为<code>1/10</code>秒，也就是100毫秒。<code>Rate::sleep()</code>是进行睡眠，实际调用<code>Duration::sleep()</code>，间隔就是从构造函数开始计算，源码处理比较复杂。</p>
<h3 id="获得当前运行的所有节点名"><a href="#获得当前运行的所有节点名" class="headerlink" title="获得当前运行的所有节点名"></a>获得当前运行的所有节点名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::string&gt; ros::V_string</span><br><span class="line"><span class="comment">// Retreives the currently-known list of nodes from the master. 放入</span></span><br><span class="line"><span class="function">ROSCPP_DECL <span class="keyword">bool</span>   <span class="title">getNodes</span> <span class="params">(V_string &amp;nodes)</span></span></span><br></pre></td></tr></table></figure>
<p>用这个函数很简单：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; nodes;</span><br><span class="line">ros::master::<span class="built_in">getNodes</span>(nodes);	<span class="comment">// bool</span></span><br><span class="line"><span class="keyword">int</span> len = nodes.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;node: &quot;</span>&lt;&lt;nodes.<span class="built_in">at</span>(i)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="获得当前运行的所有话题名"><a href="#获得当前运行的所有话题名" class="headerlink" title="获得当前运行的所有话题名"></a>获得当前运行的所有话题名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ros</span>:</span>:master::TopicInfo</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">TopicInfo</span> ()</span><br><span class="line"> 	<span class="built_in">TopicInfo</span> (<span class="keyword">const</span> std::string &amp;_name, <span class="keyword">const</span> std::string &amp;_datatype)</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::string 	datatype    <span class="comment">// Datatype of the topic. </span></span><br><span class="line">	std::string 	name        <span class="comment">// Name of the topic. </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;TopicInfo&gt; ros::<span class="function">master::V_TopicInfo</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">ROSCPP_DECL <span class="keyword">bool</span>    <span class="title">getTopics</span> <span class="params">(V_TopicInfo &amp;topics)</span></span></span><br></pre></td></tr></table></figure>
<p>使用是类似的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;ros::master::TopicInfo&gt; topics;</span><br><span class="line">ros::master::<span class="built_in">getTopics</span>(topics);</span><br><span class="line"><span class="keyword">int</span> len = topics.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;topic: &quot;</span>&lt;&lt;topics.<span class="built_in">at</span>(i).name&lt;&lt;<span class="string">&quot;   type: &quot;</span></span><br><span class="line">		&lt;&lt;topics.<span class="built_in">at</span>(i).datatype&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="其他可能用到的函数"><a href="#其他可能用到的函数" class="headerlink" title="其他可能用到的函数"></a>其他可能用到的函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ros::<span class="built_in">isInitialized</span> ()    <span class="comment">// 判断ros::init()是否被调用</span></span><br><span class="line"></span><br><span class="line">ros::<span class="built_in">isStarted</span> ()	　<span class="comment">// 判断节点是否已经通过ros::start()启动</span></span><br><span class="line"></span><br><span class="line">ros::<span class="built_in">requestShutdown</span> ()　　<span class="comment">// 在节点的一个线程内要求ROS关闭</span></span><br><span class="line"></span><br><span class="line">ros::this_node::getName       <span class="comment">// 返回当前节点的名称</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">getAdvertisedTopics</span>()　　<span class="comment">//返回节点注册的话题</span></span><br><span class="line"><span class="built_in">getSubscribedTopics</span>()   <span class="comment">//返回节点订阅的主题</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">getNamespace</span>()	<span class="comment">//返回节点的命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_ASSERT</span>(a&lt;b)			<span class="comment">//同assert()，若条件不满足，程序会终止</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_BREAK</span>()				<span class="comment">//直接终止程序，报警FATAL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Get the hostname where the master runs. </span></span><br><span class="line"><span class="function">ROSCPP_DECL <span class="keyword">const</span> std::string &amp;     <span class="title">getHost</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Get the port where the master runs. </span></span></span><br><span class="line"><span class="function">ROSCPP_DECL <span class="keyword">uint32_t</span>    <span class="title">getPort</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Get the full URI to the master (eg. http://host:port/) </span></span></span><br><span class="line"><span class="function">ROSCPP_DECL <span class="keyword">const</span> std::string &amp;     <span class="title">getURI</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">ros::Time time </span>= ros::Time::<span class="built_in">now</span>()   # 获取当前时间</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/03/G9F18s6UtHMrCpc.png" alt="ros_Time_now不能在NodeHandle之前.png"></p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wuguangbin1230/article/details/76889753">ros 初始化和关闭</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/22/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E8%A7%A3%E6%9E%90ros%20init%EF%BC%88%E4%B8%80%EF%BC%89/">解析ros::init（一）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><p>在ROS程序中，初始化ROS节点是函数<code>ros::init()</code>，启动节点是实例化类<code>ros::NodeHandle</code>，这两步是ROS程序必不可少的，先后顺序不能变，否则会报错：<br><img src="https://farm8.staticflickr.com/7847/47368088421_b9e44e7b9a_b.jpg" alt=""><br>本篇分析ros::init，另一篇分析NodeHandle。</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>使用任何roscpp函数前，必须调用<code>ros::init()</code>，一般有两种形式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_node_name&quot;</span>);</span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_node_name&quot;</span>,   ros::init_options::AnonymousName);</span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_node_name&quot;</span>,   ros::init_options::NoSigintHandler);</span><br></pre></td></tr></table></figure><br>argc和argv用于处理remapping参数，使用这种形式后，在命令行中使用参数就无效了。如果还想在命令行中处理，需要在<code>ros::init</code>之后调用<code>ros::removeROSArgs()</code></p>
<p>一般只能有一个同名节点在运行，如果再运行一个，前一个节点会自动关闭。使用第二种重载就可以同时运行多个同名节点，比如<code>rviz</code>和<code>rostopic</code>就是如此，ROS会在节点名后面加上UTC时间以示区别。</p>
<p><strong>运行同一个节点还有更好的方法</strong>，比如已经运行了一个名为Pub的节点：<code>rosrun pub Pub</code>，我们指定参数<code>__name</code>可以运行同一个可执行文件，但是节点名不同：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun pub Pub __name:=newPub</span><br></pre></td></tr></table></figure></p>
<p>默认发SIGINT信号会终结节点，也就是Ctral+C会退出节点，但也可以自定义信号处理函数，前提是使用第三种重载的<code>ros::init</code>。</p>
<h3 id="ros-init-源码"><a href="#ros-init-源码" class="headerlink" title="ros::init 源码"></a>ros::init 源码</h3><p><code>ros::init</code>有三种重载形式，以最简单的一种为例<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> M_string&amp; remappings, <span class="keyword">const</span> std::string&amp; name, <span class="keyword">uint32_t</span> options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!g_atexit_registered)</span><br><span class="line">  &#123;</span><br><span class="line">    g_atexit_registered = <span class="literal">true</span>;   <span class="comment">// 状态</span></span><br><span class="line">    <span class="comment">// 注册终止函数，在调用exit()或终止main函数时关闭shutdown()函数</span></span><br><span class="line">    <span class="built_in">atexit</span>(atexitCallback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!g_global_queue)</span><br><span class="line">  &#123;</span><br><span class="line">    g_global_queue.<span class="built_in">reset</span>(<span class="keyword">new</span> CallbackQueue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//上面做了一些预处理，主要部分在下面：</span></span><br><span class="line">  <span class="keyword">if</span> (!g_initialized)   <span class="comment">// 若未初始化</span></span><br><span class="line">  &#123;</span><br><span class="line">    g_init_options = options;</span><br><span class="line">    g_ok = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    ROSCONSOLE_AUTOINIT; <span class="comment">//在console.h中的一段宏定义：Initializes the rosconsole library. </span></span><br><span class="line">    <span class="comment">// Disable SIGPIPE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIN32     <span class="comment">// 如果不是windows系统，执行</span></span></span><br><span class="line">    <span class="built_in">signal</span>(SIGPIPE, SIG_IGN);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 重点是5个init</span></span><br><span class="line">    network::<span class="built_in">init</span>(remappings);<span class="comment">//初始化网络,实现在network.cpp中</span></span><br><span class="line">    master::<span class="built_in">init</span>(remappings); <span class="comment">//初始化master</span></span><br><span class="line">    <span class="comment">// names:: namespace is initialized by this_node</span></span><br><span class="line">    this_node::<span class="built_in">init</span>(name, remappings, options); <span class="comment">//初始化当前节点</span></span><br><span class="line">    file_log::<span class="built_in">init</span>(remappings);</span><br><span class="line">    param::<span class="built_in">init</span>(remappings);</span><br><span class="line">    g_initialized = <span class="literal">true</span>;<span class="comment">//置上初始化标记</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分析一下代码，首先是注册终止函数，也就是调用exit函数时执行的回调函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atexitCallback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; !<span class="built_in">isShuttingDown</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROSCPP_LOG_DEBUG</span>(<span class="string">&quot;shutting down due to exit() or end of main() without cleanup of all NodeHandles&quot;</span>);</span><br><span class="line">    g_started = <span class="literal">false</span>; <span class="comment">// don&#x27;t shutdown singletons, because they are already destroyed</span></span><br><span class="line">    <span class="built_in">shutdown</span>();         <span class="comment">// 关闭节点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>g_global_queue</code>的定义是<code>CallbackQueuePtr g_global_queue;</code>，再查发现类型其实是一个boost共享指针：<code>typedef boost::shared_ptr&lt;CallbackQueue&gt; CallbackQueuePtr;</code>，这里是共享指针丢弃原来的指向对象，销毁掉，重新指向新new的对象</p>
<p>再往下是一个宏ROSCONSOLE_AUTOINIT，内容不必太详细看，功能就是初始化rosconsole库。</p>
<p>然后执行<code>signal(SIGPIPE, SIG_IGN);</code>，功能是收到RST包后，不要关闭节点。</p>
<p>最后就是很重要的5个init，我们一一分析</p>
<h4 id="network-init"><a href="#network-init" class="headerlink" title="network:init()"></a>network:init()</h4><p>这个函数主要就是给g_host和g_tcpros_server_port赋值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> M_string&amp; remappings)</span> <span class="comment">//该函数在init.cpp中被调用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//模块1：</span></span><br><span class="line">  M_string::const_iterator it = remappings.<span class="built_in">find</span>(<span class="string">&quot;__hostname&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (it != remappings.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    g_host = it-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    it = remappings.<span class="built_in">find</span>(<span class="string">&quot;__ip&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != remappings.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      g_host = it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//模块2</span></span><br><span class="line">  it = remappings.<span class="built_in">find</span>(<span class="string">&quot;__tcpros_server_port&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (it != remappings.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;           <span class="comment">//  尝试将对应元素的值（std::string）转化成uint16_t类型，boost 转化</span></span><br><span class="line">                <span class="comment">//  g_tcpros_server_port初始值为0</span></span><br><span class="line">      g_tcpros_server_port = boost::lexical_cast&lt;<span class="keyword">uint16_t</span>&gt;(it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (boost::bad_lexical_cast &amp; )        <span class="comment">// 如果上述类型转化发生异常，捕捉</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> ros::<span class="built_in">InvalidPortException</span>(<span class="string">&quot;__tcpros_server_port [&quot;</span> + it-&gt;second + <span class="string">&quot;] was not specified as a number within the 0-65535 range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//模块3，如果上面未能赋值，调用函数determineHost赋值</span></span><br><span class="line">  <span class="keyword">if</span> (g_host.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    g_host = <span class="built_in">determineHost</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>M_string</code>其实是<code>std::map&lt;std::string, std::string&gt;</code>，也就是标准map容器。</p>
<p><code>boost::lexical_cast</code>用于string 和数值之间的转换比如：将一个字符串”712”转换成整数712，代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;712&quot;</span>;  </span><br><span class="line"><span class="keyword">int</span> a = lexical_cast&lt;<span class="keyword">int</span>&gt;(s); </span><br><span class="line"></span><br><span class="line">s=<span class="string">&quot;1523408.78&quot;</span>;</span><br><span class="line"><span class="keyword">float</span> num = boost::lexical_cast&lt;<span class="keyword">float</span>&gt;(s);</span><br><span class="line">cout&lt;&lt;num&lt;&lt;endl;</span><br></pre></td></tr></table></figure><br>浮点数比较大时，会四舍五入用科学计数法表示．<br>这种方法的好处是：如果转换发生了意外，lexical_cast会抛出一个bad_lexical_cast异常，可以在程序中进行捕捉。</p>
<p>最后，如果之前未能给g_host成功赋值，会调用<code>determineHost</code>函数，它依次获取环境变量<code>ROS_HOSTNAME</code>和<code>ROS_IP</code>，如果没有设置这两个环境变量，就调用<code>gethostname</code>函数获取主机名，但不能取<code>localhost</code>，如果这样还不能获取到，只好返回127.0.0.1</p>
<h4 id="master-init"><a href="#master-init" class="headerlink" title="master::init()"></a>master::init()</h4><p>这个是处理主机节点<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> M_string&amp; remappings)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//构建迭代器，查找remappings中键为&quot;__master&quot;的节点。</span></span><br><span class="line">  M_string::const_iterator it = remappings.<span class="built_in">find</span>(<span class="string">&quot;__master&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (it != remappings.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    g_uri = it-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果g_uri没有被赋值（即刚刚没找到相应节点）</span></span><br><span class="line">  <span class="keyword">if</span> (g_uri.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">char</span> *master_uri_env = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER     <span class="comment">// 根据编译器使用不同函数</span></span></span><br><span class="line">      _dupenv_s(&amp;master_uri_env, <span class="literal">NULL</span>, <span class="string">&quot;ROS_MASTER_URI&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      master_uri_env = <span class="built_in">getenv</span>(<span class="string">&quot;ROS_MASTER_URI&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!master_uri_env)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">ROS_FATAL</span>( <span class="string">&quot;ROS_MASTER_URI is not defined in the environment. Either &quot;</span> \</span><br><span class="line">                 <span class="string">&quot;type the following or (preferrably) add this to your &quot;</span> \</span><br><span class="line">                 <span class="string">&quot;~/.bashrc file in order set up your &quot;</span> \</span><br><span class="line">                 <span class="string">&quot;local machine as a ROS master:\n\n&quot;</span> \</span><br><span class="line">                 <span class="string">&quot;export ROS_MASTER_URI=http://localhost:11311\n\n&quot;</span> \</span><br><span class="line">                 <span class="string">&quot;then, type &#x27;roscore&#x27; in another shell to actually launch &quot;</span> \</span><br><span class="line">                 <span class="string">&quot;the master program.&quot;</span>);</span><br><span class="line">      <span class="built_in">ROS_BREAK</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    g_uri = master_uri_env;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">    <span class="built_in">free</span>(master_uri_env);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对g_uri进行解析，把g_uri中去掉协议部分赋值给g_host，并将端口赋值给g_port。</span></span><br><span class="line">  <span class="keyword">if</span> (!network::<span class="built_in">splitURI</span>(g_uri, g_host, g_port))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_FATAL</span>( <span class="string">&quot;Couldn&#x27;t parse the master URI [%s] into a host:port pair.&quot;</span>, g_uri.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">ROS_BREAK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果没有获得环境变量<code>ROS_MASTER_URI</code>，那么节点报错退出，可见这个环境变量必不可少，最后把值赋给<code>g_uri</code>。最后的<code>splitURI</code>函数显然是一个字符串的处理函数，过程比较复杂，我们知道功能即可</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/22/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/spin%E4%B8%8EspinOnce/">spin与spinOnce</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><p>在话题发布和订阅中，消息订阅器一旦知道话题上面有消息发布，就会将消息的值作为参数传入回调函数中，把回调函数放到了一个回调函数队列中，它们的函数名一样，只是实参不一样，这就是subscribe函数的作用。但是此时还没有执行callback函数，当spinOnce函数被调用时，spinOnce就会调用回调函数队列中第一个callback函数，此时回调函数才被执行，然后等到下次spinOnce函数又被调用时，回调函数队列中第二个回调函数就会被调用，以此类推。</p>
<p>注意：因为回调函数队列的长度是有限的，如果发布数据的速度太快，spinOnce函数调用的频率太少，就会导致队列溢出，一些回调函数就会被挤掉，导致没被执行。</p>
<p>对于spin函数，一旦进入spin函数，它就不会返回了，相当于它在自己的函数里阻塞。只要回调函数队列里面有回调函数在，它就会马上去执行。如果没有的话，它就会阻塞，不会占用CPU。</p>
<font size="4" color="blue"> spin()的目的是启动一个新的线程去获取队列中的回调函数并调用它，而回调函数本身不是线程。  </font>还有单线程，同步多线程和异步多线程等情况，这些都有内置的语句。所有用户的调用程序将从 ros::spin()开始调用。只到节点关闭（ros::shutdown() 或者 Ctrl-C），ros::spin()才有返回值。

`ros::spin`其实就相当于
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Do Something</span></span><br><span class="line">    ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
发布和订阅话题都不一定要使用spinOnce()，什么时候用ros::spin()和ros::spinOnce()呢，如果仅仅只是响应topic，就用ros::spin()。当程序中除了响应回调函数还有其他重复性工作的时候，那就在循环中做那些工作，然后调用ros::spinOnce()

## spinOnece的注意

<font size =4 color = blue> 我仔细试验了这几个参数，没有发现缺失回调函数的情况，一般不需要太注意</font>

<p>ros::spinOnce()的用法相对来说很灵活，但往往需要考虑调用消息的时机，调用频率，以及消息池的大小。</p>
<p>比如下面的程序，消息送达频率为10Hz，<code>ros::spinOnce()</code>的调用频率为5Hz，那么消息池的大小就一定要大于2，才能保证数据不丢失，无延迟，跟这里的发布消息池容量无关</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送频率为10Hz(1秒发10次)  消息池最大容量1000。</span></span><br><span class="line">ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;(<span class="string">&quot;chatter&quot;</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 发布消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ros::Subscriber sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;chatter&quot;</span>, <span class="number">2</span>, chatterCallback);</span><br><span class="line"><span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*...TODO...*/</span> </span><br><span class="line">    ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下源码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spinOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  g_global_queue-&gt;<span class="built_in">callAvailable</span>(ros::<span class="built_in">WallDuration</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>调用队列中的所有回调函数，如果一个回调还没有准备好调用，再推回队列</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/16/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/">发布和订阅</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><p>话题通信的媒介是消息，消息的产生和消费是解偶的，二者之间没有强行绑定的关系，ROS节点不在乎是谁在发布Topic，哪个节点在订阅Topic，它只关心topic的名字以及当前的消息类型时候和要求的匹配。所以说话题通信是<strong>多对多</strong>的方式</p>
<p>publisher注册时的消息类型,如果和发布时的消息类型不一致,编译不报错,运行报错</p>
<p>消息是以Boost共享指针的形式传输，我们可以存储它而又不需要复制数据。回调函数最常用的原型是这样的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> std_msgs::StringConstPtr&amp; str)</span></span></span><br></pre></td></tr></table></figure><br>其实它就是<code>void callback(const boost::shared_ptr&lt;std_msgs::String const&gt;&amp;);</code>，还有以下几种：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(boost::shared_ptr&lt;std_msgs::String <span class="keyword">const</span>&gt;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(std_msgs::StringConstPtr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(std_msgs::String::ConstPtr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> std_msgs::String&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(std_msgs::String)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> ros::MessageEvent&lt;std_msgs::String <span class="keyword">const</span>&gt;&amp;)</span></span>;</span><br></pre></td></tr></table></figure><br>MessageEvent类允许你在订阅的回调函数内获取信息的元数据。</p>
<p>其他常用的ros::Subscriber函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意： 只能判断话题是否发布，不能判断有没有发布消息</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> 	<span class="title">getNumPublishers</span> <span class="params">()</span> <span class="keyword">const</span>    <span class="comment">//获得连接订阅者的发布者个数</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> 	<span class="title">getTopic</span> <span class="params">()</span> <span class="keyword">const</span>	<span class="comment">//获得所订阅的话题</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> 	<span class="title">getNumSubscribers</span> <span class="params">()</span> <span class="keyword">const</span>　　<span class="comment">//获得连接发布者的订阅者个数</span></span></span><br></pre></td></tr></table></figure></p>
<p>订阅话题后，回调函数的参数类型必须是对应话题的消息类型，否则能订阅成功但不运行回调。</p>
<h2 id="发布者的回调函数"><a href="#发布者的回调函数" class="headerlink" title="发布者的回调函数"></a>发布者的回调函数</h2><p>用于检测是否有订阅者<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ros::Publisher pub = nh.advertise&lt;std_msgs::Int8&gt;(<span class="string">&quot;topic&quot;</span>, <span class="number">50</span>, connectCb,disconnectCb);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数如下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectCb</span><span class="params">(<span class="keyword">const</span> ros::SingleSubscriberPublisher&amp; pub)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;topic Name: %s&quot;</span>, pub.<span class="built_in">getTopic</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Subscriber Name: %s&quot;</span>, pub.<span class="built_in">getSubscriberName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disconnectCb</span><span class="params">(<span class="keyword">const</span> ros::SingleSubscriberPublisher&amp; pub)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;disconnectCb&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ROS的回调函数里定义<code>count</code>变量，居然报错<code>ambiguous</code>，看来以后最好不用<code>count</code>变量<br><img src="https://s2.loli.net/2021/12/27/Hrg9ENtqQsmKX7j.png" alt="image-20211227101811232"></p>
<h2 id="特殊需求"><a href="#特殊需求" class="headerlink" title="特殊需求"></a>特殊需求</h2><p>有时需要在订阅者的回调函数中发布消息,而且只发布一次,这时没必要用service混合topic,用static变量就可以做到:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ros::Publisher *pubPtr;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> published = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> std_msgs::Int8ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = msg-&gt;data;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;msg: %d&quot;</span>, num);</span><br><span class="line">    std_msgs::String str;</span><br><span class="line">    str.data = std::<span class="built_in">string</span>(<span class="built_in">to_string</span>(num) );</span><br><span class="line">    <span class="keyword">if</span>(!published &amp;&amp; num&gt;<span class="number">8</span>)   <span class="comment">// 在num&gt;8时发布一次,以后再也不发布</span></span><br><span class="line">    &#123;</span><br><span class="line">      pubPtr-&gt;<span class="built_in">publish</span>(str);</span><br><span class="line">      published = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv, <span class="string">&quot;Sub&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">    ros::Subscriber sub = nh.subscribe&lt;std_msgs::Int8&gt;(<span class="string">&quot;topic&quot;</span>,<span class="number">20</span>,callback);</span><br><span class="line">    ros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(<span class="string">&quot;new&quot;</span>,<span class="number">50</span>,<span class="literal">false</span>);</span><br><span class="line">    pubPtr = &amp;pub;</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="让订阅者停止订阅"><a href="#让订阅者停止订阅" class="headerlink" title="让订阅者停止订阅"></a>让订阅者停止订阅</h3><p>ROS官方有这么一段话：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function   subscribe() 　returns a Subscriber object that you must hold on to until you want to unsubscribe. When all copies of the Subscriber object go out of scope, this callback will automatically be unsubscribed from this topic.</span><br><span class="line"></span><br><span class="line">function  shutdown()   Unsubscribe the callback associated with this Subscriber.</span><br><span class="line">This method usually does not need to be explicitly called, as automatic shutdown happens when all copies of this Subscriber go out of scope</span><br><span class="line">This method overrides the automatic reference counted unsubscribe, and immediately unsubscribes the callback associated with this Subscriber</span><br></pre></td></tr></table></figure><br>根据说明，有以下三种方法：</p>
<ol>
<li><p>一般让订阅者停止订阅的方法是等<code>subscribe()</code>生成的订阅者对象出作用域．</p>
</li>
<li><p>另一种方法就是explicitly调用<code>shutdown()</code>，典型方法是声明订阅者对象为全局变量，在回调函数中满足某条件时，对此对象调用<code>shutdown()</code>，但这样会直接退出程序，并不好</p>
</li>
<li><p>第三种方法其实与第二种类似，声明一个bool全局变量ok，订阅时执行</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!ok)</span><br><span class="line">&#123;</span><br><span class="line">    ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在回调函数中满足某条件时，让ok=true</p>
<h2 id="queue-size和buff-size"><a href="#queue-size和buff-size" class="headerlink" title="queue_size和buff_size"></a>queue_size和buff_size</h2><p>发布者的原型是这样的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Publisher ros::NodeHandle::<span class="built_in">advertise</span>(<span class="keyword">const</span> std::string &amp; topic,</span><br><span class="line">    <span class="keyword">uint32_t</span>    queue_size,</span><br><span class="line">    <span class="keyword">bool</span>    latch = <span class="literal">false</span> </span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>queue_size    Maximum number of outgoing messages to be queued for delivery to subscribers。 消息队列是为了缓存发布节点发布的消息，一旦队列中消息的数量超过了queue_size，那么最先进入队列的（最老的）消息被舍弃。</li>
<li>latch (optional) If true, the last message published on this topic will be saved and sent to new subscribers when they connect</li>
</ul>
<p>订阅者<code>Subscriber ros::NodeHandle::subscribe</code>函数里也有一个<code>queue_size</code>： Number of incoming messages to queue up for processing，消息队列是为了缓存节点接收到的信息，一旦自己处理的速度过慢，接收到的消息数量超过了queue_size，那么最先进入队列的（最老的）消息会被舍弃。</p>
<p>机器人应用中难免会遇到运算起来很费时间的操作，比如图像的特征提取、点云的匹配等等。有时候，我们需要在ROS的Subscriber的Callback回调函数中进行这些费时的操作。如果我们要是没有取舍的对于每个消息都调用一次回调函数，那么势必会导致计算越来越不实时，很有可能当下在处理的还是几秒以前的数据，之前的消息被舍弃了。所以，如果我们想只处理最新的消息，实际上只需要把两个<code>queue_size</code>都设置成1，那么系统不会缓存数据，自然处理的就是最新的消息。</p>
<p><code>rospy</code>的订阅者还有个<code>buff_size</code>参数，要设置一个很大很大的数，这个缓冲区的大小是指消息队列使用的缓冲区物理内存空间大小。如果这个空间小于一个消息所需要的空间，比如消息是一副图片或者一帧点云，数据量超过了缓冲区的大小。这个时候为了保证通信不发生错误，就会触发网络通信的保护机制，TCP的Buffer会为你缓存消息。</p>
<p>但是roscpp里面没有<code>buff_size</code>参数，它获得 incoming message的大小，分配所需的缓冲区大小，然后一次读取整个incoming message</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37082966/article/details/97172729">queue_size和buff_size的理解</a><br><a target="_blank" rel="noopener" href="https://answers.ros.org/question/220502/image-subscriber-lag-despite-queue-1/">ROS anwser的解释</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/16/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/ROS%E5%AE%9A%E6%97%B6%E5%99%A8/">ROS定时器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a></span><div class="content"><p>roscpp的定时器会计划在某一速率下执行一次回调操作，在订阅或服务中的回调函数队列机制中使用。</p>
<h3 id="创建定时器"><a href="#创建定时器" class="headerlink" title="创建定时器"></a>创建定时器</h3><p>通过ros::NodeHandle::createTimer()创建: <code>ros::Timer timer = nh.createTimer(ros::Duration(0.1), timerCallback);</code>  其实有多个重载，这是用的比较多的一种。</p>
<p>回调函数只能是这种形式: <code>void callback(const ros::TimerEvent&amp;);</code><br>ros::TimerEvent结构体作为参数传入，它提供时间的相关信息，对于调试和配置非常有用。ros::TimerEvent结构体说明：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ros::Time last_expected 上次回调期望发生的时间</span><br><span class="line">ros::Time last_real 上次回调实际发生的时间</span><br><span class="line">ros::Time current_expected 本次回调期待发生的时间</span><br><span class="line">ros::Time current_real 本次回调实际发生的时间</span><br><span class="line">ros::WallTime profile.last_duration 上次回调的时间间隔（结束时间-开始时间），是wall-clock时间。</span><br></pre></td></tr></table></figure></p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>比如某些情况下，我们需要一直监视机器人的里程计数据状态，并在某个界面上显示出来。这种情况下可以用到定时器，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">odomTimerCb</span><span class="params">(<span class="keyword">const</span> ros::TimerEvent&amp; e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">odomSubCb</span><span class="params">(<span class="keyword">const</span> nav_msgs::OdometryConstPtr&amp; m)</span></span>;</span><br><span class="line">ros::Timer　odomTimer ;</span><br><span class="line">riki_msgs::HealthStatus msg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;healthStatus&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    odomTimer = nh.<span class="built_in">createTimer</span>(ros::<span class="built_in">Duration</span>(<span class="number">5</span>), odomTimerCb);</span><br><span class="line">    ros::Subscriber odomSub = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;odom&quot;</span>, <span class="number">1000</span>, odomSubCb);</span><br><span class="line"></span><br><span class="line">    ros::Publisher pub = nh.advertise&lt;riki_msgs::HealthStatus&gt;(<span class="string">&quot;healthStatus&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        pub.<span class="built_in">publish</span>(msg);</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">odomTimerCb</span><span class="params">(<span class="keyword">const</span> ros::TimerEvent&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    msg.odomData = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">odomSubCb</span><span class="params">(<span class="keyword">const</span> nav_msgs::OdometryConstPtr&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    msg.odomData = <span class="literal">true</span>;</span><br><span class="line">    odomTimer.<span class="built_in">stop</span>();</span><br><span class="line">    odomTimer.<span class="built_in">start</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未发布odom主题时，不会进入订阅者的回调函数<code>odomSubCb</code>，只进入定时器的回调<code>odomTimerCb</code>，此时消息成员<code>odomData</code>一直是false。<br>发布odom后，进入订阅者回调，此时<code>odomData</code>成为true，此时需要先停止计时器再打开。如果不停止，还会进入计时器回调，让消息成员赋值为false，实际造成赋值混乱。但是还得打开，因为一旦<code>odom</code>话题关闭了，就不会再进入订阅者回调，需要设法调用计时器回调，赋值false。订阅<code>odom</code>话题成功再打开计时器后，不会进入计时器回调。</p>
<p>参考: <a target="_blank" rel="noopener" href="https://www.ncnynl.com/archives/201702/1296.html">ROS与C++入门教程-Timers</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/16/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%8F%AA%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85%E4%B8%80%E6%AC%A1%E6%B6%88%E6%81%AF/">ROS只发布和订阅一次消息</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><h3 id="只发布一次消息"><a href="#只发布一次消息" class="headerlink" title="只发布一次消息"></a>只发布一次消息</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;op_motor&quot;</span>);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">ros::Publisher pub = nh.advertise&lt;std_msgs::Bool&gt;(<span class="string">&quot;Switch&quot;</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//不必判断订阅者，直接等待１秒钟，只发布一次</span></span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">pub.<span class="built_in">publish</span>(msg); </span><br></pre></td></tr></table></figure>
<p>只发布一次消息就简单了，不必用while循环，直接发布就可以，但是最好也延时一次，防止订阅者的网络状况不好，当然如果不考虑有没有订阅者就不必延时了，不过这样没什么意义。</p>
<p><br></p>
<h3 id="ROS只订阅一次消息"><a href="#ROS只订阅一次消息" class="headerlink" title="ROS只订阅一次消息"></a>ROS只订阅一次消息</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;node&quot;</span>);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">boost::shared_ptr&lt;riki_msgs::Battery <span class="keyword">const</span>&gt; Edge;    <span class="comment">// 必须有const</span></span><br><span class="line">Edge = ros::topic::waitForMessage&lt;riki_msgs::Battery&gt;(<span class="string">&quot;BMS&quot;</span>,ros::<span class="built_in">Duration</span>(<span class="number">0.1</span>));</span><br><span class="line"><span class="keyword">if</span>(Edge != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    riki_msgs::Battery  bat = *Edge;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;battery:&quot;</span>&lt;&lt;  bat.Ah  &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;battery:&quot;</span>&lt;&lt;  Edge-&gt;Ah  &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;no message from topic BMS&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p><font color = blue size=4> waitForMessage是等待一次消息，造成的网络传输会出现延时。如果是获得消息后再发布，新话题的发布频率会明显下降  </font> 为了保证发布频率，还是尽量使用<code>spin()</code></p>
<p>这里用到的函数是<code>ros::topic::waitForMessage</code>，没有涉及回调函数，它有4个重载，常用的是两个:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class M&gt; boost::shared_ptr&lt; M <span class="keyword">const</span> &gt;   <span class="title">waitForMessage</span> <span class="params">(<span class="keyword">const</span> std::string &amp;topic, ros::Duration timeout)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class M&gt; boost::shared_ptr&lt; M <span class="keyword">const</span> &gt;  <span class="title">waitForMessage</span> <span class="params">(<span class="keyword">const</span> std::string &amp;topic, ros::NodeHandle &amp;nh)</span></span></span><br></pre></td></tr></table></figure><br>第一个是订阅话题topic，假如没有发布话题，那么等待时间timeout，超时后程序继续执行；第二个是如果没有发现话题topic，会一直阻塞，不能向下运行，除非执行<code>rosnode kill</code>。前一个用的比较多，注意时间不要设置太短，否则可能因为网络状况不好而订阅失败。</p>
<p>返回类型一看就知道是模板类的Boost共享指针，从这里就可以看出， <font color = blue size=4>消息是以Boost共享指针的形式传输，我们可以存储它而又不需要复制数据</font>，<code>waitForMessage</code>就是返回了订阅到的消息，取指向就可以获得消息成员，也可以直接用指针获得消息成员。<br><strong>注意模板类型有const</strong>，否则不符合重载声明</p>
<p>参考:</p>
<p><a target="_blank" rel="noopener" href="https://answers.ros.org/question/11167/how-do-i-publish-exactly-one-message/">How do I publish exactly one message</a><br><a target="_blank" rel="noopener" href="http://docs.ros.org/jade/api/roscpp/html/namespaceros_1_1topic.html">ros::topic Namespace</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/07/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/%E8%B6%85%E5%A3%B0%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8%E5%92%8C%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E5%99%A8%E7%9A%84%E6%8E%A7%E5%88%B6/">超声波传感器和电机驱动器的控制</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/">ROS机器人</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2019/01/07/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/%E8%B6%85%E5%A3%B0%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8%E5%92%8C%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E5%99%A8%E7%9A%84%E6%8E%A7%E5%88%B6/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/12/15/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/ROS%E5%AE%89%E8%A3%85%E5%92%8C%E7%BC%96%E8%AF%91%E7%AD%89%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">安装和编译等常见问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a></span><div class="content"><h3 id="安装ROS报错"><a href="#安装ROS报错" class="headerlink" title="安装ROS报错"></a>安装ROS报错</h3><p>Ubuntu 16.04 安装ROS kinetic报错<code>Depends: ros-kinetic-desktop but it is not going to be installed</code></p>
<ol>
<li>删除ros-latest.list</li>
<li>修改源: <code>vim /etc/apt/sources.list</code>，改为下面内容，也就是中科大的安装源:</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb http://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>
<p>结果未变，再运行<code>sudo apt-get -f install</code>后安装了一个软件包，再安装<code>ros-kinetic-desktop-full</code>正常了</p>
<h3 id="安装时找不到软件包"><a href="#安装时找不到软件包" class="headerlink" title="安装时找不到软件包"></a>安装时找不到软件包</h3><p><img src="https://i.loli.net/2019/06/20/5d0b26a83905675577.png" alt=""><br>从报错的内容找到安装包的地址，直接下载，有时一个软件包还有其他依赖包，都要下载<br><img src="https://i.loli.net/2019/06/20/5d0b22d9b724889992.png" alt=""></p>
<h2 id="编译缺少-libvtkproj4"><a href="#编译缺少-libvtkproj4" class="headerlink" title="编译缺少 libvtkproj4"></a>编译缺少 libvtkproj4</h2><p>编译时报错: <code>No rule to make target &#39;/usr/lib/x86_64-linux-gnu/libvtkproj4-6.2.so.6.2.0&#39;</code></p>
<p>解决方法:  <code>sudo ln -s /usr/lib/x86_64-linux-gnu/libvtkCommonCore-6.2.so /usr/lib/x86_64-linux-gnu/libvtkproj4-6.2.so.6.2.0</code></p>
<h3 id="E-无法定位软件包-ros-kinetic-map-server"><a href="#E-无法定位软件包-ros-kinetic-map-server" class="headerlink" title="E: 无法定位软件包 ros-kinetic-map-server"></a>E: 无法定位软件包 ros-kinetic-map-server</h3><p>在<strong>软件和更新</strong>的<code>其他软件</code>里添加两项:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://packages.ros.org/ros/ubuntu xenial main</span><br><span class="line">deb http://packages.ros.org/ros-shadow-fixed/ubuntu xenial main</span><br></pre></td></tr></table></figure><br>然后执行<code>sudo apt-get update</code>，应该就能安装了。<br>在<code>/etc/apt/sources.list</code>里添加也是同样效果，但两个地方不能都添加，否则update时会报错</p>
<h3 id="without-authentic"><a href="#without-authentic" class="headerlink" title="without authentic"></a>without authentic</h3><p>有时安装某个包出现下面情况，<br><img src="https://i.loli.net/2020/03/10/IRAdK6sqvbEFaXN.png" alt="without authentic.png"><br>在命令最后添加<code>--allow-unauthenticated</code>即可</p>
<h3 id="安装ROS包出现404-Not-Found"><a href="#安装ROS包出现404-Not-Found" class="headerlink" title="安装ROS包出现404  Not Found"></a>安装ROS包出现404  Not Found</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Err:1 http://packages.ros.org/ros/ubuntu &lt;YOUR_UBUNTU_VERSION&gt;/main amd64 &lt;SOME_ROS_PKG&gt; amd64 0.13.3-0xenial-20190320-132757-0800</span><br><span class="line">  404  Not Found [IP: 64.50.236.52 80]</span><br></pre></td></tr></table></figure>
<p>运行<code>sudo apt update</code>也无效，打开上面的网页后，发现安装包的版本是更新的，看来我们的安装没有更新。<br>最后发现在2019年夏天，ROS官方更改了安装的Key，也就是第一次安装ROS时设置的Key。需要换成新的Key，步骤如下：</p>
<ul>
<li><p>sudo apt-key del 421C365BD9FF1F717815A3895523BAEEB01FA116  (Kinetic及以后的版本)</p>
</li>
<li><p>sudo -E apt-key adv —keyserver ‘hkp://keyserver.ubuntu.com:80’ —recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</p>
</li>
<li><p>sudo apt clean</p>
</li>
<li>sudo apt update</li>
</ul>
<p>现在可以正常安装了，如果以后安装ROS，需要用这个新的Key，目前网上很多旧资料还是以前那个Key</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://answers.ros.org/question/325039/apt-update-fails-cannot-install-pkgs-key-not-working/">apt update fails / cannot install pkgs</a><br><a target="_blank" rel="noopener" href="https://www.cxyzjd.com/article/heart_hang/95043542">ROS报错“An error occurred during the signature verification”的解决办法</a></p>
<h3 id="找不到-deb"><a href="#找不到-deb" class="headerlink" title="找不到***.deb"></a>找不到<code>***.deb</code></h3><p>有时候我们解决了上面的问题，还是会出现下载ros包出现找不到的错误，这是因为ROS的包大部分都是在更新的，比如robot_state_publisher在2020年1月就更新了，如果没有apt-get update，是下载不到的</p>
<h3 id="roscore报错"><a href="#roscore报错" class="headerlink" title="roscore报错"></a>roscore报错</h3><p>安装完ROS后，运行roscore报错<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last): File &quot;/opt/ros/groovy/lib/python2.7/dist-packages/roslaunch/__init__.py&quot;, line 230, in main write_pid_file(options.pid_fn, options.core, options.port) File &quot;/opt/ros/groovy/lib/python2.7/dist-packages/roslaunch/__init__.py&quot;, line 106, in write_pid_file with open(pid_fn, &quot;w&quot;) as f: IOError: [Errno 13] Permission denied: &#x27;/home/user/.ros/roscore-11311.pid&#x27;</span><br></pre></td></tr></table></figure><br>注意<code>rosdep update</code>不要用sudo，解决方法：<code>sudo rosdep fix-permissions</code>，然后<code>rosdep update</code></p>
<h2 id="roscore报错-2"><a href="#roscore报错-2" class="headerlink" title="roscore报错 2"></a>roscore报错 2</h2><p>在一堆报错的最后是:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InvalidURL: URL can<span class="string">&#x27;t contain control characters. &#x27;</span>192.168.1.35 <span class="string">&#x27; (found at least &#x27;</span> <span class="string">&#x27;)</span></span><br></pre></td></tr></table></figure><br>看上去是IP最后多了个空格，改了<code>MASTER_URI</code>不起作用，最后发现问题是<code>ROS_IP</code> 和 <code>ROS_HOME</code>,不要再写成<code>hostname -I</code>，写成<code>192.168.1.35</code></p>
<h2 id="roscore报错-3"><a href="#roscore报错-3" class="headerlink" title="roscore报错 3"></a>roscore报错 3</h2><p><img src="https://i.loli.net/2021/10/19/HfSe6T5qnEivCaB.png" alt="roscore启动失败"><br>原因是因为ROS1支持的是Python2.7，而我之前将Ubuntu自带的Python升级到了3.8，也就是默认版本改变了，所以导致了相关的错误。  <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45378779/article/details/102905841">解决方法</a><br>改回来之后，有些程序可能还是需要python3.8，这时运行<code>python3.8 file.py</code>，可能会报错<code>no module named rospkg</code> 和 <code>no module named pydot</code>，所以需要<code>pip install rospkg pydot</code></p>
<h3 id="liborocos-kdl-1-3-0"><a href="#liborocos-kdl-1-3-0" class="headerlink" title="liborocos-kdl_1.3.0"></a>liborocos-kdl_1.3.0</h3><p><a target="_blank" rel="noopener" href="https://ubuntu.pkgs.org/16.04/ubuntu-universe-i386/liborocos-kdl1.3_1.3.0+dfsg-1_i386.deb.html">liborocos-kdl1.3_1.3.0的下载地址</a></p>
<h3 id="rosbash出错"><a href="#rosbash出错" class="headerlink" title="rosbash出错"></a>rosbash出错</h3><p><img src="https://i.loli.net/2020/03/12/WBcXvI1h8gpmOJA.png" alt="rosbash出错"><br><code>source setup.bash</code>出现的错误，发现我用的是zsh，换了之后正常</p>
<h3 id="rosdep-init报警"><a href="#rosdep-init报警" class="headerlink" title="rosdep init报警"></a>rosdep init报警</h3><p><img src="https://i.loli.net/2020/03/12/wTezaptWXlkDiNL.png" alt="rosdep init"><br>这是因为之前运行过了，可以无视这个问题</p>
<h3 id="rosrun-Couldn’t-find-executable-named-……"><a href="#rosrun-Couldn’t-find-executable-named-……" class="headerlink" title="[rosrun] Couldn’t find executable named ……"></a>[rosrun] Couldn’t find executable named ……</h3><p><img src="https://c2.staticflickr.com/2/1868/30805780148_db59e627f5_b.jpg" alt=""></p>
<h3 id="rosrun出错"><a href="#rosrun出错" class="headerlink" title="rosrun出错"></a>rosrun出错</h3><p><img src="https://c2.staticflickr.com/2/1862/44676479061_f26db9633a_b.jpg" alt=""><br>环境变量没设置好，应当是IP和端口组合</p>
<h3 id="编译出错"><a href="#编译出错" class="headerlink" title="编译出错"></a>编译出错</h3><p><img src="https://c2.staticflickr.com/2/1953/31877502238_b9bbbfaa4a_b.jpg" alt=""><br>对用到的某个文件没有给权限，找到执行<code>chmod 755</code>即可</p>
<h3 id="rosnode-list无结果"><a href="#rosnode-list无结果" class="headerlink" title="rosnode list无结果"></a>rosnode list无结果</h3><p><code>roscore</code>和<code>rosrun</code>可以正常运行，但是<code>rosnode list</code>只有<code>rosout</code>，<code>rostopic list</code>没有任何话题。无法用命令对节点和话题操作，可能是通信问题。原因不明，重启电脑后正常。</p>
<h3 id="编译rviz出错"><a href="#编译rviz出错" class="headerlink" title="编译rviz出错"></a>编译rviz出错</h3><p><img src="https://c1.staticflickr.com/5/4806/46407510602_e90cfbd218_b.jpg" alt=""><br>没有安装yaml-cpp或者版本不对，因为rviz读取PersistentSettings文件时需要这个库，下载0.5.1版本的yaml，把之前安装的yaml删掉，重新编译安装。编译生成的几个文件在<code>/usr/local/lib</code>和<code>/usr/local/include</code>，如果找不全，就先用现在的版本再编译一遍就知道了</p>
<h3 id="Lost-sync-with-device-restarting"><a href="#Lost-sync-with-device-restarting" class="headerlink" title="Lost sync with device, restarting"></a>Lost sync with device, restarting</h3><p><img src="https://i.loli.net/2019/08/08/lZaQ5C9mVL7yGvD.png" alt=""><br>启动<code>bringup.launch</code>，偶尔会出现这个错误，这是下位机和ROS通讯失败造成的，报错在rosserial，很少发生</p>
<h3 id="Could-NOT-find-SDL-missing-SDL-LIBRARY-SDL-INCLUDE-DIR"><a href="#Could-NOT-find-SDL-missing-SDL-LIBRARY-SDL-INCLUDE-DIR" class="headerlink" title="Could NOT find SDL (missing: SDL_LIBRARY SDL_INCLUDE_DIR)"></a>Could NOT find SDL (missing: SDL_LIBRARY SDL_INCLUDE_DIR)</h3><p>在编译<code>map_server</code>时出错，是缺少了库文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libsdl-image1.2-dev</span><br><span class="line">sudo apt-get install libsdl-dev</span><br></pre></td></tr></table></figure></p>
<h3 id="缺少某个包"><a href="#缺少某个包" class="headerlink" title="缺少某个包"></a>缺少某个包</h3><p>使用<code>catkin_make</code>时，如果缺某个包，会提示缺<code>*Config.cmake</code>文件，平时都会使用<code>apt install</code>直接安装这个包，这并不是只添加了<code>*Config.cmake</code>文件，而是有一系列文件，所以不能直接从其他电脑复制。<br><img src="https://i.loli.net/2021/10/30/Kv5PZoqEVGUatkx.png" alt=""></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/12/15/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/rosparam%E4%B8%8E%E5%8F%82%E6%95%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/">rosparam与参数服务器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a></span><div class="content"><p>机器人的参数一般会提前设置好，这些参数都会放在yaml文件里，但有些参数是需要动态改变的，调试导航时尤其如此。于是ROS提供了rosparam命令和参数服务器这两个工具。<code>rosparam</code>命令的方便之处在于它可以直接读取yaml文件中的参数，而不必自己找第三方库去文件中读取。</p>
<p>一般在package的文件夹里会建一个<code>param</code>文件夹，也就是与<code>launch</code>和<code>msg</code>同一级，yaml文件就放在这个<code>param</code>文件夹里。</p>
<p>rosparam dump    # 保存参数到一个文件</p>
<p>使用<code>rosparam load file.yaml</code>命令将多个参数加载到参数服务器，在用到时会从服务器中获取。但实际上，这个命令直接用得不多。要将一个yaml文件中的参数在节点启动时都加载到参数服务器，一般是在launch文件中使用<code>rosparam</code>标签:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;$(find turtlebot_navigation)/param/move_base_params.yaml&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;$(arg custom_param_file)&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><br>加载完成后，可以使用一些调试性的命令了。用<code>rosparam list</code>查看所有参数。可以用<code>rosparam get param</code>查看某参数的值，用<code>rosparam set param value</code>设定参数的值。另外还可以用<code>rosparam delete param</code>删除某个参数。</p>
<p>使用<code>rosparam get</code>时要注意，参数名称不只是yaml文件中的名称，而是一个完整名称，比如<code>.yaml</code>中是这样的:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TrajectoryPlannerROS:</span><br><span class="line">  int_param: 2</span><br><span class="line">  max_vel_x: 0.15</span><br></pre></td></tr></table></figure></p>
<p>要获得<code>max_vel_x</code>的值，命令是<code>rosparam get /move_base/TrajectoryPlannerROS/max_vel_x</code>，也就是<code>/node/tag/param</code><br><img src="https://c1.staticflickr.com/5/4819/46282089562_a049538b6e_b.jpg" alt=""></p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>启动ROS节点后, 用<code>rosparam get param</code>可获知各个参数值，而且发现在关掉所有节点后，仍然能用<code>rosparam get</code>获得参数值，可见它被存到参数服务器里了</p>
<h3 id="程序中的param"><a href="#程序中的param" class="headerlink" title="程序中的param"></a>程序中的param</h3><p>加载参数的方法其实有三种，除了上面说的直接用<code>rosparam load</code>命令和launch文件中使用load外，还可以在程序中使用<code>param</code>和<code>setParam</code>,<code>getParam</code>函数，这里和yaml文件就没关系了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::string s;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">n.<span class="built_in">getParam</span>(<span class="string">&quot;string_param&quot;</span>, s);</span><br><span class="line">pn.<span class="built_in">getParam</span>(<span class="string">&quot;int_param&quot;</span>, num);</span><br><span class="line">n.<span class="built_in">setParam</span>(<span class="string">&quot;string_param&quot;</span>, <span class="string">&quot;hehe&quot;</span>);</span><br><span class="line">pn.<span class="built_in">setParam</span>(<span class="string">&quot;int_param&quot;</span>, <span class="number">222</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n.param&lt;std::string&gt;(<span class="string">&quot;string_param&quot;</span>, s, <span class="string">&quot;haha&quot;</span>);</span><br><span class="line">pn.param&lt;<span class="keyword">int</span>&gt;(<span class="string">&quot;int_param&quot;</span>, num, <span class="number">666</span>)</span><br></pre></td></tr></table></figure>
<p>getParam()函数可以从参数服务器获取参数值。如果成功，变量s和num的值将会被修改为参数值，函数返回true；如果不成功（譬如参数服务器没有设置这个参数），变量s和num将保持原值，函数会返回false。setParam()就是设置参数的值了。param()函数从参数服务器取参数值给变量。如果无法获取，则将默认值赋给变量，和param()函数的区别是还提供了一个默认值。</p>
<p>还有<code>ros::NodeHandle::hasParam()</code>和<code>ros::NodeHandle::deleteParam()</code>函数，不过用的不多</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>使用yaml文件时，一定要注意格式的正确，但是<strong>最好不要用-符号，也就是不要用数组项，否则可能出问题</strong>，之前尝试使用一个第三方库读取yaml文件时，总是读取失败，发现只有加上-符号，也就是将参数作为数组项后才能正常读取。但再用<code>rosparam get</code>读取这个文件中的参数就会出错，结果获得的全是默认值，不是当前值。用<code>rosparam list</code>会发现加载的参数不全，原因是yaml文件中这样编辑:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TrajectoryPlannerROS:</span><br><span class="line">  -name: value</span><br><span class="line">  int_param: 2</span><br><span class="line">  max_vel_x: 0.15</span><br></pre></td></tr></table></figure><br>不要加<code>-name</code>一行，也就是反而不能使用标准的yaml格式</p>
<p>参考:<a target="_blank" rel="noopener" href="http://wiki.ros.org/roscpp_tutorials/Tutorials/Parameters">Using Parameters in roscpp</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/12/05/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/%E8%A7%A3%E6%9E%90yaml/">解析yaml</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/">第三方库</a></span><div class="content"><p>YAML最基本，最常用的一些使用格式：<br>首先YAML中允许表示三种格式，分别是常量值，对象和数组<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://www.wolfcode.cn</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">http://www.wolfcode.cn</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">120.168</span><span class="number">.117</span><span class="number">.21</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">120.168</span><span class="number">.117</span><span class="number">.22</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">120.168</span><span class="number">.117</span><span class="number">.23</span></span><br><span class="line"><span class="comment">#常量</span></span><br><span class="line"><span class="attr">pi:</span> <span class="number">3.14</span>   <span class="comment">#定义一个数值3.14</span></span><br><span class="line"><span class="attr">hasChild:</span> <span class="literal">true</span>  <span class="comment">#定义一个boolean值</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">&#x27;Hello YAML&#x27;</span>   <span class="comment">#定义一个字符串</span></span><br></pre></td></tr></table></figure></p>
<p>读YAML的最好方法是使用Python的yaml库<code>PyYAML</code>，到<a target="_blank" rel="noopener" href="https://pyyaml.org/wiki/PyYAMLDocumentation">官网</a>下载安装后，可以先运行测试程序看是否成功。<br>读取程序如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml,os</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;test.yaml&quot;</span>)</span><br><span class="line">y = yaml.load(f,Loader=yaml.FullLoader)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> y</span><br></pre></td></tr></table></figure><br>运行后，结果：<br><img src="https://live.staticflickr.com/65535/47751988322_72c2646b97_b.jpg" alt=""></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/43/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/43/">43</a><span class="page-number current">44</span><a class="page-number" href="/page/45/">45</a><span class="space">&hellip;</span><a class="page-number" href="/page/50/">50</a><a class="extend next" rel="next" href="/page/45/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/02/18/exLTfbM3uFOq5SV.png)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>