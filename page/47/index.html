<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">659</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">55</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/25/%E6%BF%80%E5%85%89SLAM/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88/%E4%BD%BF%E7%94%A8robot_pose_ekf%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88/">修改robot_pose_ekf实现里程计融合IMU</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88/">多传感器融合</a></span><div class="content"><p>Each source gives a pose estimate and a covariance. The sources operate at different rates and with different latencies. A source can appear and disappear over time, and the node will automatically detect and use the available sensors </p>
<p>给滤波器节点提供信息的所有传感器源都有自己的参考坐标系，并且随着时间推移都可能出现漂移现象。因此，每个传感器发出来的绝对位姿不能直接对比。 </p>
<p><code>robot_pose_ekf</code>使用每个传感器的相对位姿差异来更新扩展卡尔曼滤波器，用松耦合方式融合不同传感器信息实现位姿估计。</p>
<p>在位姿本身上发布协方差是没有用的，而是传感器源发布协方差如何随时间变化，即速度的协方差。使用对世界的观测（例如，测量到已知墙壁的距离）将减少机器人位姿的不确定性；但是这是定位而不是里程计。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>编译前先安装<code>orocos-bfl</code></p>
<p>校正好IMU,因为融合后的效果就是要看imu的校准度</p>
<p>注释掉StatusPublisher.cpp中的<code>sendTransform(tf::StampedTransform(transform, current_time.fromSec(base_time_), &quot;odom&quot;, &quot;base_footprint&quot;));</code>  因为ekf包会为我们处理好这部分tf，所以不需要我们发布odom变换了。但是保留<code>odom</code>话题的发布</p>
<h2 id="修改-robot-pose-ekf-launch"><a href="#修改-robot-pose-ekf-launch" class="headerlink" title="修改 robot_pose_ekf.launch"></a>修改 robot_pose_ekf.launch</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_pose_ekf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_pose_ekf&quot;</span> <span class="attr">name</span>=<span class="string">&quot;robot_pose_ekf&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;output_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;odom_ekf&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;base_footprint_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;base_footprint&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;freq&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30.0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;sensor_timeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1.0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_used&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_data&quot;</span> <span class="attr">value</span>=<span class="string">&quot;odom&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;imu_used&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;imu_data&quot;</span> <span class="attr">value</span>=<span class="string">&quot;imu&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;vo_used&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;/robot_pose_ekf/odom_combined&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/odom_ekf&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>freq：滤波器更新和发布频率。注意频率高仅仅意味着一段时间可以获得更多机器人位姿信息，但是并不表示可以提高位姿估计的精度。</p>
</li>
<li><p>sensor_timeout：当传感器停止向滤波器发送信息时，滤波器在没有传感器的情况下等待多长时间才重新开始工作。</p>
</li>
<li><p>odom_used, imu_used, vo_used：确认是否输入。</p>
</li>
</ul>
<p>启动之后,发布一下tf树,看看各坐标系名称是否正确,而且注意<code>odom_ekf</code>是不是<code>robot_pose_ekf</code>发布的，它提供的tf变换是： <code>odom_ekf --&gt; base_footprint</code>。 我们最终要实现的目标TF关系是： <code>odom_ekf --&gt; base_footprint --&gt; base_link</code></p>
<p>启动launch: <code>roslaunch robot_pose_ekf robot_pose_ekf.launch</code><br><img src="https://s2.loli.net/2023/01/13/6o1NYmOhxcvpjlK.png" alt="节点"><br>为了查看ekf包是否正常工作，可以用下面代码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /robot_pose_efk/get_status</span><br></pre></td></tr></table></figure></p>
<h2 id="协方差问题"><a href="#协方差问题" class="headerlink" title="协方差问题"></a>协方差问题</h2><p><code>robot_pose_ekf</code>不输出协方差信息，但要求输入协方差，协方差是<font size =3 color=blue>on velocity level</font>。接收的odometry数据格式错误的问题，一般是由于底盘发布的odometry数据的协方差矩阵默认为0矩阵。解决的方法由两种：一种是底盘对协方差矩阵进行初始化；另一种方法在<code>robot_pose_ekf</code>中添加判断，如果接收到的odometry信息的协方差矩阵没有进行初始化，则进行初始化。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Arkapravo/turtlebot/blob/master/turtlebot_node/src/turtlebot_node/covariances.py">turtlebot_node</a>对odom的协方差矩阵设置为<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ODOM_POSE_COVARIANCE = [<span class="number">1e-3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">                        <span class="number">0</span>, <span class="number">1e-3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e6</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e6</span>, <span class="number">0</span>,</span><br><span class="line">                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e3</span>]</span><br><span class="line"></span><br><span class="line">ODOM_TWIST_COVARIANCE = [<span class="number">1e-3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">                         <span class="number">0</span>, <span class="number">1e-3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                         <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                         <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e6</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                         <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e6</span>, <span class="number">0</span>,</span><br><span class="line">                         <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e3</span>]</span><br></pre></td></tr></table></figure><br><a target="_blank" rel="noopener" href="https://zacdeng.github.io/2020/08/03/racecar%E4%BB%BF%E7%9C%9F%E7%AB%9E%E8%B5%9B%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89-%20AMCL%E4%B8%8E%E5%B0%8F%E8%BD%A6%E5%AE%9A%E4%BD%8D/#rf2o-laser-odometry">这篇文章</a>也提出了几个例子</p>
<p>注意imu信息的协方差矩阵中代表机器人航向角的分量方差为1e-6，而里程计信息的协方差矩阵中机器人姿态分量的协方差为1e3，两个值相差很大。在进行EKF融合时，会更“相信”imu提供的姿态信息，因为其方差更小。比如机器人在转动过程中轮子发生了打滑，用编码器推算出的姿态一直在旋转，而实际姿态（主要由IMU测量得到）却没发生太大变化，这种情况就需要使用信息融合方法来减小误差。<font size="4" color="blue"> 协方差矩阵中的参数设置非常重要，要根据传感器手册或者实际使用测量来确定。</font></p>
<p>这里的协方差矩阵就是&lt;&lt;概率机器人&gt;&gt;154页的<code>Vt*Mt*VtT</code>, 根据之前速度积分的模型,我们已知的是ωt,Δt,θ</p>
<p>只有a1~a4还未知,它们的说明在《概率机器人》103页，<font size="4" color="orange"> 似乎不对： </font>这里就涉及到粒子滤波和AMCL了,其实它们就是AMCL的四个参数,即里程计的四个噪声分量. 我们在使用AMCL定位前就要调节这四个参数, 有了这四个参数,就能算出里程计的协方差矩阵了.</p>
<p>随着机器人的移动，其位姿的不确定性越来越大。随着时间的流逝，协方差将无限增长。<code>robot_pose_ekf</code>会在每个传感器更新数据前重置协方差， 所以发布的协方差是the increase in covariance over the past time interval. 这个时间间隔不是不变的，它取决于传感器的测量速度和什么时候完成．</p>
<p>try adjusting the process noise vs. the measurement covariance for the state variables you’re fusing. Lower covariance in the measurement and higher process noise will mean that the filter trusts your sensors more. Otherwise, the filter will prefer to stick with its predictions</p>
<p><br></p>
<p>里程计消息的协方差平时可以没有,但是如果要用到卡尔曼滤波做融合,就必须有,否则到<code>OdomEstimation::addMeasurement</code>会报错，那里是判断协方差矩阵的对角线元素<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] [1519539033.600801081]: Covariance specified <span class="keyword">for</span> measurement on topic wheelodom is zero</span><br></pre></td></tr></table></figure><br>但是小强中的里程计协方差矩阵赋值大部分是0<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CarOdom.pose.covariance =  boost::assign::<span class="built_in">list_of</span>(var_len)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(var_len)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">999</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">999</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">999</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(var_angle);</span><br></pre></td></tr></table></figure><br>因此修改<code>robot_pose_ekf/src/odom_estimation_node.cpp</code>中的函数<code>OdomEstimationNode::odomCallback</code>如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">6</span>; j++)</span><br><span class="line">    <span class="built_in">odom_covariance_</span>(i+<span class="number">1</span>, j+<span class="number">1</span>) = odom-&gt;pose.covariance[<span class="number">6</span>*i+j];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// manually set covariance untile imu sends covariance</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">imu_covariance_</span>(<span class="number">1</span>,<span class="number">1</span>) == <span class="number">0.0</span>)  <span class="comment">// 或者不用 if</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">SymmetricMatrix <span class="title">measNoiseOdom_Cov</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">  measNoiseOdom_Cov = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">measNoiseOdom_Cov</span>(<span class="number">1</span>,<span class="number">1</span>) = <span class="built_in">pow</span>(<span class="number">0.01221</span>,<span class="number">2</span>);  <span class="comment">// = 0.01221 meters / sec</span></span><br><span class="line">  <span class="built_in">measNoiseOdom_Cov</span>(<span class="number">2</span>,<span class="number">2</span>) = <span class="built_in">pow</span>(<span class="number">0.01221</span>,<span class="number">2</span>);  <span class="comment">// = 0.01221 meters / sec</span></span><br><span class="line">  <span class="built_in">measNoiseOdom_Cov</span>(<span class="number">3</span>,<span class="number">3</span>) = <span class="built_in">pow</span>(<span class="number">0.01221</span>,<span class="number">2</span>);  <span class="comment">// = 0.01221 meters / sec</span></span><br><span class="line">  <span class="built_in">measNoiseOdom_Cov</span>(<span class="number">4</span>,<span class="number">4</span>) = <span class="built_in">pow</span>(<span class="number">0.007175</span>,<span class="number">2</span>);  <span class="comment">// = 0.41 degrees / sec</span></span><br><span class="line">  <span class="built_in">measNoiseOdom_Cov</span>(<span class="number">5</span>,<span class="number">5</span>) = <span class="built_in">pow</span>(<span class="number">0.007175</span>,<span class="number">2</span>);  <span class="comment">// = 0.41 degrees / sec</span></span><br><span class="line">  <span class="built_in">measNoiseOdom_Cov</span>(<span class="number">6</span>,<span class="number">6</span>) = <span class="built_in">pow</span>(<span class="number">0.007175</span>,<span class="number">2</span>);  <span class="comment">// = 0.41 degrees / sec</span></span><br><span class="line">&#125;</span><br><span class="line">my_filter_.<span class="built_in">addMeasurement</span>(<span class="built_in">StampedTransform</span>(odom_meas_.<span class="built_in">inverse</span>(), odom_stamp_, base_footprint_frame_, <span class="string">&quot;wheelodom&quot;</span>), odom_covariance_);</span><br></pre></td></tr></table></figure><br>这是仿照源码中的函数<code>imuCallback</code>做的修改</p>
<p>如果协方差太大，那么说明机器人不太依靠里程计．协方差矩阵具体值可以考虑设置为精度的二次方。工程中确保odom的协方差矩阵对角线元素不均为0，则robot_pose_ekf即可工作。</p>
<h2 id="源码的坐标系错误"><a href="#源码的坐标系错误" class="headerlink" title="源码的坐标系错误"></a>源码的坐标系错误</h2><p>使用rviz观看滤波后的行走轨迹，结果报错：<br><img src="https://i.loli.net/2020/05/23/BAwtu9NfZ3sQW4I.png" alt="rviz里的ekf_dom_path报错.png"><br>它居然要求的是odom坐标系，但是查看tf树，坐标关系是正确的<code>odom_combined --&gt; base_footprint</code>，没有odom了。</p>
<p>使用echo查看/robot_pose_ekf/odom_combined话题，发现header里的frame_id: “odom”，看来是哪个地方发布错了。 从robot_pose_ekf源码里查找，发现<code>OdomEstimation::getEstimate(geometry_msgs::PoseWithCovarianceStamped&amp; estimate)</code>中，有这样一句<code>estimate.header.frame_id = &quot;odom&quot;;</code>，按说新的坐标系是<code>odom_combined</code>，不知为什么这里还是<code>odom</code>，只能认为是源码写错了。</p>
<p>参考:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/EAIBOT/article/details/51405152">turtlebot所用的里程计和IMU协方差是手动设置的</a><br><a target="_blank" rel="noopener" href="https://answers.ros.org/question/11682/robot_pose_ekf-with-an-external-sensor/?answer=17402#post-id-17402">ROS answer的回答</a><br><a target="_blank" rel="noopener" href="http://xxty.fun/2019/08/12/ROS%E5%B0%8F%E8%BD%A6%EF%BC%9Arobot_pose_ekf%E8%9E%8D%E5%90%88%E9%87%8C%E7%A8%8B%E8%AE%A1%E4%BF%A1%E6%81%AF/">XiaoXiaoTao博客</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/25/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8/">抛出异常</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><p>异常是运行期出现的情况，编译不会报错。如果出现异常，它后面的代码不会执行，一般会显示<font color = orange size= 3> </font> The program has unexpectedly finished. &lt;/font&gt;。如果能处理好异常，就可以让后面的代码继续运行</p>
<p>throw就是抛出异常，后面可以接任何语句表示异常。比如<code>throw 123;</code>, <code>throw &quot;exception&quot;;</code></p>
<p>try里面的第一个语句必须包含throw，可以是个函数。之后的语句不再进行，直接进catch了</p>
<p>catch的参数是和throw一致的，比如下面的<code>const char*</code>，如果要catch任何类型，小括号内换成<code>...</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">division</span>(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;本句不执行&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span><br><span class="line">&#123;</span><br><span class="line">  cerr &lt;&lt; msg &lt;&lt; endl;	<span class="comment">// 输出错误用cerr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++ 提供了一系列标准的异常，定义在<exception>，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的。可以使用<code>catch(std::exception e)</code></p>
<p>一些第三方库也提供了异常，使用时要注意。比如log4cpp:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    log4cpp::PropertyConfigurator::<span class="built_in">configure</span>(config_base_path+<span class="string">&quot;setting.conf&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (log4cpp::ConfigureFailure&amp; f)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Configure Problem: &quot;</span> &lt;&lt; f.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>假如程序运行前没有配置文件，而且没有使用异常机制，后面的程序就没法运行了。这不一定是我们想要的，我们不一定要求log4cpp的运行，所以使用异常就很合适了。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/25/Linux%E5%9F%BA%E7%A1%80/ELF%E6%96%87%E4%BB%B6/">ELF文件及调试命令</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux%E5%9F%BA%E7%A1%80/">Linux基础</a></span><div class="content"><p>ELF文件有三种：可执行文件，so共享库，o目标文件</p>
<h2 id="打印文件校验和"><a href="#打印文件校验和" class="headerlink" title="打印文件校验和"></a>打印文件校验和</h2><p>二进制文件传输过程中有没有被损坏或者是否是同一个版本，看看校验和以及程序块计数:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># md5sum liblidar.so</span></span><br><span class="line">615f8ede92bb7cca3d559a46397474b6  liblidar.so</span><br></pre></td></tr></table></figure>
<h2 id="打印ELF文件中的可打印字符串-strings"><a href="#打印ELF文件中的可打印字符串-strings" class="headerlink" title="打印ELF文件中的可打印字符串  strings"></a>打印ELF文件中的可打印字符串  strings</h2><p>例如你在代码中存储了一个版本号信息，那么即使编译成elf文件后，仍然可以通过strings搜索其中的字符串甚至可以搜索某个.c文件是否编译在其中：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings elfFile| grep <span class="string">&quot;someString&quot;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="nm命令查看函数或者全局变量是否存在于elf文件"><a href="#nm命令查看函数或者全局变量是否存在于elf文件" class="headerlink" title="nm命令查看函数或者全局变量是否存在于elf文件"></a>nm命令查看函数或者全局变量是否存在于elf文件</h2><p>nm命令用于查看elf文件的符号信息。文件编译出来之后，我们可能不知道新增加的函数或者全局变量是否已经成功编译进去。这时候，我们可以使用nm命令来查看。当然也可以用来查看函数，比<code>strings</code>命令更精确</p>
<h2 id="查看文件段大小-size"><a href="#查看文件段大小-size" class="headerlink" title="查看文件段大小 size"></a>查看文件段大小 size</h2><p>可以通过size命令查看各段大小：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># size cmdTest</span></span><br><span class="line">text       data      bss      dec      hex  filename</span><br><span class="line">1319      560        8     1887      75f   cmdTest</span><br></pre></td></tr></table></figure>
<p>text段：正文段字节数大小<br>data段:包含静态变量和已经初始化的全局变量的数据段字节数大小<br>bss段：存放程序中未初始化的全局变量的字节数大小<br>当我们知道各个段的大小之后，如果有减小程序大小的需求，就可以有针对性的对elf文件进行优化处理。</p>
<h2 id="为elf文件瘦身-strip"><a href="#为elf文件瘦身-strip" class="headerlink" title="为elf文件瘦身  strip"></a>为elf文件瘦身  strip</h2><p>strip用于去掉elf文件中所有的符号信息：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls -al cmdTest</span></span><br><span class="line">-rwxr-xr-x 1 hyb root 9792 Sep 25 20:30 cmdTest <span class="comment">#总大小为9792字节</span></span><br><span class="line">strip cmdTest</span><br><span class="line">ls -al cmdTest</span><br><span class="line">-rwxr-xr-x 1 hyb root 6248 Sep 25 20:35 cmdTest<span class="comment">#strip之后大小为6248字节</span></span><br></pre></td></tr></table></figure><br>可以看到，“瘦身”之后，大小减少将近三分之一。但是要特别注意的是，“瘦身”之后的elf文件由于没有了符号信息，许多调试命令将无法正常使用，出现core dump时，问题也较难定位，因此只建议在正式发布时对其进行“瘦身”。</p>
<h2 id="查看elf文件信息-readelf"><a href="#查看elf文件信息-readelf" class="headerlink" title="查看elf文件信息 readelf"></a>查看elf文件信息 readelf</h2><p>readelf用于查看elf文件信息，它可以查看各段信息，符号信息等，<code>readelf -h cmdTest</code>是查看elf文件头信息：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  <span class="comment">#elf文件魔数字</span></span><br><span class="line">Class:                             ELF64  <span class="comment">#64位 elf文件</span></span><br><span class="line">Data:                              2<span class="string">&#x27;s complement, little endian#字节序为小端序</span></span><br><span class="line"><span class="string">Version:                           1 (current)</span></span><br><span class="line"><span class="string">OS/ABI:                            UNIX - System V #</span></span><br><span class="line"><span class="string">ABI Version:                       0</span></span><br><span class="line"><span class="string">Type:                              EXEC (Executable file)#目标文件类型</span></span><br><span class="line"><span class="string">Machine:                           Advanced Micro Devices X86-64 #目标处理器体系</span></span><br><span class="line"><span class="string">Version:                           0x1</span></span><br><span class="line"><span class="string">Entry point address:               0x400440  #入口地址</span></span><br><span class="line"><span class="string">Start of program headers:          64 (bytes into file)</span></span><br><span class="line"><span class="string">Start of section headers:          4456 (bytes into file)</span></span><br><span class="line"><span class="string">Flags:                             0x0</span></span><br><span class="line"><span class="string">Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">Size of program headers:           56 (bytes)</span></span><br><span class="line"><span class="string">Number of program headers:         9</span></span><br><span class="line"><span class="string">Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">Number of section headers:         28</span></span><br><span class="line"><span class="string">Section header string table index: 27</span></span><br></pre></td></tr></table></figure><br>从elf头信息中，我们可以知道该elf是64位可执行文件，运行在x86-64中，且字节序为小端序。另外，我们还注意到它的入口地址是<code>0x400440(_start)</code>，而不是<code>400540(main)</code>。也就是说，我们的程序运行并非从main开始。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.yanbinghu.com/2019/10/13/54745.html"></a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/25/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/operator()/">operator()</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>   <span class="title">operator</span><span class="params">()</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;Foo operator&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val*<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo f;</span><br><span class="line"><span class="built_in">f</span>();    <span class="comment">// Foo operator</span></span><br><span class="line">cout&lt;&lt; <span class="built_in">f</span>(<span class="number">5</span>) &lt;&lt;endl;  <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<p>Foo是定义了调用操作符()的类,它的对象就相当于函数名,因此<code>operator()</code>取名叫函数对象</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/21/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/MQTT(%E4%BA%8C)%20QtMqtt%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%8E%B0%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/">MQTT(二) QtMqtt客户端实现发布订阅</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/">第三方库</a></span><div class="content"><p>代码在<a target="_blank" rel="noopener" href="https://github.com/charon-cheung/MQTT_Client">这里</a>，网上的示例是<a target="_blank" rel="noopener" href="https://github.com/emqx/qmqtt">这个</a>，但是我发现现在的QtMqtt已经变换很大，之前的API很多已经不能使用了</p>
<p>值得注意的是，客户端不能在构造函数里订阅话题，因为客户端在connected信号对应的槽函数里才连接成功，所以订阅也应该换到槽函数或者自己做的按钮里</p>
<p>MQTT的通信可以在wireshark里读取，可以直接解析MQTT的数据包：<br><img src="https://i.loli.net/2020/03/22/sR7NwdvrjLHnp4m.png" alt="发布话题test到客户端"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/21/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/MQTT(%E4%B8%80)%20%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8CQt%E5%BA%93/">MQTT (一) 配置服务器和Qt库</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/">第三方库</a></span><div class="content"><h2 id="安装服务器"><a href="#安装服务器" class="headerlink" title="安装服务器"></a>安装服务器</h2><p>配置安装看<a target="_blank" rel="noopener" href="https://www.qingtingip.com/h_298196.html">ubuntu安装MQTT服务器 + windows安装MQTT客户端</a>，主要是三个安装命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装服务端</span></span><br><span class="line">sudo apt-get install mosquitto</span><br><span class="line"><span class="comment">#安装客户端 （订阅sub  与 发布pub）</span></span><br><span class="line">sudo apt-get install mosqutitto-client</span><br><span class="line"><span class="comment">#安装调试器</span></span><br><span class="line">sudo apt-get install mosquitto-dbg </span><br></pre></td></tr></table></figure></p>
<ul>
<li>订阅话题test: mosquitto_sub -t test </li>
<li>发布消息到话题test: mosquitto_pub -t test -m “hello world” </li>
</ul>
<h2 id="编译Qt库QtMqtt"><a href="#编译Qt库QtMqtt" class="headerlink" title="编译Qt库QtMqtt"></a>编译Qt库QtMqtt</h2><p>Qt现在支持MQTT了， 但是很坑的是还需要自己编译，我用的是Qt5.14，从网上找了好几个版本都编译出问题，看了不知道多少博客，最后终于编译成功了。</p>
<p>从<a target="_blank" rel="noopener" href="https://github.com/qt/qtmqtt">Github官方仓库</a>下载5.14.0，解压到<code>F:\MyCpp\qtmqtt-5.14.0</code>，打开后编译，结果会报错，这是因为头文件的问题。在<code>qtmqtt-5.14.0\src\mqtt\mqtt.pro</code>中添加一行<font color = blue size =3> INCLUDEPATH += F:\MyCpp\qtmqtt-5.14.0 </font>，然后qmake, 编译。应该就成功了。</p>
<p>新建的测试程序<code>MQTT_Client</code>，然后将<code>qtmqtt-5.14.0\src\mqtt</code>文件夹中的所有头文件放到一个文件夹<code>QtMqtt</code>，然后放到程序的根目录。到编译生成的文件夹，将<code>lib</code>和<code>include</code>文件夹也放到<code>MQTT_Client</code>根目录，其中的文件Qt5Mqtt.dll.debug可以删除。</p>
<p>编辑<code>MQTT_Client.pro</code>，添加下面内容：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INCLUDEPATH += $<span class="variable">$PWD</span></span><br><span class="line">DEPENDPATH += $<span class="variable">$PWD</span>/include</span><br><span class="line"></span><br><span class="line">win32:CONFIG(release, debug|release): LIBS += -L$<span class="variable">$PWD</span>/lib/ -lQt5Mqtt</span><br><span class="line"><span class="keyword">else</span>:win32:CONFIG(debug, debug|release): LIBS += -L$<span class="variable">$PWD</span>/lib/ -lQt5Mqtt</span><br></pre></td></tr></table></figure></p>
<p>现在程序就可以用QtMqtt了，但是最好能让mqtt跟Qt自身库一样使用，也就是在pro文件中添加<code>QT += mqtt</code>即可，这样才叫优雅。参考<a href="">如何让第三方库和Qt自身库一样使用</a></p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29350001/article/details/76680646">搭建MQTT服务器及测试</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yexiaopeng/p/8542894.html">Qt官方MQTT库的配置</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/18/%E6%BF%80%E5%85%89SLAM/%E9%9B%B7%E8%BE%BE/%E9%9B%B7%E8%BE%BE%E7%9A%84%E8%AE%BE%E5%A4%87%E5%8F%82%E6%95%B0/">单线雷达的设备参数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/%E9%9B%B7%E8%BE%BE/">雷达</a></span><div class="content"><p>大多数雷达都是TOF测量法，只有深度信息，没有相机那样的纹理信息，也就没有视觉SLAM的运算负荷。</p>
<p>目前常见的激光雷达都是旋转扫描式的，内部长期处于旋转中的机械结构会给系统带来不稳定性，在颠簸震动时影响尤其明显。固态激光雷达的逐步成熟可能会为激光SLAM扳回这项劣势。</p>
<p>激光雷达的使用寿命问题已经被解决，能够保证长时间使用不会出现故障。比如在连续工作情况下，RPLIDAR-A2的设计使用寿命可长达5年以上。</p>
<p>雷达的光线遇到大雾、烟尘会受到遮挡，影响性能。</p>
<h2 id="测试材质"><a href="#测试材质" class="headerlink" title="测试材质"></a>测试材质</h2><p>选用雷达需要判断雷达是否适用于自己的场合，所以根据需要在以下场景进行测试</p>
<ul>
<li><p>大理石瓷砖。 应用场景参考：酒店大堂、走廊、室外墙壁</p>
</li>
<li><p>玻璃。 应用场景参考：玻璃门窗，办公大厅、玻璃柜台。 激光会穿过透明玻璃，从而造成一定概率的漏检。可以增加一些辅助反射手段，比如粘贴磨砂贴纸，或配合其他非光学的传感器作为补充。 <strong>雷达有时会穿透玻璃，有时不会，所以临时在玻璃上贴磨砂纸。</strong></p>
</li>
<li><p>不锈钢板。 应用场景参考：电梯、生产车间、港口码头</p>
</li>
<li><p>反光条。 应用场景参考：医院、生产车间、酒店大堂</p>
</li>
</ul>
<h2 id="误差源"><a href="#误差源" class="headerlink" title="误差源"></a>误差源</h2><ul>
<li><p>发送和接收激光束的精确耗时误差，也就是计时设备的精度问题</p>
</li>
<li><p>目标材质的反射值特性，比如全黑的材料吸收了光的大部分能量，使得反射量极低；或者像镜子一样的材料会将大部分光反射到其它地方</p>
</li>
<li><p>运动畸变：由于激光雷达在跟随自动驾驶车辆前进的同时，对周围环境进行扫描建模，也就是说车辆相对于周围的环境是运动的，导致对环境测量的实际位置与真实位置存在偏差。但是扫描频率高，速度低时，可以不必考虑。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/05/07/ICpiBQHvzquXkJj.png" alt=""></p>
<h2 id="测距范围"><a href="#测距范围" class="headerlink" title="测距范围"></a>测距范围</h2><p>指雷达能够测量的距离范围。如果实际障碍距离超出最大值，那么雷达数据会标记为无效点（不是距离为0）。市面上2D雷达最近距离也至少几厘米</p>
<p>实际情况下，雷达测距的最大值有可能因为工作环境而产生变化。雷达要想测距，需要接收到反射的激光。所以官方在测距范围这一项上添加了备注：“基于白色70%反射率物体”。</p>
<p>如果是吸收激光比较厉害的物体，例如黑色的表面又几乎不反光的物体，会导致反射光强度很弱，那么距离稍微远点，可能就测距失败了，这时候，该物体即使在标出的12米范围内同样无法测出。针对类似这样的物体，相当于实际测距的最大值变小了。透明的玻璃也是同样原因。</p>
<p>不过因为不同的物体和环境差异太大了，所以厂商也不太可能将全部情况测试一遍，更多的时候需要靠自己来实验，看是否能够适用实际的工作环境。</p>
<h2 id="扫描角度"><a href="#扫描角度" class="headerlink" title="扫描角度"></a>扫描角度</h2><p>思岚雷达是360°扫描的。有些雷达例如SICK的一些雷达，扫描角度只有220°。 实际使用，通常也不需要完全的360°，特别是雷达放在结构的中间层，因为有结构固定装置的存在，必然会有遮挡。</p>
<h2 id="测距分辨率"><a href="#测距分辨率" class="headerlink" title="测距分辨率"></a>测距分辨率</h2><p>分辨率和精度是两个不同的概念，按照上述参数的意思，更准确来说应该指的是测距精度。</p>
<p>RPLIDAR的精度并不是恒定的一个百分比，简单的解释是，距离越远，反射光受到的干扰越大，自然精度下降了。实际上，不同批次的雷达精度之间也有一定的差异。正因为这些不确定性，官方文档给的是较保守的值。</p>
<p>1.5m范围内小于0.5mm的精度还是可以的，1.5米处约为万分之三点三。<br>当在最大距离12米的时候，如果精度下降到最差的1%，则误差为0.12m，也能接受。</p>
<h2 id="扫描频率"><a href="#扫描频率" class="headerlink" title="扫描频率"></a>扫描频率</h2><p><img src="https://i.loli.net/2020/03/18/6tNElCuaoWwJhcG.png" alt="扫描频率.png"><br>衡量雷达一秒钟能转多少圈，直接改叫雷达转速也是可以的。</p>
<p>转速实际上跟雷达数据更新周期是挂钩的，比如说典型的10Hz，那就是说转一圈的时间大概是100ms，那么雷达数据差不多也是100ms一帧。 要跟<code>scan</code>话题的发布频率区分开，后者跟计算机性能有关。</p>
<p><code>LMS1xx</code>系列的扫描频率是25～50Hz，角度分辨率为<code>0.25°～0.50°</code><br><code>LMS5xx</code>系列的扫描频率是25～100Hz，角度分辨率为<code>0.1667°～1°</code></p>
<p>雷达自身的旋转是有方向的，大部分雷达都是逆时针旋转，与ROS中规定的一样，也有少部分雷达是顺时针旋转的，只不过使用起来有点不方便。</p>
<h2 id="角度分辨率"><a href="#角度分辨率" class="headerlink" title="角度分辨率"></a>角度分辨率</h2><p>正常来说，雷达转一圈，这一圈得到的测量点是均匀分布的，每个点之间间隔的角度就是所谓的角度分辨率了。</p>
<p>角度分辨率越小说明雷达转一圈得到的点数越多。例如，角度分辨率是0.45，则一圈是800个点，角度分辨率是0.9，则一圈是400个点。</p>
<p>不过，实际的角度分辨率其实不一定是固定的，即两个点之间的间距不一定是相同的，不过都在给出的分辨率范围内。在ROS中，雷达数据的标准格式认为角度分辨率是固定的，为了符合ROS标准，雷达的ROS驱动实际上做了角度补偿，将输出点修正为均匀分布的。</p>
<h2 id="数据的强度"><a href="#数据的强度" class="headerlink" title="数据的强度"></a>数据的强度</h2><p>激光雷达的激光点是有能量的，不同品牌激光点的能量也不同。当能量太小时，远距离情况下可能存在返回不了数据的情况。</p>
<p>可以等阳光或者使用光束照射到墙面上，激光雷达再去看被光照射到的墙面，对比这时的点云效果。可以用照度仪测量此时的光强度。倍加福雷达的点云效果在高强度情况下非常好，不愧是用于反光板的雷达。<br><img src="https://i.loli.net/2021/05/07/kvqoJwYV3ItgWmd.png" alt=""></p>
<h2 id="数据的精度"><a href="#数据的精度" class="headerlink" title="数据的精度"></a>数据的精度</h2><p>这是最重要的一个指标，表示激光雷达的数据跳动情况。现在一般厂商的雷达的精度都是2%。也就是100m的情况下，点的跳动幅度为2cm。但是，实际感觉能达到这个精度的雷达不是很多。</p>
<h2 id="multi-echo"><a href="#multi-echo" class="headerlink" title="multi-echo"></a>multi-echo</h2><p>multi-echo可以分析每个测量光束的两个回波信号，这样在雨雪天可以提供可靠的测量结果。一般激光打到玻璃上会有部分穿透，导致测量不准，multi-echo使激光从玻璃上返回来，还能从玻璃后面的墙上返回来。</p>
<p>有的雷达具备这种特性，比如<code>SICK-LMS111</code></p>
<p><br></p>
<p><img src="https://i.loli.net/2020/07/17/hifrG8DxmdnAXTJ.png" alt="A2雷达.png"></p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/tiancailx/article/details/110141867">从零开始搭二维激光SLAM —- 激光雷达数据效果对比</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/VOm_h4WYREsvz7rYfOKIiA">LakiBeam1雷达</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/16/C++/C++%20%20%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/STL%E6%80%BB%E7%BB%93/">STL总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/">C++ 模板与STL</a></span><div class="content"><h3 id="查找速度"><a href="#查找速度" class="headerlink" title="查找速度"></a>查找速度</h3><p>对序列式容器，如果元素已经排好序，那么查找速度可以达到logN的时间复杂度；如果是无序，只能是N</p>
<p>对关联容器，底层是红黑树，总能达到logN</p>
<h3 id="有在任意位置插入元素的需求；-大量添加新元素的需求"><a href="#有在任意位置插入元素的需求；-大量添加新元素的需求" class="headerlink" title="有在任意位置插入元素的需求； 大量添加新元素的需求"></a>有在任意位置插入元素的需求； 大量添加新元素的需求</h3><p>最好用list，不要使用vector, deque</p>
<h3 id="元素的排序"><a href="#元素的排序" class="headerlink" title="元素的排序"></a>元素的排序</h3><p>遍历元素的时候，序列容器输出的顺序和插入的顺序是一致的，关联容器就不一定了</p>
<p>sort()函数是快速排序的分段递归版本</p>
<p>关联容器的插入删除效率一般比用其他序列容器高(list除外)，因为不需要做内存拷贝和内存移动</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/15/C++/C++%20%20%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8set%E5%92%8Cmap/">关联式容器set和map</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/">C++ 模板与STL</a></span><div class="content"><p>STL 标准库提供了 4 种关联式容器，分别为 map、set、multimap、multiset</p>
<p><img src="https://s2.loli.net/2022/02/16/elb3D1QFEnmAoIv.png" alt=""></p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set的元素有序不重复，而且能根据元素的值自动进行排序。set中的键值不能直接修改，只能先删除再插入。底层采用红黑树。</p>
<p>set不支持随机访问，只能使用迭代器去访问。由于set放入一个元素就会调整这个元素的位置，把它放到合适的位置，所以set中只有一个insert插入操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;set 的 size：&quot;</span>&lt;&lt;  s.<span class="built_in">size</span>() &lt;&lt;endl;  <span class="comment">// 5</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;set 中的第一个元素是 ：&quot;</span>&lt;&lt;  *s.<span class="built_in">begin</span>()&lt;&lt;endl;  <span class="comment">// 1</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;set 中的最后一个元素是:&quot;</span>&lt;&lt;  *s.<span class="built_in">end</span>()&lt;&lt;endl;   <span class="comment">// 5</span></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=s.<span class="built_in">begin</span>(); it!=s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt; *it &lt;&lt;endl;</span><br><span class="line">&#125;    <span class="comment">// 1  2  3  4  5</span></span><br><span class="line"><span class="comment">//    s.clear();</span></span><br><span class="line">s.<span class="built_in">erase</span>(++s.<span class="built_in">begin</span>());</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;       after erase begin&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(it=s.<span class="built_in">begin</span>(); it!=s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt; *it &lt;&lt;endl;</span><br><span class="line">&#125;	 <span class="comment">// 1  3  4  5</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;lower bound: &quot;</span>&lt;&lt;*s.<span class="built_in">lower_bound</span>(<span class="number">5</span>)&lt;&lt;endl;  <span class="comment">// 5</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;upper bound: &quot;</span>&lt;&lt;*s.<span class="built_in">upper_bound</span>(<span class="number">5</span>)&lt;&lt;endl;  <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">empty</span>())</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;set is empty !&quot;</span> &lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>multiset底层也是红黑树，但允许有重复数据</p>
<h2 id="map-和-unordered-map"><a href="#map-和-unordered-map" class="headerlink" title="map 和 unordered_map"></a>map 和 unordered_map</h2><p>map适合存储一个数据字典，并要求方便地根据key找value。Map节点有一个Key和Value两个元素，Key不重复，Value可以重复。map可以通过key改变value的值</p>
<p>底层也是红黑树，所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此它的插入删除查找的时间复杂度为O(logN)</p>
<p>map支持随机访问(<code>at</code>函数和<code>[]</code>)，这是set没有的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, string&gt; m;</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">4</span>, <span class="string">&quot;d&quot;</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">5</span>, <span class="string">&quot;e&quot;</span>));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; m.<span class="built_in">upper_bound</span>(<span class="number">3</span>)-&gt;second &lt;&lt;endl;   <span class="comment">// 大于</span></span><br><span class="line">cout &lt;&lt; m.<span class="built_in">lower_bound</span>(<span class="number">3</span>)-&gt;second &lt;&lt;endl;   <span class="comment">// 不小于</span></span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d</span><br><span class="line">c</span><br></pre></td></tr></table></figure></p>
<p><strong>缺点</strong>： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间<br><br></p>
<p><code>unordered_map</code>内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的，但查找速度非常的快。  <strong>缺点</strong>：哈希表的建立比较耗费时间。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/13/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/(%E4%BA%8C)%20%E7%BB%BC%E8%BF%B0,%20%E8%AF%9D%E9%A2%98%E5%92%8C%E6%9C%8D%E5%8A%A1/">(二) 综述, 话题和服务</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/">原理和配置</a></span><div class="content"><p>Cartographer是基于图优化的SLAM，采用误差累计少，计算成本低的<code>Scan to Map</code>匹配方式，而不是造成误差快速累积和计算成本高的scan to scan匹配。整个算法分为局部SLAM和全局SLAM，两部分都对雷达观测的位姿进行了优化。</p>
<p>虽然cartographer适用于2D和3D两种情况，但3D情况下，cartographer用的不如LOAM多</p>
<h2 id="订阅的话题"><a href="#订阅的话题" class="headerlink" title="订阅的话题"></a>订阅的话题</h2><p>节点<code>cartographer_node</code>订阅的话题是：<code>scan</code>, <code>tf</code>, <code>tf_static</code>。 <code>cartographer_node</code>的launch需要增加remap，因为它接受的话题名称和我们现有的话题可能不一致：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;scan&quot;</span>  <span class="attr">to</span>=<span class="string">&quot;/scan&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;odom&quot;</span>  <span class="attr">to</span>=<span class="string">&quot;/xqserial_server/Odom&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;imu&quot;</span>   <span class="attr">to</span>=<span class="string">&quot;/xqserial_server/IMU&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><br>所有相关的话题名称都定义在<code>node_constants.h</code></p>
<h2 id="cartographer-node-发布的话题"><a href="#cartographer-node-发布的话题" class="headerlink" title="cartographer_node 发布的话题"></a>cartographer_node 发布的话题</h2><ul>
<li><p>scan_matched_points2, 类型<code>sensor_msgs/PointCloud2</code>, <code>scan-to-submap</code>匹配的2D点云数据，这个云可以根据配置进行滤波和投影。是<code>scan</code>话题的大部分，不会包括行走的人的轮廓</p>
</li>
<li><p>submap_list, 类型<code>cartographer_ros_msgs/SubmapList</code>，所有轨迹的所有submaps的列表，成员：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header</span><br><span class="line">cartographer_ros_msgs/SubmapEntry[] submap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其中submap的类型如下</span></span><br><span class="line">int32 trajectory_id</span><br><span class="line">int32 submap_index</span><br><span class="line">int32 submap_version</span><br><span class="line">geometry_msgs/Pose pose</span><br></pre></td></tr></table></figure>
<p>话题包括一个子图的ID list(包括轨迹ID和子图index)，以及子图的全局位姿。</p>
</li>
</ul>
<p>发布话题的源码流程是 <code>Node::PublishSubmapList</code> —— <code>MapBuilderBridge::GetSubmapList()</code> —— <code>PoseGraph2D::GetAllSubmapPoses()</code>  —— <code>PoseGraph2D::GetSubmapDataUnderLock</code> —— <code>PoseGraph2D::ComputeLocalToGlobalTransform</code></p>
<ul>
<li><code>trajectory_node_list</code>，类型为<code>visualization_msgs/MarkerArray</code>，即轨迹路径node列表，代码是</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Node::PublishTrajectoryNodeList</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> ::ros::WallTimerEvent&amp; unused_timer_event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (trajectory_node_list_publisher_.<span class="built_in">getNumSubscribers</span>() &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    carto::<span class="function">common::MutexLocker <span class="title">lock</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    trajectory_node_list_publisher_.<span class="built_in">publish</span>(</span><br><span class="line">        map_builder_bridge_.<span class="built_in">GetTrajectoryNodeList</span>()  );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>constraint_list: 类型为<code>visualization_msgs/MarkerArray</code>，约束列表</p>
</li>
<li><p>landmark_poses_list: 类型为<code>visualization_msgs/MarkerArray</code>，路标点位姿列表</p>
</li>
</ul>
<p>节点 <code>cartographer_occupancy_grid_node</code> 发布话题 <code>map</code>(栅格地图)， 订阅<code>submap_list [cartographer_ros_msgs/SubmapList]</code>。 <code>cartographer_occupancy_grid_node</code> 节点将子图转换为ROS的地图格式</p>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><ul>
<li>submap_query (cartographer_ros_msgs/SubmapQuery)： 查询submap的服务，输入的是<code>trajectory_id</code> 和 <code>submap_index</code><br><img src="https://i.loli.net/2020/08/03/j4FWEl8GIfer2dJ.png" alt="call submap_query"><br><img src="https://i.loli.net/2020/08/03/EkAOlJWTapY6x7D.png" alt=""></li>
</ul>
<h3 id="start-trajectory"><a href="#start-trajectory" class="headerlink" title="start_trajectory"></a>start_trajectory</h3><p>类型<code>cartographer_ros_msgs/StartTrajectory</code>，通过将其传感器主题和轨迹选项指定为二进制编码的原型来启动另一个轨迹。返回指定的轨迹ID。</p>
<p><code>StartTrajectory.srv</code>:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string   configuration_directory</span><br><span class="line">string   configuration_basename</span><br><span class="line">bool   use_initial_pose</span><br><span class="line">geometry_msgs/Pose   initial_pose</span><br><span class="line">int32   relative_to_trajectory_id</span><br><span class="line">---</span><br><span class="line">cartographer_ros_msgs/StatusResponse   status</span><br><span class="line">int32   trajectory_id</span><br></pre></td></tr></table></figure></p>
<p>命令稍微长了点:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /start_trajectory <span class="string">&quot;configuration_directory: &#x27;/home/user/carto_ws/src/cartographer_ros/cartographer_ros/configuration_files&#x27;</span></span><br><span class="line"><span class="string">configuration_basename: &#x27;localization.lua&#x27;</span></span><br><span class="line"><span class="string">use_initial_pose: true</span></span><br><span class="line"><span class="string">initial_pose:</span></span><br><span class="line"><span class="string">  position: &#123;x: 5.211, y: 5.617, z: 0.0&#125;</span></span><br><span class="line"><span class="string">  orientation: &#123;x: 0.0, y: 0.0, z: 0.689, w: 0.725&#125;</span></span><br><span class="line"><span class="string">relative_to_trajectory_id: 0&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>出错的地方可能会在<code>relative_to_trajectory_id</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">status:</span><br><span class="line">  code: 5</span><br><span class="line">  message: <span class="string">&quot;Trajectory 6 doesn&#x27;t exist.&quot;</span></span><br><span class="line"></span><br><span class="line">status:</span><br><span class="line">  code: 3</span><br><span class="line">  message: <span class="string">&quot;Trajectory 5 is in &#x27;DELETED&#x27; state.&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>加载 frozen state 意味着不插入no pose graph constraints. 一条frozen trajectory和它的子图不受 optimization影响</p>
<h3 id="finish-trajectory"><a href="#finish-trajectory" class="headerlink" title="finish_trajectory"></a>finish_trajectory</h3><p>类型<code>cartographer_ros_msgs/FinishTrajectory</code>: Finish 一个给定ID的轨迹，方式是运行最终的图优化。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int32 trajectory_id</span><br><span class="line">---</span><br><span class="line">cartographer_ros_msgs/StatusResponse status</span><br></pre></td></tr></table></figure>
<p>命令<code>rosservice call finish_trajectory &quot;trajectory_id: 5&quot;</code>，得到这样的结果:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">status:</span><br><span class="line">  code: 3</span><br><span class="line">  message: <span class="string">&quot;Topics are already used by another trajectory.&quot;</span></span><br><span class="line">trajectory_id: 0</span><br></pre></td></tr></table></figure></p>
<h3 id="trajectory-query"><a href="#trajectory-query" class="headerlink" title="trajectory_query"></a>trajectory_query</h3><ul>
<li>get_trajectory_states (cartographer_ros_msgs/GetTrajectoryStates):  返回所有轨迹的ID和状态， 可以用于从单独的节点观察Cartographer的状态。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">cartographer_ros_msgs/StatusResponse   status</span><br><span class="line">cartographer_ros_msgs/TrajectoryStates  trajectory_states</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>命令<code>rosservice call /get_trajectory_states &quot;&#123;&#125;&quot;</code>，比如得到这样的结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">status:</span><br><span class="line">  code: 0</span><br><span class="line">  message: <span class="string">&#x27;&#x27;</span></span><br><span class="line">trajectory_states:</span><br><span class="line">  header:</span><br><span class="line">    seq: 0</span><br><span class="line">    stamp:</span><br><span class="line">      secs: 1612232712</span><br><span class="line">      nsecs:  41338148</span><br><span class="line">    frame_id: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  trajectory_id: [0, 1, 2, 3, 4, 5]</span><br><span class="line">  trajectory_state: [2, 2, 2, 2, 2, 0]</span><br></pre></td></tr></table></figure></p>
<p><code>trajectory_state</code>的枚举值也就是<font color = blue size=4> 轨迹的四种状态对应:  ACTIVE, FINISHED, FROZEN, DELETED</font></p>
<ul>
<li>write_state (cartographer_ros_msgs/WriteState): 将当前内部状态写入磁盘到文件名。用于保存pbstream文件，此文件可用作<code>assets_writer_main</code>的输入，以生成概率网格，X-Rays或PLY文件等资源</li>
</ul>
<h3 id="read-metrics"><a href="#read-metrics" class="headerlink" title="read_metrics"></a>read_metrics</h3><p>类型<code>(cartographer_ros_msgs/ReadMetrics)</code>， 返回Cartographer的所有内部指标的最新值。运行时度量标准的集合(collection of runtime metrics)是可选的，必须使用节点中的<code>-collect_metrics</code>命令行标志激活:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;cartographer_node&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;cartographer_ros&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">&quot;cartographer_node&quot;</span> <span class="attr">args</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">          -configuration_directory $(find cartographer_ros)/configuration_files</span></span></span><br><span class="line"><span class="string"><span class="tag">          -configuration_basename map.lua</span></span></span><br><span class="line"><span class="string"><span class="tag">          -collect_metrics true&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;scan&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/scan_rectified&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;odom&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/odom&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果没有加<code>-collect_metrics</code>标志，<code>rosservice call /read_metrics &quot;&#123;&#125;&quot;</code>的结果:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">status:</span><br><span class="line">  code: 14</span><br><span class="line">  message: <span class="string">&quot;Collection of runtime metrics is not activated.&quot;</span></span><br><span class="line">metric_families: []</span><br><span class="line">timestamp:</span><br><span class="line">  secs: 1612333336</span><br><span class="line">  nsecs: 359502516</span><br></pre></td></tr></table></figure></p>
<h2 id="需要的tf变换"><a href="#需要的tf变换" class="headerlink" title="需要的tf变换"></a>需要的tf变换</h2><p>必须提供从所有传入传感器数据帧到配置的<code>tracking_frame</code>和<code>published_frame</code>的转换。通常，这些是由robot_state_publisher或static_transform_publisher定期发布的。</p>
<h2 id="发布的tf变换"><a href="#发布的tf变换" class="headerlink" title="发布的tf变换"></a>发布的tf变换</h2><p>提供<code>map_frame</code>和 <code>published_frame</code>之间的转换。如果在Lua中启用了<code>provide_odom_frame</code>，则将提供配置的<code>odom_frame</code>和<code>published_frame</code>之间的连续（不受循环闭包影响）转换。</p>
<h2 id="其他节点"><a href="#其他节点" class="headerlink" title="其他节点"></a>其他节点</h2><p><img src="https://i.loli.net/2020/07/20/yG6YpBRhMjvrVWS.png" alt="cartographer_ros的所有节点.png"></p>
<ul>
<li>cartographer_rosbag_validate</li>
</ul>
<p>可以检测bag中的错误，使用：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun cartographer_ros cartographer_rosbag_validate -bag_filename &lt;bag filename&gt;</span><br></pre></td></tr></table></figure><br>比如会有这样的结果：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">E0722 <span class="number">22</span>:<span class="number">11</span>:<span class="number">01.138546</span>  <span class="number">3442</span> rosbag_validate_main.cc:<span class="number">389</span>] IMU data (frame_id: <span class="string">&quot;imu&quot;</span>) has a large gap, largest <span class="keyword">is</span> <span class="number">0.064731</span> s, recommended <span class="keyword">is</span> [<span class="number">0.0005</span>, <span class="number">0.005</span>]s <span class="keyword">with</span> no jitter.</span><br><span class="line">I0722 <span class="number">22</span>:<span class="number">11</span>:<span class="number">01.139314</span>  <span class="number">3442</span> rosbag_validate_main.cc:<span class="number">398</span>] Time delta histogram <span class="keyword">for</span> consecutive messages on topic <span class="string">&quot;/IMU_data&quot;</span> (frame_id: <span class="string">&quot;imu&quot;</span>):</span><br><span class="line">Count: <span class="number">27679</span>  Min: <span class="number">0.000144</span>  Max: <span class="number">0.064731</span>  Mean: <span class="number">0.005027</span></span><br><span class="line">[<span class="number">0.000144</span>, <span class="number">0.006602</span>)    					    Count: <span class="number">27445</span> (<span class="number">99.154594</span>%)    Total: <span class="number">27445</span> (<span class="number">99.154594</span>%)</span><br><span class="line">[<span class="number">0.006602</span>, <span class="number">0.013061</span>)                            Count: <span class="number">181</span> (<span class="number">0.653925</span>%)  Total: <span class="number">27626</span> (<span class="number">99.808517</span>%)</span><br><span class="line">[<span class="number">0.013061</span>, <span class="number">0.019520</span>)                            Count: <span class="number">42</span> (<span class="number">0.151740</span>%)   Total: <span class="number">27668</span> (<span class="number">99.960258</span>%)</span><br><span class="line">[<span class="number">0.019520</span>, <span class="number">0.025979</span>)                            Count: <span class="number">7</span> (<span class="number">0.025290</span>%)    Total: <span class="number">27675</span> (<span class="number">99.985550</span>%)</span><br><span class="line">[<span class="number">0.025979</span>, <span class="number">0.032437</span>)                            Count: <span class="number">3</span> (<span class="number">0.010839</span>%)    Total: <span class="number">27678</span> (<span class="number">99.996384</span>%)</span><br><span class="line">[<span class="number">0.032437</span>, <span class="number">0.038896</span>)                            Count: <span class="number">0</span> (<span class="number">0.000000</span>%)    Total: <span class="number">27678</span> (<span class="number">99.996384</span>%)</span><br><span class="line">[<span class="number">0.038896</span>, <span class="number">0.045355</span>)                            Count: <span class="number">0</span> (<span class="number">0.000000</span>%)    Total: <span class="number">27678</span> (<span class="number">99.996384</span>%)</span><br><span class="line">[<span class="number">0.045355</span>, <span class="number">0.051814</span>)                            Count: <span class="number">0</span> (<span class="number">0.000000</span>%)    Total: <span class="number">27678</span> (<span class="number">99.996384</span>%)</span><br><span class="line">[<span class="number">0.051814</span>, <span class="number">0.058272</span>)                            Count: <span class="number">0</span> (<span class="number">0.000000</span>%)    Total: <span class="number">27678</span> (<span class="number">99.996384</span>%)</span><br><span class="line">[<span class="number">0.058272</span>, <span class="number">0.064731</span>]                            Count: <span class="number">1</span> (<span class="number">0.003613</span>%)    Total: <span class="number">27679</span> (<span class="number">100.000000</span>%)</span><br></pre></td></tr></table></figure><br>需要的时间范围是[0.0005, 0.005]，但是看给出的范围列表，只有第一个还算在这个范围里，剩下约1%不合要求。</p>
<ul>
<li>cartographer_pbstream_map_publisher</li>
</ul>
<p>一个简单的节点，它从序列化的Cartographer状态（pbstream格式）创建静态占用网格。如果实时更新不重要，它是占用网格节点的有效替代方案。  发布话题：map (nav_msgs/OccupancyGrid)，只发布一次</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/46/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/46/">46</a><span class="page-number current">47</span><a class="page-number" href="/page/48/">48</a><span class="space">&hellip;</span><a class="page-number" href="/page/66/">66</a><a class="extend next" rel="next" href="/page/48/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2024 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>