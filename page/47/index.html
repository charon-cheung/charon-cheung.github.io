<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">652</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">53</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/11/Linux%E5%9F%BA%E7%A1%80/Linux%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">Linux的启动过程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux%E5%9F%BA%E7%A1%80/">Linux基础</a></span><div class="content"><p>几个重要文件的启动顺序：</p>
<ol>
<li><p>通过/boot/vm进行启动 vmlinuz</p>
</li>
<li><p>init /etc/inittab</p>
</li>
<li><p>启动相应的脚本，并且打开终端</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rc.sysinit</span><br><span class="line"></span><br><span class="line">rc.d(里面的脚本)</span><br><span class="line"></span><br><span class="line">rc.local</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动login登录界面</p>
</li>
<li><p>登录，此时执行sh脚本的顺序，每次登录的时候都会完全执行的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile.d/file</span><br><span class="line"></span><br><span class="line">/etc/profile</span><br><span class="line"></span><br><span class="line">/etc/bashrc</span><br><span class="line"></span><br><span class="line">/root/.bashrc</span><br><span class="line"></span><br><span class="line">/root/.bash_profile</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这里就清楚了，如果不登录还要加载环境变量，就只能把环境变量放到<code>rc.local</code>里</p>
<p>添加开机启动项： <code>sudo vim /etc/profile.d/apps-bin-path.sh</code>， 在其中放入可执行文件</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/11/C++/C++%20%20%E5%9F%BA%E7%A1%80/static%E5%85%B3%E9%94%AE%E5%AD%97/">static关键字</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E5%9F%BA%E7%A1%80/">C++ 基础</a></span><div class="content"><p>函数在stack上分配的空间在此函数执行结束时会释放掉，这样就产生了一个问题:  <font color = blue size=4>如果想将函数中此变量的值保存至下一次调用时，如何实现？ </font>最容易想到的方法是定义为全局的变量，但这样最明显的缺点是 <strong>破坏了此变量的访问范围</strong> (使得在此函数中定义的变量，不仅仅只受此函数控制). <strong>想要使用全局变量的之前应该先考虑使用 static</strong></p>
<p>全局变量和静态变量的存储都放在内存的<strong>全局区</strong></p>
<h3 id="全局变量和全局静态变量的区别"><a href="#全局变量和全局静态变量的区别" class="headerlink" title="全局变量和全局静态变量的区别"></a>全局变量和全局静态变量的区别</h3><ul>
<li><p>全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，可以在另一个文件中使用。比较规范的方法是：在A.h中声明，比如<code>extern int a;</code>，但不能赋值，否则报错。在A.cpp中定义，<code>int a=1;</code>。然后在B.cpp中使用，<code>cout &lt;&lt; a &lt;&lt;endl;</code></p>
</li>
<li><p>全局静态变量是显式用 static 修饰的全局变量，作用域仅在声明此变量的文件，其他的文件即使用 extern 声明也不能使用。这样即使两个不同的源文件都定义了相同名字的static全局变量，它们也是不同的变量。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_static</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    n++ ;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">test_static</span>();</span><br><span class="line">    <span class="built_in">test_static</span>();</span><br><span class="line">    <span class="built_in">test_static</span>();</span><br></pre></td></tr></table></figure>
<p>运行结果是<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>静态局部变量有以下特点：</p>
<ol>
<li>该变量在全局数据区分配内存；</li>
<li>静态局部变量在程序执行到该对象的声明处时，被首次初始化，即以后的函数调用不再进行初始化。即上面的<code>static int n=0;</code></li>
<li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为 0；比如上面的n可以不初始化为0</li>
<li>始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。</li>
<li>它和全局变量的区别:全局变量对所有的函数都是可见的，而static局部变量只对定义自己的函数体可见。</li>
</ol>
<p>把局部变量改变为static变量后是改变了它的生存期和内存中的存储区域，作用域其实不变。 把全局变量改变为static变量是改变了它的作用域，限制了它的使用范围。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/09/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/urdf%E5%BB%BA%E6%A8%A1/">urdf 建模和 urdf_reader.cc</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/">ROS机器人</a></span><div class="content"><p>在一个package中新建文件夹，第一个文件夹为urdf，用来放置模型文件。第二个文件夹叫做meshes，用来放置外观纹理，一般是通过三维软件建模完成后，导出并放置在meshes中，第三个为launch文件夹。第四个是config文件夹，功能包的配置文件以及rviz的显示配置文件。</p>
<p>我们要准备这样的launch文件：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span>                                               </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">textfile</span>=<span class="string">&quot;$(find robot_description)/urdf/robot.urdf&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置GUI参数，显示关节控制插件，配合下面的joint_state_publisher使用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据关节状态，创建tf关系，并发布到tf tree中  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 发布机器人的关节状态  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>一个简单的模型，就是一个底盘带一个轮子：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;robot&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;Black&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0.15 0.15 0.15 1&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;Blue&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0 0 0.8 1&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">box</span> <span class="attr">size</span>=<span class="string">&quot;0.5 0.3 0.01&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;Black&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;left_front_wheel_link&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;1.5707 0 0&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;0.1125&quot;</span> <span class="attr">length</span>=<span class="string">&quot;0.064&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;Blue&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;left_front_joint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.1375 0.182 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;left_front_wheel_link&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 1 0&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><br>有时创建URDF模型在rviz中显示时，可以显示模型形状，但不显示颜色，rviz中显示<font color = orange size= 3> No transform from [base_link] to [map] </font>。 rviz默认Fixed Frame为<code>map</code>，而我的模型中没有map，将Fixed Frame改为<code>base_link</code>，重启一遍后，模型有了颜色。 依次类推，画出另外三个轮子.</p>
<p>使用<code>check_urdf robot.urdf</code>可以检查语法,但是偶尔也有漏掉错误的时候.</p>
<p>第一行的xml版本声明,开头不能有空格, 也不能加注释. <font color = blue size=4>在urdf文件中不能加中文注释 </font></p>
<h3 id="joint-state-publisher-和-robot-state-publisher"><a href="#joint-state-publisher-和-robot-state-publisher" class="headerlink" title="joint_state_publisher 和 robot_state_publisher"></a>joint_state_publisher 和 robot_state_publisher</h3><p><strong>joint_state_publisher</strong>节点读取<code>robot_description</code>参数,这个就是我们的urdf文件.</p>
<p><code>use_gui</code>参数,布尔类型,默认false,决定是否显示GUI界面. 这个小工具把所有joint做成slider形式,供用户测试,对continuous的joint,slider范围是-π到π</p>
<p>发布话题<code>/joint_states</code>, 消息类型<code>sensor_msgs/JointState</code>,可以echo查看</p>
<p><strong>robot_state_publisher</strong>订阅话题<code>/joint_states</code>, tf变换也是它发布的,它有一个参数<code>use_tf_static</code>,用于决定是否使用<code>tf_static</code> latched 静态变换的广播,而这个参数默认true.<br><img src="https://i.loli.net/2020/03/11/DTZpH8avxUdXw26.png" alt="robot_state_publisher.png"></p>
<p>一般写成launch形式:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">textfile</span>=<span class="string">&quot;$(find robot_description)/urdf/robot.urdf&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><br>启动launch，在rviz中加载<code>RobotModel</code>，如果没有<code>map</code>坐标系，就把全局坐标系改成<code>base_link</code>坐标系，会显示下面画面：<br><img src="https://i.loli.net/2020/03/10/1DIVeEKWRsSgZd6.png" alt="urdf.png"></p>
<p>现在可以启动完整的机器人程序了，有了map坐标系，也就有了<code>map-&gt;base_link</code>转换，现在移动机器人，rviz里的模型就会跟着移动了。<br><img src="https://i.loli.net/2020/03/11/nWJHthyRDTr8LKY.png" alt="机器人模型.png"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>rviz里没有显示机器人的模型，发现终端有这样的错误：<br><img src="https://i.loli.net/2020/04/21/QglJ2yY4AS81WeV.png" alt="本机rviz加载urdf出错"></p>
<p>在urdf文件中对某个约束改名为<code>camera</code>，对相应的STL文件也改名后，在本地机的rviz打开<code>RobotModel</code>，结果终端报错：<br><img src="https://i.loli.net/2020/07/03/jLi6pVTuZRbWw8S.png" alt=""><br>但是rviz里没报错，tf树是正常的。最后发现还是URDF文件里的STL路径没有改过来</p>
<h2 id="urdf-reader-cc"><a href="#urdf-reader-cc" class="headerlink" title="urdf_reader.cc"></a>urdf_reader.cc</h2><p>cartographer中的<code>urdf_reader.cc</code>是从<code>urdf</code>文件读取所有的坐标系变换，返回<code>std::vector&lt;geometry_msgs::TransformStamped&gt;</code>类型，然后使用下面的代码发送TF变换<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;urdf_reader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tf2_ros/static_transform_broadcaster.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;urdf/model.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;absl/strings/str_split.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">  tf2_ros::Buffer tf_buffer;</span><br><span class="line">  std::vector&lt;geometry_msgs::TransformStamped&gt; urdf_transforms;</span><br><span class="line">  <span class="keyword">const</span> std::vector&lt;std::string&gt; urdf_filenames =</span><br><span class="line">      absl::<span class="built_in">StrSplit</span>(FLAGS_urdf_filenames, <span class="string">&#x27;,&#x27;</span>, absl::<span class="built_in">SkipEmpty</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; urdf_filename : urdf_filenames) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> current_urdf_transforms =</span><br><span class="line">        <span class="built_in">ReadStaticTransformsFromUrdf</span>(urdf_filename, &amp;tf_buffer);</span><br><span class="line">    urdf_transforms.<span class="built_in">insert</span>(urdf_transforms.<span class="built_in">end</span>(),</span><br><span class="line">                           current_urdf_transforms.<span class="built_in">begin</span>(),</span><br><span class="line">                           current_urdf_transforms.<span class="built_in">end</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  ::tf2_ros::StaticTransformBroadcaster static_tf_broadcaster;</span><br><span class="line">  <span class="keyword">if</span> (urdf_transforms.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">      static_tf_broadcaster.<span class="built_in">sendTransform</span>(urdf_transforms);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  	  <span class="built_in">ROS_WARN</span>(<span class="string">&quot;no transform in urdf file !&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/67550381">古月居的urdf教程</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/hitgavin/article/details/51997379">urdf文件编码导致的缺少tf变换</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/09/PCL%E7%82%B9%E4%BA%91/ROS%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E7%82%B9%E4%BA%91%E5%B7%A5%E5%85%B7/">ROS中的几个点云工具</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/PCL%E7%82%B9%E4%BA%91/">PCL点云</a></span><div class="content"><h3 id="pcd-viewer"><a href="#pcd-viewer" class="headerlink" title="pcd_viewer"></a>pcd_viewer</h3><p>查看pcd文件</p>
<p><code>pcd_viewer &lt;filename&gt;</code></p>
<p><code>pcl_viewer -multiview 1 pcd_file</code> </p>
<p><code>rosrun perception_pcl pcd_viewer &lt;filename&gt;</code></p>
<h3 id="如何判断点云的数据类型"><a href="#如何判断点云的数据类型" class="headerlink" title="如何判断点云的数据类型"></a>如何判断点云的数据类型</h3><p>先转成pcd文件，然后用文本形式打开，看<code>FIELDS</code>一行，可能的结果有<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FIELDS x y z</span><br><span class="line">FIELDS x y z intensity timestamp ring</span><br></pre></td></tr></table></figure></p>
<h3 id="pcl-ros-包"><a href="#pcl-ros-包" class="headerlink" title="pcl_ros 包"></a>pcl_ros 包</h3><p>这个包的工具如下：<br><img src="https://i.loli.net/2020/03/09/UrXntZwKoOFR9vd.png" alt="pcl_ros包.png"></p>
<p>如果想获得雷达的点云数据，可以发布<code>PointCloud2</code>类型的话题，同时用<code>rosbag record</code>录制得到bag文件，然后使用<code>pcl_ros</code>包中的<code>bag_to_pcd</code>得到pcd点云文件，用法：<code>rosrun pcl_ros bag_to_pcd input.bag topic output_directory</code>，过程：<br><img src="https://i.loli.net/2020/03/09/nZbwL31r7tRAF4N.png" alt="转换过程.png"></p>
<p>注意输出是个目录，因为<strong>bag文件的消息数量就是生成的pcd文件数量</strong>，bag文件的消息数量可以用<code>rosbag info</code>查看<br><img src="https://i.loli.net/2020/03/09/EZ8yGRJhl2Bj9nN.png" alt="rosbag info.png"></p>
<p>可以用<code>pcl_viewer</code>工具查看pcd，但是这样转换出的点云pcd文件在用<code>Cloud Compare</code><strong>打开时报错</strong></p>
<p><br></p>
<p>考虑换一种生成方式，在当前路径将点云ROS数据转为pcd文件，也就是一个pcd对应一帧点云，但是会不停地转换<br><code>rosrun pcl_ros pointcloud_to_pcd  input:=/hesai/pandar  _prefix:=./pcd</code></p>
<p>pcd转ply程序： <code>pcl_pcd2ply</code>，使用格式：<code>pcl_pcd2ply demo.pcd demo.ply</code>。生成的pcd转成ply之后可以导入<code>Cloud Compare</code></p>
<h3 id="pointcloud-to-laserscan包"><a href="#pointcloud-to-laserscan包" class="headerlink" title="pointcloud_to_laserscan包"></a>pointcloud_to_laserscan包</h3><p>将3D点云转换为2D的雷达scan, 最适用于把Kinect相机用作雷达，再使用2D算法。<a target="_blank" rel="noopener" href="http://wiki.ros.org/pointcloud_to_laserscan">详细使用</a></p>
<p>我们可以直接利用kinect的点云数据，因为costmap2D的接口是直接调用点云。问题是计算量很大，点云规模太大，可以把点云数量降下去，但这样效果又不好了，可能无法识别障碍。点云覆盖信息大，对障碍物信息敏感。计算量大，实时性差。从障碍物进入相机视野出现到加入代价地图有1.5秒时间</p>
<h3 id="depthimage-to-laserscan"><a href="#depthimage-to-laserscan" class="headerlink" title="depthimage_to_laserscan"></a>depthimage_to_laserscan</h3><p>如果想从RGBD相机创建虚拟的雷达scan，这个包的效果更好，它直接处理图像数据而不是点云。<br><a target="_blank" rel="noopener" href="http://wiki.ros.org/depthimage_to_laserscan">详细使用</a></p>
<p>使用Kinect的一个方案是把点云或深度图降维生成线激光，本质上是当成2D激光雷达，在平坦地面环境用。还是用gmapping、hector SLAM、cartographer等手段建图</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Mr_yangsir/article/details/94559945">ROS中解析bag包中的点云文件到pcd格式</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/banrixianxin/p/6378789.html">激光雷达bag文件播放和转PCD文件</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/04/PCL%E7%82%B9%E4%BA%91/(%E4%BA%8C)%20ICP%E7%AE%97%E6%B3%95/">(二) ICP算法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/PCL%E7%82%B9%E4%BA%91/">PCL点云</a></span><div class="content"><p>ICP算法采用最小二乘估计计算变换矩阵，原理简单且具有较好的精度，但是由于采用了迭代计算，导致算法计算速度较慢，而且采用ICP进行配准计算时，其对待配准点云的初始位置有一定要求，若所选初始位置不合理，则会导致算法陷入局部最优。</p>
<p>IterativeClosestPoint类提供了标准ICP算法的实现（The transformation is estimated based on SVD），算法迭代结束条件有如下几个:</p>
<ul>
<li>最大迭代次数： 最大迭代次数。  <code>setMaximumIterations (100)</code></li>
<li>两次变化矩阵之间的差值：前一个变换矩阵和当前变换矩阵的差异小于阈值时，就认为已经收敛了。 <code>setTransformationEpsilon(1e-10)</code></li>
<li>均方误差（MSE）：均方误差和小于给定阈值， 停止迭代。 <code>setEuclideanFitnessEpsilon(0.01)</code></li>
</ul>
<p><code>align</code>函数是配准，<strong>在使用之前至少给定上面三个条件</strong>，还有<code>setMaxCorrespondenceDistance</code>等其他函数。PCL的ICP里的transformation estimation就是基于SVD分解实现的。</p>
<p>如果从一个好的<strong>初始猜想变换矩阵</strong>开始迭代，那么算法将会在比较少的迭代之后就收敛，配准结果也较好，当像我们这里没有指定初始guess时，就默认使用单位阵<code>Matrix4::Identity()</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/03/PCL%E7%82%B9%E4%BA%91/(%E4%B8%89)%E6%9D%82%E9%A1%B9/">(二) 杂项</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/PCL%E7%82%B9%E4%BA%91/">PCL点云</a></span><div class="content"><h3 id="计时"><a href="#计时" class="headerlink" title="计时"></a>计时</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pcl::console::TicToc time;</span><br><span class="line">time.<span class="built_in">tic</span> ();</span><br><span class="line"><span class="comment">//需要记录执行多长时间的代码</span></span><br><span class="line">cout &lt;&lt;time.<span class="built_in">toc</span> () &lt;&lt; <span class="string">&quot; ms :&lt;&lt; endl;</span></span><br></pre></td></tr></table></figure>
<h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><p>同ROS类似，就是把ROS换成了PCL:  PCL_DEBUG, PCL_INFO, PCL_WARN, PCL_ERROR</p>
<p>参考：<a target="_blank" rel="noopener" href="http://pointclouds.org/documentation/tutorials/pcl_visualizer.php#pcl-visualizer"></a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/25/Matlab/matlab%E7%94%BB%E7%AD%89%E9%AB%98%E7%BA%BF/">matlab画等高线</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Matlab/">Matlab</a></span><div class="content"><p><img src="https://i.loli.net/2020/02/25/HD4GbkKmSudNgvE.png" alt="2020-02-25_130103.png"></p>
<p>matlab的操作步骤：</p>
<ol>
<li>产生独立变量，为带有两个变量 x 和 y 的集合，meshgrid是一个可以建立独立变量的函数，产生矩阵元素，元素x和y按照指定的范围和增量来产生。</li>
<li>输入要使用的函数</li>
<li>调用contour(x,y,w)命令，contour函数是画一个多维函数的等高线</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[x,y] = <span class="built_in">meshgrid</span>(<span class="number">-5</span>:<span class="number">0.05</span>:<span class="number">5</span>,<span class="number">-5</span>:<span class="number">0.05</span>:<span class="number">5</span>)</span><br><span class="line">w = x.^<span class="number">2</span>+y.^<span class="number">2</span></span><br><span class="line">contour(x,y,w, <span class="string">&#x27;showText&#x27;</span>, <span class="string">&#x27;on&#x27;</span>)</span><br><span class="line"><span class="comment">% surf(x,y,w), title(&#x27;等高线&#x27;)</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/25/jkSvBFGabXLyCKp.png" alt="等高线.png"></p>
<p>surf函数用于画三维的等高线<br><img src="https://i.loli.net/2020/02/25/sNKnCUXlHVGPbJB.png" alt="三维的等高线.png"></p>
<p>高维高斯分布的概率密度函数和等高线图</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">u=[0;0];%均值</span><br><span class="line">v=[4,3;3,9];%协方差阵</span><br><span class="line">x=-7:0.05:7;</span><br><span class="line">y=-7:0.05:7;</span><br><span class="line"></span><br><span class="line">[X,Y]=meshgrid(x,y);</span><br><span class="line">s2x=v(1,1)      %x的方差</span><br><span class="line">s2y=v(2,2)</span><br><span class="line">sx=sqrt(s2x)    %标准差多个</span><br><span class="line">sy=sqrt(s2y)</span><br><span class="line">Cov=v(1,2)</span><br><span class="line">r=Cov/(sx*sy)</span><br><span class="line">a=1/(2*pi*sx*sy*sqrt(1-r^2));</span><br><span class="line">b1=-1/(2*(1-r^2));</span><br><span class="line">b2=((X-u(1))./sx).^2;</span><br><span class="line">b3=((Y-u(2))./sy).^2;</span><br><span class="line">b4=2*r.*(X-u(1)).*(Y-u(2))./(sx*sy)</span><br><span class="line">Z=a*exp(b1*(b2+b3-b4));     %也就是f(x1,x2)的表达式</span><br><span class="line"></span><br><span class="line">mesh(X,Y,Z),title(<span class="string">&#x27;密度函数图&#x27;</span>)</span><br><span class="line">figure</span><br><span class="line">contour(X,Y,Z,<span class="string">&#x27;showText&#x27;</span>,<span class="string">&#x27;on&#x27;</span>),title(<span class="string">&#x27;等高线图&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/25/tWFAlsfpZD2iwvr.png" alt="等高线图.png"><br><img src="https://i.loli.net/2020/02/25/aQbV5KUmonJLg7i.png" alt="密度图.png"></p>
<p>参考： <a target="_blank" rel="noopener" href="https://zlearning.netlify.com/communication/matlab/matlab-surface-contour.html">使用surface 和 contour 画图</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/22/SLAM%E5%B7%A5%E5%85%B7/ceres%201%20%E5%AE%89%E8%A3%85%E5%92%8C%E4%BB%8B%E7%BB%8D/">ceres库(一) 安装和介绍</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SLAM%E5%B7%A5%E5%85%B7/">SLAM工具</a></span><div class="content"><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>ceres是google库，首先安装相关依赖<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y libatlas-base-dev</span><br><span class="line">sudo apt-get install -y liblapack-dev libsuitesparse-dev libcxsparse3.1.2 libgflags-dev </span><br><span class="line">sudo apt-get install -y libgoogle-glog-dev libgtest-dev</span><br></pre></td></tr></table></figure><br>如果使用Ubuntu18.04，安装<code>libcxsparse3.1.2</code>可能出错，ubuntu从18.04版本开始，libcxsparse这个包的名称改为<code>libcxsparse3</code>。具体方法参考<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15581550/5286367">安装Ceres相关依赖时libcxsparse3.1.2报错</a></p>
<p>如果安装时找不到 cxsparse 或者其他的lib，需要添加下面的源<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><br>把下面的源粘贴到source.list的最上方: <code>deb http://cz.archive.ubuntu.com/ubuntu trusty main universe</code><br>更新一下: <code>sudo apt-get update</code>， 然后再进行第一步的安装。</p>
<p>从<a target="_blank" rel="noopener" href="https://github.com/ceres-solver/ceres-solver">github</a>上下载，这里要注意ceres的版本和Eigen是搭配的，ceres版本越新，对Eigen的版本要求也越新，它的<code>CMakeLists</code>里有提示，所以不要安装最新的。 <font color = blue size=4>安装2.0.0 即可 </font></p>
<p>下载解压后执行老一套命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make </span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p>
<h2 id="配置-CMake"><a href="#配置-CMake" class="headerlink" title="配置 CMake"></a>配置 CMake</h2><p>安装官方的说明配置是错误的，应该是这样：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">find_package(Ceres REQUIRED)</span><br><span class="line"></span><br><span class="line">INCLUDE_DIRECTORIES(/usr/<span class="keyword">include</span>/eigen3)</span><br><span class="line"></span><br><span class="line">include_directories(</span><br><span class="line">  $&#123;catkin_INCLUDE_DIRS&#125;</span><br><span class="line">  <span class="comment"># 这行可以没有</span></span><br><span class="line">  $&#123;CERES_INCLUDE_DIRS&#125; </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">add_executable(program src/program.cpp) </span><br><span class="line">target_link_libraries(program</span><br><span class="line">   $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">   $&#123;CERES_LIBRARIES&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>如果这样报错，找不到ceres，就加上<code>set(Ceres_DIR  &quot;/usr/local/lib/cmake/ceres&quot;)</code>，  也可能是 <code>/usr/local/lib/cmake/ceres</code></p>
<p>ceres使用LM或狗腿算法，求解参数的数据类型只支持 <code>double*</code>。Ceres相对于g2o的缺点仅仅是依赖的库多一些（g2o仅依赖Eigen）．但是可以直接对数据进行操作</p>
<p>ceres是求解给定函数的最小值</p>
<h2 id="Solver-Options"><a href="#Solver-Options" class="headerlink" title="Solver::Options"></a>Solver::Options</h2><ul>
<li><p><code>Solver::Options::trust_region_strategy_type</code> 可以取<code>LEVENBERG_MARQUARDT</code>或<code>DOGLEG</code></p>
</li>
<li><p><code>Solver::Options::use_inner_iterations</code> 设为True，可以启用 Ruhe &amp; Wedin的非线性推广的算法II。这个版本的Ceres具有更高的迭代复杂度，但是每次迭代都显示更好的收敛行为。把 <code>Solver::Options::num_threads</code>设为最大值是非常值得推荐的</p>
</li>
<li><p>minimizer_progress_to_stdout</p>
</li>
<li><p>num_threads: 设置使用的线程，<strong>但有时线程少反而用时更少，不明白为什么</strong></p>
</li>
</ul>
<h2 id="linear-solver-type"><a href="#linear-solver-type" class="headerlink" title="linear_solver_type"></a>linear_solver_type</h2><p>对于非线性最小二乘问题，最终转化为求解方程  <script type="math/tex">H\Delta x = g</script></p>
<p>Ceres提供了很多计算的方法，这就涉及<code>Solver::Options::linear_solver_type</code>的取值问题</p>
<ul>
<li>DENSE_QR</li>
</ul>
<p><strong>默认值。</strong> 适合使用稠密雅可比矩阵的小规模问题（几百个参数和几千个残差），也就是使用Eigen库的稠密矩阵QR分解。如果ceres优化问题不是SLAM的大型后端，<strong>不是稀疏问题</strong>，使用<code>DENSE_QR</code></p>
<ul>
<li>DENSE_NORMAL_CHOLESKY &amp; SPARSE_NORMAL_CHOLESKY</li>
</ul>
<p>大规模的非线性最小二乘问题通常是稀疏的。对于这种情况使用稠密QR分解是低效率的，改用Cholesky因式分解，它有两种变体 - 稀疏和密集。</p>
<p><code>DENSE_NORMAL_CHOLESKY</code>是执行正规方程的稠密Cholesky分解。 Ceres使用Eigen稠密的<code>LDLT</code>因式分解算法。</p>
<p><code>SPARSE_NORMAL_CHOLESKY</code>是执行正规方程的稀疏Cholesky分解，这为大量稀疏问题节省了大量的时间和内存消耗。Ceres使用<code>SuiteSparse</code> 或 <code>CXSparse</code>库中的稀疏Cholesky分解算法 或 Eigen中的稀疏Cholesky分解算法。</p>
<p>如果Ceres编译时支持了这三个库，那么<code>linear_solver_type</code>默认值是<code>SPARSE_NORMAL_CHOLESKY</code>，否则就是<code>DENSE_QR</code>。使用最多的是<code>DENSE_QR</code>，cartographer前端的ceres scan mather用的也是<code>DENSE_QR</code></p>
<ul>
<li><p>CGNR : 使用共轭梯度法求解稀疏方程</p>
</li>
<li><p>DENSE_SCHUR &amp; SPARSE_SCHUR : 适用于BA问题</p>
</li>
</ul>
<h2 id="ceres-Solver-Summary-的常用函数"><a href="#ceres-Solver-Summary-的常用函数" class="headerlink" title="ceres::Solver::Summary 的常用函数"></a>ceres::Solver::Summary 的常用函数</h2><p><code>ceres::Solver::Summary summary;</code></p>
<ul>
<li>double Solver::Summary::total_time_in_seconds.  Time (in seconds) spent in the solver</li>
</ul>
<p>直接使用<code>summary.total_time_in_seconds</code></p>
<ul>
<li><p>int Solver::Summary::num_threads_given:   Number of threads specified by the user for Jacobian and residual evaluation.</p>
</li>
<li><p>int Solver::Summary::num_threads_used  </p>
</li>
</ul>
<p>Number of threads actually used by the solver for Jacobian and residual evaluation. This number is not equal to <code>Solver::Summary::num_threads_given</code> if none of <code>OpenMP</code> or <code>CXX_THREADS</code> is available.</p>
<p>以上两个线程的参数是由<code>Options::num_threads</code>决定的，如果设置太大，这两个参数就会不同，只会用最大线程数。<br><br></p>
<ul>
<li><p>min_linear_solver_iteration 和 max_linear_solver_iteration：线性求解器的最小/最大迭代次数，默认为0/500，一般不需要更改</p>
</li>
<li><p>max_num_iterations ： 默认是50。求解器的最大迭代次数，并不是越大越好。对于SLAM前端的实时性有要求，所以<code>max_num_iterations</code>不能太大，ALOAM里设置为4</p>
</li>
<li><p>bool Solver::Summary::IsSolutionUsable() const</p>
</li>
</ul>
<p>算法返回的结果是否数值可靠。 也就是<code>Solver::Summary:termination_type</code>是否是<code>CONVERGENCE</code>, <code>USER_SUCCESS</code> 或者 <code>NO_CONVERGENCE</code>，也就是说求解器满足以下条件之一：</p>
<ol>
<li>达到了收敛误差</li>
<li>达到最大迭代次数和时间</li>
<li>user indicated that it had converged</li>
</ol>
<p>通过实验发现除了多线程以及 linear_solver_type ，别的对优化性能和结果影响不是很大</p>
<h2 id="BriefReport"><a href="#BriefReport" class="headerlink" title="BriefReport"></a>BriefReport</h2><h2 id="FullReport"><a href="#FullReport" class="headerlink" title="FullReport"></a>FullReport</h2><p>例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">iter      cost      cost_change  |gradient|   |step|    tr_ratio  tr_radius  ls_iter  iter_time  total_time</span><br><span class="line">   <span class="number">0</span>  <span class="number">1.259266e+05</span>    <span class="number">0.00e+00</span>    <span class="number">5.00e+04</span>   <span class="number">0.00e+00</span>   <span class="number">0.00e+00</span>  <span class="number">1.00e+04</span>        <span class="number">0</span>    <span class="number">1.91e-05</span>    <span class="number">1.26e-04</span></span><br><span class="line">   <span class="number">1</span>  <span class="number">2.468045e+04</span>    <span class="number">1.01e+05</span>    <span class="number">2.69e+02</span>   <span class="number">1.31e+01</span>   <span class="number">1.00e+00</span>  <span class="number">3.00e+04</span>        <span class="number">1</span>    <span class="number">5.60e-05</span>    <span class="number">2.02e-04</span></span><br><span class="line">   <span class="number">2</span>  <span class="number">2.467825e+04</span>    <span class="number">2.20e+00</span>    <span class="number">1.17e+00</span>   <span class="number">5.00e-02</span>   <span class="number">1.00e+00</span>  <span class="number">9.00e+04</span>        <span class="number">1</span>    <span class="number">2.29e-05</span>    <span class="number">2.37e-04</span></span><br><span class="line"></span><br><span class="line"><span class="function">Solver <span class="title">Summary</span> <span class="params">(v <span class="number">2.0</span><span class="number">.0</span>-eigen-(<span class="number">3.3</span><span class="number">.4</span>)</span>-lapack-suitesparse-<span class="params">(<span class="number">5.1</span><span class="number">.2</span>)</span>-cxsparse-<span class="params">(<span class="number">3.1</span><span class="number">.9</span>)</span>-eigensparse-no_openmp)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">                                     Original                  Reduced</span></span><br><span class="line"><span class="function">Parameter blocks                            4                        3</span></span><br><span class="line"><span class="function">Parameters                                 12                        9</span></span><br><span class="line"><span class="function">Residual blocks                             5                        5</span></span><br><span class="line"><span class="function">Residuals                                  15                       15</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Minimizer                        TRUST_REGION</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Sparse linear algebra library    SUITE_SPARSE</span></span><br><span class="line"><span class="function">Trust region strategy     LEVENBERG_MARQUARDT</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">                                        Given                     Used</span></span><br><span class="line"><span class="function">Linear solver          SPARSE_NORMAL_CHOLESKY   SPARSE_NORMAL_CHOLESKY</span></span><br><span class="line"><span class="function">Threads                                     1                        1</span></span><br><span class="line"><span class="function">Linear solver ordering              AUTOMATIC                        3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Cost:</span></span><br><span class="line"><span class="function">Initial                          1.259266e+05</span></span><br><span class="line"><span class="function">Final                            2.467825e+04</span></span><br><span class="line"><span class="function">Change                           1.012484e+05</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Minimizer iterations                        3</span></span><br><span class="line"><span class="function">Successful steps                            3</span></span><br><span class="line"><span class="function">Unsuccessful steps                          0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Time</span> <span class="params">(in seconds)</span>:</span></span><br><span class="line"><span class="function">Preprocessor                         0.000106</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Residual only evaluation           0.000009 <span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line"><span class="function">  Jacobian &amp; residual evaluation     0.000026 <span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line"><span class="function">  Linear solver                      0.000053 <span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line"><span class="function">Minimizer                            0.000166</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Postprocessor                        0.000004</span></span><br><span class="line"><span class="function">Total                                0.000276</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Termination:                      <span class="title">CONVERGENCE</span> <span class="params">(Function tolerance reached. |cost_change|/cost: <span class="number">6.530805e-10</span> &lt;= <span class="number">1.000000e-06</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>参考:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wzheng92/article/details/80008380">官方教程学习笔记（十三）</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/21/SLAM%E5%B7%A5%E5%85%B7/Eigen(%E4%B8%89)%20%E6%AC%A7%E6%B0%8F%E5%8F%98%E6%8D%A2%EF%BC%8C%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%EF%BC%8CSVD/">Eigen(三) 欧氏变换，cholesky，SVD，最小二乘</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SLAM%E5%B7%A5%E5%85%B7/">SLAM工具</a></span><div class="content"><h2 id="欧氏变换"><a href="#欧氏变换" class="headerlink" title="欧氏变换"></a>欧氏变换</h2><p>欧氏变换(Isometry Transform)可以看作是维持任意两点距离不变的变换，在实际场景中使用比较多。在Eigen中已经内置好了一些常用的欧氏变换:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Transform&lt;<span class="keyword">float</span>,<span class="number">2</span>,Isometry&gt; Isometry2f;</span><br><span class="line"><span class="keyword">typedef</span> Transform&lt;<span class="keyword">float</span>,<span class="number">3</span>,Isometry&gt; Isometry3f;</span><br><span class="line"><span class="keyword">typedef</span> Transform&lt;<span class="keyword">double</span>,<span class="number">2</span>,Isometry&gt; Isometry2d;</span><br><span class="line"><span class="keyword">typedef</span> Transform&lt;<span class="keyword">double</span>,<span class="number">3</span>,Isometry&gt; Isometry3d;</span><br></pre></td></tr></table></figure><br>欧氏变换必须初始化，如果没初始化，Isometry3d中的元素全为0，一般初始化为单位矩阵，也可以初始化为Quaternion。 赋值可以通过它的成员函数.rotate()和.translate()完成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AngleAxisd <span class="title">rotation</span><span class="params">(<span class="number">3.1415926</span> / <span class="number">4</span>, Vector3d(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>).normalized())</span></span>;</span><br><span class="line"><span class="function">Vector3d <span class="title">translation</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">Isometry3d T= Isometry3d::<span class="built_in">Identity</span>();</span><br><span class="line"><span class="comment">// 先平移后旋转</span></span><br><span class="line">T.<span class="built_in">translate</span>(translation);</span><br><span class="line">T.<span class="built_in">rotate</span>(rotation);</span><br></pre></td></tr></table></figure>
<p>A.translate(B)等价于A×B，而A.pretranslate(B)等价于B×A，对应于左乘和右乘的区别。凡是前面带pre的函数，其变化都是相对于上一步变化之前的状态进行的。举例说我要新建一个按固定轴先平移后旋转的变换。但我首先设置了旋转，然后再设置平移。这个时候设置平移就不能用<code>translate()</code>了，而应该用<code>pretranslate()</code>。因为第一步已经对坐标系进行了旋转，后面的平移是在旋转后的坐标系中进行的，所以最好不要用pre开头的函数</p>
<p><br></p>
<p>针对求解<code>Ax = b</code>这种线性问题，Eigen提供了下面几种分解方法，每一种方法都提供了一个<code>solve()</code>函数以便求解得到 x，Eigen对每一种分解方法的速度和精度做了如下对比。当然对于小矩阵，各个方法没什么区别<br><img src="https://i.loli.net/2021/07/16/weh8xszc3EOrGd2.png" alt=""><br><code>LLT</code>(cholesky)是最快的求解器，但是精度也是最差的，并且只能对正定矩阵进行分解，而<code>LDLT</code>则可以应对正半定和负半定问题，精度较LLT更高，所以尽量使用LDLT，但是LDLT在求解大矩阵问题时，耗时较<code>QR</code>增加更多，所以究竟选择那种分解方式求解问题，需要根据速度和精度综合考量</p>
<p>使用info()判断是否收敛<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SelfAdjointEigenSolver&lt;Matrix2f&gt; <span class="title">eigensolver</span><span class="params">(A)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (eigensolver.<span class="built_in">info</span>() != Success)</span><br><span class="line">    <span class="built_in">abort</span>();</span><br></pre></td></tr></table></figure><br>对于自伴随矩阵，Eigen使用<code>SelfAdjointEigenSolver</code>进行特征值分解<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Eigen::SelfAdjointEigenSolver&lt; Eigen::Matrix3d &gt; <span class="title">eigen_solver</span><span class="params">( matrix_33 )</span></span>;</span><br><span class="line"><span class="comment">// 特征值   特征向量</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Eigen values = &quot;</span> &lt;&lt; eigen_solver.<span class="built_in">eigenvalues</span>( ) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Eigen vectors = &quot;</span> &lt;&lt; eigen_solver.<span class="built_in">eigenvectors</span>( ) &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<h2 id="cholesky-分解"><a href="#cholesky-分解" class="headerlink" title="cholesky 分解"></a>cholesky 分解</h2><p>Cholesky分解是把一个对称正定的矩阵表示成一个下三角矩阵L和其转置的乘积的分解。Eigen的LLT分解实现了Cholesky分解。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Eigen/Cholesky&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Eigen::Matrix2d down;</span><br><span class="line">   down&lt;&lt;<span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">         <span class="number">2</span>,<span class="number">1</span>;</span><br><span class="line">   <span class="comment">// A &lt;&lt;1,2</span></span><br><span class="line">   <span class="comment">//   2,5</span></span><br><span class="line">   Eigen::Matrix2d A = down*down.<span class="built_in">transpose</span>();</span><br><span class="line">   std::cout&lt;&lt;<span class="string">&quot;A: &quot;</span>&lt;&lt; A &lt;&lt;std::endl;</span><br><span class="line">   <span class="comment">// 直接用 llt() 函数</span></span><br><span class="line">   Eigen::Matrix2d ml = A.<span class="built_in">llt</span>().<span class="built_in">matrixL</span>();</span><br><span class="line">   Eigen::Matrix2d testA = ml*ml.<span class="built_in">transpose</span>();</span><br><span class="line"></span><br><span class="line">   std::cout&lt;&lt;<span class="string">&quot;mllt:   &quot;</span>&lt;&lt; ml&lt;&lt;std::endl;</span><br><span class="line">   std::cout&lt;&lt;<span class="string">&quot;testA:  &quot;</span>&lt;&lt;testA&lt;&lt;std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于<code>Ax=b</code>，LLT分解并不会检查 A 矩阵的对称性，所以如果你输入的 A 矩阵不是正定的Hermite矩阵，你也会得到分解结果，只不过是错误的</p>
<h2 id="LDLT分解"><a href="#LDLT分解" class="headerlink" title="LDLT分解"></a>LDLT分解</h2><p>LDLT分解法实际上是Cholesky分解法的改进，优先使用LDLT而不是LLT方法。 Cholesky分解法虽然不需要选主元，但其运算过程中涉及到开方问题，而LDLT分解法则避免了这一问题。<strong>仍然要求A矩阵正定。</strong> 其中L为下三角形 单位 矩阵(即主对角线元素皆为1，下三角其他元素不为0)，D为对角矩阵， <script type="math/tex">L^T</script> 为L的转置矩阵。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Matrix2f A, b;</span><br><span class="line">A &lt;&lt; <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">3</span>;</span><br><span class="line">b &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is the matrix A:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is the right hand side b:\n&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">Matrix2f x = A.<span class="built_in">ldlt</span>().<span class="built_in">solve</span>(b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The solution is: \n&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<h2 id="QR分解"><a href="#QR分解" class="headerlink" title="QR分解"></a>QR分解</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Matrix3f A;</span><br><span class="line">Vector3f b;</span><br><span class="line">A &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,  <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,  <span class="number">7</span>,<span class="number">8</span>,<span class="number">10</span>;</span><br><span class="line">b &lt;&lt; <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 返回一个类ColPivHouseholderQR的对象</span></span><br><span class="line">Vector3f x = A.<span class="built_in">colPivHouseholderQr</span>().<span class="built_in">solve</span>(b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The solution is:\n&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="SVD分解-奇异值分解"><a href="#SVD分解-奇异值分解" class="headerlink" title="SVD分解 - 奇异值分解"></a>SVD分解 - 奇异值分解</h2><p>特征值分解仅针对方阵，而不是方阵的矩阵就有了SVD分解： <script type="math/tex">A=U\Sigma V^T</script><br>其中A为<code>m x n</code>的矩阵， 正交矩阵 U(<code>m x m</code>阶) 和 V(<code>n x n</code>阶)。  </p>
<script type="math/tex; mode=display">\Sigma_{mn} = \left[ \begin{matrix} \Sigma_1 & t \\ 0 & 1 \\ \end{matrix} \right]</script><script type="math/tex; mode=display">\Sigma_1=diag(\sigma_1....\sigma_r)</script><p>矩阵U的列称为左奇异向量, 是正交的。矩阵V的列向量(也称为右奇异向量)也是正交的. </p>
<p>此时的A如果是方阵，那么逆矩阵也很容易求出: <script type="math/tex">A^{-1} = VD^{-1}U^T</script><br>奇异值分解同时包含了旋转、缩放(<script type="math/tex">\Sigma</script>)和投影三种作用。特征值分解只有缩放的效果。<br><img src="https://i.loli.net/2021/08/04/4PntEcjMWQvLyO3.png" alt=""><br><img src="https://i.loli.net/2021/08/04/6Ety3UPv4hY7Abm.png" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix3f A;</span><br><span class="line">A &lt;&lt; <span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,</span><br><span class="line">     <span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,</span><br><span class="line">     <span class="number">8</span>,<span class="number">0</span>,<span class="number">1</span>;</span><br><span class="line"><span class="comment">// SVD分解</span></span><br><span class="line"><span class="function">Eigen::JacobiSVD&lt;Eigen::Matrix3f&gt; <span class="title">svd</span><span class="params">(A, Eigen::ComputeFullU | Eigen::ComputeFullV)</span></span>;</span><br><span class="line"><span class="comment">// 求出三个矩阵</span></span><br><span class="line">Eigen::Matrix3f U = svd.<span class="built_in">matrixU</span>();</span><br><span class="line">Eigen::Matrix3f V = svd.<span class="built_in">matrixV</span>();</span><br><span class="line"><span class="comment">// 推荐方法，从对角线元素组成的向量直接构造对角矩阵</span></span><br><span class="line">Eigen::Matrix3f diag = svd.<span class="built_in">singularValues</span>().<span class="built_in">asDiagonal</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;U: &quot;</span>&lt;&lt;endl&lt;&lt; U &lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;V transpose: &quot;</span>&lt;&lt; endl &lt;&lt; V.<span class="built_in">transpose</span>() &lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Sigma from SVD: &quot;</span>&lt;&lt; endl &lt;&lt; diag&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断U和V是否正交矩阵（酉矩阵），和转置的乘积为单位矩阵</span></span><br><span class="line">cout &lt;&lt; U.<span class="built_in">isUnitary</span>() &lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; V.<span class="built_in">isUnitary</span>() &lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;***********************&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从公式推导出的对角矩阵，有误差</span></span><br><span class="line">Eigen::Matrix3f Sigma = U.<span class="built_in">inverse</span>() * A * V.<span class="built_in">transpose</span>().<span class="built_in">inverse</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Sigma from formula: &quot;</span>&lt;&lt; endl &lt;&lt; Sigma &lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大致等于原矩阵A</span></span><br><span class="line">cout&lt;&lt; <span class="string">&quot;A from formula: &quot;</span>&lt;&lt; endl &lt;&lt;U *Sigma *V.<span class="built_in">transpose</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure><br>运行结果:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">U: </span><br><span class="line">   0.4853 -0.514629 -0.706853</span><br><span class="line"> 0.299358 -0.661777   0.68734</span><br><span class="line"> 0.821504  0.545168  0.167102</span><br><span class="line"></span><br><span class="line">V transpose: </span><br><span class="line">  0.904647   0.275928   0.324773</span><br><span class="line">  0.423663  -0.664689  -0.615385</span><br><span class="line">-0.0460712    -0.6943    0.71821</span><br><span class="line"></span><br><span class="line">S from SVD: </span><br><span class="line">9.20501       0       0</span><br><span class="line">      0  5.0882       0</span><br><span class="line">      0       0 2.09237</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">***********************</span><br><span class="line">S from formula: </span><br><span class="line">     9.20501 -9.53674e-07 -2.38419e-07</span><br><span class="line"> -1.3113e-06       5.0882  1.05798e-06</span><br><span class="line">-7.15256e-07  2.90573e-07      2.09237</span><br><span class="line"></span><br><span class="line">A from formula: </span><br><span class="line">3 4 2</span><br><span class="line">1 2 4</span><br><span class="line">8 0 1</span><br></pre></td></tr></table></figure><br>Eigen提供了两个类以实现SVD分解：<code>BDCSVD</code>（大矩阵）和<code>JacobiSVD</code>（小矩阵），推荐使用<code>BDCSVD</code>，因为当发现要分解的矩阵是小矩阵时，将自动切换到<code>JacobiSVD</code></p>
<ul>
<li>A转为正交矩阵</li>
</ul>
<p>把上面的<code>ComputeFullU</code>换成<code>ComputeThinU</code>，那么<script type="math/tex">U \times V^T</script> 就是一个正交矩阵B<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SVD分解, ComputeThin参数时，A必须是 Eigen::MatrixXf</span></span><br><span class="line"><span class="function">Eigen::JacobiSVD&lt;Eigen::MatrixXf&gt; <span class="title">svd</span><span class="params">(A, Eigen::ComputeThinU | Eigen::ComputeThinV )</span></span>;</span><br><span class="line"><span class="comment">// 求出三个矩阵，这样B就是个正交矩阵</span></span><br><span class="line">Eigen::Matrix3f U = svd.<span class="built_in">matrixU</span>();</span><br><span class="line">Eigen::Matrix3f V = svd.<span class="built_in">matrixV</span>();</span><br><span class="line">Eigen::Matrix3f B = U * V.<span class="built_in">transpose</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; B.<span class="built_in">transpose</span>() &lt;&lt; endl &lt;&lt;endl;</span><br><span class="line">cout &lt;&lt; B.<span class="built_in">inverse</span>() &lt;&lt; endl&lt;&lt;endl;</span><br></pre></td></tr></table></figure></p>
<h2 id="线性方程组的最小二乘解"><a href="#线性方程组的最小二乘解" class="headerlink" title="线性方程组的最小二乘解"></a>线性方程组的最小二乘解</h2><p>如果一个线性方程组是超定的(overdeterminated，未知数个数&gt;方程数)，这时候常规方法无解，就需要用最小二乘拟合最优结果。最精确的解法是SVD分解。SVD也有多种解法，官方推荐的是<code>BDCSVD</code>方法。</p>
<p>如下超定方程组：<br><img src="https://i.loli.net/2021/07/13/nO5X2yTVvZKbPoj.png" alt="1.png"><br><img src="https://i.loli.net/2021/07/13/fiXjLN8AkCqJgZI.png" alt="2.png"></p>
<p>最小二乘求解代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXf <span class="title">A</span><span class="params">(<span class="number">3</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Vector3f b;</span><br><span class="line">Vector2f x;</span><br><span class="line">A &lt;&lt; <span class="number">1</span>,<span class="number">1</span>, <span class="number">1</span>,<span class="number">2</span>, <span class="number">1</span>,<span class="number">3</span> ;</span><br><span class="line">b &lt;&lt; <span class="number">0</span>,<span class="number">4</span>,<span class="number">10</span>;</span><br><span class="line">x = A.<span class="built_in">bdcSvd</span>(ComputeThinU | ComputeThinV).<span class="built_in">solve</span>(b);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Vector3f error = (A*x - b).<span class="built_in">cwiseAbs</span>();</span><br><span class="line"><span class="keyword">double</span> mean_error = error.<span class="built_in">mean</span>();</span><br></pre></td></tr></table></figure><br>程序运行需要一点时间，最后得到的x就是通过最小二乘算出来的。这里<code>bcdScd()</code>函数里面的参数<code>ComputeThinU | ComputeThinV</code>必须要写(可以先记住)，否则会报错。</p>
<p>将得到的解带回方程会发现其并不是严格成立的，有时可能还会相差较大。这是因为对于超定方程，采用最小二乘法得出的解并不一定对每一个方程都严格成立，其确保的是当前解在所有方程上的总误差最小。得到解以后我们可以反算出其解的整体精度</p>
<p><br></p>
<p>对于小矩阵，逆矩阵和行列式随便算，如果是大矩阵，计算量会很庞大。确定你是否真的需要逆矩阵，因为很多时候求逆矩阵都是为了求解<code>Ax = b</code>问题，所以最好使用上面介绍的分解方法代替.</p>
<p>参考：<br><a target="_blank" rel="noopener" href="http://zhaoxuhui.top/blog/2019/09/03/eigen-note-4.html#5%E5%8F%98%E6%8D%A2">Eigen学习与使用笔记</a><br><a target="_blank" rel="noopener" href="http://zhaoxuhui.top/blog/2019/08/22/eigen-note-2.html#2%E8%AE%A1%E7%AE%97%E7%89%B9%E5%BE%81%E5%80%BC%E4%B8%8E%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F">Eigen学习与使用笔记2</a><br><a target="_blank" rel="noopener" href="https://eigen.tuxfamily.org/dox/classEigen_1_1AngleAxis.html">Eigen官方文档-AngleAxis</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31386807">矩阵的特征分解与奇异值分解</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/15/%E7%9B%B8%E6%9C%BA/Kinect%20v1%E8%BF%90%E8%A1%8CORB_SLAM2/">KinectV1运行 ORB_SLAM2</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E7%9B%B8%E6%9C%BA/">相机</a></span><div class="content"><p>ORB_SLAM2是一个基于深度相机、Pose graph （图优化）的程序，后端用的是g2o。第一个版本仅仅是单目SLAM，第二个版本在原来的单目基础上增加了双目和RGBD的接口，尽管地图还是单目常见的稀疏特征点图，但是我们能通过各种传感器来玩ORB_SLAM2了</p>
<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>只要按照<a target="_blank" rel="noopener" href="https://github.com/raulmur/ORB_SLAM2">Github上的安装指导</a>进行就可以</p>
<p>需要先安装Eigen3和Pangolin，后者也按Github上的说明安装即可，不必安装Recommended Dependencies和Optional Dependencies，只要执行<code>Building</code>就行。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/raulmur/ORB_SLAM2.git ORB_SLAM2</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ORB_SLAM2</span><br><span class="line">chmod +x build.sh</span><br><span class="line">./build.sh</span><br></pre></td></tr></table></figure>
<p>这会编译产生<code>libORB_SLAM2.so</code>到<code>lib</code>文件夹，以及<code>Examples/Monocular</code>文件夹中生成<code>mono_euroc</code>,<code>mono_tum</code>, <code>mono_kitti</code>; <code>RGB-D</code>文件夹中生成<code>rgbd_tum</code>; <code>Stereo</code>文件夹中生成<code>stereo_kitti</code>和<code>stereo_euroc</code></p>
<p>第一次编译忘了<code>build_ros.sh</code>，也就是少编译了几个核心文件，结果无法运行运行后又产生了问题</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>编译报错<code>ros_rgbd.cc.o: undefined reference to symbol &#39;_ZN5boost6system15system_categoryEv&#39;</code>，解决方法是在<code>/ORB_SLAM2/Examples/ROS/ORB_SLAM2/CMakeLists.txt</code>中添加boost_system库：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set(LIBS</span><br><span class="line">	$&#123;OpenCV_LIBS&#125;</span><br><span class="line">	$&#123;EIGEN3_LIBS&#125;</span><br><span class="line">	$&#123;Pangolin_LIBRARIES&#125;</span><br><span class="line">	$&#123;PROJECT_SOURCE_DIR&#125;/../../../Thirdparty/DBoW2/lib/libDBoW2.so</span><br><span class="line">	$&#123;PROJECT_SOURCE_DIR&#125;/../../../Thirdparty/g2o/lib/libg2o.so</span><br><span class="line">	$&#123;PROJECT_SOURCE_DIR&#125;/../../../lib/libORB_SLAM2.so</span><br><span class="line">	-lboost_system</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h2 id="RGB-D例子"><a href="#RGB-D例子" class="headerlink" title="RGB-D例子"></a>RGB-D例子</h2><p>从<a target="_blank" rel="noopener" href="http://vision.in.tum.de/data/datasets/rgbd-dataset/download">序列下载</a>下载一个序列并解压。</p>
<p>使用<code>associate.py</code> associate RGB images and depth images. We already provide associations for some of the sequences in Examples/RGB-D/associations/. 你可以生成自己的associations文件:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python associate.py PATH_TO_SEQUENCE/rgb.txt PATH_TO_SEQUENCE/depth.txt &gt; associations.txt</span><br></pre></td></tr></table></figure></p>
<p>将<code>TUMX.yaml</code>换成TUM1.yaml,TUM2.yaml or TUM3.yaml for freiburg1, freiburg2 and freiburg3 sequences respectively. 填好<code>PATH_TO_SEQUENCE_FOLDER</code>和<code>ASSOCIATIONS_FILE</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Examples/RGB-D/rgbd_tum Vocabulary/ORBvoc.txt Examples/RGB-D/TUMX.yaml PATH_TO_SEQUENCE_FOLDER ASSOCIATIONS_FILE</span><br></pre></td></tr></table></figure></p>
<h2 id="运行自己的RGBD节点"><a href="#运行自己的RGBD节点" class="headerlink" title="运行自己的RGBD节点"></a>运行自己的RGBD节点</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun ORB_SLAM2 RGBD ORB_SLAM2/Vocabulary/ORBvoc.txt ~/path/kinect_calibration.yaml</span><br></pre></td></tr></table></figure>
<p><code>ORBvoc.txt</code>还是下载的那个，<code>kinect_calibration.yaml</code>就是我们自己的相机标定文件，这里有个问题，之前标定得到的yaml文件和这里要求的yaml文件格式不同，我们需要的可以参考<code>~/ORB_SLAM2-master/Examples/ROS/ORB_SLAM2/Asus.yaml</code>，只需要修改相机矩阵和畸变系数即可。</p>
<p>之前标定的yaml文件部分：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">camera_matrix:</span><br><span class="line">  rows: <span class="number">3</span></span><br><span class="line">  cols: <span class="number">3</span></span><br><span class="line">  data: [<span class="number">519.7959964940057</span>, <span class="number">0</span>, <span class="number">311.8351165024031</span>, <span class="number">0</span>, <span class="number">520.264653178918</span>, <span class="number">260.4976776521158</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">distortion_model: plumb_bob</span><br><span class="line">distortion_coefficients:</span><br><span class="line">  rows: <span class="number">1</span></span><br><span class="line">  cols: <span class="number">5</span></span><br><span class="line">  data: [<span class="number">0.1316145046090376</span>, -<span class="number">0.2008704147933575</span>, <span class="number">0.002009131405045224</span>, <span class="number">0.0002143881752906817</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<p>参数解释如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#内参数矩阵</span></span><br><span class="line">|        fx          0             cx     |</span><br><span class="line">|         0          fy            cy     |</span><br><span class="line">|         0          0             1      |</span><br><span class="line"></span><br><span class="line">fx : focal length <span class="keyword">in</span> direction of camera<span class="string">&#x27;s x axis </span></span><br><span class="line"><span class="string">fy : focal length in direction of camera&#x27;</span>s y axis </span><br><span class="line">cx,cy  : Principal point <span class="keyword">in</span> image</span><br><span class="line"></span><br><span class="line">distortion_coefficients (1x5):   <span class="comment">#畸变相关系数，是一个1x5的矩阵</span></span><br><span class="line">[k1    k2     p1     p2     k3]</span><br><span class="line"></span><br><span class="line">k1,k2,k3 : Radial distortion coefficients    <span class="comment"># 径向畸变</span></span><br><span class="line">p1, p2 : Tangential distortion coefficinets  <span class="comment"># 切向畸变</span></span><br><span class="line">k3 - <span class="built_in">set</span> to zero (only applicable <span class="keyword">for</span> fish-eyed lens)</span><br></pre></td></tr></table></figure></p>
<p>根据说明将需要的参数对<code>Asus.yaml</code>进行修改：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Camera calibration and distortion parameters (OpenCV) </span><br><span class="line">Camera.fx: 519.7959964940057</span><br><span class="line">Camera.fy: 520.264653178918</span><br><span class="line">Camera.cx: 311.8351165024031</span><br><span class="line">Camera.cy: 260.4976776521158</span><br><span class="line"></span><br><span class="line">Camera.k1: 0.1316145046090376</span><br><span class="line">Camera.k2: -0.2008704147933575</span><br><span class="line">Camera.p1: 0.002009131405045224</span><br><span class="line">Camera.p2: 0.0002143881752906817</span><br></pre></td></tr></table></figure></p>
<p>现在运行节点，终端一切正常，出现两个窗口<code>Current Frame</code>和<code>Map Viewer</code>，但是前者一片黑，后者没有内容。发现<code>Current Frame</code>状态是<code>Waiting for images</code>，节点需要的是话题<code>/camera/rgb/image_raw</code>和<code>/camera/depth_registered/image_raw</code>，使用<code>rostopic info</code>发现话题发布订阅都正常，但是<code>rostopic echo</code>后者却没有数据。</p>
<p>默认情况下，对于深度图，选择<code>/camera/depth/XXXX</code>的话题才会显示出来图像，因为没有设置<code>depth_registered</code>，如果在显示的过程中，在新的终端里使用<code>rosrun rqt_reconfiguration rqt_reconfiguration</code>，之后在<strong>camera-&gt;driver</strong>中勾选了<em>depth_registered</em>，此时rqt窗口就不会进行图像刷新了，此时切换至<code>/camera/depth_registered/XXXX</code>的话题后，继续会刷新图像。   <strong>但问题是好像重启freenect之后又要设置</strong><br><img src="https://i.loli.net/2020/02/19/wHf4Kgm2eQ7LBpl.png" alt="rqt_reconfigure"><br>再次启动节点，就能看到结果了。在<code>MapViewer</code>上，鼠标左键是移动，右键旋转，滚轮放大缩小。</p>
<h2 id="SLAM-和-Localization-模式"><a href="#SLAM-和-Localization-模式" class="headerlink" title="SLAM 和 Localization 模式"></a>SLAM 和 Localization 模式</h2><p>你可以使用<code>map viewer</code>在SLAM和Localization模式之间切换</p>
<p>SLAM Mode：默认模式，有三个线程: Tracking, Local Mapping 和 Loop Closing. 对相机定位，建立新地图并close loops</p>
<p>Localization Mode：如果当前区域一个比较好的地图，可以用这个模式。Local Mapping 和 Loop Closing 线程没有启动. 定位地图中的相机(which is no longer updated), 有必要的话会重定位</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/46/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/46/">46</a><span class="page-number current">47</span><a class="page-number" href="/page/48/">48</a><span class="space">&hellip;</span><a class="page-number" href="/page/66/">66</a><a class="extend next" rel="next" href="/page/48/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2023 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>