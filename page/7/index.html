<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">661</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">53</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2023/05/04/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/Gazebo%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/">Gazebo使用心得</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-05-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/">ROS机器人</a></span><div class="content"><p><strong>Gazebo不好上手，费了一番功夫终于熟悉了，内容太多，只记录注意事项。</strong></p>
<p>Gazebo里用的是<font size="4" color="blue"> 前x 左y 上z的右手坐标系 </font>，gazebo的栅格范围是<code>20mX20m</code></p>
<p>启动<code>simple_world.launch</code>，然后在Gazebo里添加一个圆柱体，保存覆盖<code>simple.world</code>文件。再次启动时，报错 <font color=orange >  SpawnModel: Failure - model name sunny already exist. [Spawn service failed. Exiting. </font> 和 <font color=orange > [spawn_urdf-6] process has died  </font></p>
<p>按<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44236630/article/details/124609824">网上说的方法</a>没能解决，也不能重命名<code>model</code>，修改<code>simple.world</code>无效。 最后删除了<code>&lt;node pkg=&quot;gazebo_ros&quot; type=&quot;spawn_model&quot; name=&quot;spawn_urdf&quot;  args=&quot;-urdf -model sunny -x $(arg x_pos) -y $(arg y_pos) -z $(arg z_pos) -param robot_description&quot; /&gt;</code> 解决问题。</p>
<h2 id="urdf-和-xacro"><a href="#urdf-和-xacro" class="headerlink" title="urdf 和 xacro"></a>urdf 和 xacro</h2><p><code>urdf.xacro</code>文件里，<code>&lt;link name=&quot;base_link&quot;&gt;</code>代表机器人的主体。<code>&lt;geometry&gt; &lt;box size=&quot;0.4 0.39 0.5&quot; /&gt;</code>是尺寸。</p>
<p>gazebo插件，可以简单理解为就是连接gazebo和ros的一个桥梁，一边插件通过gazebo的api来控制仿真环境的机器人关节等数据，一边通过关节数据通过运动学模型生成里程计、雷达的scan、image等类似的信息</p>
<h2 id="solidworks生成urdf"><a href="#solidworks生成urdf" class="headerlink" title="solidworks生成urdf"></a>solidworks生成urdf</h2><p><code>solidworks to urdf</code>安装后，如果在solidworks里找不到，就安装最新版的，不用管版本是否对应。</p>
<p>solidworks只生成的URDF文件，没有xacro文件. URDF文件做一些简单修改可保存为xacro，注意：</p>
<ol>
<li><code>joint</code>的 <code>type=&quot;fixed&quot;</code>，应当为<code>continuous</code></li>
<li><code>joint</code>的某些参数值错误，导致车加载差速模型后，运动错误</li>
</ol>
<h2 id="xacro"><a href="#xacro" class="headerlink" title="xacro"></a>xacro</h2><p>xacro里面的模型仍然是urdf模型，有如下变化：</p>
<ol>
<li>创建宏定义</li>
<li>文件包含</li>
<li>提供可编程接口:常量, 变量, 数学计算, 条件语句</li>
</ol>
<p>启动Gazebo时，机器人模型的tf关系不完整，即使<code>xacro</code>文件正确。还需要添加<code>joint_state_publisher</code> 和<code>robot_state_publisher</code></p>
<p>设置雷达时，看情况决定是否需要可视化<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sensor</span> <span class="attr">type</span>=<span class="string">&quot;ray&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lds_lfcd_sensor&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pose</span>&gt;</span>0 0 0 0 0 0<span class="tag">&lt;/<span class="name">pose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">visualize</span>&gt;</span>false<span class="tag">&lt;/<span class="name">visualize</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Gazebo默认的障碍物质量轻，车撞上之后会把障碍物推开。改变<code>density</code>选项为铁，则不会推动障碍物。</p>
<p><br></p>
<p>在Gazebo world中用以下方式加载模型时：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">uri</span>&gt;</span>model://one_building<span class="tag">&lt;/<span class="name">uri</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure><br>要让Gazebo能够找到uri中的自建model，需要将自己的model路径加入环境变量， <code>export GAZEBO_MODEL_PATH=~/&lt;path&gt;/my_package/models:$&#123;GAZEBO_MODEL_PATH&#125;</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/04/25/C++/C++%20%20%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%AD%97%E7%9A%84%E7%B1%BB%E5%9E%8B/">数字的类型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-04-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E5%9F%BA%E7%A1%80/">C++ 基础</a></span><div class="content"><p>数字后面带个U，L，F的含义</p>
<ul>
<li>U表示该常数用无符号整型方式存储，相当于 unsigned int</li>
<li>L表示该常数用长整型方式存储，相当于 long</li>
<li>F表示该常数用浮点方式存储，相当于 float</li>
</ul>
<p>比如 <code>-1UL</code>, 其实是一个很大很大的数</p>
<h2 id="OpennCV的数据类型"><a href="#OpennCV的数据类型" class="headerlink" title="OpennCV的数据类型"></a>OpennCV的数据类型</h2><p>S = 有符号整型 U = 无符号整型 F = 浮点型</p>
<ul>
<li>CV_8U - 8位无符号整数（0…255）</li>
<li><p>CV_32F - 32位浮点数（-FLT_MAX…FLT_MAX，INF，NAN）</p>
</li>
<li><p>CV_8U - 8位无符号整数（0…255）</p>
</li>
<li><p>CV_8S - 8位有符号整数（-128…127）</p>
</li>
<li><p>CV_16U - 16位无符号整数（0…65535）</p>
</li>
<li><p>CV_16S - 16位有符号整数（-32768…32767）</p>
</li>
<li><p>CV_32S - 32位有符号整数（-2147483648…2147483647）</p>
</li>
<li><p>CV_32F - 32位浮点数（-FLT_MAX…FLT_MAX，INF，NAN）</p>
</li>
<li><p>CV_64F - 64位浮点数（-DBL_MAX…DBL_MAX，INF，NAN）</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/04/04/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/trimmer%E6%9C%BA%E5%88%B6-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%90%E5%9B%BE/">trimmer机制 - 移除重复子图</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-04-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>在<code>PoseGraph2D::HandleWorkQueue</code>里，<code>RunOptimization();</code>之后<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子图的裁剪，如果没有裁剪器就不裁剪</span></span><br><span class="line">   <span class="function">TrimmingHandle <span class="title">trimming_handle</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; trimmer : trimmers_) &#123;</span><br><span class="line">     trimmer-&gt;<span class="built_in">Trim</span>(&amp;trimming_handle);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 这里只有纯定位时才执行</span></span><br><span class="line"><span class="comment">// 裁剪器完成状态，删除裁剪器</span></span><br><span class="line">   trimmers_.<span class="built_in">erase</span>(</span><br><span class="line">       std::<span class="built_in">remove_if</span>(trimmers_.<span class="built_in">begin</span>(), trimmers_.<span class="built_in">end</span>(),</span><br><span class="line">                      [](std::unique_ptr&lt;PoseGraphTrimmer&gt;&amp; trimmer) &#123;</span><br><span class="line">                        <span class="keyword">return</span> trimmer-&gt;<span class="built_in">IsFinished</span>();</span><br><span class="line">                      &#125;),</span><br><span class="line">       trimmers_.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><br><code>trimmers_</code>的添加是 <code>PoseGraph2D</code>构造函数 —— <code>PoseGraph2D::AddTrimmer</code></p>
<p>先看构造函数部分<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options.<span class="built_in">has_overlapping_submaps_trimmer_2d</span>()  )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; trimmer_options = options.<span class="built_in">overlapping_submaps_trimmer_2d</span>();</span><br><span class="line">    <span class="built_in">AddTrimmer</span>(absl::make_unique&lt;OverlappingSubmapsTrimmer2D&gt;(</span><br><span class="line">        trimmer_options.<span class="built_in">fresh_submaps_count</span>(),</span><br><span class="line">        trimmer_options.<span class="built_in">min_covered_area</span>(),</span><br><span class="line">        trimmer_options.<span class="built_in">min_added_submaps_count</span>() )  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>三个参数:</p>
<ol>
<li>fresh_submaps_count = 2    最新的2个submaps</li>
<li>min_covered_area = 3.0     最小未被覆盖的面积</li>
<li>min_added_submaps_count = 5      代表在5个submaps之后才会进行该项操作，这个参数不实用，主要是上面两个</li>
</ol>
<p>Trims submaps that have less than <code>min_covered_cells_count</code> cells not overlapped by at least <code>fresh_submaps_count</code> submaps. 也就是说一些子图如果只有<code>min_covered_cells_count</code>个栅格没有被<code>fresh_submaps_count</code>个子图覆盖，那么这些子图被裁剪掉。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::AddTrimmer</span><span class="params">(std::unique_ptr&lt;PoseGraphTrimmer&gt; trimmer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// C++11 does not allow us to move a unique_ptr into a lambda.</span></span><br><span class="line">  PoseGraphTrimmer* <span class="keyword">const</span> trimmer_ptr = trimmer.<span class="built_in">release</span>();</span><br><span class="line">  <span class="built_in">AddWorkItem</span>([<span class="keyword">this</span>, trimmer_ptr]() <span class="built_in">LOCKS_EXCLUDED</span>(mutex_) &#123;</span><br><span class="line">    absl::MutexLock <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">    trimmers_.<span class="built_in">emplace_back</span>(trimmer_ptr);</span><br><span class="line">    <span class="keyword">return</span> WorkItem::Result::kDoNotRunOptimization;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类<code>PoseGraphTrimmer</code>的派生类有 <code>PureLocalizationTrimmer</code> 和 <code>OverlappingSubmapsTrimmer2D</code>。前者属于纯定位部分，这里不看。后者其实主要就实现了一个<code>Trim</code>函数。 </p>
<p>回头看<code>trimmers_.erase</code>这一句，发现<code>OverlappingSubmapsTrimmer2D::IsFinished()</code>永远返回 false，所以这一句只有纯定位时才会执行，建图不执行。 </p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/03/29/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/frozen%E8%BD%A8%E8%BF%B9%E7%9A%84%E7%89%B9%E7%82%B9/">frozen轨迹的特点</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>frozen轨迹的子图和节点不参与优化问题中的优化，也就是5个残差的计算。但是参与inter global约束的计算，也就是纯定位。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/03/04/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E9%9A%9C%E7%A2%8D%E7%BA%A6%E6%9D%9F%E5%92%8C%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8E%A8%E5%AF%BC/">障碍约束和雅格比矩阵的推导</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/">TEB算法</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E5%90%84%E7%B1%BB%E7%BA%A6%E6%9D%9F%E5%8F%8A%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5/">各类约束及雅格比矩阵</a></span><div class="content"><p>障碍约束定义的误差函数表示机器人到障碍的最小距离。 $ \min \textrm{penaltyBelow}( dist2point ) \cdot weight $. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VertexPose* bandpt = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> VertexPose*&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// calculateDistance(const PoseSE2&amp; current_pose, const Obstacle* obstacle) 计算机器人到障碍物的距离</span></span><br><span class="line"><span class="comment">// current_pose为当前机器人的位姿。</span></span><br><span class="line"><span class="keyword">double</span> dist = robot_model_-&gt;<span class="built_in">calculateDistance</span>(bandpt-&gt;<span class="built_in">pose</span>(), _measurement);</span><br><span class="line">_error[<span class="number">0</span>] = <span class="built_in">penaltyBoundFromBelow</span>(dist, cfg_-&gt;obstacles.min_obstacle_dist, cfg_-&gt;optim.penalty_epsilon);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cfg_-&gt;optim.obstacle_cost_exponent != <span class="number">1.0</span> &amp;&amp; cfg_-&gt;obstacles.min_obstacle_dist &gt; <span class="number">0.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  _error[<span class="number">0</span>] = cfg_-&gt;obstacles.min_obstacle_dist * std::<span class="built_in">pow</span>(_error[<span class="number">0</span>] / cfg_-&gt;obstacles.min_obstacle_dist, </span><br><span class="line">  										cfg_-&gt;optim.obstacle_cost_exponent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>obstacle_cost_exponent</code>和<code>min_obstacle_dist</code>的设置，一般都会进入if情况。 注意 max cost (before weighting) is the same as the straight line version and that all other costs are below the straight line (for positive exponent), so it may be necessary to increase weight_obstacle and/or the inflation_weight when using larger exponents.</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/03/04/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4%E7%BA%A6%E6%9D%9F%E5%92%8Ckinematics%E7%BA%A6%E6%9D%9F%E5%8F%8A%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8E%A8%E5%AF%BC/">时间约束和kinematics约束及雅格比矩阵的推导</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/">TEB算法</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E5%90%84%E7%B1%BB%E7%BA%A6%E6%9D%9F%E5%8F%8A%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5/">各类约束及雅格比矩阵</a></span><div class="content"><h2 id="时间约束"><a href="#时间约束" class="headerlink" title="时间约束"></a>时间约束</h2><p><code>EdgeTimeOptimal</code>类太简单了，误差函数 <code>_error[0] = timediff-&gt;dt();</code>，优化 <script type="math/tex">\Delta T_i</script>，那么对其求偏导，显然只有一个矩阵，一个元素 1 ： <code>_jacobianOplusXi( 0 , 0 ) = 1;</code></p>
<h2 id="kinematics-约束"><a href="#kinematics-约束" class="headerlink" title="kinematics 约束"></a>kinematics 约束</h2><p>两个误差方程，一个是 non-holonomic约束， ：<br><img src="https://s2.loli.net/2023/03/09/fA3hlesp26nZrN7.png" alt=""><br>初始配置<script type="math/tex">x_i</script>和方向<script type="math/tex">d_i,d_{i+1}</script>之间的角度<script type="math/tex">\theta _i</script> 必须等于配置<script type="math/tex">x_{i+1}</script>和方向<script type="math/tex">d_i,d_{i+1}</script>之间的夹角，即<script type="math/tex">\theta _i = \theta_{i+1}</script></p>
<p>根据二维叉积 A×B=|A| |B|⋅sinα 得到<br><img src="https://s2.loli.net/2023/03/09/XRLQ2BNg1Mu8VfE.png" alt=""><br>所以代码中的目标函数写成</p>
<script type="math/tex; mode=display">|(cos{\theta_1}+cos{\theta_2})(y_2-y_1) - (sin{\theta_1}+sin{\theta_2})(x_2-x_1) |</script><p>另一个是 positive-drive-direction约束</p>
<script type="math/tex; mode=display">-(x_2-x_1)cos{\theta_1} -(y_2-y_1)sin{\theta_1}</script><p>两个configure，所以两个雅格比，维度明显是 2x3，两个误差方程分别对(x, y, angle)求偏导，源码里的求导很简单，还不如速度约束的求导复杂，就不写过程了。</p>
<p>值得注意的是绝对值的求导结果会用<code>sign</code>函数表示。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/03/04/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E5%8A%A0%E9%80%9F%E5%BA%A6%E7%BA%A6%E6%9D%9F%E5%8F%8A%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8E%A8%E5%AF%BC/">加速度约束和雅格比矩阵的推导</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/">TEB算法</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E5%90%84%E7%B1%BB%E7%BA%A6%E6%9D%9F%E5%8F%8A%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5/">各类约束及雅格比矩阵</a></span><div class="content"><p>默认为5元边约束。 但是包含3个类：<code>EdgeAcceleration</code>, <code>EdgeAccelerationStart</code>, <code>EdgeAccelerationGoal</code>，后两个为3元边</p>
<p><script type="math/tex">\frac{error}{cost}</script> 向量的维度是2，第一个元素代表线加速度，第二个是角加速度。<br><code>EdgeAccelerationStart()</code> and <code>EdgeAccelerationGoal()</code> 用于边界值</p>
<p>加速度约束和速度约束类似，不过变成两段圆弧和角度差、两个时间差、两个线速度和角速度。两个线速度的差除以两个时间差之和就是加速度。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> vel1 = dist1 / dt1-&gt;<span class="built_in">dt</span>();</span><br><span class="line"><span class="keyword">double</span> vel2 = dist2 / dt2-&gt;<span class="built_in">dt</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> acc_lin  = (vel2 - vel1)*<span class="number">2</span> / ( dt1-&gt;<span class="built_in">dt</span>() + dt2-&gt;<span class="built_in">dt</span>() );</span><br><span class="line">_error[<span class="number">0</span>] = <span class="built_in">penaltyBoundToInterval</span>(acc_lin,cfg_-&gt;robot.acc_lim_x, cfg_-&gt;optim.penalty_epsilon);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> omega1 = angle_diff1 / dt1-&gt;<span class="built_in">dt</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> omega2 = angle_diff2 / dt2-&gt;<span class="built_in">dt</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> acc_rot  = (omega2 - omega1)*<span class="number">2</span> / ( dt1-&gt;<span class="built_in">dt</span>() + dt2-&gt;<span class="built_in">dt</span>() );</span><br><span class="line">_error[<span class="number">1</span>] = <span class="built_in">penaltyBoundToInterval</span>(acc_rot,cfg_-&gt;robot.acc_lim_theta, cfg_-&gt;optim.penalty_epsilon);</span><br></pre></td></tr></table></figure></p>
<h3 id="起点的加速度约束"><a href="#起点的加速度约束" class="headerlink" title="起点的加速度约束"></a>起点的加速度约束</h3><p>注意：起点加速度约束和终点加速度约束都是3元边。</p>
<p>对于起点的加速度约束，源码有以下变化:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInitialVelocity</span><span class="params">(<span class="keyword">const</span> geometry_msgs::Twist&amp; vel_start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_measurement = &amp;vel_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_ASSERT_MSG</span>(cfg_ &amp;&amp; _measurement, </span><br><span class="line"><span class="string">&quot;You must call setTebConfig() and setInitialVelocity() on EdgeAccelerationStart()&quot;</span>);</span><br><span class="line">vel1 = _measurement-&gt;linear.x;</span><br><span class="line">omega1 = _measurement-&gt;angular.z;</span><br></pre></td></tr></table></figure><br>其他全一样，对于终点的加速度约束，则是<code>vel2</code>和<code>omega2</code>换成了<code>_measurement</code>的成员。那么这个<code>_measurement</code>从何而来？</p>
<p>在<code>TebOptimalPlanner::plan</code>里有一段:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (start_vel)</span><br><span class="line">  <span class="built_in">setVelocityStart</span>(*start_vel);</span><br><span class="line"><span class="keyword">if</span> (free_goal_vel)</span><br><span class="line">  <span class="built_in">setVelocityGoalFree</span>();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  vel_goal_.first = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>setVelocityStart</code>给起始速度赋值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::pair&lt;bool, geometry_msgs::Twist&gt;  vel_start_;</span></span><br><span class="line"><span class="comment">// 注意vel_start_ 和 vel_start 不同</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TebOptimalPlanner::setVelocityStart</span><span class="params">(<span class="keyword">const</span> geometry_msgs::Twist&amp; vel_start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vel_start_.first = <span class="literal">true</span>;</span><br><span class="line">  vel_start_.second.linear.x = vel_start.linear.x;</span><br><span class="line">  vel_start_.second.linear.y = vel_start.linear.y;</span><br><span class="line">  vel_start_.second.angular.z = vel_start.angular.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后到了<code>AddEdgesAcceleration</code>里添加起始加速度约束，才用到<code>vel_start_</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vel_start_.first)</span><br><span class="line">&#123;</span><br><span class="line">  EdgeAccelerationStart* acceleration_edge = <span class="keyword">new</span> EdgeAccelerationStart;</span><br><span class="line">  acceleration_edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>,teb_.<span class="built_in">PoseVertex</span>(<span class="number">0</span>));</span><br><span class="line">  acceleration_edge-&gt;<span class="built_in">setVertex</span>(<span class="number">1</span>,teb_.<span class="built_in">PoseVertex</span>(<span class="number">1</span>));</span><br><span class="line">  acceleration_edge-&gt;<span class="built_in">setVertex</span>(<span class="number">2</span>,teb_.<span class="built_in">TimeDiffVertex</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="comment">// 这里就是上面的 setInitialVelocity, _measurement 就是 vel_start_.second</span></span><br><span class="line">  acceleration_edge-&gt;<span class="built_in">setInitialVelocity</span>(vel_start_.second);</span><br><span class="line">  acceleration_edge-&gt;<span class="built_in">setInformation</span>(information);</span><br><span class="line">  acceleration_edge-&gt;<span class="built_in">setTebConfig</span>(*cfg_);</span><br><span class="line">  optimizer_-&gt;<span class="built_in">addEdge</span>(acceleration_edge);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>AddEdgesAcceleration</code>然后添加普通的加速度约束，再就是终点的加速度约束，这里就奇怪了，相应的<code>setVelocityGoal</code>函数没有调用的地方，这里是<code>vel_goal_.second</code>唯一赋值的地方。即使<code>free_goal_vel</code>为false，也没有赋值，意思是终点的速度为0？</p>
<p>雅格比矩阵的推导可以参照速度约束的，不同的地方是这次把角度单独拿出来了，这样有了8个雅格比<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_jacobianOplus[<span class="number">0</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// conf1</span></span><br><span class="line">_jacobianOplus[<span class="number">1</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// conf2</span></span><br><span class="line">_jacobianOplus[<span class="number">2</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// conf3</span></span><br><span class="line">_jacobianOplus[<span class="number">3</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">// deltaT1</span></span><br><span class="line">_jacobianOplus[<span class="number">4</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">// deltaT2</span></span><br><span class="line">_jacobianOplus[<span class="number">5</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">// angle1</span></span><br><span class="line">_jacobianOplus[<span class="number">6</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">// angle2</span></span><br><span class="line">_jacobianOplus[<span class="number">7</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">// angle3</span></span><br></pre></td></tr></table></figure><br>既然拿出了角度，那么对<code>conf</code>的雅格比矩阵的维度就变成了 2x2，不是2x3。两个误差函数，一个是线速度的，一个是角速度的</p>
<p><font size="4" color="blue"> 代码中的 double aux0 = 2/sum_time_inv; 错了  </font> 应当是 <code>double aux0 = 2/sum_time;</code><br><img src="https://s2.loli.net/2023/03/04/UWQmsEB4AHIGSOr.png" alt="J[0](0,0)的推导过程"><br>其他项以此类推</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/03/03/SLAM%E5%B7%A5%E5%85%B7/g2o%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8/">g2o的详细使用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SLAM%E5%B7%A5%E5%85%B7/">SLAM工具</a></span><div class="content"><p>G2O 与ceres风格不同，它是专门用于进行图优化的库，提供了大量预先定义的节点和边供用户调用。</p>
<p>曲线拟合的例子其实不太适合用来理解g2o，它涉及的顶点只有一个，边是一元边，有很多个。还是用图优化的例子更容易理解。</p>
<p>TEB算法的<code>base_teb_edges.h</code>, <code>g2o_types\vertex_pose.h</code> 和 <code>g2o_types\vertex_timediff.h</code>很有学习价值，以及<code>edge_obstacle.h</code>, <code>edge_shortest_path.h</code>, <code>edge_velocity.h</code></p>
<h2 id="顶点"><a href="#顶点" class="headerlink" title="顶点"></a>顶点</h2><p>最基础的<code>BaseVertex</code>类，<code>template &lt;int D, typename T&gt; class BaseVertex</code>，</p>
<ul>
<li>D: minimal dimension of the vertex, 例如 3 for rotation in 3D. D并非是顶点（更确切的说是状态变量）的维度，而是其在流形空间（manifold）的最小表示</li>
<li>T: 节点估计值的类型,例如 Quaternion for rotation in 3D</li>
</ul>
<p>g2o本身内部定义了一些常用的顶点类型</p>
<ul>
<li>VertexSE2 : public BaseVertex<3, SE2>  // 2D pose Vertex, (x,y,theta)</li>
<li>VertexSE3 : public BaseVertex<6, Isometry3> //6d vector (x,y,z,qx,qy,qz) (注意不管四元数的 w)</li>
<li>VertexPointXY : public BaseVertex<2, Vector2></li>
<li>VertexPointXYZ : public BaseVertex<3, Vector3></li>
<li>VertexSBAPointXYZ : public BaseVertex<3, Vector3></li>
<li>VertexSE3Expmap : public BaseVertex<6, SE3Quat></li>
</ul>
<p>如果我们需要的顶点类型这里面没有，就得自己定义了</p>
<p>重新定义顶点一般需要考虑重写如下函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 读盘、存盘函数，一般情况下不需要进行读/写操作的话，仅仅声明一下，作为空函数</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(std::istream&amp; is)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(std::ostream&amp; os)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">number_t</span>* update)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="setToOriginImpl-和-estimate"><a href="#setToOriginImpl-和-estimate" class="headerlink" title="setToOriginImpl 和 _estimate"></a>setToOriginImpl 和 <code>_estimate</code></h3><p><code>setToOriginImpl</code>：顶点重置函数，设定被优化变量的原始值。有时可以不用实现。具体来说就是初始化成员变量 <code>_estimate</code>，<font size="4" color="blue">  <code>_estimate</code>的类型就是继承 <code>BaseVertex</code>时的模板参数  </font></p>
<p>如果<code>_estimate</code>是<code>Eigen::Vector3d</code>，那么<code>setToOriginImpl</code>的内容可以是: <code>_estimate &lt;&lt; 0,0,0;</code>。 如果是<code>PoseSE2</code>， <code>_estimate</code>的赋值可以这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_estimate.<span class="built_in">position</span>() = position;</span><br><span class="line">_estimate.<span class="built_in">x</span>() = x;</span><br><span class="line">_estimate.<span class="built_in">y</span>() = y;</span><br><span class="line">_estimate.<span class="built_in">theta</span>() = theta;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _estimate.<span class="built_in">setZero</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="oplusImpl"><a href="#oplusImpl" class="headerlink" title="oplusImpl"></a>oplusImpl</h3><p>顶点更新函数。非常重要的一个函数，主要用于优化过程中增量 △x 的计算。我们根据增量方程计算出增量之后，就是通过这个函数对估计值进行调整的，因此这个函数的内容一定要重视。</p>
<p>比较简单的类型是这样实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// double 也可以换成 number_t</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">( <span class="keyword">const</span> <span class="keyword">double</span>* update )</span> <span class="comment">// 更新</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">// update为增量△m 迭代的时候，估计值 m= m + △m, m是向量（a,b,c）</span></span><br><span class="line">    _estimate += Eigen::<span class="built_in">Vector3d</span>(update);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>* update)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _estimate.<span class="built_in">plus</span>(update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>李代数的类<code>VertexSE3Expmap</code>，上面两个函数是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> </span>&#123;    <span class="comment">// 重置</span></span><br><span class="line">    _estimate = <span class="built_in">SE3Quat</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">number_t</span>* update_)</span>  </span>&#123;</span><br><span class="line">    <span class="function">Eigen::Map&lt;<span class="keyword">const</span> Vector6&gt; <span class="title">update</span><span class="params">(update_)</span></span>;</span><br><span class="line">    <span class="comment">//更新方式 类似于左扰动？</span></span><br><span class="line">    <span class="built_in">setEstimate</span>(SE3Quat::<span class="built_in">exp</span>(update)*<span class="built_in">estimate</span>());        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="边"><a href="#边" class="headerlink" title="边"></a>边</h2><p>g2o自带的边</p>
<ul>
<li>EdgeSE3ProjectXYZ: public  BaseBinaryEdge<2, Vector2d, VertexSBAPointXYZ, VertexSE3Expmap></li>
<li>EdgeSE3ProjectXYZOnlyPose: public  BaseUnaryEdge<2, Vector2d, VertexSE3Expmap></li>
<li>EdgeSE3Expmap : public BaseBinaryEdge<6, SE3Quat, VertexSE3Expmap, VertexSE3Expmap></li>
</ul>
<font size="4" color="blue"> 仅优化一个变量的时候选择单边  </font>

<p>以一元边为例<code>template &lt;int D, typename E, typename VertexXi&gt; class BaseUnaryEdge : public BaseEdge&lt;D,E&gt;</code>。</p>
<ul>
<li>D 表示测量值的维度 </li>
<li>E 表示测量值的数据类型</li>
<li>VertexXi，VertexXj 分别表示不同顶点的类型。（一元边只有一个顶点）</li>
</ul>
<p>例如，<code>BaseBinaryEdge&lt;2, Vector2D, VertexSBAPointXYZ, VertexSE3Expmap&gt;</code>是个二元边。2是说测量值是2维的，也就是图像的像素坐标x,y的差值，对应测量值的类型是Vector2D，两个顶点也就是优化变量分别是三维点 VertexSBAPointXYZ，和李群位姿VertexSE3Expmap。</p>
<ul>
<li><p>read，write：分别是读盘、存盘函数，一般情况下不需要进行读/写操作的话，仅仅声明一下就可以</p>
</li>
<li><p>computeError函数：非常重要，是使用当前顶点的值计算的测量值与真实的测量值之间的误差</p>
</li>
<li><p>linearizeOplus函数：非常重要，是在当前顶点的值下，该误差对优化变量的偏导数，也就是我们说的Jacobian。</p>
</li>
</ul>
<p>重要的成员变量：</p>
<ul>
<li><p><code>_measurement</code>：存储观测值</p>
</li>
<li><p><code>_error</code>：存储computeError() 函数计算的误差</p>
</li>
<li><p><code>_vertices[]</code>：存储顶点信息，比如二元边的话，<code>_vertices[]</code> 的大小为2，存储顺序和调用setVertex(int, vertex) 是设定的int有关（0 或1）</p>
</li>
<li><p>setId(int)： 来定义边的编号（决定了在H矩阵中的位置）</p>
</li>
<li><p>setMeasurement(type) 函数来定义观测值</p>
</li>
<li><p>setVertex(int, vertex) 来定义顶点</p>
</li>
<li><p><code>setInformation()</code> 来定义协方差矩阵的逆</p>
</li>
</ul>
<p>最重要的就是<code>computeError()</code>，<code>linearizeOplus()</code>两个函数了。如果我们没有给出雅可比，g2o也会进行数值求导，但是会比重写的雅可比慢。<font size="4" color="blue"> 雅克比矩阵的维度为 <strong>误差维度 × 优化变量的维度</strong>  </font>，两个函数一般是这样的形式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    _error = _measurement - Something;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _jacobianOplusXi(pos, pos) = something;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    _jocobianOplusXj(pos, pos) = something;</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure><br>雅格比矩阵要针对每个顶点求解，上面说的维度是每个顶点求解的维度。比如边的类型继承<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VertexPose</span> :</span> <span class="keyword">public</span> g2o::BaseVertex&lt;<span class="number">6</span>, Sophus::SE3d&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeProjection</span> :</span> <span class="keyword">public</span> g2o::BaseUnaryEdge&lt;<span class="number">2</span>, Eigen::Vector2d, VertexPose&gt;</span><br></pre></td></tr></table></figure><br>由于是一元边，那么只针对一个顶点求解，误差维度是边的第一个模板类型2，优化变量的维度是顶点的第一个模板参数6.</p>
<p>TEB算法中的<code>class EdgeVelocity : public BaseTebMultiEdge&lt;2, double&gt;</code>，是三元边，两个<code>VertexPose</code>顶点，类型<code>PoseSE2</code>。顶点<code>VertexTimeDiff</code>，类型double。对于前者，雅格比矩阵是 2x3，对后者是 2x1，也就是如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_jacobianOplus[<span class="number">0</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// conf1</span></span><br><span class="line">_jacobianOplus[<span class="number">1</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// conf2</span></span><br><span class="line">_jacobianOplus[<span class="number">2</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">// deltaT</span></span><br></pre></td></tr></table></figure></p>
<p>对于边<code>class G2O_TYPES_SBA_API EdgeProjectXYZ2UV : public  BaseBinaryEdge&lt;2, Vector2D, VertexSBAPointXYZ, VertexSE3Expmap&gt;</code>，这是二元边，雅格比包含两部分，维度分别为 2x3 和 2x6. 后一个顶点的类型是李群。可以这样写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相对 _jacobianOplus[2] 的另一种写法</span></span><br><span class="line">_jacobianOplusXi(<span class="number">0</span>,<span class="number">0</span>) =</span><br><span class="line">......</span><br><span class="line">_jacobianOplusXj(<span class="number">0</span>,<span class="number">0</span>) = </span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<h2 id="removeEdge"><a href="#removeEdge" class="headerlink" title="removeEdge()"></a>removeEdge()</h2><p><code>removeEdge</code> 和 <code>removeVertex</code>只有在ORB-SLAM中看到。</p>
<p>After running optimize() once, I am finding a high number of outliers. Is there any way to delete a single edge out of the graph and run optimize again, or do I have to construct it again?</p>
<p>The method <code>removeEdge()</code> removes the edge from a graph and unlinks it from all of the vertices it was attached to. After you call it on your edges, I think you need to call <code>initializeOptimization()</code> to reset all of g2o’s internal data structures to the new graph configuration. You should then be able to call <code>optimize()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector&lt;g2o::EdgeSim3ProjectXYZ*&gt; vpEdges12;</span></span><br><span class="line"><span class="comment">// 剔除一些误差大的边</span></span><br><span class="line"><span class="comment">// Check inliers</span></span><br><span class="line"><span class="keyword">int</span> nBad=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;vpEdges12.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    g2o::EdgeSim3ProjectXYZ* e12 = vpEdges12[i];</span><br><span class="line">    g2o::EdgeInverseSim3ProjectXYZ* e21 = vpEdges21[i];</span><br><span class="line">    <span class="keyword">if</span>(!e12 || !e21)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(e12-&gt;<span class="built_in">chi2</span>()&gt;th2 || e21-&gt;<span class="built_in">chi2</span>()&gt;th2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> idx = vnIndexEdge[i];</span><br><span class="line">        vpMatches1[idx]=<span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">        optimizer.<span class="built_in">removeEdge</span>(e12);</span><br><span class="line">        optimizer.<span class="built_in">removeEdge</span>(e21);</span><br><span class="line">        vpEdges12[i]=<span class="keyword">static_cast</span>&lt;g2o::EdgeSim3ProjectXYZ*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">        vpEdges21[i]=<span class="keyword">static_cast</span>&lt;g2o::EdgeInverseSim3ProjectXYZ*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">        nBad++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="setLevel-int-level"><a href="#setLevel-int-level" class="headerlink" title="setLevel(int level)"></a>setLevel(int level)</h2><p>也是在ORB-SLAM中用到</p>
<p>优化完成后，对每一条边都进行检查，剔除误差较大的边（认为是错误的边），并设置setLevel为0，即下次不再对该边进行优化</p>
<p>setLevel(int ) is useful when you call <code>optimizer.initializeOptimization(int )</code>. If you assign <code>initializeOptimization(0)</code>, the optimizer will include all edges up to <strong>level 0</strong> in the optimization, and edges set to <strong>level &gt;=1</strong> will not be included</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于卡方检验计算出的阈值（假设测量有一个像素的偏差）</span></span><br><span class="line"><span class="comment">// 第二个判断条件，用于检查构成该边的MapPoint在该相机坐标系下的深度是否为正？</span></span><br><span class="line"><span class="keyword">if</span>(e-&gt;<span class="built_in">chi2</span>()&gt;<span class="number">5.991</span> || !e-&gt;<span class="built_in">isDepthPositive</span>())</span><br><span class="line">&#123;</span><br><span class="line">    e-&gt;<span class="built_in">setLevel</span>(<span class="number">1</span>);<span class="comment">// 不优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/02/27/%E6%BF%80%E5%85%89SLAM/LOAM%E7%B3%BB%E5%88%97/LOAM%E4%B8%AD%E7%9A%84%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5%E6%8E%A8%E5%AF%BC/">LOAM中的雅格比矩阵推导</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-02-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/LOAM%E7%B3%BB%E5%88%97/">LOAM系列</a></span><div class="content"><p>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011341856/article/details/127673012">一点儿也不萌的萌萌的文章</a></p>
<p>代价函数使用的是欧拉角的方式进行求导解算的。一方面由于未采用矩阵的形式进行推导，导致整个推导过程非常复杂. 在LEGO-LOAM、LIO-SAM中还能看到欧拉角，另外还有旋转矩阵等表示方法。</p>
<p>FLOAM使用SE(3)推导雅格比。</p>
<p>点到直线的误差函数  <script type="math/tex">d_e =||(Rp_s+t-p_t) \times \overrightarrow {n_e}\  ||_2</script></p>
<p><script type="math/tex">d_e</script>   点到直线的距离</p>
<p><script type="math/tex">p_t</script>   目标（地图）点云中的角点</p>
<p><script type="math/tex">p_s</script>   源（当前帧）点云中的角点</p>
<p><script type="math/tex">\overrightarrow {n_e}</script>   近邻角点组成的直线对应的单位向量</p>
<p>这里我没太明白，LOAM中应该是两个目标点云中的角点，也就是 <script type="math/tex">\overrightarrow {PA} \times \overrightarrow {PB}</script>， 不明白为什么叉乘两个角点对应的单位向量。</p>
<p>作者讲的计算有点绕远，根据叉乘的求导公式，范数部分的求导如下<br><img src="https://s2.loli.net/2023/02/27/KJ8gDWOCesaj5uo.png" alt="image.png"></p>
<p>完整2范数的对R求导，直接套用<a href="https://charon-cheung.github.io/2023/02/27/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E8%8C%83%E6%95%B0/">范数求雅格比的公式</a></p>
<p>这样直接把上面的计算结果带入 <script type="math/tex">J_f(X)</script>，就得到最终结果。 关于t的导数同样计算。</p>
<p>点到平面误差函数就是 <script type="math/tex">d_p =||(Rp_s+t-p_t) * \overrightarrow {n_e}\  ||_2</script>  没有疑问</p>
<p><script type="math/tex">p_t</script>    目标（地图）点云中的平面点；</p>
<p><script type="math/tex">\overrightarrow {n_e}</script>    近邻平面点组成的平面对应的法向量。</p>
<p>推导过程还是按我上面讲的更容易理解。</p>
<p><script type="math/tex">\frac{(Rp_s+t-p_t) * \overrightarrow {n_e}}{||(Rp_s+t-p_t) * \overrightarrow {n_e}\  ||_2 }</script> 的值是-1或者1</p>
<p><img src="https://s2.loli.net/2023/02/27/sSTwkJKje93btqa.png" alt=" "><br>得到每一个误差的导数，组成一个大的雅克比矩阵(也有可能是向量)，有了雅克比矩阵之后带入高斯牛顿或者LM算法即可以求解最优的R和t。<br>点到线的误差项在优化过程中的贡献比较小，在r3live、fast-lio都只计算点到面的误差。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/02/27/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E8%8C%83%E6%95%B0/">范数及求导</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-02-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a></span><div class="content"><p><code>||x||</code> 是 1 范数</p>
<p><img src="https://s2.loli.net/2023/02/27/v3zkxDic42Jh1om.png" alt=" "></p>
<p>2范数其实就是：列向量 x,  2范数为 <script type="math/tex">\sqrt{x^Tx}</script></p>
<p>2范数为 <script type="math/tex">\phi(x) =||Ax- \overrightarrow {b} ||_2</script></p>
<p>对 x 求导<br><img src="https://s2.loli.net/2023/02/27/uqj9y2M1ckU37dW.png" alt=" "></p>
<p>如果是求雅格比，<br><img src="https://s2.loli.net/2023/02/27/IJZ4vVckAtCpFTW.png" alt=" "><br>也就是只需求f(x)的雅格比，再转置。</p>
<p><br></p>
<p>再看矩阵的范数</p>
<ul>
<li><p>0 范数:  矩阵中非零元素的个数</p>
</li>
<li><p>1 范数: 又称为 列和范数，将每列元素进行绝对值求和，取最大值</p>
</li>
<li><p><script type="math/tex">\infin</script> 范数: 又称为 列和范数，将每列元素进行绝对值求和，取最大值</p>
</li>
<li><p>2 范数: 公式为 <script type="math/tex">\sqrt{\lambda_{max}(A^TA) }</script>， 其中 <script type="math/tex">\lambda_{max}(A^TA)</script> 表示 <script type="math/tex">A^TA</script>的最大特征值。 2范数可以用来判断一个矩阵是不是病态矩阵</p>
</li>
</ul>
<p>2范数是由向量范数诱导而来，F范数是直接定义，是两种不同的度量方式。F范数可以比较真实的矩阵和估计的矩阵值之间的误差。<br><img src="https://s2.loli.net/2023/03/27/HgmrFxQyu1Mpa49.png" alt=""></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/6/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/67/">67</a><a class="extend next" rel="next" href="/page/8/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2023 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>