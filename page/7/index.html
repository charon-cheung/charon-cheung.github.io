<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">655</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">52</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2023/05/17/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/tf%E5%92%8Cgeometry_msgs%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/">tf常用函数和geometry_msgs的互相转换</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-05-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><p>来自<code>transform_datatypes.h</code>，这个头文件真是太有用了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> tf::Vector3 	tf::Point</span><br><span class="line"><span class="keyword">typedef</span> tf::Transform 	tf::Pose</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>static tf::Quaternion     tf::createQuaternionFromRPY (double roll, double pitch, double yaw)</p>
</li>
<li><p>static geometry_msgs::Quaternion     tf::createQuaternionMsgFromRollPitchYaw (double roll, double pitch, double yaw)</p>
</li>
<li><p>static geometry_msgs::Quaternion     tf::createQuaternionMsgFromYaw (double yaw)</p>
</li>
<li><p>static double   tf::getYaw (const geometry_msgs::Quaternion &amp;orientation)</p>
</li>
<li><p>static void     tf::transformTFToMsg (const Transform &amp;bt, geometry_msgs::Transform &amp;msg)</p>
</li>
<li><p>static void     tf::transformStampedMsgToTF (const geometry_msgs::TransformStamped &amp;msg, StampedTransform &amp;bt)</p>
</li>
<li><p>static void     tf::transformMsgToTF (const geometry_msgs::Transform &amp;msg, Transform &amp;bt)</p>
</li>
<li><p>static void     tf::quaternionTFToMsg (const Quaternion &amp;bt, geometry_msgs::Quaternion &amp;msg)</p>
</li>
<li><p>static void     tf::poseTFToMsg (const Pose &amp;bt, geometry_msgs::Pose &amp;msg)</p>
</li>
<li><p>static void     tf::poseStampedMsgToTF (const geometry_msgs::PoseStamped &amp;msg, Stamped&lt; Pose &gt; &amp;bt)</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tf2_geometry_msgs/tf2_geometry_msgs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">tf2::Quaternion quat_tf;</span><br><span class="line">quat_tf.<span class="built_in">setRPY</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">geometry_msgs::Quaternion quat_msg;</span><br><span class="line">tf2::<span class="built_in">convert</span>(quat_tf, quat_msg);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs::PoseStamped  p;</span><br><span class="line"><span class="comment">// 对 p 赋值</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">tf2::Quaternion  q;</span><br><span class="line">tf2::<span class="built_in">convert</span>(p.pose.orientation,  q);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>geometry_msgs::TransformStamped</code> 和 <code>tf::StampedTransform</code>, <code>tf2::Transform</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs::TransformStamped   transform;</span><br><span class="line">tf::StampedTransform  tfTransform;</span><br><span class="line"><span class="built_in">transformStampedTFToMsg</span>(tfTransform , transform);</span><br><span class="line"></span><br><span class="line">tf2::Transform  tf2_transform;</span><br><span class="line">tf2::<span class="built_in">convert</span>(transform.transform, tf2_transform);</span><br></pre></td></tr></table></figure>
<p><code>tf::StampedTransform</code>和<code>geometry_msgs/TransformStamped</code>的区别：前者是C++中的一个类，只能用于C++中，而后者则是ROS的消息，只依赖于ROS，与语言无关，都可以使用。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/05/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/costmap%E5%92%8COpenCV%E7%9A%84%E5%85%B3%E7%B3%BB/">costmap和OpenCV的坐标关系</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-05-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content"><p><img src="https://s2.loli.net/2023/05/21/MDHgo6feC3O7Vcu.png" alt="costmap和OpenCV的坐标系关系"><br>costmap原点在左下角，OpenCV图片的原点在左上。</p>
<p><code>cv::Mat map_mat = cv::Mat(m_y, m_x, CV_8U);</code>，<code>type</code>经常设置为<code>CV_8U</code>，无符号整数 <code>0~255</code>，Mat代表矩阵，该类声明在头文件<code>opencv2/core/core.hpp</code>。对（行，列）元素访问、赋值常使用<code>m.at&lt;类型&gt;(行,列);</code></p>
<p>OpenCV的黑白图像是二维数组，255是白色，0是黑色. 数组中每个元素就是图像对应位置的像素值，数组索引、像素行列、像素坐标关系如下：</p>
<ul>
<li>数组行索引 = 像素所在行数 - 1 = 像素纵坐标</li>
<li>数组列索引 = 像素所在列数 - 1 = 像素横坐标</li>
</ul>
<p>在ROS中的地图像素扫描方向是从左下角向右上角扫描的。resolution表示地图上一个像素宽度代表实际的距离（通常为0.05，代表一个像素代表<code>5cm*5cm</code>），costmap的本质是栅格地图，其示意图如下：<br><img src="https://s2.loli.net/2023/05/23/X8oGSvLqP1CFEBQ.png" alt=""><br>OpenCV的图相当于costmap先逆时针转180°，再对y轴取对称。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pgm的像素值，或者说保存方式和OpenCV是一样的</span></span><br><span class="line">costmap_-&gt;<span class="built_in">saveMap</span>(<span class="string">&quot;/home/user/costmap.pgm&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 范围 0~255</span></span><br><span class="line">cv::Mat map_mat = cv::<span class="built_in">Mat</span>(m_y, m_x, CV_8U);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; map_mat.cols; x++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; map_mat.rows; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        map_mat.at&lt;<span class="keyword">uint8_t</span>&gt;(map_mat.rows <span class="number">-1</span> - y, x) = <span class="number">255</span> - costmap_-&gt;<span class="built_in">getCharMap</span>()[ y * map_mat.cols + x];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/05/15/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Action%E9%80%9A%E4%BF%A1(%E4%BA%8C)%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81/">Action通信(二)  MoveBase客户端和服务端的常用代码</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-05-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><p><code>MoveBase.action</code><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs/PoseStamped target_pose</span><br><span class="line">---</span><br><span class="line">---</span><br><span class="line">geometry_msgs/PoseStamped base_position</span><br></pre></td></tr></table></figure><br><code>target_pose</code>是目标位姿。<code>base_position</code>作为feedback，是base_link在world坐标系的位姿。</p>
<p><br></p>
<p><code>MoveBase</code>的Action实际就是另一种形式的话题，会生成7个msg文件:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MoveBaseActionFeedback.msg  </span><br><span class="line">MoveBaseActionResult.msg  </span><br><span class="line">MoveBaseResult.msg</span><br><span class="line">MoveBaseActionGoal.msg      </span><br><span class="line">MoveBaseFeedback.msg      </span><br><span class="line">MoveBaseAction.msg          </span><br><span class="line">MoveBaseGoal.msg</span><br></pre></td></tr></table></figure></p>
<p>另外有个<code>RecoveryStatus.msg</code>，目前没有使用过。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs/PoseStamped pose_stamped</span><br><span class="line">uint16 current_recovery_number</span><br><span class="line">uint16 total_number_of_recoveries</span><br><span class="line">string recovery_behavior_name</span><br></pre></td></tr></table></figure></p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ActionSpec</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span>   actionlib::SimpleActionClient&lt; ActionSpec &gt;::<span class="built_in">waitForServer</span> (<span class="keyword">const</span> ros::Duration &amp;  timeout = ros::<span class="built_in">Duration</span>(<span class="number">0</span>,<span class="number">0</span>) )  [<span class="keyword">inline</span>]</span><br></pre></td></tr></table></figure>
<p>一般花点时间，比如几百毫秒实现二者的连接，在此时间内的goal会发送失败。</p>
<p>参数:</p>
<ul>
<li>timeout   Max time to block before returning. 参数为 0 is interpreted as an infinite timeout.</li>
<li>返回 True if the server connected in the allocated time. False on timeout</li>
</ul>
<p>所以这样写代码比较优雅：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( ! ac-&gt;<span class="built_in">isServerConnected</span>() )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Waiting for move_base action server to start&quot;</span>);</span><br><span class="line">    ac-&gt;<span class="built_in">waitForServer</span>(ros::<span class="built_in">Duration</span>(<span class="number">1</span>) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发送goal的常用程序<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ac = <span class="keyword">new</span> actionlib::SimpleActionClient&lt;move_base_msgs::MoveBaseAction&gt;(<span class="string">&quot;move_base&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 注意是 MoveBaseGoal, 成员只有  geometry_msgs/PoseStamped  target_pose</span></span><br><span class="line">move_base_msgs::MoveBaseGoal  goal;</span><br><span class="line"><span class="comment">// 一系列赋值 ......</span></span><br><span class="line">ac-&gt;<span class="built_in">sendGoal</span>(goal);</span><br><span class="line"><span class="comment">// ac-&gt;sendGoal(goal, &amp;doneCb, &amp;activeCb, &amp;feedbackCb);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> finished_before_timeout = ac-&gt;<span class="built_in">waitForResult</span>(ros::<span class="built_in">Duration</span>(<span class="number">30.0</span>)); </span><br><span class="line"><span class="keyword">if</span> (finished_before_timeout)</span><br><span class="line">&#123;</span><br><span class="line">    actionlib::SimpleClientGoalState state = ac-&gt;<span class="built_in">getState</span>();</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;MoveBase Action finished: %s&quot;</span>, state.<span class="built_in">toString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><font size="3" color="blue"> 三个回调函数  </font>：当action完成后，调用回调函数<code>doneCb</code>一次。  当action激活后，调用回调函数<code>activeCb</code>一次，此时还没有获得路径。 收到feedback后，不断调用回调函数<code>feedbackCb</code>，一直到action结束</p>
<ul>
<li>bool  waitForResult (const ros::Duration &amp;timeout = ros::Duration(0, 0))</li>
</ul>
<p>Blocks until this goal finishes. 可以指定阻塞的时间，如果是0，则无线阻塞。</p>
<ul>
<li>SimpleClientGoalState   getState() const</li>
</ul>
<p>Get the state information for this goal. Possible States Are: <code>PENDING, ACTIVE, RECALLED, REJECTED, PREEMPTED, ABORTED, SUCCEEDED, LOST</code></p>
<p>如果在服务端的回调函数里没有对goal的状态进行设置，会有下面报警</p>
<p><font size="3" color="orange"> Your executeCallback did not set the goal to a terminal status. This is a bug in your ActionServer implementation. Fix your code!<br>For now, the ActionServer will set this goal to aborted  </font> 因为没有设置goal的最终状态，比如使用<code>setSucceeded</code>和<code>setAborted</code>设置状态.</p>
<ul>
<li>cancelGoal</li>
</ul>
<p><code>cancelGoal()</code>之后，<code>getState()</code>的状态还是<code>ACTIVE</code></p>
<p>如果没有goal处于ACTIVE，不要使用<code>cancelGoal</code>，会报错但是不会让进程退出：<br><img src="https://i.loli.net/2019/12/03/pOGM7EF2Y94ytLQ.png" alt=""></p>
<h2 id="两个回调函数"><a href="#两个回调函数" class="headerlink" title="两个回调函数"></a>两个回调函数</h2><p><code>actionlib::SimpleActionServer</code>的成员函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allows users to register a callback to be invoked when a new goal is available.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>    <span class="title">registerGoalCallback</span> <span class="params">(boost::function&lt; <span class="keyword">void</span>()&gt; cb)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Allows users to register a callback to be invoked when a new preempt request is available.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>    <span class="title">registerPreemptCallback</span> <span class="params">(boost::function&lt; <span class="keyword">void</span>()&gt; cb)</span></span></span><br></pre></td></tr></table></figure></p>
<p>客户端向<code>SimpleActionServer</code>发送新目标时，<code>isNewGoalAvailable()</code>为true，<code>isPreemptRequested()</code>也为true。 如果客户端调用<code>cancelGoal()</code>，<code>isNewGoalAvailable()</code>为false，但<code>isPreemptRequested()</code>还是true.</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>有时候我在<code>move_base</code>设置了<code>setAborted</code>之后，会出现报警 <font size=3 color = orange> To transition to an aborted state, the goal must be in a preempting or active state, it is currently in state: 4 </font>。 这是因为多次调用了 <code>setAborted</code>，state 4 其实就是状态 <code>Aborted</code>。 </p>
<p>此时如果再发送goal，就会出现报警 <font size=3 color = orange><br>Your executeCallback did not set the goal to a terminalstatus. This is a bug in your ActionServer implementation. Fix your code! For now, the ActionServer will set this goal to aborted </font>，这打乱了 Action 的状态机，必须避免这个报警。</p>
<p><br></p>
<p>我使用了一段时间后，感觉缺<code>resetGoal</code>和<code>getGoal</code>函数，不太方便。</p>
<p>参考:<br><a target="_blank" rel="noopener" href="https://www.guyuehome.com/14050">ROS Action动作通讯编程C++</a><br><a target="_blank" rel="noopener" href="http://library.isr.ist.utl.pt/docs/roswiki/actionlib_tutorials(2f">Writing a Callback Based SimpleActionClient</a>Tutorials(2f)Writing(20)a(20)Callback(20)Based(20)Simple(20)Action(20)Client.html)</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/05/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BD%8D%E7%BD%AE%E6%AD%A3%E7%A1%AE%EF%BC%8C%E6%9C%9D%E5%90%91%E4%B8%8D%E6%AD%A3%E7%A1%AE%E4%BC%9A%E5%A6%82%E4%BD%95%E8%A7%84%E5%88%92%E8%B7%AF%E5%BE%84/">机器人位置正确，朝向不正确会如何规划路径</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-05-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%85%B6%E4%BB%96/">其他</a></span><div class="content"><p><img src="https://s2.loli.net/2023/05/15/qhB3YTEIfgoAvRJ.png" alt=""><br>如图所示，起点的朝向为0°，终点朝向相同，这个路径显然就是直着走。</p>
<p>假如机器人实际朝向为90°，但定位程序给出的是0°，那么传给路径规划后，规划出的是直线，路径点的朝向都不变，输出的角速度为0，只有线速度。那么车会朝90°直着走，这就偏离路径了。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/05/14/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move_base%20%E5%88%86%E6%9E%90/%E6%9B%B4%E6%8D%A2%E7%AE%97%E6%B3%95%E5%87%BA%E7%8E%B0%E7%9A%84%E7%96%91%E9%9A%BEbug/">动态切换算法出现的疑难bug</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-05-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move-base%E5%88%86%E6%9E%90/">move_base分析</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E7%96%91%E9%9A%BEbug/">疑难bug</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2023/05/14/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move_base%20%E5%88%86%E6%9E%90/%E6%9B%B4%E6%8D%A2%E7%AE%97%E6%B3%95%E5%87%BA%E7%8E%B0%E7%9A%84%E7%96%91%E9%9A%BEbug/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/05/04/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/Gazebo%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/">Gazebo使用心得</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-05-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/">ROS机器人</a></span><div class="content"><p><strong>Gazebo不好上手，费了一番功夫终于熟悉了，内容太多，只记录注意事项。</strong></p>
<p>Gazebo里用的是<font size="4" color="blue"> 前x 左y 上z的右手坐标系 </font>，gazebo的栅格范围是<code>20mX20m</code></p>
<p>启动<code>simple_world.launch</code>，然后在Gazebo里添加一个圆柱体，保存覆盖<code>simple.world</code>文件。再次启动时，报错 <font color=orange >  SpawnModel: Failure - model name sunny already exist. [Spawn service failed. Exiting. </font> 和 <font color=orange > [spawn_urdf-6] process has died  </font></p>
<p>按<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44236630/article/details/124609824">网上说的方法</a>没能解决，也不能重命名<code>model</code>，修改<code>simple.world</code>无效。 最后删除了<code>&lt;node pkg=&quot;gazebo_ros&quot; type=&quot;spawn_model&quot; name=&quot;spawn_urdf&quot;  args=&quot;-urdf -model sunny -x $(arg x_pos) -y $(arg y_pos) -z $(arg z_pos) -param robot_description&quot; /&gt;</code> 解决问题。</p>
<h2 id="urdf-和-xacro"><a href="#urdf-和-xacro" class="headerlink" title="urdf 和 xacro"></a>urdf 和 xacro</h2><p><code>urdf.xacro</code>文件里，<code>&lt;link name=&quot;base_link&quot;&gt;</code>代表机器人的主体。<code>&lt;geometry&gt; &lt;box size=&quot;0.4 0.39 0.5&quot; /&gt;</code>是尺寸。</p>
<p>gazebo插件，可以简单理解为就是连接gazebo和ros的一个桥梁，一边插件通过gazebo的api来控制仿真环境的机器人关节等数据，一边通过关节数据通过运动学模型生成里程计、雷达的scan、image等类似的信息</p>
<h2 id="solidworks生成urdf"><a href="#solidworks生成urdf" class="headerlink" title="solidworks生成urdf"></a>solidworks生成urdf</h2><p><code>solidworks to urdf</code>安装后，如果在solidworks里找不到，就安装最新版的，不用管版本是否对应。</p>
<p>solidworks只生成的URDF文件，没有xacro文件. URDF文件做一些简单修改可保存为xacro，注意：</p>
<ol>
<li><code>joint</code>的 <code>type=&quot;fixed&quot;</code>，应当为<code>continuous</code></li>
<li><code>joint</code>的某些参数值错误，导致车加载差速模型后，运动错误</li>
</ol>
<h2 id="xacro"><a href="#xacro" class="headerlink" title="xacro"></a>xacro</h2><p>xacro里面的模型仍然是urdf模型，有如下变化：</p>
<ol>
<li>创建宏定义</li>
<li>文件包含</li>
<li>提供可编程接口:常量, 变量, 数学计算, 条件语句</li>
</ol>
<p>启动Gazebo时，机器人模型的tf关系不完整，即使<code>xacro</code>文件正确。还需要添加<code>joint_state_publisher</code> 和<code>robot_state_publisher</code></p>
<p>设置雷达时，看情况决定是否需要可视化<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sensor</span> <span class="attr">type</span>=<span class="string">&quot;ray&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lds_lfcd_sensor&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pose</span>&gt;</span>0 0 0 0 0 0<span class="tag">&lt;/<span class="name">pose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">visualize</span>&gt;</span>false<span class="tag">&lt;/<span class="name">visualize</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Gazebo默认的障碍物质量轻，车撞上之后会把障碍物推开。改变<code>density</code>选项为铁，则不会推动障碍物。</p>
<p><br></p>
<p>在Gazebo world中用以下方式加载模型时：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">uri</span>&gt;</span>model://one_building<span class="tag">&lt;/<span class="name">uri</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure><br>要让Gazebo能够找到uri中的自建model，需要将自己的model路径加入环境变量， <code>export GAZEBO_MODEL_PATH=~/&lt;path&gt;/my_package/models:$&#123;GAZEBO_MODEL_PATH&#125;</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/04/25/C++/C++%20%20%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%AD%97%E7%9A%84%E7%B1%BB%E5%9E%8B/">数字的类型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-04-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E5%9F%BA%E7%A1%80/">C++ 基础</a></span><div class="content"><p>数字后面带个U，L，F的含义</p>
<ul>
<li>U表示该常数用无符号整型方式存储，相当于 unsigned int</li>
<li>L表示该常数用长整型方式存储，相当于 long</li>
<li>F表示该常数用浮点方式存储，相当于 float</li>
</ul>
<p>比如 <code>-1UL</code>, 其实是一个很大很大的数</p>
<h2 id="OpennCV的数据类型"><a href="#OpennCV的数据类型" class="headerlink" title="OpennCV的数据类型"></a>OpennCV的数据类型</h2><p>S = 有符号整型 U = 无符号整型 F = 浮点型</p>
<ul>
<li>CV_8U - 8位无符号整数（0…255）</li>
<li><p>CV_32F - 32位浮点数（-FLT_MAX…FLT_MAX，INF，NAN）</p>
</li>
<li><p>CV_8U - 8位无符号整数（0…255）</p>
</li>
<li><p>CV_8S - 8位有符号整数（-128…127）</p>
</li>
<li><p>CV_16U - 16位无符号整数（0…65535）</p>
</li>
<li><p>CV_16S - 16位有符号整数（-32768…32767）</p>
</li>
<li><p>CV_32S - 32位有符号整数（-2147483648…2147483647）</p>
</li>
<li><p>CV_32F - 32位浮点数（-FLT_MAX…FLT_MAX，INF，NAN）</p>
</li>
<li><p>CV_64F - 64位浮点数（-DBL_MAX…DBL_MAX，INF，NAN）</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/04/04/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/trimmer%E6%9C%BA%E5%88%B6-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%90%E5%9B%BE/">trimmer机制 - 移除重复子图</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-04-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>在<code>PoseGraph2D::HandleWorkQueue</code>里，<code>RunOptimization();</code>之后<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子图的裁剪，如果没有裁剪器就不裁剪</span></span><br><span class="line">   <span class="function">TrimmingHandle <span class="title">trimming_handle</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; trimmer : trimmers_) &#123;</span><br><span class="line">     trimmer-&gt;<span class="built_in">Trim</span>(&amp;trimming_handle);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 这里只有纯定位时才执行</span></span><br><span class="line"><span class="comment">// 裁剪器完成状态，删除裁剪器</span></span><br><span class="line">   trimmers_.<span class="built_in">erase</span>(</span><br><span class="line">       std::<span class="built_in">remove_if</span>(trimmers_.<span class="built_in">begin</span>(), trimmers_.<span class="built_in">end</span>(),</span><br><span class="line">                      [](std::unique_ptr&lt;PoseGraphTrimmer&gt;&amp; trimmer) &#123;</span><br><span class="line">                        <span class="keyword">return</span> trimmer-&gt;<span class="built_in">IsFinished</span>();</span><br><span class="line">                      &#125;),</span><br><span class="line">       trimmers_.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><br><code>trimmers_</code>的添加是 <code>PoseGraph2D</code>构造函数 —— <code>PoseGraph2D::AddTrimmer</code></p>
<p>先看构造函数部分<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options.<span class="built_in">has_overlapping_submaps_trimmer_2d</span>()  )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; trimmer_options = options.<span class="built_in">overlapping_submaps_trimmer_2d</span>();</span><br><span class="line">    <span class="built_in">AddTrimmer</span>(absl::make_unique&lt;OverlappingSubmapsTrimmer2D&gt;(</span><br><span class="line">        trimmer_options.<span class="built_in">fresh_submaps_count</span>(),</span><br><span class="line">        trimmer_options.<span class="built_in">min_covered_area</span>(),</span><br><span class="line">        trimmer_options.<span class="built_in">min_added_submaps_count</span>() )  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>三个参数:</p>
<ol>
<li>fresh_submaps_count = 2    最新的2个submaps</li>
<li>min_covered_area = 3.0     最小未被覆盖的面积</li>
<li>min_added_submaps_count = 5      代表在5个submaps之后才会进行该项操作，这个参数不实用，主要是上面两个</li>
</ol>
<p>Trims submaps that have less than <code>min_covered_cells_count</code> cells not overlapped by at least <code>fresh_submaps_count</code> submaps. 也就是说一些子图如果只有<code>min_covered_cells_count</code>个栅格没有被<code>fresh_submaps_count</code>个子图覆盖，那么这些子图被裁剪掉。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::AddTrimmer</span><span class="params">(std::unique_ptr&lt;PoseGraphTrimmer&gt; trimmer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// C++11 does not allow us to move a unique_ptr into a lambda.</span></span><br><span class="line">  PoseGraphTrimmer* <span class="keyword">const</span> trimmer_ptr = trimmer.<span class="built_in">release</span>();</span><br><span class="line">  <span class="built_in">AddWorkItem</span>([<span class="keyword">this</span>, trimmer_ptr]() <span class="built_in">LOCKS_EXCLUDED</span>(mutex_) &#123;</span><br><span class="line">    absl::MutexLock <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">    trimmers_.<span class="built_in">emplace_back</span>(trimmer_ptr);</span><br><span class="line">    <span class="keyword">return</span> WorkItem::Result::kDoNotRunOptimization;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类<code>PoseGraphTrimmer</code>的派生类有 <code>PureLocalizationTrimmer</code> 和 <code>OverlappingSubmapsTrimmer2D</code>。前者属于纯定位部分，这里不看。后者其实主要就实现了一个<code>Trim</code>函数。 </p>
<p>回头看<code>trimmers_.erase</code>这一句，发现<code>OverlappingSubmapsTrimmer2D::IsFinished()</code>永远返回 false，所以这一句只有纯定位时才会执行，建图不执行。 </p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/03/29/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/frozen%E8%BD%A8%E8%BF%B9%E7%9A%84%E7%89%B9%E7%82%B9/">frozen轨迹的特点</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>frozen轨迹的子图和节点不参与优化问题中的优化，也就是5个残差的计算。但是参与inter global约束的计算，也就是纯定位。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/03/04/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E9%9A%9C%E7%A2%8D%E7%BA%A6%E6%9D%9F%E5%92%8C%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8E%A8%E5%AF%BC/">障碍约束和雅格比矩阵的推导</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/">TEB算法</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E5%90%84%E7%B1%BB%E7%BA%A6%E6%9D%9F%E5%8F%8A%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5/">各类约束及雅格比矩阵</a></span><div class="content"><p>障碍约束定义的误差函数表示机器人到障碍的最小距离。 $ \min \textrm{penaltyBelow}( dist2point ) \cdot weight $. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VertexPose* bandpt = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> VertexPose*&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// calculateDistance(const PoseSE2&amp; current_pose, const Obstacle* obstacle) 计算机器人到障碍物的距离</span></span><br><span class="line"><span class="comment">// current_pose为当前机器人的位姿。</span></span><br><span class="line"><span class="keyword">double</span> dist = robot_model_-&gt;<span class="built_in">calculateDistance</span>(bandpt-&gt;<span class="built_in">pose</span>(), _measurement);</span><br><span class="line">_error[<span class="number">0</span>] = <span class="built_in">penaltyBoundFromBelow</span>(dist, cfg_-&gt;obstacles.min_obstacle_dist, cfg_-&gt;optim.penalty_epsilon);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cfg_-&gt;optim.obstacle_cost_exponent != <span class="number">1.0</span> &amp;&amp; cfg_-&gt;obstacles.min_obstacle_dist &gt; <span class="number">0.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  _error[<span class="number">0</span>] = cfg_-&gt;obstacles.min_obstacle_dist * std::<span class="built_in">pow</span>(_error[<span class="number">0</span>] / cfg_-&gt;obstacles.min_obstacle_dist, </span><br><span class="line">  										cfg_-&gt;optim.obstacle_cost_exponent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>obstacle_cost_exponent</code>和<code>min_obstacle_dist</code>的设置，一般都会进入if情况。 注意 max cost (before weighting) is the same as the straight line version and that all other costs are below the straight line (for positive exponent), so it may be necessary to increase weight_obstacle and/or the inflation_weight when using larger exponents.</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/6/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/66/">66</a><a class="extend next" rel="next" href="/page/8/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2024 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>