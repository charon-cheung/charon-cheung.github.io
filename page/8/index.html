<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">564</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">52</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/02/18/exLTfbM3uFOq5SV.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/21/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/cartographer%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E5%8F%98%E5%8C%96/">cartographer新版本的变化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><h2 id="publish-tracked-pose-和-use-pose-extrapolator"><a href="#publish-tracked-pose-和-use-pose-extrapolator" class="headerlink" title="publish_tracked_pose 和 use_pose_extrapolator"></a>publish_tracked_pose 和 use_pose_extrapolator</h2><p>新版本增加的参数<code>publish_tracked_pose</code>，默认false<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeOptions</span> &#123;</span></span><br><span class="line">  ::cartographer::mapping::proto::MapBuilderOptions map_builder_options;</span><br><span class="line">  std::string map_frame;</span><br><span class="line">  <span class="keyword">double</span> lookup_transform_timeout_sec;</span><br><span class="line">  <span class="keyword">double</span> submap_publish_period_sec;</span><br><span class="line">  <span class="keyword">double</span> pose_publish_period_sec;</span><br><span class="line">  <span class="keyword">double</span> trajectory_publish_period_sec;</span><br><span class="line">  <span class="keyword">bool</span> publish_to_tf = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">bool</span> publish_tracked_pose = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">bool</span> use_pose_extrapolator = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在<code>Node</code>构造函数中的部分<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node_options_.publish_tracked_pose) &#123;</span><br><span class="line">    tracked_pose_publisher_ =</span><br><span class="line">        node_handle_.advertise&lt;::geometry_msgs::PoseStamped&gt;(</span><br><span class="line">            kTrackedPoseTopic, kLatestOnlyPublisherQueueSize);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>发布消息的部分在<code>Node::PublishLocalTrajectoryData</code>的最后。</p>
<p>这里用到了<strong>新版本</strong>的另一个新内容： 参数<code>use_pose_extrapolator</code></p>
<p>Node里的位姿估计器，作用是融合里程计和IMU，推测出一个位姿。 如果<code>use_pose_extrapolator</code>参数为true，发布出的这个位姿不准，因为是先验的位姿，没有经过雷达校准，除非IMU和里程计特别准。因此这个参数一般都是false</p>
<p>如果参数<code>publish_tracked_pose</code>为false，<code>use_pose_extrapolator</code>其实就无效了</p>
<h2 id="Node-MaybeWarnAboutTopicMismatch"><a href="#Node-MaybeWarnAboutTopicMismatch" class="headerlink" title="Node::MaybeWarnAboutTopicMismatch"></a>Node::MaybeWarnAboutTopicMismatch</h2><p>新版本中的<code>Node::AddTrajectory</code>添加<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wall_timers_.<span class="built_in">push_back</span>(node_handle_.<span class="built_in">createWallTimer</span>(</span><br><span class="line">      ::ros::<span class="built_in">WallDuration</span>(kTopicMismatchCheckDelaySec),</span><br><span class="line">      &amp;Node::MaybeWarnAboutTopicMismatch, <span class="keyword">this</span>, <span class="comment">/*oneshot=*/</span><span class="literal">true</span>)  );</span><br></pre></td></tr></table></figure><br>创建一个3s执行一次的定时器，由于<code>oneshot=true</code>，所以只执行一次。检查设置的topic名字在ROS中是否存在，不存在则报错</p>
<h2 id="pose-graph-odometry-motion-filter"><a href="#pose-graph-odometry-motion-filter" class="headerlink" title="pose_graph_odometry_motion_filter"></a>pose_graph_odometry_motion_filter</h2><p><code>CreateGlobalTrajectoryBuilder2D</code>的参数增加 <code>pose_graph_odometry_motion_filter</code>里程计的滤波器，但没有初始化</p>
<h2 id="GetTrajectoryStates-改名为-GetLocalTrajectoryData"><a href="#GetTrajectoryStates-改名为-GetLocalTrajectoryData" class="headerlink" title="GetTrajectoryStates 改名为 GetLocalTrajectoryData"></a><code>GetTrajectoryStates</code> 改名为 <code>GetLocalTrajectoryData</code></h2><p>原因在于后端里也有<code>GetTrajectoryStates</code>，容易混淆</p>
<p><code>Node</code>构造函数 —— <code>Node::PublishLocalTrajectoryData</code> —— <code>map_builder_bridge_.GetLocalTrajectoryData()</code></p>
<p>最后用到的<code>local_slam_data_</code>在<code>MapBuilderBridge::OnLocalSlamResult</code>中赋值</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/16/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/ROS%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">ROS常用数据类型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a></span><div class="content"><h2 id="geometry-msgs-系列"><a href="#geometry-msgs-系列" class="headerlink" title="geometry_msgs 系列"></a>geometry_msgs 系列</h2><ul>
<li><p><code>geometry_msgs/Pose</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs/Point position</span><br><span class="line">geometry_msgs/Quaternion orientation</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>geometry_msgs::PoseStamped</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header  header</span><br><span class="line">geometry_msgs/Pose  pose</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>geometry_msgs::Point</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float64 x</span><br><span class="line">float64 y</span><br><span class="line">float64 z</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>geometry_msgs::Quaternion</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float64 x</span><br><span class="line">float64 y</span><br><span class="line">float64 z</span><br><span class="line">float64 w</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>geometry_msgs/PoseArray</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header</span><br><span class="line">geometry_msgs/Pose[] poses</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>geometry_msgs/Pose2D</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float64 x</span><br><span class="line">float64 y</span><br><span class="line">float64 theta</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>geometry_msgs/Transform</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs/Vector3 translation</span><br><span class="line">geometry_msgs/Quaternion rotation</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>geometry_msgs/PoseWithCovariance</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs/Pose  pose</span><br><span class="line">float64[36]  covariance</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>geometry_msgs::Polygon</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs/Point32[]  points</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="tf-系列"><a href="#tf-系列" class="headerlink" title="tf 系列"></a>tf 系列</h2><p>以下两个类都继承 <code>tf::Transform</code></p>
<h3 id="tf-Pose"><a href="#tf-Pose" class="headerlink" title="tf::Pose"></a><code>tf::Pose</code></h3><p><code>tf::Stamped</code>对数据类型做模板化（除了tf::Transform），并附带元素frame<em>id</em>和stamp、<br><code>setData</code>成员函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tf::Stamped&lt;tf::Pose&gt; pose;</span><br><span class="line"><span class="built_in">getOrigin</span>().<span class="built_in">getX</span>();</span><br><span class="line"><span class="built_in">getOrigin</span>().<span class="built_in">getY</span>();</span><br><span class="line">tf::<span class="built_in">getYaw</span>(pose.<span class="built_in">getRotation</span>())</span><br></pre></td></tr></table></figure></p>
<h3 id="tf-StampedTransform"><a href="#tf-StampedTransform" class="headerlink" title="tf::StampedTransform"></a>tf::StampedTransform</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x= transform.<span class="built_in">getOrigin</span>().<span class="built_in">getX</span>();</span><br><span class="line"><span class="keyword">double</span> y= transform.<span class="built_in">getOrigin</span>().<span class="built_in">getY</span>();</span><br><span class="line"><span class="keyword">double</span> z= transform.<span class="built_in">getOrigin</span>().<span class="built_in">getZ</span>();</span><br><span class="line"><span class="keyword">double</span> angle = transform.<span class="built_in">getRotation</span>().<span class="built_in">getAngle</span>();</span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;x: %f, y: %f, z: %f, angle: %f&quot;</span>,x,y,z,angle);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry_msgs::PoseStamped&amp; pose = ;</span><br><span class="line">tf::StampedTransform  transform;</span><br><span class="line">geometry_msgs::PoseStamped new_pose;</span><br><span class="line"></span><br><span class="line">tf::Stamped&lt;tf::Pose&gt; tf_pose;</span><br><span class="line">tf::<span class="built_in">poseStampedMsgToTF</span>(pose, tf_pose);</span><br><span class="line"></span><br><span class="line">tf_pose.<span class="built_in">setData</span>(transform * tf_pose);</span><br><span class="line">tf_pose.stamp_ = transform.stamp_;</span><br><span class="line">tf_pose.frame_id_ = global_frame;</span><br><span class="line">tf::<span class="built_in">poseStampedTFToMsg</span>(tf_pose, new_pose);  <span class="comment">//转为 geometry_msgs::PoseStamped类型</span></span><br></pre></td></tr></table></figure>
<p><code>tf::poseStampedMsgToTF</code>函数，把<code>geometry_msgs::PoseStamped</code>转化为<code>Stamped&lt;Pose&gt;</code></p>
<p><br></p>
<h2 id="PoseSE2"><a href="#PoseSE2" class="headerlink" title="PoseSE2"></a>PoseSE2</h2><p>源码在<code>pose_se2.h</code>，有两个private成员<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Vector2d  _position; </span><br><span class="line"><span class="keyword">double</span> _theta;</span><br></pre></td></tr></table></figure><br>支持下列函数:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PoseSE2</span>(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> theta)</span><br><span class="line"><span class="built_in">PoseSE2</span>(<span class="keyword">const</span> geometry_msgs::Pose&amp; pose)</span><br><span class="line"><span class="built_in">PoseSE2</span>(<span class="keyword">const</span> tf::Pose&amp; pose)</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; stream, <span class="keyword">const</span> PoseSE2&amp; pose)</span><br></pre></td></tr></table></figure><br>另外还支持运算符* + - =</p>
<p><code>Eigen::Vector2d  orientationUnitVec() const</code>: 获得当前朝向的单位向量</p>
<p><code>PoseSE2::average(start, goal);</code></p>
<h2 id="costmap-converter-ObstacleArrayMsg"><a href="#costmap-converter-ObstacleArrayMsg" class="headerlink" title="costmap_converter/ObstacleArrayMsg"></a>costmap_converter/ObstacleArrayMsg</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header    <span class="comment"># frame_id 为map</span></span><br><span class="line">costmap_converter/ObstacleMsg[] obstacles</span><br><span class="line"></span><br><span class="line"><span class="comment"># costmap_converter/ObstacleMsg 的成员如下</span></span><br><span class="line">std_msgs/Header header    <span class="comment"># frame_id 为map</span></span><br><span class="line"><span class="comment"># Obstacle footprint (polygon descriptions)</span></span><br><span class="line">geometry_msgs/Polygon polygon</span><br><span class="line"><span class="comment"># radius for circular/point obstacles</span></span><br><span class="line">float64 radius</span><br><span class="line"><span class="comment"># Obstacle ID</span></span><br><span class="line"><span class="comment"># Specify IDs in order to provide (temporal) relationships</span></span><br><span class="line"><span class="comment"># between obstacles among multiple messages.</span></span><br><span class="line">int64 id</span><br><span class="line"><span class="comment"># Individual orientation (centroid)</span></span><br><span class="line">geometry_msgs/Quaternion orientation</span><br><span class="line"><span class="comment"># Individual velocities (centroid)</span></span><br><span class="line">geometry_msgs/TwistWithCovariance velocities</span><br></pre></td></tr></table></figure>
<p>类<code>Obstacle</code>定义在<code>obstacle.h</code>，派生类有<code>PointObstacle</code>, <code>CircularObstacle</code>, <code>LineObstacle</code>,<code>PolygonObstacle</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> boost::shared_ptr&lt;Obstacle&gt; ObstaclePtr;</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;ObstaclePtr&gt;  ObstContainer;</span><br></pre></td></tr></table></figure></p>
<p>PoseSequence pose<em>vec</em>; //!&lt; Internal container storing the sequence of optimzable pose vertices</p>
<p>TimeDiffSequence timediff<em>vec</em>;  //!&lt; Internal container storing the sequence of optimzable timediff vertices</p>
<p><code>VertexPose</code> 继承<code>g2o::BaseVertex&lt;3, PoseSE2 &gt;</code>。<br>This class stores and wraps a SE2 pose (position and orientation) into a vertex that can be optimized via g2o</p>
<p><code>VertexTimeDiff</code>继承<code>g2o::BaseVertex&lt;1, double&gt;</code>。This class stores and wraps a time difference \f$ \Delta T \f$ into a vertex that can be optimized via g2o</p>
<p>判断初始化：<code>bool isInit() const &#123;return !timediff_vec_.empty() &amp;&amp; !pose_vec_.empty(); &#125;</code></p>
<p><code>TimedElasticBand::clearTimedElasticBand()</code>: 清空 timediff<em>vec</em>  pose<em>vec</em></p>
<p><code>addPoseAndTimeDiff</code>: Add one single Pose first. Timediff describes the time difference between last conf and given conf”;</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/16/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E6%89%80%E6%9C%89%E7%BA%A6%E6%9D%9F/">所有约束</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/">TEB算法</a></span><div class="content"><ul>
<li>速度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix&lt;<span class="keyword">double</span>,<span class="number">2</span>,<span class="number">2</span>&gt; information;</span><br><span class="line"><span class="built_in">information</span>(<span class="number">0</span>,<span class="number">0</span>) = cfg_-&gt;optim.weight_max_vel_x;</span><br><span class="line"><span class="built_in">information</span>(<span class="number">1</span>,<span class="number">1</span>) = cfg_-&gt;optim.weight_max_vel_theta;</span><br><span class="line"><span class="built_in">information</span>(<span class="number">0</span>,<span class="number">1</span>) = <span class="number">0.0</span>;</span><br><span class="line"><span class="built_in">information</span>(<span class="number">1</span>,<span class="number">0</span>) = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>加速度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix&lt;<span class="keyword">double</span>,<span class="number">2</span>,<span class="number">2</span>&gt; information;</span><br><span class="line">information.<span class="built_in">fill</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">information</span>(<span class="number">0</span>,<span class="number">0</span>) = cfg_-&gt;optim.weight_acc_lim_x;</span><br><span class="line"><span class="built_in">information</span>(<span class="number">1</span>,<span class="number">1</span>) = cfg_-&gt;optim.weight_acc_lim_theta;</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix&lt;<span class="keyword">double</span>,<span class="number">1</span>,<span class="number">1</span>&gt; information;</span><br><span class="line">information.<span class="built_in">fill</span>(cfg_-&gt;optim.weight_optimaltime);</span><br></pre></td></tr></table></figure>
</li>
<li><p>最短距离</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix&lt;<span class="keyword">double</span>,<span class="number">1</span>,<span class="number">1</span>&gt; information;</span><br><span class="line">information.<span class="built_in">fill</span>(cfg_-&gt;optim.weight_shortest_path);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>优先转弯方向，二元边</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create edge for satisfiying kinematic constraints</span></span><br><span class="line">Eigen::Matrix&lt;<span class="keyword">double</span>,<span class="number">1</span>,<span class="number">1</span>&gt; information_rotdir;</span><br><span class="line">information_rotdir.<span class="built_in">fill</span>(cfg_-&gt;optim.weight_prefer_rotdir);</span><br></pre></td></tr></table></figure>
</li>
<li><p>障碍</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix&lt;<span class="keyword">double</span>,<span class="number">1</span>,<span class="number">1</span>&gt; information;</span><br><span class="line">information.<span class="built_in">fill</span>(cfg_-&gt;optim.weight_obstacle * weight_multiplier);</span><br></pre></td></tr></table></figure>
<ul>
<li>动态障碍   AddEdgesDynamicObstacles</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix&lt;<span class="keyword">double</span>,<span class="number">2</span>,<span class="number">2</span>&gt; information;</span><br><span class="line"><span class="built_in">information</span>(<span class="number">0</span>,<span class="number">0</span>) = cfg_-&gt;optim.weight_dynamic_obstacle * weight_multiplier;</span><br><span class="line"><span class="built_in">information</span>(<span class="number">1</span>,<span class="number">1</span>) = cfg_-&gt;optim.weight_dynamic_obstacle_inflation;</span><br><span class="line"><span class="built_in">information</span>(<span class="number">0</span>,<span class="number">1</span>) = <span class="built_in">information</span>(<span class="number">1</span>,<span class="number">0</span>) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/13/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%89%8D%E7%AB%AF%205.%20Ceres%20scan%20matcher%E4%B8%AD%E7%9A%84%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0/">前端 5. Ceres scan matcher中的占用空间代价函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>先看这个匹配的原理</p>
<h2 id="ceres中的类-BiCubicInterpolator"><a href="#ceres中的类-BiCubicInterpolator" class="headerlink" title="ceres中的类 BiCubicInterpolator"></a>ceres中的类 BiCubicInterpolator</h2><p>输入无限的二维grid<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Grid2D</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> DATA_DIMENSION = <span class="number">2</span> &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GetValue</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">double</span>* f)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><code>GetValue</code>函数返回函数<code>f</code>(可能是向量)的值， 枚举<code>DATA_DIMENSION</code>表示所插值函数的维度，比如对一个图片(红绿蓝)进行插值，那么<code>DATA_DIMENSION = 3</code></p>
<p><code>BiCubicInterpolator</code>使用<a target="_blank" rel="noopener" href="https://blog.csdn.net/shiyimin1/article/details/80141333">三次卷积算法</a>生成平滑估计，用来在真实曲线的任一点评价 <script type="math/tex">f(r,c), \frac{\partial f(r,c)}{\partial r}, \frac{\partial f(r,c)}{\partial c}</script> </p>
<p>对二维数组进行插值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> data[] = &#123;<span class="number">1.0</span>, <span class="number">3.0</span>, <span class="number">-1.0</span>, <span class="number">4.0</span>,</span><br><span class="line">                       <span class="number">3.6</span>, <span class="number">2.1</span>,  <span class="number">4.2</span>, <span class="number">2.0</span>,</span><br><span class="line">                       <span class="number">2.0</span>, <span class="number">1.0</span>,  <span class="number">3.1</span>, <span class="number">5.2</span>&#125;;</span><br><span class="line"><span class="comment">// 生成 BiCubicInterpolator 需要的二维数组</span></span><br><span class="line"><span class="function">Grid2D&lt;<span class="keyword">double</span>, 1&gt;  <span class="title">array</span><span class="params">(data, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">BiCubicInterpolator <span class="title">interpolator</span><span class="params">(array)</span></span>;</span><br><span class="line"><span class="keyword">double</span> f, dfdr, dfdc;</span><br><span class="line">interpolator.<span class="built_in">Evaluate</span>(<span class="number">1.2</span>, <span class="number">2.5</span>, &amp;f, &amp;dfdr, &amp;dfdc);</span><br></pre></td></tr></table></figure><br>函数<code>void Evaluate(double r, double c, double* f, double* dfdr, double* dfdc)</code>，残差会对应第3个参数<code>f</code></p>
<p>Evaluate the interpolated function value and/or its 导数. Returns false 如果<code>r</code> 或者 <code>c</code>越界</p>
<h2 id="OccupiedSpaceCostFunction2D"><a href="#OccupiedSpaceCostFunction2D" class="headerlink" title="OccupiedSpaceCostFunction2D"></a>OccupiedSpaceCostFunction2D</h2><p>这个<code>Occupied Space Cost Function</code>的模型和 <code>Real time correlative scan matching</code> 的思路基本上一致，只是求解方法变成了最小二乘问题的求解。</p>
<p>将点云中所有点的坐标映射到栅格坐标系，<font size="4" color="blue"> 假如点对应的空闲概率最小，说明对应栅格几乎被占据，点确实是hit点，此时的变换为最优变换。  </font>出于精度考虑使用了ceres提供的双三线性插值。 还有地图大小限制的问题，即一旦点云变换后存在部分脱离地图范围的点，这些点的代价值需要定义。cartographer中的做法是在地图周围增加一个巨大的边框(kPadding)，并且通过一个地图适配器定义点落在边框中的代价值。</p>
<p>先看创建代价函数 <code>CreateOccupiedSpaceCostFunction2D</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建代价函数 for matching the &#x27;point_cloud&#x27; to the &#x27;grid&#x27; with a &#x27;pose&#x27;</span></span><br><span class="line"><span class="comment">//  &#x27;point_cloud&#x27; 是 filtered_gravity_aligned_point_cloud</span></span><br><span class="line"><span class="comment">// &#x27;grid&#x27; 是 matching_submap-&gt;grid()</span></span><br><span class="line"><span class="comment">//  grid 和 point observation  匹配越差，代价越大</span></span><br><span class="line"><span class="comment">//  比如 points falling into less occupied space</span></span><br><span class="line"><span class="function">ceres::CostFunction* <span class="title">CreateOccupiedSpaceCostFunction2D</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">double</span> scaling_factor, <span class="keyword">const</span> sensor::PointCloud&amp; point_cloud,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Grid2D&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ceres::AutoDiffCostFunction&lt;OccupiedSpaceCostFunction2D,</span><br><span class="line">           ceres::DYNAMIC,   <span class="comment">/* residuals 残差维度未知 */</span></span><br><span class="line">           <span class="number">3</span>  <span class="comment">/* pose variables */</span>&gt;</span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">OccupiedSpaceCostFunction2D</span>(scaling_factor, point_cloud, grid),</span><br><span class="line">    point_cloud.<span class="built_in">size</span>() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>OccupiedSpaceCostFunction2D</code>的构造函数只有参数赋值</p>
<p><br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> pose, T* residual)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Eigen::Matrix&lt;T, 2, 1&gt; <span class="title">translation</span><span class="params">(pose[<span class="number">0</span>], pose[<span class="number">1</span>])</span></span>;</span><br><span class="line">    <span class="function">Eigen::Rotation2D&lt;T&gt; <span class="title">rotation</span><span class="params">(pose[<span class="number">2</span>])</span></span>;</span><br><span class="line">    Eigen::Matrix&lt;T, <span class="number">2</span>, <span class="number">2</span>&gt; rotation_matrix = rotation.<span class="built_in">toRotationMatrix</span>();</span><br><span class="line">    Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">3</span>&gt; transform;</span><br><span class="line">    transform &lt;&lt; rotation_matrix, translation, <span class="built_in">T</span>(<span class="number">0.</span>), <span class="built_in">T</span>(<span class="number">0.</span>), <span class="built_in">T</span>(<span class="number">1.</span>);</span><br><span class="line">    <span class="comment">// 构造二阶线性插值类， 成员变量只有 grid_</span></span><br><span class="line">    <span class="comment">// 功能主要是在概率栅格图对应的 index 中取出相应的概率值</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> GridArrayAdapter  <span class="title">adapter</span><span class="params">(grid_)</span></span>;</span><br><span class="line">    <span class="comment">// 使用Ceres提供的双三次插值迭代器</span></span><br><span class="line">    <span class="function">ceres::BiCubicInterpolator&lt;GridArrayAdapter&gt;  <span class="title">interpolator</span><span class="params">(adapter)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> MapLimits&amp;  limits = grid_.<span class="built_in">limits</span>();</span><br><span class="line">    <span class="comment">// 遍历点云（当前 scan）中的所有点，计算该点匹配残差： 1-Smooth(Tp)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; point_cloud_.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这是2D点，第三个元素是 scaling factor</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> Eigen::Matrix&lt;T, 3, 1&gt; <span class="title">point</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        (  T(point_cloud_[i].position.x()) ),</span></span></span><br><span class="line"><span class="params"><span class="function">        (  T(point_cloud_[i].position.y()) ),</span></span></span><br><span class="line"><span class="params"><span class="function">           T(<span class="number">1.</span>)   )</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将点转换到 local map 坐标系下</span></span><br><span class="line">        <span class="keyword">const</span> Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; world = transform * point;</span><br><span class="line">        <span class="comment">/* 计算  1-Smooth(T * point)</span></span><br><span class="line"><span class="comment">        前两个参数用来描述x y轴索引， 第三个参数用于记录插值后的结果</span></span><br><span class="line"><span class="comment">        xy索引的计算是通过 GridArrayAdapter::GetValue 获取栅格数据 </span></span><br><span class="line"><span class="comment">        取出每个点对应的栅格地图空闲概率（双三次插值之后的） p */</span></span><br><span class="line">        interpolator.<span class="built_in">Evaluate</span>(</span><br><span class="line">        <span class="comment">// 传进来的时候x和y都分别加了  kPadding</span></span><br><span class="line">        <span class="comment">// max的x y减掉真实的xy得到  cell_index</span></span><br><span class="line">        <span class="comment">/* kPadding是为了解决有些点可能跑到地图外面去的情况，所以加了一个超大的值</span></span><br><span class="line"><span class="comment">          即将地图上下左右边界分别扩大 kPadding，这是为了照顾ceres的Evaluate函数 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将坐标转换为栅格坐标，与子图坐标方向相反，双三次插值器自动计算中对应坐标的value</span></span><br><span class="line">        (limits.<span class="built_in">max</span>().<span class="built_in">x</span>() - world[<span class="number">0</span>]) / limits.<span class="built_in">resolution</span>() - <span class="number">0.5</span> +</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(kPadding),</span><br><span class="line">        (limits.<span class="built_in">max</span>().<span class="built_in">y</span>() - world[<span class="number">1</span>]) / limits.<span class="built_in">resolution</span>() - <span class="number">0.5</span> +</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(kPadding),</span><br><span class="line">        &amp;residual[i]  );</span><br><span class="line">        <span class="comment">// 因为有多个点，残差不是一维的，所有残差使用同一权重</span></span><br><span class="line">        residual[i] = scaling_factor_ * residual[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于占用栅格中原本存储的就是栅格空闲的概率，所以这里<code>GetValue</code>查询出来的概率其实就是 <script type="math/tex">1-M_{smooth}\ \ (T_{\xi} H_k)</script>，令其最小化就对了</p>
<script type="math/tex; mode=display">每个残差权重=\frac{参数 occupied\ space\  weight} {\sqrt{点云数}}</script><p><br></p>
<p><code>GridArrayAdapter</code>是cartographer定义的，使用适配器模式，<code>interpolator</code>构造函数的参数需要的是模板里的类型。重要函数的是<code>GetValue</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GridArrayAdapter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> DATA_DIMENSION = <span class="number">1</span> &#125;;  <span class="comment">//被插值的向量维度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GridArrayAdapter</span><span class="params">(<span class="keyword">const</span> Grid2D&amp; grid)</span> : grid_(grid) &#123;</span>&#125;</span><br><span class="line">    <span class="comment">// 返回空闲概率， kPadding 是个很大的数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> row, <span class="keyword">const</span> <span class="keyword">int</span> column, <span class="keyword">double</span>* <span class="keyword">const</span> value)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="comment">// 处于地图外部时，赋予最大的free值</span></span><br><span class="line">      <span class="keyword">if</span>(row &lt; kPadding || column &lt; kPadding || </span><br><span class="line">      	row &gt;= <span class="built_in">NumRows</span>() - kPadding || column &gt;= <span class="built_in">NumCols</span>() - kPadding)</span><br><span class="line">        	*value = kMaxCorrespondenceCost;</span><br><span class="line">     <span class="comment">// 在地图里取空闲概率，这里需要减掉kPadding，因为在传进来的时候，已经加了kPadding</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        	*value = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(grid_.<span class="built_in">GetCorrespondenceCost</span>(</span><br><span class="line">            Eigen::<span class="built_in">Array2i</span>(column - kPadding, row - kPadding) )  );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumRows</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> grid_.<span class="built_in">limits</span>().<span class="built_in">cell_limits</span>().num_y_cells + <span class="number">2</span> * kPadding;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumCols</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> grid_.<span class="built_in">limits</span>().<span class="built_in">cell_limits</span>().num_x_cells + <span class="number">2</span> * kPadding;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> Grid2D&amp;  grid_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>GetValue</code>函数调用的地方在<code>interpolator.Evaluate</code>里面</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/09/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E6%A6%82%E7%8E%87%E7%9F%A5%E8%AF%86/">概率知识</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a></span><div class="content"><p>贝叶斯法则： <script type="math/tex">P(x|z) = \frac{P(z|x)P(x)}{P(z)}</script></p>
<p><script type="math/tex">P(x|z)</script>是后验， <script type="math/tex">P(z|x)</script> 是似然， <script type="math/tex">P(x)</script>是先验</p>
<ul>
<li>先验：指根据以往经验得到事件发生的概率</li>
</ul>
<p>最大后验： 使<script type="math/tex">P(x|z)</script>最大的x估计，比如分布是高斯分布，那么求出的是均值，比估计整个分布简单的多。 </p>
<p>有时求最大后验时，<script type="math/tex">P(x)</script>也不知道，所以只把似然最大化。</p>
<p>最大似然： 在什么状态下，最可能产生当前的观测。对于高斯分布，就是什么情况下最可能取得均值，让概率密度函数最大</p>
<p>在状态估计中，可以这么理解，先验就是没有得到观测值时的概率分布，似然就是观测的概率分布，后验就是在得到观测值后对先验校正后的概率分布。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/15/PCL%E7%82%B9%E4%BA%91/KD%E6%A0%91%E5%92%8C%E6%9C%80%E8%BF%91%E9%82%BB%E6%90%9C%E7%B4%A2/">KD树和最近邻搜索</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/PCL%E7%82%B9%E4%BA%91/">PCL点云</a></span><div class="content"><p>kD树的构建步骤：</p>
<ol>
<li><p>在K维数据集合中选择具有最大方差的维度k，然后在该维度上选择中值为pivot对该数据集合进行划分，得到两个子集合；同时创建一个树结点node，用于存储</p>
</li>
<li><p>对两个子集合重复（1）步骤的过程，直至所有子集合都不能再划分为止；</p>
</li>
</ol>
<ul>
<li><p>选择数据方差大的维度，是因为沿该坐标轴方向上数据点分散的比较开；另外可以减少最近邻搜索时的回溯代价，减少子树的访问</p>
</li>
<li><p>对于n个实例的k维数据来说，建立kd-tree的时间复杂度为 <script type="math/tex">O(k*n*logn)</script> ， 这有时会比较复杂</p>
</li>
</ul>
<h2 id="最近邻搜索"><a href="#最近邻搜索" class="headerlink" title="最近邻搜索"></a>最近邻搜索</h2><p>算法的时间复杂度是 <script type="math/tex">O(log\ n)</script><br>举例如下：<br><img src="https://s2.loli.net/2022/02/26/TR5Udj1KFEmeksC.png" alt="KD树构建"><br><img src="https://s2.loli.net/2022/02/26/gUTYFzSAe32fMZx.png" alt="坐标图"><br><img src="https://s2.loli.net/2022/02/27/dmfrgANo64Lxqj5.png" alt="搜索过程"></p>
<ul>
<li>不会去搜索根节点的另一颗子树</li>
<li>不需要计算每一个节点的欧式距离，而多数情况只需要计算点到超平面的距离就可以了。</li>
<li>KD树在维度较小时（比如20、30），算法的查找效率很高，然而当数据维度增大（例如：K≥100），查找效率会随着维度的增加而迅速下降。假设数据集的维数为 D，一般来说要求数据的规模 N 满足 <script type="math/tex">N>>2^D</script>，才能达到高效的搜索，否则大部分的点都会被查询。</li>
</ul>
<h2 id="PCL中的KD树"><a href="#PCL中的KD树" class="headerlink" title="PCL中的KD树"></a>PCL中的KD树</h2><p>PCL中的KD-Tree一般适用于三维特征点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/kdtree/kdtree_flann.h&gt;</span>  <span class="comment">//kdtree近邻搜索</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/io/pcd_io.h&gt;</span>  <span class="comment">//文件输入输出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span>  <span class="comment">//点类型相关定义</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/visualization/cloud_viewer.h&gt;</span>  <span class="comment">//点类型相关定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.读取点云</span></span><br><span class="line">	pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::<span class="function">Ptr <span class="title">cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZRGB&gt;)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (pcl::io::loadPCDFile&lt;pcl::PointXYZRGB&gt;(<span class="string">&quot;rabbit.pcd&quot;</span>, *cloud) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">PCL_ERROR</span>(<span class="string">&quot;Cloudn&#x27;t read file!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.原始点云着色</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;points.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">		cloud-&gt;points[i].r = <span class="number">255</span>;</span><br><span class="line">		cloud-&gt;points[i].g = <span class="number">255</span>;</span><br><span class="line">		cloud-&gt;points[i].b = <span class="number">255</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3.  建立kd-tree</span></span><br><span class="line">	pcl::KdTreeFLANN&lt;pcl::PointXYZRGB&gt;  kdtree;  <span class="comment">//建立kdtree对象</span></span><br><span class="line">	kdtree.<span class="built_in">setInputCloud</span>(cloud); <span class="comment">//设置需要建立kdtree的点云指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//  4.  K近邻搜索</span></span><br><span class="line">	pcl::PointXYZRGB searchPoint = cloud-&gt;points[<span class="number">1000</span>];   <span class="comment">// 设置查找点</span></span><br><span class="line">	<span class="keyword">int</span> K = <span class="number">900</span>;  <span class="comment">//设置需要查找的近邻点个数</span></span><br><span class="line">	<span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">pointIdxNKNSearch</span><span class="params">(K)</span></span>;  <span class="comment">//  保存每个近邻点的索引</span></span><br><span class="line">	<span class="function">std::vector&lt;<span class="keyword">float</span>&gt; <span class="title">pointNKNSquaredDistance</span><span class="params">(K)</span></span>; <span class="comment">// 保存每个近邻点与查找点之间的欧式距离平方</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kdtree.<span class="built_in">nearestKSearch</span>(searchPoint, K, pointIdxNKNSearch, pointNKNSquaredDistance) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; pointIdxNKNSearch.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">			cloud-&gt;points[pointIdxNKNSearch[i]].r = <span class="number">0</span>;</span><br><span class="line">			cloud-&gt;points[pointIdxNKNSearch[i]].g = <span class="number">255</span>;</span><br><span class="line">			cloud-&gt;points[pointIdxNKNSearch[i]].b = <span class="number">0</span>;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;K = 900近邻点个数：&quot;</span> &lt;&lt; pointIdxNKNSearch.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  5.  显示点云</span></span><br><span class="line">	pcl::<span class="function">visualization::CloudViewer <span class="title">viewer</span><span class="params">(<span class="string">&quot;cloud viewer&quot;</span>)</span></span>;</span><br><span class="line">	viewer.<span class="built_in">showCloud</span>(cloud);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/02/15/La14Fe6wiCg52J7.png" alt="KD树和八叉树的比较"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/HelloJinYe/article/details/106587816">点云数据通过pcl的kdtree搜索关键点某半径邻域内的区域</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/14/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E5%81%B6%E7%84%B6%E5%87%BA%E7%8E%B0%E5%80%92%E9%80%80%E7%9A%84%E5%B0%8F%E9%80%9F%E5%BA%A6/">偶然出现倒退的小速度</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/">TEB算法</a></span><div class="content"><p>机器人导航时偶然出现倒退的小速度<code>-0.02</code>，但周围又没有障碍物，其实就是参数<code>max_vel_x_backwards=0.02</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/11/Matlab/Matlab%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5/">Matlab中的矩阵</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Matlab/">Matlab</a></span><div class="content"><h2 id="定义矩阵"><a href="#定义矩阵" class="headerlink" title="定义矩阵"></a>定义矩阵</h2><p><code>a=[1,2,3; 4,5,6]</code>是一个2×3的矩阵<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p><code>matrix = [1;2;3;4;5]</code> 是5x1的矩阵，  <code>matrix = [1,2,3,4,5]</code>是1x5的矩阵</p>
<p><code>matrix = [1,2,3,4,5]&#39;</code> 是做了转置，结果是5x1的矩阵</p>
<p><code>matrix(:, 1)</code>是矩阵的第一列<br><br></p>
<ul>
<li><p>zeros(m,n): 生成一个 m 行 n 列的零矩阵，m=n 时可简写为 <code>zeros(n)</code></p>
</li>
<li><p>ones(m,n): 生成一个 m 行 n 列的元素全为 1 的矩阵， 当m=n 时可写为 <code>ones(n)</code></p>
</li>
<li><p>eye(m,n): 生成一个主对角线全为 1 的 m 行 n 列矩阵， m=n 时可简写为 <code>eye(n)</code>，即为 n 维单位矩阵</p>
</li>
<li><p>rand(m,n): 产生 <code>0～1</code> 间均匀分布的随机矩阵， m=n 时简写为 <code>rand(n)</code></p>
</li>
<li><p>randn(m,n): 产生均值为0，方差为1的标准正态分布矩阵，m=n 时简写为 <code>randn(n)</code></p>
</li>
</ul>
<p><code>zeros(m, n)</code>中的n可以为0，此时矩阵实际是空。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">matrix = zeros(<span class="number">5</span>,<span class="number">0</span>)</span><br><span class="line">matrix = [matrix, [<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>;<span class="number">4</span>;<span class="number">5</span>] ]</span><br><span class="line">matrix = [matrix, [<span class="number">11</span>;<span class="number">12</span>;<span class="number">13</span>;<span class="number">14</span>;<span class="number">15</span>] ]</span><br></pre></td></tr></table></figure><br>最终matrix是5x2的矩阵，也就是逐步扩展<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>    <span class="number">11</span></span><br><span class="line"><span class="number">2</span>    <span class="number">12</span></span><br><span class="line"><span class="number">3</span>    <span class="number">13</span></span><br><span class="line"><span class="number">4</span>    <span class="number">14</span></span><br><span class="line"><span class="number">5</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/09/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%BC%A0%E6%A5%AB%E7%9A%84autonomous_exploration/%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB%20Autonomous%20Exploration%20Development%20Environment%20and%20the%20Planning%20Algorithms/">论文解读 Autonomous Exploration Development Environment and the Planning Algorithms</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/CMU%E7%9A%84autonomous-exploration/">CMU的autonomous_exploration</a></span><div class="content"><p>这篇论文发表于2021.10，大部分内容在官网上，对一些重点内容做一下记录。</p>
<h2 id="I-INTRODUCTION"><a href="#I-INTRODUCTION" class="headerlink" title="I. INTRODUCTION"></a>I. INTRODUCTION</h2><p>算法框架包括探索算法<code>TARE</code> (<code>exploration planner</code>)；  路径算法<code>FAR</code> (<code>route planner</code>)</p>
<p>我们的算法不依赖只有仿真才提供的信息，比如 semantic and terrain segmentation groundtruth. 算法是为了让用户重点开发上层的规划算法。</p>
<p>在2021 DARPA地下挑战赛中， CMU-OSU Team Explorer 虽然没拿到冠军，但获得”探索最多区域奖“(26 out of 28 sectors).</p>
<h2 id="II-RELATED-WORK"><a href="#II-RELATED-WORK" class="headerlink" title="II. RELATED WORK"></a>II. RELATED WORK</h2><p>For <font size="4" color="blue">outdoor settings </font>, the most well-known dataset is <code>KITTI Vision Benchmark Dataset</code> [4] collected<br>from a self-driving suite in road driving scenarios. The<br>dataset contains sensor data from stereo cameras, 3D Lidar,<br>and GPS/INS ground truth for benchmarking depth reconstruction, odometry estimation, object segmentation, etc. </p>
<p>For <font size="4" color="blue">localization purposes, </font> the long-term localization benchmark includes a comprehensive list of datasets :  Aachen Day-Night dataset, Extended CMU Seasons dataset, RobotCar Seasons dataset, and SILDa Weather and Time of Day dataset. </p>
<font size="4" color="blue">For indoor navigation </font>, iGibson [15], [16], Sapien [17], AI2Thor [18], Virtual Home [19], ThreeDWorld [20], MINOS [21], House3D [22] and CHALET [23] use synthetic scenes, while reconstructed scenes are also available in iGibson, AI Habitatand MINOS. Compared to datasets, simulation environments have the advantage of providing access to ground truth data, e.g. vehicle pose and semantic segmentation to simplify the algorithm development and allowing full navigation system tests in closed control loop。

For <font size="4" color="blue"> indoor scenes</font>, datasets such as NYUDepth dataset [7], TUM SLAM dataset [8], inLoc dataset [9], MIT Stata center dataset, and KTH-INDOL dataset [11], [12] are available. Datasets are useful in developing and

<font size="4" color="blue">Simulation environments </font>: Carla [13] and AirSim [14] are two representative simulation environments for autonomous driving and flying. These simulators support various conditions such as lighting and weather changes, moving objects such as pedestrians, and incident scenes.


其他的导航框架:  ROS Navigation Stack 和港科大的 fast_planner ，不过是针对无人机的。

我们的导航框架: 支持photorealistic house models from Matterport3D 以及向AI Habitat提供接口。这两个在机器人学和计算视觉中应用很多。Users are provided with scan data and RGB, depth, and semantic images rendered by AI Habitat. Users have the option of running AI Habitat side by side with our system or in post-processing.

![](https://s2.loli.net/2022/02/09/VnzOjNr5Y7UQcsf.png)


参考：
[阅读笔记 《Matterport3D: Learning from RGB-D Data inIndoor Environments》](https://blog.csdn.net/ShuqiaoS/article/details/88361949)
[AI Habitat室内仿真平台使用](https://blog.csdn.net/weixin_43823054/article/details/106903128)

## III. DEVELOPMENT ENVIRONMENT

### Local Planner

`local planner`保证了到达目标时的安全，它预计算 a motion primitive library and associates the motion primitives to 车周围的3D locations(这里说的就是`free_paths`对应的曲线簇)。 <font size="4" color="blue"> The motion primitives are modeled as Monte Carlo samples and organized in groups </font>

<p>现实中快遇到障碍物时，<code>local planner</code>可以在几毫秒内判断出哪些 motion primitives 会和障碍相撞，然后从motion primitives中选出最可能朝向目标的一组。</p>
<p>The module also has interface to take in additional range data for collision avoidance as an extension option</p>
<h3 id="Terrain-Traversability-Analysis"><a href="#Terrain-Traversability-Analysis" class="headerlink" title="Terrain Traversability Analysis"></a>Terrain Traversability Analysis</h3><p>模块建立了一个代价地图，地图中的每一个点和一个traversal cost相关联. 代价值取决于 local smoothness of the terrain. </p>
<p>我们使用体素网格表示环境，分析 distributions of data points in adjacent voxels to 估计地面高度. The points are associated with higher traversal costs if they are further apart from the ground.</p>
<p>模块还能处理<code>negative obstacles</code>，这些障碍生成空区域with no data points on the terrain map. 如果开启了<code>negative obstacle</code>的处理，模块认为那些区域不可经过</p>
<h3 id="Visualization-and-Debugging-Tools"><a href="#Visualization-and-Debugging-Tools" class="headerlink" title="Visualization and Debugging Tools"></a>Visualization and Debugging Tools</h3><p>可视化算法的性能. 可视化工具显示地图，已探索区域，车的轨迹. Metrics包括 explored volume, traveling distance, and algorithm runtime are plotted and logged to files. </p>
<p>另外，支持手柄和导航交互，在多种操作模式之间切换 to ease the process of system debugging. </p>
<h2 id="IV-HIGH-LEVEL-PLANNERS"><a href="#IV-HIGH-LEVEL-PLANNERS" class="headerlink" title="IV. HIGH-LEVEL PLANNERS"></a>IV. HIGH-LEVEL PLANNERS</h2><h2 id="V-BEST-PRACTICES"><a href="#V-BEST-PRACTICES" class="headerlink" title="V. BEST PRACTICES"></a>V. BEST PRACTICES</h2><p>Safety margin: <code>local planner</code>使用车和<code>waypoint</code>之间的距离作为规划尺度(planning horizon)。即使<code>waypoint</code>很接近障碍，也可以让车到达。但是，如果车不能在<code>waypoint</code>停下，上层规划器倾向于让车到<code>waypoint</code>保持一定距离(默认≥<br>3.75m)。If the waypoint is closer, users can project the waypoint further away and keep the waypoint in the same direction w.r.t. the vehicle to fully use the safety margin. (这句话没理解什么意思)</p>
<p>但是，如果车需要经过窄通道，降低这一距离可以让<code>local planner</code>找到安全合适的路径。</p>
<p><strong>大转弯</strong>: Typically, a high-level planner selects the waypoint along the path that is a distance, namely look-ahead distance, ahead of the vehicle and sends the waypoint to the local planner (possibly after projecting the waypoint further away from the vehicle as discussed above).</p>
<p>When handling sharp turns (≥ 90 deg), the look-ahead distance needs to be properly set or the waypoint may jump to the back of the vehicle, causing the vehicle to osculate back-and-forth. We recommend to select the waypoint on the starting segment of the path that is in line-of-sight from the vehicle. </p>
<p><strong>动态障碍</strong>: <code>terrain analysis</code>模块在动态障碍走过之后，通过<code>ray-tracing</code>清除动态障碍。这是在车的附近范围实现的(到车的距离≤5m)， 因为雷达数据在远处比较稀疏，以及难以权衡清除动态障碍和thin structures之间的矛盾。 用户根据自己的情况来清除动态障碍，TARE和FAR都有这一步骤。</p>
<h2 id="VI-SYSTEM-INTEGRATION"><a href="#VI-SYSTEM-INTEGRATION" class="headerlink" title="VI. SYSTEM INTEGRATION"></a>VI. SYSTEM INTEGRATION</h2><h3 id="用于DARPA挑战赛的平台"><a href="#用于DARPA挑战赛的平台" class="headerlink" title="用于DARPA挑战赛的平台"></a>用于DARPA挑战赛的平台</h3><p><img src="https://s2.loli.net/2022/02/09/EijtMkq5SJKRN6s.png" alt=""><br>The state estimation module can detect and introduce loop closures. The module outputs state estimation in the odometry frame generated by 3D Lidar-based odometry containing accumulated drift. When loop closure is triggered, it outputs loop closure adjustments to globally relax the vehicle trajectory and corresponding maps. Loop closure adjustments are used by the high-level planners since they are in charge of planning at the global scale.</p>
<p>The local planner and terrain analysis modules are extended to handle complex terrains including negative obstacles such as cliffs, pits, and water puddles <font size="4" color="blue"> with a downward-looking depth sensor</font>. The TARE planner, FAR planner, and other planners (for stuck recovery, etc) are run in parallel for tasks such as exploration, go-to waypoint, and return home.</p>
<p>On top of these planners, behavior executive and multi-robot coordination modules are built specifically for the challenge. The modules share explored and unexplored areas across multirobots and call TARE and FAR planners cooperatively. In particular, when a long-distance transition is determined due to new areas containing artifacts are discovered or operator waypoints are received, the behavior executive switches to<br>FAR planner for relocating the vehicle. During the relocation, FAR planner uses a sparse roadmap merged from multi-robots for high-level guidance. After the relocation is complete, TARE planner takes place for exploration</p>
<p>DARPA最后决赛是在<code>Louisville Mega Cavern, KY</code>. 赛道包括隧道、urban、洞穴环境。我们的三台车使用<code>TARE</code> 和 <code>FAR</code>进行探索。<br><img src="https://s2.loli.net/2022/02/09/VmEYJnZG7OhgXzx.png" alt="DARPA Subterranean Challenge Final Competition"><br>红色轨迹：车先使用TARE一直探索到B，然后使用FAR经过C，一到达C，车换成TARE进行剩下的探索。</p>
<p>绿色轨迹：车只用TARE；蓝色轨迹：车先使用FAR经过A，在换成TARE进行之后的搜索。</p>
<p>三台车各行走596.6m, 499.8m, 445.2m。共花费时间2259s<br><img src="https://s2.loli.net/2022/02/09/G2aoUBhjF9tNWRi.png" alt="比赛地图，与上图一样"><br>这里只看论文不太明白，看实际视频才清楚。实际是两辆车和一架无人机进行探索。</p>
<h2 id="VII-EXTENDED-APPLICATION-EXAMPLES"><a href="#VII-EXTENDED-APPLICATION-EXAMPLES" class="headerlink" title="VII. EXTENDED APPLICATION EXAMPLES"></a>VII. EXTENDED APPLICATION EXAMPLES</h2><p>这部分我暂时用不到，就不研究了。</p>
<p>训练基于学习的探索和导航算法。大家可以使用我们的仿真平台作为专家系统(expert system)来训练基于学习的规划算法。专家系统里包含状态估计，局部避障，上层的探索或者路径规划算法。训练的对象可以是一些端对端的方法，比如只有一层深度网络的探索或者路径规划算法。</p>
<p>基于激光或者视觉的sim-to-real学习。大家可以用我们的仿真平台训练一些基于学习的方法，并将训练好的系统应用在现实世界中。因为我们提供了多个仿真世界以及支持来自Matterport3D的90个photorealistic环境模型，并且兼容AI Habitat的RGB，深度，和语义(Semantic)图像的渲染功能，所以不管是基于激光还是视觉的算法，大家都可以找到适用的环境模型，当然也可以根据需求换上自己的模型。举个简单的例子，需要做Semantic-in-loop导航的人可以使用我们提供的带有语义信息的环境，使用我们的地面机器人仿真平台，去训练他们的算法，并且在训练结束后，直接将算法移植到实际的机器人上。下面是我们的仿真机器人在Matterport3D的两个环境模型中导航的场景，用AI Habitat实时生成RGB，深度及语义图像。</p>
<p>开发人群导航(social navigation)算法。大家可以在我们的仿真环境中加入动态的障碍物或者行人，模拟真实环境中的社区场景，辅助开发人群导航算法，甚至可以在这种场景中预测动态物体的行为及其轨迹。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/08/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%BC%A0%E6%A5%AB%E7%9A%84autonomous_exploration/DSVP%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E8%BF%90%E8%A1%8C/">DSVP的介绍和运行</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/Dual-Stage-Viewpoint-Planner/">Dual-Stage Viewpoint Planner</a></span><div class="content"><p>Dual-Stage Viewpoint Planner 包含两个阶段：探索阶段用于扩展地图边界，重定位阶段用于 explicitly 把机器人传到环境中不同的子区域。探索阶段采用RRT，并动态地扩展RRT over replanning steps. 重定位阶段维护一个graph结构 through the mapped environment. 在探索过程中，算法在两个阶段来回切换，以探索整个环境。</p>
<h2 id="dsvp-launch-的使用"><a href="#dsvp-launch-的使用" class="headerlink" title="dsvp_launch 的使用"></a>dsvp_launch 的使用</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install ros-melodic-octomap-ros libgoogle-glog-dev libgflags-dev</span><br><span class="line"><span class="comment"># 取melodic分支</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/HongbiaoZ/dsv_planner.git</span><br></pre></td></tr></table></figure>
<p>编译结束后，运行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 车库仿真环境，可以换成其他的</span></span><br><span class="line">roslaunch vehicle_simulator system_garage.launch</span><br><span class="line">roslaunch dsvp_launch explore_garage.launch</span><br></pre></td></tr></table></figure></p>
<p>然后是<code>Matterport3D</code>环境的配置，先跳过：To run DSV Planner in a Matterport3D environment, follow instructions to setup the development environment to use the Matterport3D environment. Then, use the command lines below to launch the system and DSV Planner.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roslaunch vehicle_simulator system_matterport.launch</span><br><span class="line">roslaunch dsvp_launch explore_matterport.launch</span><br></pre></td></tr></table></figure></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/7/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/57/">57</a><a class="extend next" rel="next" href="/page/9/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/02/18/exLTfbM3uFOq5SV.png)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>