<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | Silent Assassin</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">442</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">48</span></a></div></div></div><nav id="nav" style="background-image: url(https://i.loli.net/2021/07/13/RCLw5Bx8aFPN74b.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Silent Assassin</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">Silent Assassin</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/12/14/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/TEB%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%BA%BF%E9%80%9F%E5%BA%A6%E7%BA%A6%E6%9D%9F/">TEB中的最大线速度约束</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/">TEB算法</a></span><div class="content"><p>最大线速度约束主要在 <code>bool TimedElasticBand::initTrajectoryToGoal (const PoseSE2&amp; start, const PoseSE2&amp; goal, double diststep, double max_vel_x, int min_samples, bool guess_backwards_motion)</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/12/14/%E6%BF%80%E5%85%89SLAM/%E9%9B%B7%E8%BE%BE/%E9%9B%B7%E8%BE%BE%E6%89%AB%E6%8F%8F%E5%88%B0%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E9%9A%9C%E7%A2%8D/">雷达扫描到不存在的障碍</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/%E9%9B%B7%E8%BE%BE/">雷达</a></span><div class="content"><p><img src="https://i.loli.net/2020/12/14/21NmoitDAsf3KI4.png" alt="雷达默认参数"></p>
<ol>
<li><img src="https://i.loli.net/2021/02/24/DhPp5GqxolsM7Ar.png" alt="机器人的杂物挡住了雷达.png"><br>这是常见的一种情况</li>
</ol>
<ol start="2">
<li>起初经过观察，发现在一些地方容易出现，而且是都在雷达的左侧出现，于是怀疑是雷达自身问题，最后把<code>angle_min</code>的绝对值改小，不再出现这个问题。<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=h1TfzAyHez8">雷达扫描到不存在的障碍</a></li>
</ol>
<p>后来又出现这种现象，而且不分左右，有时看不出在哪边<br><img src="https://i.loli.net/2020/12/14/2wtrSiULXGYjsk1.png" alt="不存在的障碍导致全局路径改变"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/12/14/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E6%A0%B9%E6%8D%AE%E5%85%A8%E5%B1%80%E8%B7%AF%E5%BE%84%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C%E5%A4%9A%E4%B8%AA%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%97%B4%E8%B7%9D%E4%BC%98%E5%8C%96%E9%80%9F%E5%BA%A6/">根据全局路径的目标和多个机器人间距优化速度</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%85%B6%E4%BB%96/">其他</a></span><div class="content"><h3 id="dist-end-和-distanceToGoal-函数"><a href="#dist-end-和-distanceToGoal-函数" class="headerlink" title="dist_end_ 和 distanceToGoal 函数"></a>dist_end_ 和 distanceToGoal 函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">TebLocalPlannerROS::distanceToGoal</span><span class="params">(std::vector&lt;geometry_msgs::PoseStamped&gt;&amp; global_plan)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> dist_goal = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> plan_size = global_plan.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(plan_size &gt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; plan_size <span class="number">-2</span>; ++i)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">double</span> dx = global_plan[i + <span class="number">1</span>].pose.position.x - global_plan[i].pose.position.x;</span><br><span class="line">        <span class="keyword">double</span> dy = global_plan[i + <span class="number">1</span>].pose.position.y - global_plan[i].pose.position.y;</span><br><span class="line">        dist_goal += <span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dist_goal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求出全局路径每个路径点的欧氏距离，一直累加，作为到全局路径终点的距离<code>distance_to_goal</code>。函数主要调用在<code>computeVelocityCommands</code>函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dist_end_ = <span class="built_in">distanceToGoal</span>(global_plan_);</span><br><span class="line">&#123;</span><br><span class="line">	std_msgs::Float64  distance;</span><br><span class="line">	distance.data = dist_end_;</span><br><span class="line">	dist_to_goal_pub_.<span class="built_in">publish</span>(distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>global_plan_</code>就是<code>TebLocalPlannerROS::setPlan</code>中的全局路径，最后发布话题<code>distance_to_goal</code></p>
<h2 id="话题rectangle-distance-和-frontDistanceCB函数"><a href="#话题rectangle-distance-和-frontDistanceCB函数" class="headerlink" title="话题rectangle_distance 和 frontDistanceCB函数"></a>话题rectangle_distance 和 frontDistanceCB函数</h2><p>话题<code>rectangle_distance</code>来自节点<code>queue_follow_node</code>。单独一个车时，<code>rectangle_distance</code>话题对应的消息最大值是4</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">front_dist_sub_ = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;/rectangle_distance&quot;</span>, <span class="number">10</span>, &amp;TebLocalPlannerROS::frontDistanceCB, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上既根据小车到全局路径终点的距离而改变速度，又根据排队之间的距离改变速度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TebLocalPlannerROS::frontDistanceCB</span><span class="params">(<span class="keyword">const</span> std_msgs::Float64::ConstPtr&amp; front_dist_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> scale_max_vel_x;</span><br><span class="line">    <span class="keyword">if</span>(front_dist_msg-&gt;data &gt; <span class="number">1.2</span>)</span><br><span class="line">        scale_max_vel_x = std::<span class="built_in">min</span>(<span class="number">1.0</span>, <span class="built_in">sqrt</span>(front_dist_msg-&gt;data / <span class="number">4.0</span>));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(front_dist_msg-&gt;data &lt;= <span class="number">1.2</span> &amp;&amp; front_dist_msg-&gt;data &gt; <span class="number">0.6</span>)</span><br><span class="line">        scale_max_vel_x = <span class="number">0.3</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        scale_max_vel_x = <span class="number">0.2</span>;  </span><br><span class="line">    </span><br><span class="line">    boost::<span class="function">mutex::scoped_lock <span class="title">l</span><span class="params">(max_vel_mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(dist_end_ &lt; <span class="number">2.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">// robot_goal_ 是子目标</span></span><br><span class="line">        <span class="keyword">double</span> dx = robot_pose_.<span class="built_in">x</span>() - robot_goal_.<span class="built_in">x</span>();</span><br><span class="line">        <span class="keyword">double</span> dy = robot_pose_.<span class="built_in">y</span>() - robot_goal_.<span class="built_in">y</span>();</span><br><span class="line">        <span class="keyword">double</span> distance = <span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line">        <span class="keyword">if</span>(distance &gt; <span class="number">0.5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 线性速度系数</span></span><br><span class="line">          <span class="keyword">if</span>(!line_k_)</span><br><span class="line">          &#123;</span><br><span class="line">             line_k_ = (robot_vel_.linear.x - <span class="number">0.3</span>) / (distance - <span class="number">0.5</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">double</span> vel = <span class="number">0.3</span> + line_k_ * (distance - <span class="number">0.5</span>);</span><br><span class="line">          </span><br><span class="line">          cfg_.robot.max_vel_x = vel;</span><br><span class="line">          <span class="keyword">if</span>(cfg_.robot.max_vel_x &lt; <span class="number">0.3</span>)</span><br><span class="line">              cfg_.robot.max_vel_x = <span class="number">0.3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dist_end_ &gt; <span class="number">0.0</span>)</span><br><span class="line">           cfg_.robot.max_vel_x = <span class="number">0.3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dist_end_ &gt;= <span class="number">2.0</span>)</span><br><span class="line">    &#123;	</span><br><span class="line">    	<span class="comment">// param_max_vel_x_ 是yaml里的配置值，这里是1.25</span></span><br><span class="line">        cfg_.robot.max_vel_x = scale_max_vel_x * param_max_vel_x_;</span><br><span class="line">        <span class="keyword">if</span>(cfg_.robot.max_vel_x &lt; <span class="number">0.3</span>)</span><br><span class="line">            cfg_.robot.max_vel_x = <span class="number">0.3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最大速度不能低于0.3，否则实际速度会非常慢</span></span><br><span class="line">    front_max_vel = cfg_.robot.max_vel_x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/12/11/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%9F%BA%E4%BA%8Erealsense%E6%89%AB%E6%8F%8F%E7%82%B9%E4%BA%91%E7%9A%84%E4%BD%8E%E7%9F%AE%E9%81%BF%E9%9A%9C/2.%20%E6%9C%80%E5%A4%A7%E7%BA%BF%E9%80%9F%E5%BA%A6%E7%9A%84%E4%BC%98%E5%8C%96/">(二) 最大线速度优化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%9F%BA%E4%BA%8Erealsense%E6%89%AB%E6%8F%8F%E7%82%B9%E4%BA%91%E7%9A%84%E4%BD%8E%E7%9F%AE%E9%81%BF%E9%9A%9C/">基于realsense扫描点云的低矮避障</a></span><div class="content"><p>realsense在距离低矮障碍1.8米时才能观测到其点云，如果是更矮的障碍，需要离得更近。 为了能及时避障，在检测到点云时，将**最大速度约束(不是速度)**降到0.25.</p>
<p>如果相机的扫描视野和距离更大，效果一定会好很多。 </p>
<h2 id="根据点云障碍改变最大线速度约束"><a href="#根据点云障碍改变最大线速度约束" class="headerlink" title="根据点云障碍改变最大线速度约束"></a>根据点云障碍改变最大线速度约束</h2><p>在<code>TebLocalPlannerROS::initialize</code>中添加:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅处理过的点云话题</span></span><br><span class="line">pcl_dist_sub = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;/obstacle/PCloud&quot;</span>, <span class="number">1</span>, &amp;TebLocalPlannerROS::pclDistanceCB, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>回调函数如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TebLocalPlannerROS::pclDistanceCB</span><span class="params">(<span class="keyword">const</span> sensor_msgs::PointCloud2::ConstPtr &amp;pcl_dist_msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> max_pcl_dist = <span class="number">0</span>;</span><br><span class="line">  sensor_msgs::PointCloud out_pcl;</span><br><span class="line">  <span class="comment">// 转为点云1类型，因为点云2类型的数据不可读</span></span><br><span class="line">  sensor_msgs::<span class="built_in">convertPointCloud2ToPointCloud</span>(*pcl_dist_msg, out_pcl);</span><br><span class="line"></span><br><span class="line">  pcl_size = out_pcl.points.<span class="built_in">size</span>();</span><br><span class="line">  hasPCL = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>( pcl_size==<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 没有点云则不处理</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;out_pcl.points.<span class="built_in">size</span>(); i++)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// x表示在机器人的左右，规定矩形区域，使机器人不至于面对周边障碍也减速</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">fabs</span>(out_pcl.points[i].x) &gt; <span class="number">0.27</span>)   <span class="comment">// 配置参数</span></span><br><span class="line">      &#123;</span><br><span class="line">          hasPCL = (hasPCL | <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新相机到点云的最大距离，注意这里是z，不是x</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(out_pcl.points[i].z &gt; max_pcl_dist)</span><br><span class="line">      &#123;</span><br><span class="line">        hasPCL = (hasPCL | <span class="literal">true</span>);</span><br><span class="line">        max_pcl_dist = out_pcl.points[i].z;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 点云全在矩形区域外，无需减速</span></span><br><span class="line">  <span class="keyword">if</span>(!hasPCL)    <span class="keyword">return</span>;</span><br><span class="line">  boost::<span class="function">mutex::scoped_lock <span class="title">l</span><span class="params">(max_vel_mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// 线性减速，否则可能卡顿</span></span><br><span class="line">  <span class="keyword">if</span>(max_pcl_dist &gt; <span class="number">1.4</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!line_p)</span><br><span class="line">        line_p = (robot_vel_.linear.x - <span class="number">0.25</span>) / (max_pcl_dist - <span class="number">0.4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> pcl_vel = <span class="number">0.25</span> + line_p * (max_pcl_dist - <span class="number">0.7</span>);</span><br><span class="line">  </span><br><span class="line">    cfg_.robot.max_vel_x = pcl_vel;</span><br><span class="line">    <span class="keyword">if</span>(cfg_.robot.max_vel_x &lt; <span class="number">0.25</span>)</span><br><span class="line">        cfg_.robot.max_vel_x = <span class="number">0.25</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      cfg_.robot.max_vel_x = <span class="number">0.25</span>;</span><br><span class="line"></span><br><span class="line">  pcl_max_vel = cfg_.robot.max_vel_x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在离障碍&gt;1.4m时，最大速度约束遵从线性规律，如果直接改为0.25，会有稍微卡顿。最后把最大速度约束赋值给<code>pcl_max_vel</code><br><img src="https://i.loli.net/2021/06/08/ao6PfUDRsALWhvY.png" alt="2021-06-08_175446.png"></p>
<h2 id="最大线速度约束冲突的问题"><a href="#最大线速度约束冲突的问题" class="headerlink" title="最大线速度约束冲突的问题"></a>最大线速度约束冲突的问题</h2><p>但是回调函数<code>frontDistanceCB</code>也对<code>cfg_.robot.max_vel_x</code>做了修改，两次的最大速度约束可能不同，所以我们需要取较小值。</p>
<p>这就出现了一个线程同步的问题。两个回调函数是子线程，<code>computeVelocityCommands</code>函数是主线程，在其<code>plan</code>函数和<code>getVelocityCommand</code>函数之间，可能会运行了回调函数，但也可能未运行。</p>
<table><tr><td bgcolor=yellow> 在computeVelocityCommands函数内部， 我们要求 plan 函数之前和 getVelocityCommand 函数之前的 cfg_.robot.max_vel_x 应当是相同的 </td></tr></table>

<br>

<p>在没有加入低矮点云的时候，TEB日志如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">14</span>:<span class="number">12</span>:<span class="number">22.711</span>]: before plan, max vel:  <span class="number">1.236174</span></span><br><span class="line">[<span class="number">14</span>:<span class="number">12</span>:<span class="number">22.729</span>]: frontDistanceCB max_vel_x: <span class="number">1.232059</span></span><br><span class="line">[<span class="number">14</span>:<span class="number">12</span>:<span class="number">22.776</span>]: frontDistanceCB max_vel_x: <span class="number">1.226975</span></span><br><span class="line">[<span class="number">14</span>:<span class="number">12</span>:<span class="number">22.786</span>]: frontDistanceCB max_vel_x: <span class="number">1.223149</span></span><br><span class="line">[<span class="number">14</span>:<span class="number">12</span>:<span class="number">22.792</span>]: before getVelocityCommand, max vel:  <span class="number">1.223149</span></span><br><span class="line"></span><br><span class="line">[<span class="number">14</span>:<span class="number">12</span>:<span class="number">22.826</span> - INFO] (): before plan,  max vel:   <span class="number">1.211759</span></span><br><span class="line">[<span class="number">14</span>:<span class="number">12</span>:<span class="number">22.836</span> - INFO] (): before getVelocityCommand, max vel:  <span class="number">1.211759</span></span><br></pre></td></tr></table></figure>
<p>这就是既有程序的缺陷了，因为ROS的回调函数是事件驱动的，根据消息的接受顺序而运行。ROS的多线程跟线程库不同，目前没发现让多个线程按顺序运行的方法，只能暂时这样了，一般二者的差距也不大。</p>
<p>现在又加了一个回调函数<code>pclDistanceCb</code>，这下成了三个线程，更加不同步了</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># case 1: frontDistanceCB  成功更新最小值</span></span><br><span class="line">[15:51:07.195 - INFO] (): before plan, max vel: 0.749479</span><br><span class="line">[15:51:07.207 - INFO] (): pclDistanceCB max_vel_x: 1.200000</span><br><span class="line">[15:51:07.230 - INFO] (): frontDistanceCB max_vel_x: 0.753378</span><br><span class="line">[15:51:07.231 - INFO] (): frontDistanceCB max_vel_x: 0.751301</span><br><span class="line">[15:51:07.243 - INFO] (): before getVelocityCommand, max vel: 0.751301</span><br><span class="line"></span><br><span class="line"><span class="comment"># case 2: pclDistanceCB  未能成功更新最小值</span></span><br><span class="line">[15:51:07.717 - INFO] (): frontDistanceCB max_vel_x: 0.739510</span><br><span class="line">[15:51:07.718 - INFO] (): before plan, max vel: 0.739510</span><br><span class="line">[15:51:07.750 - INFO] (): frontDistanceCB max_vel_x: 0.726184</span><br><span class="line">[15:51:07.751 - INFO] (): pclDistanceCB max_vel_x: 0.25  <span class="comment"># 更小值</span></span><br><span class="line">[15:51:07.751 - INFO] (): frontDistanceCB max_vel_x: 0.725915</span><br><span class="line">[15:51:07.758 - INFO] (): before getVelocityCommand, max vel: 0.725915</span><br><span class="line"></span><br><span class="line"><span class="comment"># case 3: pclDistanceCB  成功更新最小值 0.3</span></span><br><span class="line">[15:51:08.209 - INFO] (): before plan, max vel: 0.25</span><br><span class="line">[15:51:08.246 - INFO] (): frontDistanceCB max_vel_x: 0.375000</span><br><span class="line">[15:51:08.287 - INFO] (): frontDistanceCB max_vel_x: 0.705724</span><br><span class="line">[15:51:08.314 - INFO] (): pclDistanceCB max_vel_x: 0.25</span><br><span class="line">[15:51:08.322 - INFO] (): before getVelocityCommand, max vel: 0.25</span><br><span class="line"></span><br><span class="line"><span class="comment"># case 4: 未扫描到点云</span></span><br><span class="line">[15:51:08.322 - INFO] (): before plan, max vel: 0.25</span><br><span class="line">[15:51:08.340 - INFO] (): frontDistanceCB max_vel_x: 0.702673</span><br><span class="line">[15:51:08.378 - INFO] (): frontDistanceCB max_vel_x: 0.714799</span><br><span class="line">[15:51:08.379 - INFO] (): before getVelocityCommand, max vel: 0.714799</span><br></pre></td></tr></table></figure>
<p>两个回调函数对最大线速度约束的修改，使机器人行走卡顿，速度不平滑。对于单机器人，可以将<code>frontDistanceCB</code>去掉。此时对低处障碍的避障成功率已经很高了:   <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=IJ6X5FW8N4w">视频</a></p>
<p>但是二者的冲突还是要解决，先考虑取两个修改值的最小值，也就是在<code>plan</code>函数之前要确定。问题转换为<font color = blue size=4>从两个回调函数(写同一个变量的两个线程)中取最小值，返回到主线程。 </font> 这里的难点是<code>pclDistanceCB</code>有时候不发布消息，最小值还是之前pclDistCb里的<code>max_vel_x</code>，没有更新为<code>frontDistanceCb</code>对应的<code>max_vel_x</code></p>
<h2 id="整合三个线程"><a href="#整合三个线程" class="headerlink" title="整合三个线程"></a>整合三个线程</h2><p>因为两个回调函数里都修改了<code>cfg_.robot.max_vel_x</code>，为了保险，取二者的较小值用于规划。这其实就是ROS线程同步，也就是回调函数和主函数通信的问题了，参考<a href="https://charon-cheung.github.io/2019/04/22/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%A6%82%E4%BD%95%E8%AE%A9%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%B8%8Emain%E5%87%BD%E6%95%B0%E4%BA%92%E7%9B%B8%E4%BC%A0%E5%80%BC/">回调函数和main函数互相传值</a>，要把两次修改的<code>cfg_.robot.max_vel_x</code>各自赋给新的成员变量，然后到主线程里比较二者大小。没有点云时，要使用<code>frontDistanceCB</code>传来的最大速度，所以还要对点云数据的size做判断。</p>
<p>上面说过，最大速度约束在<code>plan</code>函数和<code>getVelocityCommand</code>中使用，所以最终获得的最大速度约束在这两个地方应该相同。之前说过<code>frontDistanceCB</code>使得两次的值可能不同，但差距很小。现在是三个线程了，经过测试，发现两次max_vel_x的差距就可能大了:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before plan,  size:863,  max vel: 0.337497</span><br><span class="line">before getVelocityCommand, max vel: 1.250000</span><br></pre></td></tr></table></figure>

<p>这样就造成了机器人行走时的卡顿，最终主线程的代码要改成这样:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( pcl_size &gt; <span class="number">0</span> &amp;&amp; pcl_max_vel&gt;<span class="number">0</span>)</span><br><span class="line">    cfg_.robot.max_vel_x = ( front_max_vel &gt; pcl_max_vel) ? pcl_max_vel : front_max_vel ;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cfg_.robot.max_vel_x = front_max_vel;</span><br><span class="line"><span class="comment">// actual plan</span></span><br><span class="line"><span class="keyword">bool</span> success = planner_-&gt;<span class="built_in">plan</span>(transformed_plan, &amp;robot_vel_, cfg_.goal_tolerance.free_goal_vel);</span><br><span class="line">         <span class="comment">// ...... 省略</span></span><br><span class="line"><span class="keyword">if</span>( pcl_size &gt; <span class="number">0</span> &amp;&amp; pcl_max_vel&gt;<span class="number">0</span>)</span><br><span class="line">    cfg_.robot.max_vel_x = ( front_max_vel &gt; pcl_max_vel) ? pcl_max_vel : front_max_vel ;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cfg_.robot.max_vel_x = front_max_vel;</span><br><span class="line"><span class="comment">// Get the velocity command for this sampling interval</span></span><br><span class="line"><span class="keyword">if</span> (!planner_-&gt;<span class="built_in">getVelocityCommand</span>(......)</span><br></pre></td></tr></table></figure>

<p>开始<code>pcl_size</code>没有初始化为0，加上只比较了一次最小值，造成最大速度约束频繁赋值为1.25和0，机器人不停地卡顿，无法行走。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/12/11/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/17.%20%E5%8F%AF%E8%A7%86%E5%8C%96/">(十七) 可视化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/">TEB算法</a></span><div class="content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">planner_-&gt;<span class="built_in">visualize</span>();</span><br><span class="line">visualization_-&gt;<span class="built_in">publishObstacles</span>(obstacles_);</span><br><span class="line"><span class="comment">// 很简单，显示 via_point, 坐标来源是 via_points_</span></span><br><span class="line">visualization_-&gt;<span class="built_in">publishViaPoints</span>(via_points_);</span><br><span class="line"><span class="comment">// 很简单，实际调用的是 base_local_planner::publishPlan</span></span><br><span class="line">visualization_-&gt;<span class="built_in">publishGlobalPlan</span>(global_plan_);</span><br></pre></td></tr></table></figure>

<h2 id="TebOptimalPlanner-visualize"><a href="#TebOptimalPlanner-visualize" class="headerlink" title="TebOptimalPlanner::visualize"></a>TebOptimalPlanner::visualize</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TebOptimalPlanner::visualize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!visualization_)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">  visualization_-&gt;<span class="built_in">publishLocalPlanAndPoses</span>(teb_);</span><br><span class="line">  <span class="keyword">if</span> (teb_.<span class="built_in">sizePoses</span>() &gt; <span class="number">0</span>)</span><br><span class="line">      visualization_-&gt;<span class="built_in">publishRobotFootprintModel</span>(teb_.<span class="built_in">Pose</span>(<span class="number">0</span>), *robot_model_);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (cfg_-&gt;trajectory.publish_feedback)</span><br><span class="line">      visualization_-&gt;<span class="built_in">publishFeedbackMessage</span>(*<span class="keyword">this</span>, *obstacles_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后部分是发布feedback消息 (single trajectory overload)，话题<code>teb_feedback</code>. 需要设置<code>publish_feedback</code>为true，默认为false</p>
<p><code>feedback message</code>包括规划的轨迹，速度和时间信息(temporal information)，也包括 active obstacles</p>
<p><code>publishLocalPlanAndPoses</code>很简单，需要注意的是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不明白z为什么这样赋值 ???</span></span><br><span class="line">pose.pose.position.z = cfg_-&gt;hcp.visualize_with_time_as_z_axis_scale *</span><br><span class="line">    teb.<span class="built_in">getSumOfTimeDiffsUpToIdx</span>(i);</span><br><span class="line"><span class="comment">// getSumOfTimeDiffsUpToIdx 就是从起点到当前位姿i的所有deltaT的总和</span></span><br></pre></td></tr></table></figure>

<p><code>publishRobotFootprintModel</code>也很简单，机器人在局部路径第一个点的时候，可视化轮廓，就是一些对<code>visualization_msgs::Marker</code>的操作。不过对不同的轮廓类型，调用的函数不同</p>
<h3 id="publishFeedbackMessage"><a href="#publishFeedbackMessage" class="headerlink" title="publishFeedbackMessage"></a>publishFeedbackMessage</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TebVisualization::publishFeedbackMessage</span><span class="params">(<span class="keyword">const</span> TebOptimalPlanner&amp; teb_planner, <span class="keyword">const</span> ObstContainer&amp; obstacles)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FeedbackMsg msg;</span><br><span class="line">  msg.header.stamp = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">  msg.header.frame_id = cfg_-&gt;map_frame;</span><br><span class="line">  msg.selected_trajectory_idx = <span class="number">0</span>;</span><br><span class="line">  msg.trajectories.<span class="built_in">resize</span>(<span class="number">1</span>);</span><br><span class="line">  msg.trajectories.<span class="built_in">front</span>().header = msg.header;</span><br><span class="line"></span><br><span class="line">  teb_planner.<span class="built_in">getFullTrajectory</span>(msg.trajectories.<span class="built_in">front</span>().trajectory);</span><br><span class="line">  <span class="comment">// add obstacles</span></span><br><span class="line">  msg.obstacles_msg.obstacles.<span class="built_in">resize</span>(obstacles.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (std::<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;obstacles.<span class="built_in">size</span>(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    msg.obstacles_msg.header = msg.header;</span><br><span class="line">    <span class="comment">// copy polygon</span></span><br><span class="line">    msg.obstacles_msg.obstacles[i].header = msg.header;</span><br><span class="line">    obstacles[i]-&gt;<span class="built_in">toPolygonMsg</span>(msg.obstacles_msg.obstacles[i].polygon);</span><br><span class="line">    <span class="comment">// copy id</span></span><br><span class="line">    msg.obstacles_msg.obstacles[i].id = i; <span class="comment">// <span class="doctag">TODO:</span> we do not have any id stored yet</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// orientation</span></span><br><span class="line">    <span class="comment">//msg.obstacles_msg.obstacles[i].orientation =; // TODO</span></span><br><span class="line">    <span class="comment">// copy velocities</span></span><br><span class="line">    obstacles[i]-&gt;<span class="built_in">toTwistWithCovarianceMsg</span>(msg.obstacles_msg.obstacles[i].velocities);</span><br><span class="line">  &#125;</span><br><span class="line">  feedback_pub_.<span class="built_in">publish</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="publishObstacles"><a href="#publishObstacles" class="headerlink" title="publishObstacles"></a>publishObstacles</h2><p>这里需要注意的是点障碍的可视化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">visualization_msgs::Marker marker;</span><br><span class="line">marker.header.frame_id = cfg_-&gt;map_frame;</span><br><span class="line">marker.header.stamp = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">marker.ns = <span class="string">&quot;PointObstacles&quot;</span>;     marker.id = <span class="number">0</span>;</span><br><span class="line">marker.type = visualization_msgs::Marker::POINTS;</span><br><span class="line">marker.action = visualization_msgs::Marker::ADD;</span><br><span class="line">marker.lifetime = ros::<span class="built_in">Duration</span>(<span class="number">2.0</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (ObstContainer::const_iterator obst = obstacles.<span class="built_in">begin</span>(); obst != obstacles.<span class="built_in">end</span>(); ++obst)</span><br><span class="line">&#123;</span><br><span class="line">  boost::shared_ptr&lt;PointObstacle&gt; pobst = boost::dynamic_pointer_cast&lt;PointObstacle&gt;(*obst);      </span><br><span class="line">  <span class="keyword">if</span> (!pobst) 		<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cfg_-&gt;hcp.visualize_with_time_as_z_axis_scale &lt; <span class="number">0.001</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    geometry_msgs::Point point;</span><br><span class="line">    point.x = pobst-&gt;<span class="built_in">x</span>();</span><br><span class="line">    point.y = pobst-&gt;<span class="built_in">y</span>();</span><br><span class="line">    point.z = <span class="number">0</span>;</span><br><span class="line">    marker.points.<span class="built_in">push_back</span>(point);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">// Spatiotemporally point obstacles become a line</span></span><br><span class="line">  &#123;</span><br><span class="line">    marker.type = visualization_msgs::Marker::LINE_LIST;</span><br><span class="line">    geometry_msgs::Point start;</span><br><span class="line">    start.x = pobst-&gt;<span class="built_in">x</span>();   start.y = pobst-&gt;<span class="built_in">y</span>();</span><br><span class="line">    start.z = <span class="number">0</span>;</span><br><span class="line">    marker.points.<span class="built_in">push_back</span>(start);</span><br><span class="line"></span><br><span class="line">    geometry_msgs::Point end;</span><br><span class="line">    <span class="keyword">double</span> t = <span class="number">20</span>;</span><br><span class="line">    Eigen::Vector2d pred;</span><br><span class="line">    pobst-&gt;<span class="built_in">predictCentroidConstantVelocity</span>(t, pred);</span><br><span class="line">    end.x = pred[<span class="number">0</span>];</span><br><span class="line">    end.y = pred[<span class="number">1</span>];</span><br><span class="line">    end.z = cfg_-&gt;hcp.visualize_with_time_as_z_axis_scale * t;</span><br><span class="line">    marker.points.<span class="built_in">push_back</span>(end);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略 marker的着色</span></span><br><span class="line">teb_marker_pub_.<span class="built_in">publish</span>( marker );</span><br></pre></td></tr></table></figure>



<h2 id="HomotopyClassPlanner-visualize"><a href="#HomotopyClassPlanner-visualize" class="headerlink" title="HomotopyClassPlanner::visualize"></a>HomotopyClassPlanner::visualize</h2><p><code>visualization_</code>的赋值在<code>HomotopyClassPlanner::initialize</code> 最后的 <code>setVisualization(visual);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (visualization_)</span><br><span class="line">&#123;</span><br><span class="line">  		<span class="comment">// Visualize graph</span></span><br><span class="line">  	<span class="keyword">if</span> (cfg_-&gt;hcp.visualize_hc_graph &amp;&amp; graph_search_)</span><br><span class="line">    		visualization_-&gt;<span class="built_in">publishGraph</span>(graph_search_-&gt;graph_);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Visualize active tebs as marker</span></span><br><span class="line">   visualization_-&gt;<span class="built_in">publishTebContainer</span>(tebs_);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Visualize best teb and feedback message if desired</span></span><br><span class="line">   TebOptimalPlannerConstPtr best_teb = <span class="built_in">bestTeb</span>();</span><br><span class="line">   <span class="keyword">if</span> (best_teb)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 只发布best_teb的局部路径，类型是nav_msgs::Path 和 geometry_msgs::PoseArray</span></span><br><span class="line">   	<span class="comment">// 对应话题 local_plan 和 teb_poses</span></span><br><span class="line">     <span class="comment">// 位姿点的z = cfg_-&gt;hcp.visualize_with_time_as_z_axis_scale * </span></span><br><span class="line">   	<span class="comment">// teb.getSumOfTimeDiffsUpToIdx(i)</span></span><br><span class="line"></span><br><span class="line">     visualization_-&gt;<span class="built_in">publishLocalPlanAndPoses</span>(best_teb-&gt;<span class="built_in">teb</span>() );</span><br><span class="line">     <span class="keyword">if</span> (best_teb-&gt;<span class="built_in">teb</span>().<span class="built_in">sizePoses</span>() &gt; <span class="number">0</span>)   <span class="comment">// 路径的位姿点个数</span></span><br><span class="line">         visualization_-&gt;<span class="built_in">publishRobotFootprintModel</span>(best_teb-&gt;<span class="built_in">teb</span>().<span class="built_in">Pose</span>(<span class="number">0</span>), *robot_model_);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (cfg_-&gt;trajectory.publish_feedback)  <span class="comment">// feedback message</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">int</span> best_idx = <span class="built_in">bestTebIdx</span>();</span><br><span class="line">       <span class="keyword">if</span> (best_idx&gt;=<span class="number">0</span>)</span><br><span class="line">           visualization_-&gt;<span class="built_in">publishFeedbackMessage</span>(tebs_, </span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">int</span>) best_idx,  *obstacles_  );</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">ROS_DEBUG</span>(<span class="string">&quot;Ignoring HomotopyClassPlanner::visualize() call, since no visualization class was instantiated before.&quot;</span>);</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/12/09/PCL%E7%82%B9%E4%BA%91/ROS%E4%B8%AD%E7%9A%84%E7%82%B9%E4%BA%91%E6%B6%88%E6%81%AF%E5%92%8C%E8%A7%A3%E6%9E%90/">点云消息的解析和转换</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/PCL%E7%82%B9%E4%BA%91/">PCL点云</a></span><div class="content"><p><code>sensor_msgs/PointCloud2</code>类型如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># N维的点云，点的数据以二进制blob形式保存，其layout用fields数组描述</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The point cloud data may be organized 2d (image-like) or 1d</span></span><br><span class="line"><span class="comment"># (unordered). Point clouds organized as 2d images may be produced by</span></span><br><span class="line"><span class="comment"># camera depth sensors such as stereo or time-of-flight.</span></span><br><span class="line"></span><br><span class="line">Header header</span><br><span class="line"></span><br><span class="line">点云的2D结构，如果点云无序，height是1，width就是点云的length</span><br><span class="line">uint32 height</span><br><span class="line">uint32 width</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用二进制数据blob的形式，描述channels 及其layout</span></span><br><span class="line">PointField[] fields</span><br><span class="line"></span><br><span class="line">bool    is_bigendian</span><br><span class="line">uint32  point_step   <span class="comment"># Length of a point in bytes</span></span><br><span class="line">uint32  row_step     <span class="comment"># Length of a row in bytes</span></span><br><span class="line">uint8[]   data       <span class="comment"># 点的数据，size = row_step * height</span></span><br><span class="line">bool is_dense        <span class="comment"># True if there are no invalid points</span></span><br></pre></td></tr></table></figure>
<p>PointCloud2的data是序列化后的数据，直接看不到物理意义。只能转为点云1类型</p>
<p><code>sensor_msgs/PointCloud</code>类型如下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Header header</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在header坐标系中的3D点云</span></span><br><span class="line">geometry_msgs/Point32[]  points</span><br><span class="line"></span><br><span class="line"><span class="comment"># Each channel should have the same number of elements as points array,</span></span><br><span class="line"><span class="comment"># and the data in each channel should correspond 1:1 with each point.</span></span><br><span class="line"><span class="comment"># Channel names in common practice are listed in ChannelFloat32.msg.</span></span><br><span class="line">ChannelFloat32[] channels</span><br></pre></td></tr></table></figure>
<p>坐标系和点云的位置关系如下，我们感兴趣的是z，也就是相机坐标系到点云的距离</p>
<p>从<code>sensor_msgs::PointCloud2</code>类型转为<code>sensor_msgs::PointCloud</code>，而且获知坐标</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sensor_msgs/PointCloud.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sensor_msgs/PointCloud2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sensor_msgs/point_cloud_conversion.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sensor_msgs::PointCloud2 in_pcl;</span><br><span class="line">sensor_msgs::PointCloud out_pcl;</span><br><span class="line">sensor_msgs::<span class="built_in">convertPointCloud2ToPointCloud</span>(in_pcl, out_pcl);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; out_pcl.points.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;out_pcl x: %f, y: %f, z: %f&quot;</span>, </span><br><span class="line">          out_pcl.points[i].x, out_pcl.points[i].y, out_pcl.points[i].z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="几种点云类型的转换"><a href="#几种点云类型的转换" class="headerlink" title="几种点云类型的转换"></a>几种点云类型的转换</h2><p>点云格式主要有四种，<code>sensor_msgs::PointCloud</code>已经弃用</p>
<ul>
<li><p>sensor_msgs::PointCloud</p>
</li>
<li><p>sensor_msgs::PointCloud2</p>
</li>
<li><p>pcl::PCLPointCloud2 — PCL data structure mostly for compatibility with ROS (I think)</p>
</li>
<li><p>pcl::PointCloud<T> — standard PCL data structure </p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/12/23/SXuTcHoWa4gwQNA.png" alt="相互转换关系"><br><code>find_package</code>里添加<code>sensor_msgs</code>, <code>pcl_ros</code>, <code>pcl_conversions</code></p>
<h3 id="PointCloud2-和-PointCloud的转换"><a href="#PointCloud2-和-PointCloud的转换" class="headerlink" title="PointCloud2 和 PointCloud的转换"></a>PointCloud2 和 PointCloud的转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sensor_msgs::PointCloud out_pcl;</span><br><span class="line">sensor_msgs::<span class="built_in">convertPointCloud2ToPointCloud</span>(*pcl_dist_msg, out_pcl);</span><br></pre></td></tr></table></figure>
<p>反过来就用<code>sensor_msgs::convertPointCloudToPointCloud2</code></p>
<h3 id="PointCloud2-转-pcl-PCLPointCloud2"><a href="#PointCloud2-转-pcl-PCLPointCloud2" class="headerlink" title="PointCloud2 转 pcl::PCLPointCloud2"></a>PointCloud2 转 pcl::PCLPointCloud2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sensor_msgs::PointCloud2 cloud;</span><br><span class="line">pcl::PCLPointCloud2  pcl_pc2;</span><br><span class="line"></span><br><span class="line">pcl_conversions::<span class="built_in">toPCL</span>(cloud, pcl_pc2</span><br></pre></td></tr></table></figure>

<h3 id="pcl-PCLPointCloud2-转-pcl-PointCloud-lt-pcl-PointXYZ-gt"><a href="#pcl-PCLPointCloud2-转-pcl-PointCloud-lt-pcl-PointXYZ-gt" class="headerlink" title="pcl::PCLPointCloud2 转 pcl::PointCloud &lt; pcl::PointXYZ &gt;"></a>pcl::PCLPointCloud2 转 pcl::PointCloud &lt; pcl::PointXYZ &gt;</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pcl::PCLPointCloud2  pcl_pc2;</span><br><span class="line">pcl::PointCloud &lt; pcl::PointXYZ &gt;  pcl_cloud;</span><br><span class="line"></span><br><span class="line">pcl::<span class="built_in">fromPCLPointCloud2</span>(pcl_pc2, pcl_cloud);</span><br></pre></td></tr></table></figure>

<h3 id="pcl-PointCloud-lt-pcl-PointXYZ-gt-转-sensor-msgs-PointCloud2"><a href="#pcl-PointCloud-lt-pcl-PointXYZ-gt-转-sensor-msgs-PointCloud2" class="headerlink" title="pcl::PointCloud &lt; pcl::PointXYZ &gt; 转 sensor_msgs::PointCloud2"></a>pcl::PointCloud &lt; pcl::PointXYZ &gt; 转 sensor_msgs::PointCloud2</h3><p><code>pcl::toROSMsg(*cloud, output);</code></p>
<p>反过来就是<code>fromROSMsg(const sensor_msgs::PointCloud2 &amp;, pcl::PointCloud&lt;T&gt;&amp;)</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/12/08/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/%E8%86%A8%E8%83%80%E5%B1%82%20/">膨胀层</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content"><p>膨胀层用于执行每个cell的障碍物膨胀</p>
<ul>
<li>inflation_radius (double, default: 0.55) 障碍物在地图中向外扩展的膨胀区的半径</li>
<li>cost_scaling_factor (double, default: 10.0) 膨胀过程中应用到代价值的比例因子。这个值越大，代价衰减越严重</li>
</ul>
<p><img src="https://i.loli.net/2020/05/13/zEXgNALkVBIiD7r.png" alt="膨胀层加载过程.png"><br>膨胀层所用的参数：<a target="_blank" rel="noopener" href="http://wiki.ros.org/costmap_2d/hydro/inflation">inflation params</a></p>
<p>可以修改膨胀层代码 <code>inflation_layer.h</code>， 添加函数<code>double  getInflationRadius() const</code> 和 <code>double   getInscribedRadius() const</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/12/04/Linux%E5%9F%BA%E7%A1%80/ldd%E5%92%8Cldconfig%E5%91%BD%E4%BB%A4/">ldd和ldconfig命令</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux%E5%9F%BA%E7%A1%80/">Linux基础</a></span><div class="content"><h2 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a>ldd</h2><p>命令的作用是打印共享库的依赖关系</p>
<ol>
<li><p>ldd不是一个可执行程序，而只是一个shell脚本。ldd能够显示可执行模块的 dependency，其原理是通过设置一系列的环境变量，如下：LD_TRACE_LOADED_OBJECTS、LD_WARN、LD_BIND_NOW、LD_LIBRARY_VERSION、 LD_VERBOSE等。</p>
</li>
<li><p>ldd的工作原理，其实质是通过ld-linux.so（elf动态库的装载器）来实现的。<code>ld-linux.so</code>模块会先于<code>executable</code>模块程序工作，并获得控制权，因此当上述的那些环境变量被设置时，ld-linux.so选择了显示可执行模块的dependency。<br>实际上可以直接执行ld-linux.so模块，如：<code>/lib/ld-linux.so.2 --list program</code>（这相当于ldd program）</p>
</li>
</ol>
<h2 id="ldconfig"><a href="#ldconfig" class="headerlink" title="ldconfig"></a>ldconfig</h2><p>有时装完某个库后，需要使用命令<code>sudo ldconfig -v</code>，否则在程序运行后会出现找不到动态库的问题: <font size =4 color = orange> error while loading shared libraries: liblog4cpp.so.5: cannot open shared object file: No such file or directory </font></p>
<p>ldconfig是一个动态链接库管理命令，为了让动态链接库为系统所共享,还需运行动态链接库的管理命令</p>
<p><code>ldconfig</code>通常在系统启动时运行,而当用户安装了一个新的动态链接库时,就需要手工运行这个命令.主要是在默认搜寻目录(/lib和/usr/lib)以及动态库配置文件/etc/ld.so.conf内所列的目录下,搜索出可共享的动态链接库(格式如前介绍,lib*.so*),进而创建出动态装入程序(ld.so)所需的连接和缓存文件.  ldconfig与运行程序时有关，跟编译时一点关系都没有。不管做了什么关于library的变动后，最好都ldconfig一下，不然会出现一些意想不到的结果。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/12/04/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%9F%BA%E4%BA%8Erealsense%E6%89%AB%E6%8F%8F%E7%82%B9%E4%BA%91%E7%9A%84%E4%BD%8E%E7%9F%AE%E9%81%BF%E9%9A%9C/1.%20%E5%88%9D%E6%AD%A5%E9%85%8D%E7%BD%AE%E5%92%8C%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/">(一) 初步配置和发现的问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%9F%BA%E4%BA%8Erealsense%E6%89%AB%E6%8F%8F%E7%82%B9%E4%BA%91%E7%9A%84%E4%BD%8E%E7%9F%AE%E9%81%BF%E9%9A%9C/">基于realsense扫描点云的低矮避障</a></span><div class="content"><p>为了能扫描到低处的障碍，相机的安装也是个问题，realsense435与地面呈一定角度，也就是相机需要低着头，这跟相机的FOV有关，FOV当然是越大越好。在机器人静止状态下，根据rviz中的原始点云情况调试。如果低头太多，等看到低处障碍时，车已经离得太近，躲避不开；如果低头少或者相机平视前方，车近处的障碍看不到，无法避障。</p>
<p>realsense需要加滤波片，其他相机不清楚<br><img src="https://i.loli.net/2021/06/08/fQJGilwkKbeqTPg.png" alt="原始点云的扫描情况"></p>
<p><img src="https://i.loli.net/2021/06/08/eD9oLa21vK8MhOI.png" alt="机器人, 相机坐标系和障碍.png"></p>
<p><img src="https://i.loli.net/2020/12/23/L8HBIJea2sgFhvE.png" alt="相机坐标系和点云的关系"></p>
<h2 id="代价地图的配置"><a href="#代价地图的配置" class="headerlink" title="代价地图的配置"></a>代价地图的配置</h2><p>通用代价地图的障碍层需要这样设置</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">obstacles:</span><br><span class="line"> enabled: <span class="literal">true</span></span><br><span class="line"> obstacle_range: 2.0</span><br><span class="line"> raytrace_range: 5.0</span><br><span class="line"> track_unknown_space: <span class="literal">true</span></span><br><span class="line"> combination_method: 1</span><br><span class="line"> <span class="comment"># 传感器种类, data_type只能是 LaserScan  PointCloud  PointCloud2</span></span><br><span class="line"> observation_sources: laser_scan_sensor  pointcloud2_sensor</span><br><span class="line"> laser_scan_sensor: </span><br><span class="line">    data_type: LaserScan</span><br><span class="line">    topic: /scan</span><br><span class="line">    marking: <span class="literal">true</span></span><br><span class="line">    clearing: <span class="literal">true</span></span><br><span class="line">    max_obstacle_height: 1.0</span><br><span class="line">    min_obstacle_height: -1.0</span><br><span class="line"></span><br><span class="line"> pointcloud2_sensor:</span><br><span class="line">    topic:          /obstacles_cloud</span><br><span class="line">    data_type:      PointCloud2</span><br><span class="line">    sensor_frame:   <span class="string">&quot;camera_depth_optical_frame&quot;</span></span><br><span class="line">    obstacle_range: 5.0</span><br><span class="line">    raytrace_range: 5.0</span><br><span class="line">    observation_persistence: 20.0</span><br><span class="line">    marking:        <span class="literal">true</span></span><br><span class="line">    clearing:       <span class="literal">true</span> </span><br><span class="line">    min_obstacle_height: -1.0</span><br><span class="line">    max_obstacle_height: 1.0</span><br></pre></td></tr></table></figure>

<p>如果雷达和相机扫描到同一个障碍物，代价地图里不会膨胀两次，这就是<code>combination_method</code>的作用，配置中为1，取的是较大值，源码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObstacleLayer::updateCosts</span><span class="params">(costmap_2d::Costmap2D&amp; master_grid, </span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> min_i, <span class="keyword">int</span> min_j, <span class="keyword">int</span> max_i, <span class="keyword">int</span> max_j )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!enabled_)   <span class="keyword">return</span>;</span><br><span class="line">     <span class="comment">// 参数 footprint_clearing_enabled</span></span><br><span class="line">  <span class="keyword">if</span> (footprint_clearing_enabled_)</span><br><span class="line">  	<span class="comment">// 获得机器人轮廓内的cells，然后赋值为 costmap_2d::FREE_SPACE</span></span><br><span class="line">    <span class="built_in">setConvexPolygonCost</span>(transformed_footprint_, costmap_2d::FREE_SPACE);</span><br><span class="line">    <span class="comment">// 选择参数值</span></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (combination_method_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">// Overwrite</span></span><br><span class="line">      <span class="built_in">updateWithOverwrite</span>(master_grid, min_i, min_j, max_i, max_j);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">// Maximum</span></span><br><span class="line">      <span class="built_in">updateWithMax</span>(master_grid, min_i, min_j, max_i, max_j);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:  <span class="comment">// Nothing</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数在<code>LayeredCostmap::updateMap</code>里调用</p>
<p><font color = blue size=4>注意: </font> 点云障碍作为PointCloud2类型加入代价地图时，点云程序必须给发布的点云消息加时间戳，时间戳也要更新，否则无法成功加入到代价地图，也就是点云的障碍在代价地图里没有膨胀</p>
<h2 id="外参标定"><a href="#外参标定" class="headerlink" title="外参标定"></a>外参标定</h2><p><strong>这里只是粗糙标定</strong></p>
<p>因为相机和雷达有tf关系，realsense生成的点云和雷达生成的scan开始是没有对齐的，比如机器人面对墙壁时，scan是紧贴墙壁的，但点云距离墙有一点距离<br><img src="https://i.loli.net/2021/06/08/h7SZ8csf3kdierV.png" alt="2021-06-08_101907.png"></p>
<p>如果雷达扫描出错，点云也会跟着出错，结果出现很多不应存在的障碍<br><img src="https://i.loli.net/2021/06/08/T34hGDneAbHq6rW.png" alt="2021-06-08_101916.png"></p>
<p><img src="https://i.loli.net/2021/06/08/W2jkeTLJCYRKdP3.png" alt="2021-06-08_101852.png"></p>
<p>tf体系中，<code>base_link</code>是parent，<code>laser_link</code>和<code>camera_link</code>都是child，二者的关系不能直接修改。    我们需要修改的是<code>tf.launch</code>中的<code>base_link</code>和<code>camera_link</code>的关系。所有的机器人都要更新<code>tf.launch</code>，最好确定一下是否每台的参数都一样</p>
<p>在上面的墙壁扫描结果中，经过rviz中的测量，相机的点云和雷达点云在z方向差0.2米。对齐之后，扫描结果正常，导航效果明显提高</p>
<h2 id="初步调整参数"><a href="#初步调整参数" class="headerlink" title="初步调整参数"></a>初步调整参数</h2><p>测试发现越低的障碍越容易碰撞，等时间达到 <code>observation_persistence</code> 会从代价地图清除所有障碍</p>
<p>机器人的速度比较快，由于规划频率、代价地图更新频率、加速度约束、CostmapConverter频率等等因素，很难及时停下，采取以下措施:</p>
<ul>
<li>降低膨胀半径为 0.9</li>
<li>增大costmap_converter_rate 为 8</li>
<li>增大局部地图的更新和发布频率 <code>update_frequency</code>  和  <code>publish_frequency</code></li>
<li>增大全局地图的更新和发布频率 <code>update_frequency</code>  和  <code>publish_frequency</code></li>
</ul>
<p>一帧一帧观察导航的过程，发现点云的识别和加入代价地图并不慢，但是<font color = blue size=4>局部和全局路径的规划较慢 ，从代价地图生成点云障碍到改变全局路径，车已经走了至少0.5米，局部路径就更滞后了。</font> 因此适当加大全局和局部路径的规划频率。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">base_global_planner: <span class="string">&quot;global_planner/GlobalPlanner&quot;</span></span><br><span class="line">planner_frequency: 5.0    <span class="comment"># 之前是 0.05 </span></span><br><span class="line">planner_patience: 2.0</span><br></pre></td></tr></table></figure>

<table><tr><td bgcolor=yellow> 以上加大频率的做法都会加大CPU占用 </td></tr></table>


<h2 id="导航的问题"><a href="#导航的问题" class="headerlink" title="导航的问题"></a>导航的问题</h2><ul>
<li><p>从远处快速接近低处障碍时，小车不能停下来</p>
</li>
<li><p>初步优化后，在通道内，小车仍然以慢速行走</p>
</li>
<li><p>对于通道内的低处障碍，经常避障失败</p>
</li>
<li><p>避障时的速度波动，使小车卡顿</p>
</li>
</ul>
<h3 id="原因和可能的优化"><a href="#原因和可能的优化" class="headerlink" title="原因和可能的优化"></a>原因和可能的优化</h3><ul>
<li><p>相机扫描到点云的最大距离约1.8m，不利于及时刹车。在小车速度很快时，甚至扫描不到障碍</p>
</li>
<li><p>比较罕见的情况：相机FOV小，当小车快速接近障碍时，没有产生点云，一般是从障碍旁边走过。最好换一个视野和扫描距离更大的相机</p>
</li>
<li><p>对低矮避障时，局部路径明显偏离全局路径，问题在全局路径的转换和<code>Homoplanner</code>的选择</p>
</li>
<li><p>CPU性能不足</p>
</li>
<li><p>比较罕见的情况： <code>costmap_converter</code>有时不能及时转换出障碍，结果TEB不认为代价地图中的点云是障碍；有时又把代价地图中的点云障碍转换得更大</p>
</li>
</ul>
<h2 id="点云的问题"><a href="#点云的问题" class="headerlink" title="点云的问题"></a>点云的问题</h2><p>点云程序的误检测，或者因为雷达出错而造成的不存在的障碍</p>
<ul>
<li>点云不稳定，来回摇晃，经过的地方都在代价地图中形成了障碍，结果障碍太大使导航失败</li>
</ul>
<p><img src="https://i.loli.net/2021/06/08/wSV3dPMmKOoktGT.gif" alt="点云抖动.gif"><br><img src="https://i.loli.net/2021/01/12/QUZnRPGXHlMeVCo.png" alt="1"></p>
<p><img src="https://i.loli.net/2021/01/12/8I5jJ1DzG2BQSKn.png" alt="2"></p>
<ul>
<li>在阳光下严重误检测，产生大量不存在的障碍</li>
</ul>
<p><img src="https://i.loli.net/2021/06/08/7YXTHKUge2bOiWr.gif" alt="阳光.gif"></p>
<ul>
<li>没有经过shadow filter，使点云阴影形成障碍</li>
</ul>
<p><img src="https://i.loli.net/2020/12/21/XKURAlhe3uEvQDC.png" alt="点云影子产生障碍 1"></p>
<p><img src="https://i.loli.net/2020/12/21/pj16sirAZumzvDO.png" alt="点云影子产生障碍 2"></p>
<ul>
<li>其他不应存在的障碍</li>
</ul>
<p>多台车每次到这里都会发现这个障碍，但是看现实环境又什么都没有<br><img src="https://i.loli.net/2021/02/19/YkEb28QDmXJzUjN.png" alt="每次都出现的不明障碍.png"><br><img src="https://i.loli.net/2021/02/19/Uv7N8bZPsBkCSGp.png" alt="原始点云.png"><br>看来原始点云就有，还是需要处理，可以用滤波，在原始launch中 <code>&lt;arg name=&quot;filters&quot;    value=&quot;decimation&quot;  /&gt;</code></p>
<p>还有这种，好像是雷达运动畸变导致的点云也出错，也可能是点云本身问题<br><img src="https://i.loli.net/2021/06/08/JsIRxZ4qKpjUYBD.gif" alt="大量不应存在的点云"></p>
<p>点云出现在墙另一边<br><img src="https://i.loli.net/2020/12/14/TUoFJ693pj4qDSZ.png"></p>
<ul>
<li>点云障碍无法自动请除</li>
</ul>
<p>虽然在yaml里设置了<code>observation_persistence</code>，但发现代价地图里的点云障碍会长时间保留，早已超过了配置的值<br><img src="https://i.loli.net/2020/12/18/cg5yEqoRZuPX31H.png" alt="之前的点云障碍不会自动清除"><br>雷达导航没有这个现象，因为雷达扫描的范围很大，马上就清除了。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/12/03/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%A4%A7%E8%BD%AE%E5%BB%93%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%AF%BC%E8%88%AA/(%E4%BA%94)%20%E5%AF%BC%E8%88%AA%E7%9A%84%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98/">(五) 导航的其他问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%A4%A7%E8%BD%AE%E5%BB%93%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%AF%BC%E8%88%AA/">大轮廓机器人的导航</a></span><div class="content"><h2 id="尾部撞障碍"><a href="#尾部撞障碍" class="headerlink" title="尾部撞障碍"></a>尾部撞障碍</h2><p><img src="https://i.loli.net/2020/11/30/8D6iYKqEWo3QCGJ.png" alt="尾部潜在的碰撞.png"><br>车的局部路径明显偏离全局路径，其实是目标点太贴近障碍了，如果按全局路径，尾部就会撞。即使按局部路径，走了一点后还是可能撞，但是<code>isFeasible</code>判断的路径点不够多，所以不会报警。  这其实是全局路径规划的不好</p>
<h2 id="禁止后，导致局部路径需要后退时动不了"><a href="#禁止后，导致局部路径需要后退时动不了" class="headerlink" title="禁止后，导致局部路径需要后退时动不了"></a>禁止后，导致局部路径需要后退时动不了</h2><p><img src="https://i.loli.net/2020/11/30/CBGmwdihu7leQVo.png" alt="无法后退1.png"><br><img src="https://i.loli.net/2020/11/30/T6Nf3R4OeYZGU1g.png" alt="无法后退2.png"></p>
<h2 id="路径点杂乱"><a href="#路径点杂乱" class="headerlink" title="路径点杂乱"></a>路径点杂乱</h2><p>这个很难复现<br><img src="https://i.loli.net/2020/11/30/dDxbKJmkIPoaNZQ.png" alt="路径点杂乱.png"><br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=ETORdzBcT0w">video</a></p>
<p><code>HomotopyClassPlanner::plan</code>中的最后部分修改如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TebOptimalPlannerPtr best_teb_ptr = <span class="built_in">selectBestTeb</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(best_teb_ptr-&gt;<span class="built_in">teb</span>().<span class="built_in">sizePoses</span>()&gt;<span class="number">40</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>结果发现有时有效，有时到终点附近会move_base的<code>gotPlan</code>一直失败，一直到恢复行为然后Abort，最后停的位置和终点已经很接近，但<code>gotPlan</code>却规划不出来。看来这么修改还是太浅了。</p>
<h2 id="恢复行为时仍在行走"><a href="#恢复行为时仍在行走" class="headerlink" title="恢复行为时仍在行走"></a>恢复行为时仍在行走</h2><p>一个典型的日志:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[10:59:26.877] (): Received move_base goal (x: 1.533, y: 4.569, yaw deg: -177, yaw rad: -3.10)</span><br><span class="line">[10:59:44.914 - WARN] (): Robot <span class="keyword">in</span> controlling, but can<span class="string">&#x27;t get new global plan</span></span><br><span class="line"><span class="string">[10:59:44.991] (): move_base_recovery,state machine is CLEARING, Executing behavior 0 of 2</span></span><br><span class="line"><span class="string">[10:59:47.024 - WARN] (): two valid global plan time gap is too long: 0.032124</span></span><br><span class="line"><span class="string">[10:59:47.057] (): move_base_recovery,state machine is CLEARING, Executing behavior 1 of 2</span></span><br><span class="line"><span class="string">[10:59:49.079 - WARN] (): two valid global plan time gap is too long: 0.018764</span></span><br><span class="line"><span class="string">[10:59:49.091 - ERROR] (): Aborting because a valid plan could not be found. Even after executing all recovery behaviors</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[11:02:20.791] (): Received move_base goal (x: 2.740, y: 4.620, yaw deg: -179, yaw rad: -3.14)</span></span><br><span class="line"><span class="string">[11:02:22.799 - WARN] (): Robot in controlling, but can&#x27;</span>t get new global plan</span><br><span class="line">[11:02:22.833] (): move_base_recovery,state machine is CLEARING, Executing behavior 0 of 2</span><br><span class="line">[11:02:24.970 - WARN] (): Robot <span class="keyword">in</span> controlling, but can<span class="string">&#x27;t get new global plan</span></span><br><span class="line"><span class="string">[11:02:25.015] (): move_base_recovery,state machine is CLEARING, Executing behavior 0 of 2</span></span><br><span class="line"><span class="string">[11:02:28.076 - WARN] (): Robot in controlling, but can&#x27;</span>t get new global plan</span><br><span class="line">[11:02:28.089] (): move_base_recovery,state machine is CLEARING, Executing behavior 0 of 2</span><br><span class="line">[11:02:30.123 - WARN] (): two valid global plan time gap is too long: 0.032326</span><br><span class="line">[11:02:30.156] (): move_base_recovery,state machine is CLEARING, Executing behavior 1 of 2</span><br><span class="line">[11:02:32.671 - WARN] (): Robot <span class="keyword">in</span> controlling, but can<span class="string">&#x27;t get new global plan</span></span><br><span class="line"><span class="string">[11:02:32.694] (): move_base_recovery,state machine is CLEARING, Executing behavior 0 of 2</span></span><br><span class="line"><span class="string">[11:02:34.728 - WARN] (): two valid global plan time gap is too long: 0.028351</span></span><br><span class="line"><span class="string">[11:02:34.762] (): move_base_recovery,state machine is CLEARING, Executing behavior 1 of 2</span></span><br><span class="line"><span class="string">[11:02:37.029 - WARN] (): Robot in controlling, but can&#x27;</span>t get new global plan</span><br><span class="line">[11:02:37.119] (): move_base_recovery,state machine is CLEARING, Executing behavior 0 of 2</span><br><span class="line">[11:02:39.153 - WARN] (): two valid global plan time gap is too long: 0.033766</span><br><span class="line">[11:02:39.186] (): move_base_recovery,state machine is CLEARING, Executing behavior 1 of 2</span><br><span class="line">[11:02:41.187 - WARN] (): two valid global plan time gap is too long: 0.001234</span><br><span class="line">[11:02:41.219 - ERROR] (): Aborting because a valid plan could not be found. Even after executing all recovery behaviors</span><br></pre></td></tr></table></figure>

<p>这其实对应<code>makePlan</code>失败的两种情况，在<code>move_base</code>中搜索<code>solution for issue #523</code>可发现，一个的state是<code>CONTROLLING</code>，一个是<code>PLANNING</code>。都添加了<code>publishZeroVelocity</code>禁止小车再移动，但是小车还是会移动，结果撞障碍。 这个现象在仿真中没有出现过。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/7/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/45/">45</a><a class="extend next" rel="next" href="/page/9/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/07/13/RCLw5Bx8aFPN74b.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>