<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">617</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">52</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2024/11/12/x1aqcwUG3XDiskN.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2023/07/20/C++/C++%20%20%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/vector%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E7%B4%A2%E5%BC%95%E7%9A%84%E5%85%83%E7%B4%A0/">vector删除指定索引的元素</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-07-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/">C++ 模板与STL</a></span><div class="content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> size = v.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + i - j);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;after remove&quot;</span>&lt;&lt; endl ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; v[i] &lt;&lt;<span class="string">&quot;   &quot;</span>;</span><br></pre></td></tr></table></figure>
<p>结果是  <code>1   3   5   7   9</code></p>
<p><br></p>
<p>常见iterator自增，如果多增加，可能报错<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator it=v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    it = it + <span class="number">5</span>;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样的程序是错的，会越界。 应该改成这样<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator it=v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> step = v.<span class="built_in">end</span>() - it;</span><br><span class="line">    it = it+step/<span class="number">5</span>;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/07/20/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E7%BA%AF%E8%B7%9F%E8%B8%AA%E7%AE%97%E6%B3%95/prune_plan%E6%9C%BA%E5%88%B6%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/">prune_plan机制及相关问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-07-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E7%BA%AF%E8%B7%9F%E8%B8%AA%E7%AE%97%E6%B3%95/">纯跟踪算法</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2023/07/20/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E7%BA%AF%E8%B7%9F%E8%B8%AA%E7%AE%97%E6%B3%95/prune_plan%E6%9C%BA%E5%88%B6%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/07/20/%E9%82%A3%E4%BA%9B%E5%8D%A1%E6%88%91%E5%BE%88%E4%B9%85%E7%9A%84bug/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92%E5%85%A8%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E5%AF%BC%E8%87%B4move_base%E9%80%80%E5%87%BA/">第二次规划全局路径导致move_base退出</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-07-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E9%82%A3%E4%BA%9B%E5%8D%A1%E6%88%91%E5%BE%88%E4%B9%85%E7%9A%84bug/">那些卡我很久的bug</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2023/07/20/%E9%82%A3%E4%BA%9B%E5%8D%A1%E6%88%91%E5%BE%88%E4%B9%85%E7%9A%84bug/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92%E5%85%A8%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E5%AF%BC%E8%87%B4move_base%E9%80%80%E5%87%BA/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/07/06/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/%E6%97%A0%E4%BC%A0%E6%84%9F%E5%99%A8%E6%97%B6%E7%9A%84%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE%E5%92%8Cmove_base%E6%8A%A5%E8%AD%A6/">不使用传感器时的代价地图和move_base报警</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-07-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content"><p>有一次机器人没有装雷达和相机，打算随便跑跑。于是在通用代价地图的障碍层，不设置传感器数据来源，运行<code>move_base</code>出现频繁报警<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The /scan observation buffer has not been updated <span class="keyword">for</span> <span class="number">22.06</span> seconds, and it should be updated every <span class="number">5.00</span> seconds.</span><br></pre></td></tr></table></figure><br>来源在<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ObservationBuffer::isCurrent</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (expected_update_rate_ == ros::<span class="built_in">Duration</span>(<span class="number">0.0</span>))</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// last_updated_ 没有赋值</span></span><br><span class="line">  <span class="keyword">bool</span> current = (ros::Time::<span class="built_in">now</span>() - last_updated_).<span class="built_in">toSec</span>() &lt;= expected_update_rate_.<span class="built_in">toSec</span>();</span><br><span class="line">  <span class="keyword">if</span> (!current)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_WARN</span>(</span><br><span class="line">        <span class="string">&quot;The %s observation buffer has not been updated for %.2f seconds, and it should be updated every %.2f seconds.&quot;</span>,</span><br><span class="line">        topic_name_.<span class="built_in">c_str</span>(), (ros::Time::<span class="built_in">now</span>() - last_updated_).<span class="built_in">toSec</span>(), expected_update_rate_.<span class="built_in">toSec</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时发导航命令，又有报警<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[/move_base]:Sensor data is out of date, we<span class="string">&#x27;re not going to allow commanding of the base for safety</span></span><br></pre></td></tr></table></figure><br>因为没有可靠的传感器数据，<code>move_base</code>不允许车跑起来。来源在<code>MoveBase::executeCycle</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!controller_costmap_ros_-&gt;<span class="built_in">isCurrent</span>())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">ROS_WARN</span>(<span class="string">&quot;[%s]:Sensor data is out of date, we&#x27;re not going to allow commanding of the base for safety&quot;</span>,ros::this_node::<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">  <span class="built_in">publishZeroVelocity</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>也就是函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LayeredCostmap::isCurrent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  current_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (vector&lt;boost::shared_ptr&lt;Layer&gt; &gt;::iterator plugin = plugins_.<span class="built_in">begin</span>(); plugin != plugins_.<span class="built_in">end</span>();</span><br><span class="line">      ++plugin)</span><br><span class="line">  &#123;</span><br><span class="line">    current_ = current_ &amp;&amp; (*plugin)-&gt;<span class="built_in">isCurrent</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>显然是因为障碍层不符合<code>isCurrent</code>，导致代价地图也不符合<code>isCurrent</code>。如果希望车照样跑，就把<code>MoveBase::executeCycle</code>那段注释掉，把<code>ObservationBuffer::isCurrent()</code>的报警也注释掉，否则没完没了。</p>
<p>从网上下载一个包含雷达数据的bag，又设置了通用代价地图和tf树后，发现报警依然，应该还是时间戳问题，懒得再对齐了。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/29/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ROS%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/">ROS编程规范</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><ul>
<li><p><code>Packages</code>,  <code>Topics / Services</code>, 文件、库的命名都采用 <strong>under_scored</strong></p>
</li>
<li><p><code>Classes / Types</code>的命名采用 <strong>CamelCased</strong>，比如<code>class ExampleClass</code>, <code>class HokuyoURGLaser</code>。  函数命名采用 <strong>camelCased</strong>，比如<code>int exampleMethod(int example_arg)</code></p>
</li>
<li><p>普通变量和成员变量命名、命名空间都使用 <strong>under_scored</strong>，循环中的临时变量使用<code>i,j,k</code>，i on the outer loop, j on the next inner loop</p>
</li>
<li><p>常量命名采用 <strong>ALL_CAPITALS</strong></p>
</li>
<li><p>全局变量采用 <code>g_</code> 开头的 <strong>under_scored</strong></p>
</li>
<li><p>每行最多120个字符</p>
</li>
<li><p>所有头文件要包含<code>#ifndef</code>，比如:</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PACKAGE_PATH_FILE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACKAGE_PATH_FILE_H</span></span><br><span class="line">	......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这部分应该在license之后，<code>#endif</code>在头文件的最后</p>
<ul>
<li>不使用宏</li>
</ul>
<p>预处理所用的宏，比如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">        <span class="built_in">temporary_debugger_break</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>函数的输出参数使用指针，而不是引用:  <code>int exampleMethod(FooThing input, BarThing* output);</code></p>
</li>
<li><p>头文件里不要用<code>using namespace</code>关键字，在源文件里可使用<code>using</code>，但不要<code>using namespace std;</code>，而是使用<code>using std::list;</code>, <code>using std::vector;</code>，否则引入了<code>std</code>所有内容。</p>
</li>
<li><p>建议使用Exceptions，而不是returning integer error codes。 析构函数不要抛出异常。 不直接触发的回调函数，不要抛出异常。 </p>
</li>
<li><p>保证代码是 <code>exception-safe</code>: When your code can be interrupted by exceptions, you must ensure that resources you hold will be deallocated when stack variables go out of scope. In particular, mutexes must be released, and heap-allocated memory must be freed. Accomplish this safety by using the following mutex guards and smart pointers</p>
</li>
</ul>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Choices</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Choice</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">     Choice1,</span><br><span class="line">     Choice2,</span><br><span class="line">     Choice3</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> Choices::Choice Choice;</span><br></pre></td></tr></table></figure>
<p>This prevents enums from polluting the namespace they’re inside. Individual items within the enum are referenced by: Choices::Choice1, but the typedef still allows declaration of the Choice enum without the namespace.</p>
<ul>
<li>If you are using C++11 and above, you can use scoped enumeration</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Choice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Choice1,</span><br><span class="line">    Choice2,</span><br><span class="line">    Choice3</span><br><span class="line">&#125;;</span><br><span class="line">Choice c = Choice::Choice1;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>不建议使用全局变量和函数，尤其前者。更不能在多线程中使用。大多数变量和函数都该在类的体内，其他应当在命名空间里。</p>
</li>
<li><p>类不要使用静态变量。</p>
</li>
<li><p>只在 well-defined exit point 调用<code>exit()</code>函数</p>
</li>
<li><p>使用assertions之类的比条件判断语句好，比如<code>ROS_ASSERT</code>, <code>ROS_ASSERT_MSG</code>, <code>ROS_ASSERT_CMD</code>, <code>ROS_BREADK</code></p>
</li>
</ul>
<p>Depending on compilation settings, the assertion may not be executed.</p>
<p>It is typical to develop software with assertion-checking enabled, in order to catch violations. When nearing software completion and when assertions are found to always be true in the face of extensive testing, you build with a flag that removes assertions from compilation, so they take up no space or time. </p>
<p>The following option to catkin_make will define the NDEBUG macro for all your ROS packages, and thereby remove assertion checks.<br><code>catkin_make -DCMAKE_CXX_FLAGS:STRING=&quot;-DNDEBUG&quot;</code></p>
<p>Note: cmake will rebuild all your software when you run it with this command, and will remember the setting through subsequent catkin_make runs until you delete your build and devel directories and rebuild.</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/27/C++/C++%20%20%E5%9F%BA%E7%A1%80/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADCPU%20%E6%9E%B6%E6%9E%84%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B/">判断CPU 架构和操作系统类型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E5%9F%BA%E7%A1%80/">C++ 基础</a></span><div class="content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> defined __linux__</span></span><br><span class="line">      std::cout&lt;&lt;<span class="string">&quot;linux system&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">elif</span> defined _WIN32</span></span><br><span class="line">      std::cout&lt;&lt;<span class="string">&quot;windows system&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   </span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> defined  __aarch64__</span></span><br><span class="line">      std::cout&lt;&lt;<span class="string">&quot;this is arm cpu&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">elif</span> defined __x86_64__</span></span><br><span class="line">      std::cout&lt;&lt;<span class="string">&quot;this id x86 cpu&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cmake 中判断CPU 架构，操作系统类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.10</span><span class="number">.0</span>)</span><br><span class="line"> </span><br><span class="line">message($&#123;CMAKE_HOST_SYSTEM_NAME&#125;)</span><br><span class="line">message($&#123;CMAKE_HOST_SYSTEM_PROCESSOR&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(CMAKE_HOST_SYSTEM_NAME MATCHES <span class="string">&quot;Linux&quot;</span>)</span><br><span class="line">    message(<span class="string">&quot;this is Linux&quot;</span>)</span><br><span class="line">elseif(CMAKE_HOST_SYSTEM_NAME MATCHES <span class="string">&quot;Windows&quot;</span>)</span><br><span class="line">  message(<span class="string">&quot;this is Windows&quot;</span>)</span><br><span class="line">endif()</span><br><span class="line"><span class="keyword">if</span>(CMAKE_HOST_SYSTEM_PROCESSOR MATCHES <span class="string">&quot;aarch64&quot;</span>)</span><br><span class="line">    message(<span class="string">&quot;this is aarch64 cpu&quot;</span>)</span><br><span class="line">elseif(CMAKE_HOST_SYSTEM_PROCESSOR MATCHES <span class="string">&quot;x86_64&quot;</span>)</span><br><span class="line">  message(<span class="string">&quot;this is x86_64 cpu&quot;</span>)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure></p>
<p>根据编译器的情况，有下面的宏用于调试程序:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是不是C++环境，需要注意的是ROS环境中这里为否</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _cplusplus</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;C++\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//判断是不是C环境</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STDC__</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;C\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//输出语句所在函数，行，文件等参数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;function %s: Line 25\n&quot;</span>,__func__);   <span class="comment">//或者用__FUNCTION__</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pretty function %s: Line 25\n&quot;</span>,__PRETTY_FUNCTION__);   <span class="comment">//函数声明，包括了参数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;line: %d\n&quot;</span>,__LINE__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;current file: %s\n&quot;</span>,__FILE__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;date: %s\n&quot;</span>,__DATE__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;time: %s\n&quot;</span>,__TIME__);</span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/25/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/Costmap2DROS%E7%9A%84%E5%87%BD%E6%95%B0getRobotPose/">Costmap2DROS的函数getRobotPose</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content"><p>源码其实并不复杂<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Costmap2DROS::getRobotPose</span><span class="params">(tf::Stamped&lt;tf::Pose&gt;&amp; global_pose)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  global_pose.<span class="built_in">setIdentity</span>();</span><br><span class="line">  tf::Stamped &lt; tf::Pose &gt; robot_pose;</span><br><span class="line">  robot_pose.<span class="built_in">setIdentity</span>();</span><br><span class="line">  robot_pose.frame_id_ = robot_base_frame_;</span><br><span class="line">  robot_pose.stamp_ = ros::<span class="built_in">Time</span>();</span><br><span class="line">  ros::Time current_time = ros::Time::<span class="built_in">now</span>();  <span class="comment">// save time for checking tf delay later</span></span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    tf_.<span class="built_in">transformPose</span>(global_frame_, robot_pose, global_pose);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (tf::LookupException&amp; ex)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR_THROTTLE</span>(<span class="number">1.0</span>, <span class="string">&quot;No Transform available Error looking up robot pose: %s\n&quot;</span>, ex.<span class="built_in">what</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (tf::ConnectivityException&amp; ex)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR_THROTTLE</span>(<span class="number">1.0</span>, <span class="string">&quot;Connectivity Error looking up robot pose: %s\n&quot;</span>, ex.<span class="built_in">what</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (tf::ExtrapolationException&amp; ex)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR_THROTTLE</span>(<span class="number">1.0</span>, <span class="string">&quot;Extrapolation Error looking up robot pose: %s\n&quot;</span>, ex.<span class="built_in">what</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// check global_pose timeout</span></span><br><span class="line">  <span class="keyword">if</span> (current_time.<span class="built_in">toSec</span>() - global_pose.stamp_.<span class="built_in">toSec</span>() &gt; transform_tolerance_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_WARN_THROTTLE</span>(<span class="number">1.0</span>,</span><br><span class="line">                      <span class="string">&quot;Costmap2DROS transform timeout. Current time: %.4f, global_pose stamp: %.4f, tolerance: %.4f&quot;</span>,</span><br><span class="line">                      current_time.<span class="built_in">toSec</span>(), global_pose.stamp_.<span class="built_in">toSec</span>(), transform_tolerance_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>核心是函数 <code>transformPose</code>，<code>tf_</code>在这里是<code>tf::TransformListener</code>，但函数实际是继承自基类<code>tf::Transformer</code>，有两个重载，常用的是第一个<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transformer::transformPose</span><span class="params">(<span class="keyword">const</span> std::string&amp;   target_frame,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">const</span> Stamped&lt; tf::Pose &gt;&amp;   stamped_in,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Stamped&lt; tf::Pose &gt;&amp;   stamped_out </span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transformer::transformPose</span><span class="params">(<span class="keyword">const</span> std::string&amp;   target_frame,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">const</span> ros::Time&amp;   target_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">const</span> Stamped&lt; tf::Pose &gt;&amp;   stamped_in,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">const</span> std::string&amp;   fixed_frame,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Stamped&lt; tf::Pose &gt;&amp;   stamped_out </span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure><br>第二个重载会调用函数<code>lookupTransform</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the transform between two frames by frame ID assuming fixed frame.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transformer::lookupTransform</span> <span class="params">( <span class="keyword">const</span> std::string &amp;   target_frame,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> ros::Time &amp;   target_time,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> std::string &amp;   source_frame,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> ros::Time &amp;   source_time,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> std::string &amp;   fixed_frame,</span></span></span><br><span class="line"><span class="params"><span class="function">	StampedTransform &amp;  transform </span></span></span><br><span class="line"><span class="params"><span class="function">)</span>   <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>target_frame  The frame to which data should be transformed</li>
<li>target_time The time to which the data should be transformed. (0 will get the latest)</li>
<li>source_frame  The frame where the data originated</li>
<li>source_time The time at which the source_frame should be evaluated. (0 will get the latest)</li>
<li>fixed_frame The frame in which to assume the transform is constant in time.</li>
<li>transform The transform reference to fill.</li>
</ul>
<p>可能抛出的异常<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> tf&#123;</span><br><span class="line">  <span class="comment">// Pass through exceptions from tf2</span></span><br><span class="line">  <span class="keyword">typedef</span> tf2::TransformException TransformException;</span><br><span class="line">  <span class="keyword">typedef</span> tf2::LookupException LookupException;</span><br><span class="line">  <span class="keyword">typedef</span> tf2::ConnectivityException ConnectivityException;</span><br><span class="line">  <span class="keyword">typedef</span> tf2::ExtrapolationException ExtrapolationException;</span><br><span class="line">  <span class="keyword">typedef</span> tf2::InvalidArgumentException InvalidArgument; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="报警-Costmap2DROS-transform-timeout"><a href="#报警-Costmap2DROS-transform-timeout" class="headerlink" title="报警 Costmap2DROS transform timeout"></a>报警 Costmap2DROS transform timeout</h2><p>报警对应的<code>transform_tolerance_</code>是在构造函数里写死的<code>0.3</code>，一开始我以为这个数太小了，于是改为2，结果没有改善。</p>
<p>以下报警的根源都是<code>Costmap2DROS::getRobotPose</code><br><img src="https://s2.loli.net/2023/06/27/zstZTuh8cO63VvG.png" alt=""><br><img src="https://s2.loli.net/2023/06/27/jnCAr6sdbgxJwBK.png" alt="获取不到开始位姿，无法生成全局路径"></p>
<p>尝试的改善措施(全都无效):</p>
<ul>
<li><code>Costmap2DROS</code>构造函数中设置: <code>transform_tolerance_(2)</code></li>
<li><code>timer_ = private_nh.createTimer(ros::Duration(.1), &amp;Costmap2DROS::movementCB, this);</code> 0.1秒间隔太短了。增大到1.5，稍有改善，但未解决根本问题，反而降低了代价地图的性能。</li>
<li>降低两个代价地图的<code>update_frequency</code></li>
</ul>
<p>所有报警基本来自<code>Costmap2DROS::getRobotPose</code>，或者说<code>map</code>—-&gt;<code>base_link</code>的tf变换不及时。</p>
<ol>
<li>如果不启动VSLAM，启动诠视相机的<code>xv_sdk.launch</code>，使用<code>static_transform_republisher</code>建立假的TF树，启动导航框架，一个报警也没有。因此问题还在VSLAM，怀疑是CPU而不是网络问题。</li>
<li>启动诠视相机的<code>xv_sdk.launch</code>和VSLAM，但不发布tf，使用假的tf树，启动导航框架，仍然没有报警。</li>
<li>继续缩小问题范围，发布假的tf: <code>world</code>—-&gt;<code>map</code>—-&gt;<code>odom</code>—-&gt; <code>base_link</code>，导航框架不报警。但是如果由VSLAM发布<code>map</code>—-&gt;<code>odom</code>，就有报警了。</li>
</ol>
<p>所以问题的原因：</p>
<ol>
<li>VSLAM的<code>map</code>—-&gt;<code>odom</code>—-&gt; <code>base_link</code>变换。</li>
<li>Nano的CPU没有使用到极致，还有多余算力</li>
</ol>
<p>在此情况下规划路径时，全局路径可生成，因为全局规划频率是0，虽然有很多报警，总能成功规划一次。但局部路径就不同了，需要频繁规划。<br>只看TF的频率和<code>tf echo</code>有没有数据还不够，<strong>应该看Rviz里，<code>base_link</code>坐标系在<code>map</code>中的坐标是否能随着机器人的移动实时更新。</strong>先满足这一点，再运行导航框架。</p>
<font size="3" color="blue"> 另一种原因是网络带宽不足  </font></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/13/C++/%E5%A4%9A%E7%BA%BF%E7%A8%8B/unique_lock/">unique_lock</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span><div class="content"><p><code>unique_lock</code>是管理具有唯一所有权的互斥对象的对象。类似智能指针<code>unique_ptr</code>。在构造时（或通过移动分配给它），对象获得一个互斥对象，负责该对象的锁定和解锁操作。该对象支持两种状态：锁定和解锁。此类保证在销毁时将管理的互斥对象解锁（即使未显式调用解锁函数）。因此，它能够保证互斥对象在抛出异常的情况下正确解锁，克服了mutex使用中的缺点。但是，unique_lock对象不以任何方式管理互斥对象的生命周期：这要求互斥对象的持续时间应至少延长到管理它的unique_lock销毁。</p>
<p><code>unique_lock</code>是一个模板类，需要使用Mutex类型作为模板参数。</p>
<ul>
<li><p><code>try_lock</code>初始化: 新创建的<code>unique_lock</code>对象管理<code>Mutex</code>对象<code>m</code>，并尝试调用<code>m.lock()</code>对<code>Mutex</code>对象进行上锁，如果此时另外某个<code>unique_lock</code>对象已经管理了该<code>Mutex</code>对象<code>m</code>，则当前线程将会被阻塞。</p>
</li>
<li><p><code>try-locking</code>初始化: 新创建的<code>unique_lock</code>对象管理Mutex对象m，并尝试调用m.try_lock()对Mutex对象进行上锁，但如果上锁不成功，并不会阻塞当前线程</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">boost::mutex mut;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">boost::unique_lock&lt;boost::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;This is bar!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>( lock.<span class="built_in">owns_lock</span>() )</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;owns lock&quot;</span> &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      lock.<span class="built_in">lock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">boost::unique_lock&lt;boost::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is foo!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/05/C++/%E5%A4%9A%E7%BA%BF%E7%A8%8B/recursive_mutex/">递归锁 recursive_mutex</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span><div class="content"><p>如果一个<code>mutex</code>被许多模块和类共享，就使用<code>boost::recursive_mutex</code>，如果只被一个模块和类使用，而且不需要re-entrant特性， 就使用<code>boost::mutex</code></p>
<p>特点:</p>
<ol>
<li>递归锁是互斥锁的一种，同一线程对其多次加锁不会产生死锁。</li>
<li>递归锁会使用引用计数机制，以便可以从同一线程多次加锁、解锁，当加锁、解锁次数相等时，锁才可以被其他线程获取。</li>
<li>能用普通互斥锁就不要用递归锁，会增大开销</li>
<li>无法定义lock递归锁的次数，当然也不是无限的，次数太多会有报错</li>
<li>递归锁也可以在循环中使用</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/console.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">boost::mutex  mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ! dead-locked here</span></span><br><span class="line">    boost::<span class="function">mutex::scoped_lock <span class="title">lLock</span><span class="params">(mtx)</span></span>; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bar&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boost::<span class="function">mutex::scoped_lock <span class="title">lLock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;test_curve&quot;</span>);</span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">foo</span>();</span><br><span class="line">  <span class="built_in">bar</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下，线程正常运行，不会死锁。</p>
<p>但是这种情况下，线程就死锁了，只能运行<code>foo</code>，因为mutex不可重入，<code>foo</code>这个线程没有运行完<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/console.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">boost::mutex  mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boost::<span class="function">mutex::scoped_lock <span class="title">lLock</span><span class="params">(mtx)</span></span>; <span class="comment">// dead-locked here</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bar&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boost::<span class="function">mutex::scoped_lock <span class="title">lLock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;test_curve&quot;</span>);</span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">foo</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果把<code>mutex</code>换成<code>recursive_mutex</code>，又能正常运行了。</p>
<p>recursive_mutex类可多次进入锁，这样在递归时可以避免一次死锁的几率，这是原本BOOST中所体现的一种思想。递归锁可多次锁，同样的需要多次解锁，那么问题就来了，如果真正或可能造成这次死锁的位置在某个已经进入死锁的地方，那么死锁的位置可能并不是你需要的位置，简单的说，如果A锁了3次，B锁一次，C锁一次，这样就锁出现死锁，排错之困难可想而知。</p>
<p><br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;boost/thread/mutex.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">boost::recursive_mutex  mtx;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mtx.<span class="built_in">lock</span>();</span><br><span class="line">  mtx.<span class="built_in">lock</span>();</span><br><span class="line">  mtx.<span class="built_in">lock</span>();</span><br><span class="line">  sum = sum * n;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;thread 1, sum: &quot;</span>&lt;&lt; sum &lt;&lt;endl;</span><br><span class="line">  mtx.<span class="built_in">unlock</span>();</span><br><span class="line"><span class="comment">//   mtx.unlock();</span></span><br><span class="line"><span class="comment">//   mtx.unlock();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mtx.<span class="built_in">lock</span>();</span><br><span class="line">  sum = sum * <span class="number">7</span> * n;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;thread 2, sum: &quot;</span>&lt;&lt; sum &lt;&lt;endl;</span><br><span class="line">  mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line">    boost::thread th_1 = boost::<span class="built_in">thread</span>(boost::<span class="built_in">bind</span>(&amp;thread_1,  n) );</span><br><span class="line">    boost::thread th_2 = boost::<span class="built_in">thread</span>(boost::<span class="built_in">bind</span>(&amp;thread_2,  n) );</span><br><span class="line"></span><br><span class="line">    th_1.<span class="built_in">join</span>();</span><br><span class="line">    th_2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>thread_1</code>里如果<code>lock</code>3次，<code>unlock</code>1次，运行时会阻塞在<code>thread_1</code>。只有3次<code>unlock</code>才会正常运行两个线程。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/05/24/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/rosbag%E7%9A%84%E8%AF%BB%E5%86%99/">rosbag的读写</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-05-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><p>头文件<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rosbag/bag.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rosbag/view.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rosbag/message_instance.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/foreach.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> foreach BOOST_FOREACH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;nav_msgs/Path.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="读写bag文件"><a href="#读写bag文件" class="headerlink" title="读写bag文件"></a>读写bag文件</h3><p><code>open</code>函数默认是读模式。</p>
<p>写bag文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rosbag::Bag bag;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    bag.<span class="built_in">open</span>(<span class="string">&quot;/home/user/plan.bag&quot;</span>, rosbag::bagmode::Write);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> rosbag::BagException&amp; ex) &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;open rosbag error: %s&quot;</span>, ex.<span class="built_in">what</span>() );</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">bag.<span class="built_in">write</span>(<span class="string">&quot;record_plan&quot;</span>,ros::Time::<span class="built_in">now</span>(), coverage_plan);</span><br><span class="line">bag.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><br>打开文件的模式有：<code>enum rosbag::bagmode::BagMode</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Write   </span><br><span class="line">Read    </span><br><span class="line">Append  </span><br></pre></td></tr></table></figure></p>
<p>读bag文件一定要用<code>try</code>和<code>catch</code></p>
<p>下面的例子，bag文件只有一个话题<code>/move_base/transformed_plan</code>，一堆<code>nav_msgs/Path</code>消息<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">rosbag::Bag bag;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    bag.<span class="built_in">open</span>(<span class="string">&quot;/home/user/plan.bag&quot;</span>, rosbag::bagmode::Read);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> rosbag::BagException&amp; ex) &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;open rosbag error: %s&quot;</span>, ex.<span class="built_in">what</span>() );</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;        </span><br><span class="line">std::vector&lt;std::string&gt; topics;</span><br><span class="line"><span class="keyword">bool</span> bag_read_once = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">topics.<span class="built_in">push_back</span>(std::<span class="built_in">string</span>(<span class="string">&quot;record_plan&quot;</span>) );</span><br><span class="line"><span class="function">rosbag::View <span class="title">view</span><span class="params">(bag, rosbag::TopicQuery(topics) )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOST_FOREACH</span>(rosbag::MessageInstance <span class="keyword">const</span> m, view)</span><br><span class="line">&#123;</span><br><span class="line">    nav_msgs::Path::ConstPtr i = m.instantiate&lt;nav_msgs::Path&gt;();</span><br><span class="line">    plan_from_bag.header.frame_id = i-&gt;header.frame_id;</span><br><span class="line">    plan_from_bag.header.stamp = i-&gt;header.stamp;</span><br><span class="line">    plan_from_bag.header.seq = i-&gt;header.seq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> path_size = i-&gt;poses.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;plan from bag size: %zu&quot;</span>,i-&gt;poses.<span class="built_in">size</span>() );</span><br><span class="line">    plan_from_bag.poses.<span class="built_in">reserve</span>(path_size);</span><br><span class="line">    <span class="keyword">if</span>(bag_read_once)    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    plan_from_bag.poses = i-&gt;poses;</span><br><span class="line">    bag_read_once = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">bag.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><br>注意读的时候，topics容器的元素必须还是<code>number</code>，与写文件时一致。如果不一致，读文件会不执行foreach</p>
<p>用到的类如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a view and add a query</span></span><br><span class="line"><span class="comment"> * param bag             The bag file on which to run this query</span></span><br><span class="line"><span class="comment"> * param query           The actual query to evaluate which connections to include</span></span><br><span class="line"><span class="comment"> * param start_time      The beginning of the time range for the query</span></span><br><span class="line"><span class="comment"> * param end_time        The end of the time range for the query</span></span><br><span class="line"><span class="comment"> * param reduce_overlap  If multiple views return the same messages, reduce them to a single message</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">View</span>(Bag <span class="keyword">const</span>&amp; bag, boost::function&lt;<span class="built_in"><span class="keyword">bool</span></span>(ConnectionInfo <span class="keyword">const</span>*)&gt; query,</span><br><span class="line">     ros::Time <span class="keyword">const</span>&amp; start_time = ros::TIME_MIN, ros::Time <span class="keyword">const</span>&amp; end_time = ros::TIME_MAX, <span class="keyword">bool</span> <span class="keyword">const</span>&amp; reduce_overlap = <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ROSBAG_DECL</span> <span class="title">TopicQuery</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TopicQuery</span>(std::string <span class="keyword">const</span>&amp; topic);</span><br><span class="line">    <span class="built_in">TopicQuery</span>(std::vector&lt;std::string&gt; <span class="keyword">const</span>&amp; topics);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ConnectionInfo <span class="keyword">const</span>*)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::string&gt; topics_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>rosbag::View</code>的常用函数</p>
<ul>
<li><code>iterator   begin()</code>  Simply copy the merge_queue state into the iterator.</li>
<li><code>iterator   end()</code>    Default constructed iterator signifies end.</li>
<li><code>ros::Time  getBeginTime()</code></li>
<li><code>ros::Time  getEndTime()</code></li>
<li><code>uint32_t    size ()</code>    获得bag文件中所含消息的个数，不是文件大小</li>
</ul>
<p><br></p>
<p>其他常用函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the filename of the bag</span></span><br><span class="line"><span class="function">std::string  <span class="title">getFileName</span> <span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Get the current size of the bag file (a lower bound) More...</span></span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span>  <span class="title">getSize</span> <span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span>    <span class="title">isOpen</span> <span class="params">()</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="bag文件-unindexed"><a href="#bag文件-unindexed" class="headerlink" title="bag文件 unindexed"></a>bag文件 unindexed</h3><p><img src="https://s2.loli.net/2024/03/21/gdxyEB2KUOtu18s.png" alt=""><br>这种情况下如果没有用<code>try</code>和<code>catch</code>就会出错<br><img src="https://s2.loli.net/2024/03/21/FEfZkL2jmYbtBeg.png" alt=""><br>我查来查去，没发现C++ API里有类似<code>rosbag reindex</code>命令的函数，只能不处理。似乎python里有，没有深入研究，</p>
<p>参考：<br><a target="_blank" rel="noopener" href="http://wiki.ros.org/rosbag/Code%20API">rosbag  API </a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/7/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/62/">62</a><a class="extend next" rel="next" href="/page/9/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2024/11/12/x1aqcwUG3XDiskN.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2025 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>