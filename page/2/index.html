<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">482</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">44</span></a></div></div></div><nav id="nav" style="background-image: url(https://i.loli.net/2021/07/13/RCLw5Bx8aFPN74b.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/27/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/rqt_plot%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%93%81%20plotjuggler/">rqt_plot的替代品 plotjuggler</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a></span><div class="content"><p>安装: <code>sudo apt-get install -y ros-melodic-plotjuggler-ros</code>，运行 <code>rosrun plotjuggler plotjuggler</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/27/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move_base%20%E5%88%86%E6%9E%90/move_base%E7%9A%84CPU%E5%8D%A0%E7%94%A8%E5%92%8C%E4%B8%A4%E4%B8%AA%E5%B8%B8%E8%A7%81%E6%8A%A5%E8%AD%A6/">move_base的CPU占用和两个常见报警</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move-base%E5%88%86%E6%9E%90/">move_base分析</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2021/11/27/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move_base%20%E5%88%86%E6%9E%90/move_base%E7%9A%84CPU%E5%8D%A0%E7%94%A8%E5%92%8C%E4%B8%A4%E4%B8%AA%E5%B8%B8%E8%A7%81%E6%8A%A5%E8%AD%A6/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/22/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%BC%A0%E6%A5%ABDual-Stage%20Viewpoint%20Planner/DSVP%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E8%BF%90%E8%A1%8C/">DSVP的介绍和运行</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/Dual-Stage-Viewpoint-Planner/">Dual-Stage Viewpoint Planner</a></span><div class="content"><p>Dual-Stage Viewpoint Planner 包含两个阶段：探索阶段用于扩展地图边界，重定位阶段用于 explicitly 把机器人传到环境中不同的子区域。探索阶段采用RRT，并动态地扩展RRT over replanning steps. 重定位阶段维护一个graph结构 through the mapped environment. 在探索过程中，算法在两个阶段来回切换，以探索整个环境。</p>
<p>DSVP有几个上层规划算法，包括在未知环境中的探索算法和全局路径规划算法，以及全套算法的系统集成和扩展应用。</p>
<p>我们提供的避障算法优势在于能实时高效地应对复杂环境,同时最大化到达目标点的概率。算法的主要思想在于尽可能地让计算在线下完成。具体来说，一个避障算法最耗时的计算一般在于检测机器人在未来时间点与环境发生碰撞的可能。我们的算法先通过离线生成一个庞大的轨迹库（trajectory library）来模拟机器人在未来一段时间内可能走过的轨迹。接下来对于所有轨迹覆盖的空间，我们计算其内部所有点（在一定解析度下）与所有轨迹发生碰撞的可能性。经过这样的离线计算，我们可以得到一个空间内3D点到轨迹的对应关系。在实时运行的过程中，一旦空间内的某个点上有障碍物，我们可以马上知道哪些轨迹将会受到影响。我们的算法会降低选择这些轨迹作为最终路径的可能性。因为大量的计算都在线下进行，线上运行的时候只需要实时选择无碰撞的轨迹，我们的算法可以在几毫秒之内规划出一条无碰撞而最接近目标点的路径。</p>
<p>测试平台是野外机器人，车上用了velodyne-16激光雷达，xsens mti-200 imu。速度只能达到2m/s。运行系统要求是18.04或者20.04</p>
<p>TARE系统有使用多线激光点云做地面分割，来判断哪些高度的地方可以去，哪些不能去，以应对有坡度、崎岖的地面。 系统里维护的是3d octomap</p>
<p>只是把点云数据register到了全局坐标系下，然后把局部的点云叠加起来先做地形分析再用地形图做避障和导航。</p>
<p><code>roslaunch waypoint_example waypoint_example_garage.launch</code></p>
<p>Alternatively, users can run a ROS node to send a series of waypoints. The ROS node sends navigation boundary and speed as well. The vehicle will navigate inside the boundary while following the waypoints.</p>
<h2 id="Autonomous-Navigation-Modules"><a href="#Autonomous-Navigation-Modules" class="headerlink" title="Autonomous Navigation Modules"></a>Autonomous Navigation Modules</h2><p>Sending waypoints, navigation boundary, and speed: Upon receiving waypoint, navigation boundary, and speed messages, the system will navigate the vehicle inside the navigation boundary to the waypoint. Sending navigation boundary and speed is optional. The default speed in the system is set to 2m/s. Users can take the code in the ‘waypoint_example’ package as an example of sending these messages.</p>
<ul>
<li><p>Waypoint: 话题<code>way_point</code>，<code>geometry_msgs::PointStamped</code>类型的消息，在<code>map</code>坐标系。 发布者当然是<code>rvizGA</code> 和 <code>localPlanner</code> 和 <code>rvizGA</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">header: </span><br><span class="line">  seq: 6</span><br><span class="line">  stamp: </span><br><span class="line">    secs: 215</span><br><span class="line">    nsecs: 380000000</span><br><span class="line">  frame_id: <span class="string">&quot;map&quot;</span></span><br><span class="line">point: </span><br><span class="line">  x: 9.90468215942</span><br><span class="line">  y: 12.2474937439</span><br><span class="line">  z: 0.839443683624</span><br><span class="line">---</span><br><span class="line">header: </span><br><span class="line">  seq: 7</span><br><span class="line">  stamp: </span><br><span class="line">    secs: 215</span><br><span class="line">    nsecs: 380000000</span><br><span class="line">  frame_id: <span class="string">&quot;map&quot;</span></span><br><span class="line">point: </span><br><span class="line">  x: 9.90468215942</span><br><span class="line">  y: 12.2474937439</span><br><span class="line">  z: 0.839443683624</span><br></pre></td></tr></table></figure>
</li>
<li><p>Navigation boundary (optional): 话题<code>navigation_boundary</code>，<code>geometry_msgs::PolygonStamped</code>的消息， 在<code>map</code>坐标系。 <strong>默认没有发布</strong>，订阅者是<code>localPlanner</code></p>
</li>
<li><p>速度 (optional): 话题<code>speed</code>，消息为<code>std_msgs::Float32</code>类型。 <strong>默认没有发布</strong>，订阅者是<code>pathFollower</code>和<code>localPlanner</code></p>
</li>
<li><p>避障: The collision avoidance is handled by the ‘local_planner’ package. The package computes collision-free paths to guide the vehicle through the environment. Motion primitives are pre-generated and loaded into the system upon start. When the vehicle navigates, the system in real-time determines the motion primitives occluded by obstacles. Those motion primitives are eliminated and the collision-free paths are selected. In the image below, the coordinate frame indicates the vehicle and the yellow dots are collision-free paths. In an autonomous navigation system, the collision avoidance module should be guided by a high-level planning module, e.g. a route planner that sends waypoints in the vicinity of the vehicle along the route. The collision avoidance module uses terrain maps from the ‘terrain_analysis’ package to determine terrain traversability (information below).</p>
</li>
<li><p>Terrain traversability analysis: The ‘terrain_analysis’ package analyzes the local smoothness of the terrain and associates a cost to each point on the terrain map. The system publishes terrain map messages where each message contains a set of ‘pcl::PointXYZI’ typed points. The x, y, and z fields of a point indicate the coordinates and the intensity field stores the cost. The terrain map covers a 10m x 10m area with the vehicle in the center. Further, the ‘terrain_analysis_ext’ package extends the terrain map to a 40m x 40m area. The extended terrain map keeps lidar points over a sliding window of 10 seconds with a non-decay region within 4m from the vehicle. In an autonomous navigation system, the terrain map is used by the collision avoidance module (information above) and the extended terrain map is to be used by a high-level planning module. To view the terrain map or the extended terrain map in RVIZ, click ‘Panels-&gt;Displays’ and check ‘terrainMap’ or ‘terrainMapExt’. The green points are traversable and the red points are non-traversable.</p>
</li>
<li><p>Terrain map (5Hz): ‘sensor_msgs::PointCloud2’ typed messages on ROS topic ‘/terrain_map’, in ‘map’ frame.</p>
</li>
</ul>
<p>Publishers:<br>terrainAnalysis</p>
<p>Subscribers:<br>terrainAnalysisExt<br>localPlanner<br>vehicleSimulator</p>
<ul>
<li>Extended terrain map (5Hz): ‘sensor_msgs::PointCloud2’ typed messages on ROS topic ‘/terrain_map_ext’, in ‘map’ frame.  发布者 <code>/terrainAnalysisExt</code></li>
</ul>
<p>Waypoint following: Upon receiving a waypoint, the system guides the vehicle to the waypoint. For information on tuning path following control, i.e. speed, yaw rate, acceleration, look-ahead distance, gains, and changing vehicle size, please refer to Ground-based Autonomy Base Repository.</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/18/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%85%A8%E5%B1%80%E8%B7%AF%E5%BE%84/%E5%85%A8%E5%B1%80%E8%B7%AF%E5%BE%84%E6%97%A0%E6%B3%95%E8%B5%B0%E5%87%BA%E9%9A%9C%E7%A2%8D/">全局路径无法走出障碍</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%85%A8%E5%B1%80%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/">全局路径算法</a></span><div class="content"><p><a target="_blank" rel="noopener" href="https://youtu.be/bjMK5P5YhrU">视频</a><br>这个问题的本质是ROS的全局路径算法不考虑车体的轮廓，跟轮廓有关的避障交给了局部路径，DWA和TEB算法里都有<code>footprintCost</code>之类的函数，可以判断是否撞了障碍，但全局路径算法没有。 全局路径是把车当成了点，从所在栅格到目标栅格进行规划。这里开始规划出的路线就是这样，在走了一段时间被TEB认为不可行后，全局路径换成另一条，但是马上被认为不如之前的全局路径更优，又换回去了。如此循环，所以走不出去了。</p>
<p>但是要让全局路径考虑轮廓，会改动很大(即使不考虑动态障碍)，成本太高了。所以有必要考虑其他导航框架了。</p>
<p>暂时的解决方法只有设置中间点或者加虚拟墙</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/18/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ROS%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%20MultiThreadedSpinner%E5%92%8CAsyncSpinner/">ROS中的多线程 MultiThreadedSpinner和AsyncSpinner</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><p>在ROS当中，原作者是不推荐用多线程的，他建议用多进程，变成一个个节点的形式进行通信。多线程分为两种模式：同步和异步。 </p>
<ul>
<li><p>同步：<code>MultiThreadSpinner s(4)</code>，一共5个线程。包括了主线程。</p>
</li>
<li><p>异步：<code>AsyncSpinner s(4)</code>， 一共5个线程。包括了主线程。</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">回调方法</th>
<th style="text-align:center">阻塞</th>
<th style="text-align:center">线程</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ros::spin()</td>
<td style="text-align:center">阻塞</td>
<td style="text-align:center">单线程</td>
</tr>
<tr>
<td style="text-align:center">ros::spinOnce</td>
<td style="text-align:center">非阻塞</td>
<td style="text-align:center">单线程</td>
</tr>
<tr>
<td style="text-align:center">ros::MultiThreadedSpinner</td>
<td style="text-align:center">阻塞</td>
<td style="text-align:center">多线程</td>
</tr>
<tr>
<td style="text-align:center">ros::AsyncSpinner</td>
<td style="text-align:center">非阻塞</td>
<td style="text-align:center">多线程</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://i.loli.net/2021/11/17/nDG1izHFmLsTPrZ.png" alt=""></p>
<font color = blue size = 4> 这里讨论的是多线程形式的回调函数，而不是多线程之间如何同步的问题  </font>

<p><br></p>
<p>对于多话题的订阅，我们先看传统的方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cb1</span><span class="params">(<span class="keyword">const</span> geometry_msgs::PoseStamped::ConstPtr&amp; msg)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;uwb_pose x: %f&quot;</span>, msg-&gt;pose.position.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cb2</span><span class="params">(<span class="keyword">const</span> geometry_msgs::PoseStamped::ConstPtr&amp; msg)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;yolo_pose x: %f&quot;</span>, msg-&gt;pose.position.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;node&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ros::Subscriber uwbSub = nh.subscribe&lt;geometry_msgs::PoseStamped&gt;(<span class="string">&quot;uwb_pose&quot;</span>, <span class="number">1</span>, cb1);</span><br><span class="line">    ros::Subscriber yoloSub = nh.subscribe&lt;geometry_msgs::PoseStamped&gt;(<span class="string">&quot;yolo_pose&quot;</span>, <span class="number">1</span>, cb2);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在回调函数<code>cb2</code>里，可能先执行一大堆耗时的命令，这里用sleep(2)代替，这样<code>cb1</code>的 <code>ROS_INFO</code>获得的消息就会缺失，这明显就是多线程的问题了。</p>
<p>把代码加上<code>ros::MultiThreadedSpinner s(2);</code> (<font color = blue size = 4> 无需加入头文件  </font>), <code>ros::spin();</code>改为<code>ros::spin(s);</code>, 再运行会发现<code>cb1</code>里没有缺少一个消息。</p>
<p>这里多线程的目的是<strong>保证线程<code>cb1</code>不丢失消息，而不是<code>cb2</code></strong>，它丢失消息是必然的。</p>
<p>对于<code>ros::AsyncSpinner</code>，代码在<code>ros::Subscriber</code>定义之后这样写:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ros::AsyncSpinner <span class="title">spinner</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">spinner.<span class="built_in">start</span>();</span><br><span class="line">ros::<span class="built_in">waitForShutdown</span>();</span><br></pre></td></tr></table></figure></p>
<p>当程序当中有数据处理线程的时候，建议开辟<strong>异步多线程</strong>订阅，算法写在订阅函数里面。 当然，目前的处理当中，我更倾向于重新开辟一个线程，然后通过循环数组来进行数据交互。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://wenglihong.github.io/2016/02/01/ROS%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89ROS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF/">ROS多线程订阅消息</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/%E6%89%AB%E5%88%B0%E5%A4%AA%E4%BD%8E%E7%9A%84%E9%9A%9C%E7%A2%8D%E5%92%8C%E6%89%AB%E4%B8%8D%E5%88%B0%E9%9A%9C%E7%A2%8D/">扫到太低的障碍和扫不到障碍</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2021/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/%E6%89%AB%E5%88%B0%E5%A4%AA%E4%BD%8E%E7%9A%84%E9%9A%9C%E7%A2%8D%E5%92%8C%E6%89%AB%E4%B8%8D%E5%88%B0%E9%9A%9C%E7%A2%8D/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/%E9%9A%9C%E7%A2%8D%E5%B1%827%20%20%E6%B7%BB%E5%8A%A0%E9%9A%9C%E7%A2%8D/">障碍层7  添加障碍</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content"><p>后面的<code>observations</code>是下面这样获得的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Observation&gt;  observations;</span><br><span class="line"><span class="comment">// get the marking observations</span></span><br><span class="line"><span class="built_in">getMarkingObservations</span>(observations);</span><br></pre></td></tr></table></figure><br><code>Observation</code>保存的是 observation in terms of a point cloud and the origin of the source，有4个成员变量：</p>
<ul>
<li><code>geometry_msgs::Point origin_;</code>   The origin point of the observation</li>
<li><code>pcl::PointCloud&lt;pcl::PointXYZ&gt;* cloud_;</code>   point cloud of the observation</li>
<li><code>double obstacle_range_;</code>  The range out to which an observation should be able to insert obstacles</li>
<li><code>double raytrace_range_;</code>  The range out to which an observation should be able to clear via raytracing</li>
</ul>
<p>获得的<code>observations</code>实际上是从<code>bufferCloud</code>里的<code>observation_list_</code>而来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// place the new obstacles into a priority queue</span></span><br><span class="line"><span class="comment">// each with a priority of zero to begin with</span></span><br><span class="line"><span class="keyword">for</span> (std::vector&lt;Observation&gt;::const_iterator it = observations.<span class="built_in">begin</span>(); </span><br><span class="line">      it != observations.<span class="built_in">end</span>();     ++it)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> Observation&amp; obs = *it;</span><br><span class="line">    <span class="keyword">const</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp;  cloud = *(obs.cloud_);</span><br><span class="line">    <span class="comment">// obstacle_range_ 其实就是参数 obstacle_range</span></span><br><span class="line">    <span class="keyword">double</span> sq_obstacle_range = obs.obstacle_range_ * obs.obstacle_range_;</span><br><span class="line">    <span class="comment">// 遍历点云中的每一个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cloud.points.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">double</span> px = cloud.points[i].x, py = cloud.points[i].y, pz = cloud.points[i].z;</span><br><span class="line">      <span class="comment">// if the obstacle is too high or too far away from the robot we won&#x27;t add it</span></span><br><span class="line">      <span class="keyword">if</span> (pz &gt; max_obstacle_height_)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">ROS_DEBUG</span>(<span class="string">&quot;The point is too high&quot;</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// compute the squared distance from the hitpoint to the pointcloud&#x27;s origin</span></span><br><span class="line">      <span class="keyword">double</span> sq_dist = (px - obs.origin_.x) * (px - obs.origin_.x) + (py - obs.origin_.y) * (py - obs.origin_.y)</span><br><span class="line">          + (pz - obs.origin_.z) * (pz - obs.origin_.z);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if the point is far enough away... we won&#x27;t consider it</span></span><br><span class="line">      <span class="keyword">if</span> (sq_dist &gt;= sq_obstacle_range)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">ROS_DEBUG</span>(<span class="string">&quot;The point is too far away&quot;</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// now we need to compute the map coordinates for the observation</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> mx, my;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">worldToMap</span>(px, py, mx, my))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">ROS_DEBUG</span>(<span class="string">&quot;Computing map coords failed&quot;</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> index = <span class="built_in">getIndex</span>(mx, my);</span><br><span class="line">      costmap_[index] = LETHAL_OBSTACLE;</span><br><span class="line">      <span class="built_in">touch</span>(px, py, min_x, min_y, max_x, max_y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">updateFootprint</span>(robot_x, robot_y, robot_yaw, min_x, min_y, max_x, max_y);</span><br></pre></td></tr></table></figure>
<p>对于多线雷达，<code>(pz - obs.origin_.z) * (pz - obs.origin_.z)</code>是0，可以考虑把这段去掉。 另外点云数据量比单线大了很多，在检测近处障碍的时候，计算<code>sq_dist</code>会得到很多点(虽然delta_z不是0)。单线雷达扫描的是一条线，多线其实是很多条线，但是代价地图是2D的，投影会有很多重复的，需要针对xy去重，显著降低了效率，这又是<code>costmap_2d</code>不适合多线雷达的一个例子。 另外这里就是参数<code>obstacle_range</code>出现的地方。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/14/%E5%9F%BA%E4%BA%8EUWB%E7%9A%84%E8%B7%9F%E9%9A%8F%E5%AF%BC%E8%88%AA/4.%20%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88/">(四) 数据融合</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E4%BA%8EUWB%E7%9A%84%E8%B7%9F%E9%9A%8F%E5%AF%BC%E8%88%AA/">基于UWB的跟随导航</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2021/11/14/%E5%9F%BA%E4%BA%8EUWB%E7%9A%84%E8%B7%9F%E9%9A%8F%E5%AF%BC%E8%88%AA/4.%20%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/13/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/%E9%9A%9C%E7%A2%8D%E5%B1%824%20%20%E9%9A%9C%E7%A2%8D%E5%B1%82%E7%9A%84UpdateBounds/">障碍层4  障碍层的updateBounds</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content"><p>代码流程比较复杂: <code>Costmap2DROS::mapUpdateLoop</code> —— <code>Costmap2DROS::updateMap()</code> —— <code>LayeredCostmap::updateMap</code>—— 每一层的 <code>updateBounds</code></p>
<h2 id="mapUpdateLoop"><a href="#mapUpdateLoop" class="headerlink" title="mapUpdateLoop"></a>mapUpdateLoop</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Costmap2DROS::mapUpdateLoop</span><span class="params">(<span class="keyword">double</span> frequency)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (frequency == <span class="number">0.0</span>)		<span class="keyword">return</span>;</span><br><span class="line">  ros::NodeHandle  nh;</span><br><span class="line">  <span class="function">ros::Rate  <span class="title">r</span><span class="params">(frequency)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (nh.<span class="built_in">ok</span>() &amp;&amp; !map_update_thread_shutdown_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">start_t</span>, <span class="keyword">end_t</span>, t_diff;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">updateMap</span>();</span><br><span class="line">    <span class="comment">// 目前的时间用tv 结构体返回</span></span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">start_t</span> = start.tv_sec + <span class="built_in"><span class="keyword">double</span></span>(start.tv_usec) / <span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">end_t</span> = end.tv_sec + <span class="built_in"><span class="keyword">double</span></span>(end.tv_usec) / <span class="number">1e6</span>;</span><br><span class="line">    t_diff = <span class="keyword">end_t</span> - <span class="keyword">start_t</span>;</span><br><span class="line">    <span class="built_in">ROS_DEBUG</span>(<span class="string">&quot;Map update time: %.9f&quot;</span>, t_diff);</span><br><span class="line">    <span class="keyword">if</span> (publish_cycle.<span class="built_in">toSec</span>() &gt; <span class="number">0</span> &amp;&amp; layered_costmap_-&gt;<span class="built_in">isInitialized</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> x0, y0, xn, yn;</span><br><span class="line">      layered_costmap_-&gt;<span class="built_in">getBounds</span>(&amp;x0, &amp;xn, &amp;y0, &amp;yn);</span><br><span class="line">       <span class="comment">// publisher_ 是 Costmap2DPublisher</span></span><br><span class="line">      publisher_-&gt;<span class="built_in">updateBounds</span>(x0, xn, y0, yn);</span><br><span class="line"></span><br><span class="line">      ros::Time now = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">      <span class="keyword">if</span> (last_publish_ + publish_cycle &lt; now)</span><br><span class="line">      &#123;</span><br><span class="line">        publisher_-&gt;<span class="built_in">publishCostmap</span>();</span><br><span class="line">        last_publish_ = now;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r.<span class="built_in">sleep</span>();</span><br><span class="line">    <span class="comment">// make sure to sleep for the remainder of our cycle time</span></span><br><span class="line">    <span class="keyword">if</span> (r.<span class="built_in">cycleTime</span>() &gt; ros::<span class="built_in">Duration</span>(<span class="number">1</span> / frequency))</span><br><span class="line">      <span class="built_in">ROS_WARN</span>(<span class="string">&quot;Map update loop missed its desired rate of %.4fHz... the loop actually took %.4f seconds&quot;</span>, frequency,  r.<span class="built_in">cycleTime</span>().<span class="built_in">toSec</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="updateMap"><a href="#updateMap" class="headerlink" title="updateMap"></a>updateMap</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Costmap2DROS::updateMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!stop_updates_)</span><br><span class="line">  &#123;</span><br><span class="line">	tf::Stamped &lt; tf::Pose &gt; pose;</span><br><span class="line">	<span class="comment">//得到global_frame_ 与 robot_base_frame_ tf</span></span><br><span class="line">	<span class="comment">// 转换信息中的 translation 坐标信息</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getRobotPose</span> (pose))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//获取当前机器人位置，必须要弄清楚这个x，y 代表什么意思</span></span><br><span class="line">      <span class="keyword">double</span> x = pose.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>(),</span><br><span class="line">      y = pose.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(),</span><br><span class="line">      yaw = tf::<span class="built_in">getYaw</span>(pose.<span class="built_in">getRotation</span>());</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/*调用LayeredCostmap 类中的updateMap 更新边界和cost值</span></span><br><span class="line"><span class="comment">		* 先依据各层的更新情况，判断地图更新过的范围的边界。</span></span><br><span class="line"><span class="comment">		* 然后用初始值重置全局地图更新边界范围内的地图信息，</span></span><br><span class="line"><span class="comment">		* 并用各层的信息在更新边界内部更新地图信息</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">      layered_costmap_-&gt;<span class="built_in">updateMap</span>(x, y, yaw);</span><br><span class="line"> </span><br><span class="line">      geometry_msgs::PolygonStamped footprint;</span><br><span class="line">      footprint.header.frame_id = global_frame_;</span><br><span class="line">      footprint.header.stamp = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">      <span class="built_in">transformFootprint</span>(x, y, yaw, padded_footprint_, footprint);</span><br><span class="line">      footprint_pub_.<span class="built_in">publish</span>(footprint);</span><br><span class="line">      initialized_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Costmap2DROS::getRobotPose</span><span class="params">(tf::Stamped&lt;tf::Pose&gt;&amp; global_pose)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//local_costmap和global_costmap的robot_base_frame_都是/base_footprint</span></span><br><span class="line">  robot_pose.frame_id_ = robot_base_frame_;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *如果是local_costmap,global_frame_是/map</span></span><br><span class="line"><span class="comment">    * 如果是global_costmap 是/odom_combined</span></span><br><span class="line"><span class="comment">    * 然后根据tf信息，转换的到global_pose，即机器人当前位置 </span></span><br><span class="line"><span class="comment">    *得到global_frame_ 与robot_base_frame_ tf转换信息中的 translation 坐标信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    tf_.<span class="built_in">transformPose</span>(global_frame_, robot_pose, global_pose);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就只看障碍层的<code>updateBounds</code>函数。这个函数主要完成 clearing, marking以及确定bound。和静态地图类似，同样也是先判断是否是rolling地图，若是则更新地图原点。</p>
<p><img src="https://i.loli.net/2021/11/28/vurPkGCXg6LanSE.png" alt=""><br>点云数据最终传到<code>const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cloud = *(obs.cloud_);</code>  点云z坐标在计算<code>sq_dist</code>之后就不处理了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObstacleLayer::updateBounds</span><span class="params">(<span class="keyword">double</span> robot_x, <span class="keyword">double</span> robot_y, </span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">double</span> robot_yaw, <span class="keyword">double</span>* min_x, <span class="keyword">double</span>* min_y, </span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">double</span>* max_x,  <span class="keyword">double</span>* max_y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (rolling_window_)</span><br><span class="line">    <span class="built_in">updateOrigin</span>(robot_x - <span class="built_in">getSizeInMetersX</span>() / <span class="number">2</span>, </span><br><span class="line">    			 robot_y - <span class="built_in">getSizeInMetersY</span>() / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (!enabled_)   <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">useExtraBounds</span>(min_x, min_y, max_x, max_y);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> current = <span class="literal">true</span>;</span><br><span class="line">  std::vector&lt;Observation&gt; observations, clearing_observations;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get the marking observations</span></span><br><span class="line">  current = current &amp;&amp; <span class="built_in">getMarkingObservations</span>(observations);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get the clearing observations</span></span><br><span class="line">  current = current &amp;&amp; <span class="built_in">getClearingObservations</span>(clearing_observations);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// update the global current status</span></span><br><span class="line">  current_ = current;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// raytrace freespace</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clearing_observations.<span class="built_in">size</span>(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="built_in">raytraceFreespace</span>(clearing_observations[i], min_x, min_y, max_x, max_y);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>清除和添加障碍在后面的文章继续</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/13/%E5%9F%BA%E4%BA%8EUWB%E7%9A%84%E8%B7%9F%E9%9A%8F%E5%AF%BC%E8%88%AA/3.%20%E8%B7%9F%E9%9A%8F%E5%AF%BC%E8%88%AA%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/">(三) 跟随导航中的问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E4%BA%8EUWB%E7%9A%84%E8%B7%9F%E9%9A%8F%E5%AF%BC%E8%88%AA/">基于UWB的跟随导航</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2021/11/13/%E5%9F%BA%E4%BA%8EUWB%E7%9A%84%E8%B7%9F%E9%9A%8F%E5%AF%BC%E8%88%AA/3.%20%E8%B7%9F%E9%9A%8F%E5%AF%BC%E8%88%AA%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/#more">Read more</a><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/49/">49</a><a class="extend next" rel="next" href="/page/3/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/07/13/RCLw5Bx8aFPN74b.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>