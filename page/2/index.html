<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">496</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">45</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/02/18/exLTfbM3uFOq5SV.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/11/Matlab/Matlab%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5/">Matlab中的矩阵</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Matlab/">Matlab</a></span><div class="content"><h2 id="定义矩阵"><a href="#定义矩阵" class="headerlink" title="定义矩阵"></a>定义矩阵</h2><p><code>a=[1,2,3; 4,5,6]</code>是一个2×3的矩阵<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p><code>matrix = [1;2;3;4;5]</code> 是5x1的矩阵，  <code>matrix = [1,2,3,4,5]</code>是1x5的矩阵</p>
<p><code>matrix = [1,2,3,4,5]&#39;</code> 是做了转置，结果是5x1的矩阵</p>
<p><code>matrix(:, 1)</code>是矩阵的第一列<br><br></p>
<ul>
<li><p>zeros(m,n): 生成一个 m 行 n 列的零矩阵，m=n 时可简写为 <code>zeros(n)</code></p>
</li>
<li><p>ones(m,n): 生成一个 m 行 n 列的元素全为 1 的矩阵， 当m=n 时可写为 <code>ones(n)</code></p>
</li>
<li><p>eye(m,n): 生成一个主对角线全为 1 的 m 行 n 列矩阵， m=n 时可简写为 <code>eye(n)</code>，即为 n 维单位矩阵</p>
</li>
<li><p>rand(m,n): 产生 <code>0～1</code> 间均匀分布的随机矩阵， m=n 时简写为 <code>rand(n)</code></p>
</li>
<li><p>randn(m,n): 产生均值为0，方差为1的标准正态分布矩阵，m=n 时简写为 <code>randn(n)</code></p>
</li>
</ul>
<p><code>zeros(m, n)</code>中的n可以为0，此时矩阵实际是空。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">matrix = zeros(<span class="number">5</span>,<span class="number">0</span>)</span><br><span class="line">matrix = [matrix, [<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>;<span class="number">4</span>;<span class="number">5</span>] ]</span><br><span class="line">matrix = [matrix, [<span class="number">11</span>;<span class="number">12</span>;<span class="number">13</span>;<span class="number">14</span>;<span class="number">15</span>] ]</span><br></pre></td></tr></table></figure><br>最终matrix是5x2的矩阵，也就是逐步扩展<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>    <span class="number">11</span></span><br><span class="line"><span class="number">2</span>    <span class="number">12</span></span><br><span class="line"><span class="number">3</span>    <span class="number">13</span></span><br><span class="line"><span class="number">4</span>    <span class="number">14</span></span><br><span class="line"><span class="number">5</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/09/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%BC%A0%E6%A5%AB%E7%9A%84autonomous_exploration/%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB%20Autonomous%20Exploration%20Development%20Environment%20and%20the%20Planning%20Algorithms/">论文解读 Autonomous Exploration Development Environment and the Planning Algorithms</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/CMU%E7%9A%84autonomous-exploration/">CMU的autonomous_exploration</a></span><div class="content"><p>这篇论文发表于2021.10，大部分内容在官网上，对一些重点内容做一下记录。</p>
<h2 id="I-INTRODUCTION"><a href="#I-INTRODUCTION" class="headerlink" title="I. INTRODUCTION"></a>I. INTRODUCTION</h2><p>算法框架包括探索算法<code>TARE</code> (<code>exploration planner</code>)；  路径算法<code>FAR</code> (<code>route planner</code>)</p>
<p>我们的算法不依赖只有仿真才提供的信息，比如 semantic and terrain segmentation groundtruth. 算法是为了让用户重点开发上层的规划算法。</p>
<p>在2021 DARPA地下挑战赛中， CMU-OSU Team Explorer 虽然没拿到冠军，但获得”探索最多区域奖“(26 out of 28 sectors).</p>
<h2 id="II-RELATED-WORK"><a href="#II-RELATED-WORK" class="headerlink" title="II. RELATED WORK"></a>II. RELATED WORK</h2><p>For <font size="4" color="blue">outdoor settings </font>, the most well-known dataset is <code>KITTI Vision Benchmark Dataset</code> [4] collected<br>from a self-driving suite in road driving scenarios. The<br>dataset contains sensor data from stereo cameras, 3D Lidar,<br>and GPS/INS ground truth for benchmarking depth reconstruction, odometry estimation, object segmentation, etc. </p>
<p>For <font size="4" color="blue">localization purposes, </font> the long-term localization benchmark includes a comprehensive list of datasets :  Aachen Day-Night dataset, Extended CMU Seasons dataset, RobotCar Seasons dataset, and SILDa Weather and Time of Day dataset. </p>
<font size="4" color="blue">For indoor navigation </font>, iGibson [15], [16], Sapien [17], AI2Thor [18], Virtual Home [19], ThreeDWorld [20], MINOS [21], House3D [22] and CHALET [23] use synthetic scenes, while reconstructed scenes are also available in iGibson, AI Habitatand MINOS. Compared to datasets, simulation environments have the advantage of providing access to ground truth data, e.g. vehicle pose and semantic segmentation to simplify the algorithm development and allowing full navigation system tests in closed control loop。

For <font size="4" color="blue"> indoor scenes</font>, datasets such as NYUDepth dataset [7], TUM SLAM dataset [8], inLoc dataset [9], MIT Stata center dataset, and KTH-INDOL dataset [11], [12] are available. Datasets are useful in developing and

<font size="4" color="blue">Simulation environments </font>: Carla [13] and AirSim [14] are two representative simulation environments for autonomous driving and flying. These simulators support various conditions such as lighting and weather changes, moving objects such as pedestrians, and incident scenes.


其他的导航框架:  ROS Navigation Stack 和港科大的 fast_planner ，不过是针对无人机的。

我们的导航框架: 支持photorealistic house models from Matterport3D 以及向AI Habitat提供接口。这两个在机器人学和计算视觉中应用很多。Users are provided with scan data and RGB, depth, and semantic images rendered by AI Habitat. Users have the option of running AI Habitat side by side with our system or in post-processing.

![](https://s2.loli.net/2022/02/09/VnzOjNr5Y7UQcsf.png)


参考：
[阅读笔记 《Matterport3D: Learning from RGB-D Data inIndoor Environments》](https://blog.csdn.net/ShuqiaoS/article/details/88361949)
[AI Habitat室内仿真平台使用](https://blog.csdn.net/weixin_43823054/article/details/106903128)

## III. DEVELOPMENT ENVIRONMENT

### Local Planner

`local planner`保证了到达目标时的安全，它预计算 a motion primitive library and associates the motion primitives to 车周围的3D locations(这里说的就是`free_paths`对应的曲线簇)。 <font size="4" color="blue"> The motion primitives are modeled as Monte Carlo samples and organized in groups </font>

<p>现实中快遇到障碍物时，<code>local planner</code>可以在几毫秒内判断出哪些 motion primitives 会和障碍相撞，然后从motion primitives中选出最可能朝向目标的一组。</p>
<p>The module also has interface to take in additional range data for collision avoidance as an extension option</p>
<h3 id="Terrain-Traversability-Analysis"><a href="#Terrain-Traversability-Analysis" class="headerlink" title="Terrain Traversability Analysis"></a>Terrain Traversability Analysis</h3><p>模块建立了一个代价地图，地图中的每一个点和一个traversal cost相关联. 代价值取决于 local smoothness of the terrain. </p>
<p>我们使用体素网格表示环境，分析 distributions of data points in adjacent voxels to 估计地面高度. The points are associated with higher traversal costs if they are further apart from the ground.</p>
<p>模块还能处理<code>negative obstacles</code>，这些障碍生成空区域with no data points on the terrain map. 如果开启了<code>negative obstacle</code>的处理，模块认为那些区域不可经过</p>
<h3 id="Visualization-and-Debugging-Tools"><a href="#Visualization-and-Debugging-Tools" class="headerlink" title="Visualization and Debugging Tools"></a>Visualization and Debugging Tools</h3><p>可视化算法的性能. 可视化工具显示地图，已探索区域，车的轨迹. Metrics包括 explored volume, traveling distance, and algorithm runtime are plotted and logged to files. </p>
<p>另外，支持手柄和导航交互，在多种操作模式之间切换 to ease the process of system debugging. </p>
<h2 id="IV-HIGH-LEVEL-PLANNERS"><a href="#IV-HIGH-LEVEL-PLANNERS" class="headerlink" title="IV. HIGH-LEVEL PLANNERS"></a>IV. HIGH-LEVEL PLANNERS</h2><h2 id="V-BEST-PRACTICES"><a href="#V-BEST-PRACTICES" class="headerlink" title="V. BEST PRACTICES"></a>V. BEST PRACTICES</h2><p>Safety margin: <code>local planner</code>使用车和<code>waypoint</code>之间的距离作为规划尺度(planning horizon)。即使<code>waypoint</code>很接近障碍，也可以让车到达。但是，如果车不能在<code>waypoint</code>停下，上层规划器倾向于让车到<code>waypoint</code>保持一定距离(默认≥<br>3.75m)。If the waypoint is closer, users can project the waypoint further away and keep the waypoint in the same direction w.r.t. the vehicle to fully use the safety margin. (这句话没理解什么意思)</p>
<p>但是，如果车需要经过窄通道，降低这一距离可以让<code>local planner</code>找到安全合适的路径。</p>
<p><strong>大转弯</strong>: Typically, a high-level planner selects the waypoint along the path that is a distance, namely look-ahead distance, ahead of the vehicle and sends the waypoint to the local planner (possibly after projecting the waypoint further away from the vehicle as discussed above).</p>
<p>When handling sharp turns (≥ 90 deg), the look-ahead distance needs to be properly set or the waypoint may jump to the back of the vehicle, causing the vehicle to osculate back-and-forth. We recommend to select the waypoint on the starting segment of the path that is in line-of-sight from the vehicle. </p>
<p><strong>动态障碍</strong>: <code>terrain analysis</code>模块在动态障碍走过之后，通过<code>ray-tracing</code>清除动态障碍。这是在车的附近范围实现的(到车的距离≤5m)， 因为雷达数据在远处比较稀疏，以及难以权衡清除动态障碍和thin structures之间的矛盾。 用户根据自己的情况来清除动态障碍，TARE和FAR都有这一步骤。</p>
<h2 id="VI-SYSTEM-INTEGRATION"><a href="#VI-SYSTEM-INTEGRATION" class="headerlink" title="VI. SYSTEM INTEGRATION"></a>VI. SYSTEM INTEGRATION</h2><h3 id="用于DARPA挑战赛的平台"><a href="#用于DARPA挑战赛的平台" class="headerlink" title="用于DARPA挑战赛的平台"></a>用于DARPA挑战赛的平台</h3><p><img src="https://s2.loli.net/2022/02/09/EijtMkq5SJKRN6s.png" alt=""><br>The state estimation module can detect and introduce loop closures. The module outputs state estimation in the odometry frame generated by 3D Lidar-based odometry containing accumulated drift. When loop closure is triggered, it outputs loop closure adjustments to globally relax the vehicle trajectory and corresponding maps. Loop closure adjustments are used by the high-level planners since they are in charge of planning at the global scale.</p>
<p>The local planner and terrain analysis modules are extended to handle complex terrains including negative obstacles such as cliffs, pits, and water puddles <font size="4" color="blue"> with a downward-looking depth sensor</font>. The TARE planner, FAR planner, and other planners (for stuck recovery, etc) are run in parallel for tasks such as exploration, go-to waypoint, and return home.</p>
<p>On top of these planners, behavior executive and multi-robot coordination modules are built specifically for the challenge. The modules share explored and unexplored areas across multirobots and call TARE and FAR planners cooperatively. In particular, when a long-distance transition is determined due to new areas containing artifacts are discovered or operator waypoints are received, the behavior executive switches to<br>FAR planner for relocating the vehicle. During the relocation, FAR planner uses a sparse roadmap merged from multi-robots for high-level guidance. After the relocation is complete, TARE planner takes place for exploration</p>
<p>DARPA最后决赛是在<code>Louisville Mega Cavern, KY</code>. 赛道包括隧道、urban、洞穴环境。我们的三台车使用<code>TARE</code> 和 <code>FAR</code>进行探索。<br><img src="https://s2.loli.net/2022/02/09/VmEYJnZG7OhgXzx.png" alt="DARPA Subterranean Challenge Final Competition"><br>红色轨迹：车先使用TARE一直探索到B，然后使用FAR经过C，一到达C，车换成TARE进行剩下的探索。</p>
<p>绿色轨迹：车只用TARE；蓝色轨迹：车先使用FAR经过A，在换成TARE进行之后的搜索。</p>
<p>三台车各行走596.6m, 499.8m, 445.2m。共花费时间2259s<br><img src="https://s2.loli.net/2022/02/09/G2aoUBhjF9tNWRi.png" alt="比赛地图，与上图一样"><br>这里只看论文不太明白，看实际视频才清楚。实际是两辆车和一架无人机进行探索。</p>
<h2 id="VII-EXTENDED-APPLICATION-EXAMPLES"><a href="#VII-EXTENDED-APPLICATION-EXAMPLES" class="headerlink" title="VII. EXTENDED APPLICATION EXAMPLES"></a>VII. EXTENDED APPLICATION EXAMPLES</h2><p>这部分我暂时用不到，就不研究了。</p>
<p>训练基于学习的探索和导航算法。大家可以使用我们的仿真平台作为专家系统(expert system)来训练基于学习的规划算法。专家系统里包含状态估计，局部避障，上层的探索或者路径规划算法。训练的对象可以是一些端对端的方法，比如只有一层深度网络的探索或者路径规划算法。</p>
<p>基于激光或者视觉的sim-to-real学习。大家可以用我们的仿真平台训练一些基于学习的方法，并将训练好的系统应用在现实世界中。因为我们提供了多个仿真世界以及支持来自Matterport3D的90个photorealistic环境模型，并且兼容AI Habitat的RGB，深度，和语义(Semantic)图像的渲染功能，所以不管是基于激光还是视觉的算法，大家都可以找到适用的环境模型，当然也可以根据需求换上自己的模型。举个简单的例子，需要做Semantic-in-loop导航的人可以使用我们提供的带有语义信息的环境，使用我们的地面机器人仿真平台，去训练他们的算法，并且在训练结束后，直接将算法移植到实际的机器人上。下面是我们的仿真机器人在Matterport3D的两个环境模型中导航的场景，用AI Habitat实时生成RGB，深度及语义图像。</p>
<p>开发人群导航(social navigation)算法。大家可以在我们的仿真环境中加入动态的障碍物或者行人，模拟真实环境中的社区场景，辅助开发人群导航算法，甚至可以在这种场景中预测动态物体的行为及其轨迹。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/08/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%BC%A0%E6%A5%AB%E7%9A%84autonomous_exploration/DSVP%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E8%BF%90%E8%A1%8C/">DSVP的介绍和运行</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/Dual-Stage-Viewpoint-Planner/">Dual-Stage Viewpoint Planner</a></span><div class="content"><p>Dual-Stage Viewpoint Planner 包含两个阶段：探索阶段用于扩展地图边界，重定位阶段用于 explicitly 把机器人传到环境中不同的子区域。探索阶段采用RRT，并动态地扩展RRT over replanning steps. 重定位阶段维护一个graph结构 through the mapped environment. 在探索过程中，算法在两个阶段来回切换，以探索整个环境。</p>
<h2 id="dsvp-launch-的使用"><a href="#dsvp-launch-的使用" class="headerlink" title="dsvp_launch 的使用"></a>dsvp_launch 的使用</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install ros-melodic-octomap-ros libgoogle-glog-dev libgflags-dev</span><br><span class="line"><span class="comment"># 取melodic分支</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/HongbiaoZ/dsv_planner.git</span><br></pre></td></tr></table></figure>
<p>编译结束后，运行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 车库仿真环境，可以换成其他的</span></span><br><span class="line">roslaunch vehicle_simulator system_garage.launch</span><br><span class="line">roslaunch dsvp_launch explore_garage.launch</span><br></pre></td></tr></table></figure></p>
<p>然后是<code>Matterport3D</code>环境的配置，先跳过：To run DSV Planner in a Matterport3D environment, follow instructions to setup the development environment to use the Matterport3D environment. Then, use the command lines below to launch the system and DSV Planner.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roslaunch vehicle_simulator system_matterport.launch</span><br><span class="line">roslaunch dsvp_launch explore_matterport.launch</span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/01/22/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%BC%A0%E6%A5%AB%E7%9A%84autonomous_exploration/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E6%A8%A1%E5%9D%97(%E4%B8%80)%20%E6%A6%82%E8%BF%B0/">路径规划模块(一) 概述</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-01-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/CMU%E7%9A%84autonomous-exploration/">CMU的autonomous_exploration</a></span><div class="content"><p><code>local_planner.launch</code>包括节点<code>localPlanner</code>和<code>pathFollower</code>，以及发布<code>sensor ---&gt; vehicle</code> 和 <code>sensor ---&gt; camera</code>的tf变换</p>
<ul>
<li><p>避障: 由<code>local_planner</code>实现. 程序一启动就先预生成 <code>Motion primitives</code>. <font size="4" color="blue"> The motion primitives are modeled as Monte Carlo samples and organized in groups </font> 现实中快遇到障碍物时，<code>local planner</code>可以在几毫秒内判断出哪些 motion primitives 会和障碍相撞，然后从motion primitives中选出最可能朝向目标的一组。 </p>
</li>
<li><p>Sending waypoints, navigation boundary, and speed:  一收到waypoint, navigation boundary, and speed 的消息, the system will navigate the vehicle inside the navigation boundary to the waypoint. 发送的<code>navigation boundary</code>和速度是可设置的，默认速度<code>2m/s</code>. 可以参考<code>waypoint_example</code>如何发送这些消息</p>
</li>
<li><p>Waypoint: 话题<code>way_point</code>，<code>geometry_msgs::PointStamped</code>类型的消息，在<code>map</code>坐标系。 发布者当然是<code>rvizGA</code> 和 <code>localPlanner</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">header: </span><br><span class="line">  seq: 6</span><br><span class="line">  stamp: </span><br><span class="line">    secs: 215</span><br><span class="line">    nsecs: 380000000</span><br><span class="line">  frame_id: <span class="string">&quot;map&quot;</span></span><br><span class="line">point: </span><br><span class="line">  x: 9.90468215942</span><br><span class="line">  y: 12.2474937439</span><br><span class="line">  z: 0.839443683624</span><br><span class="line">---</span><br><span class="line">header: </span><br><span class="line">  seq: 7</span><br><span class="line">  stamp: </span><br><span class="line">    secs: 215</span><br><span class="line">    nsecs: 380000000</span><br><span class="line">  frame_id: <span class="string">&quot;map&quot;</span></span><br><span class="line">point: </span><br><span class="line">  x: 9.90468215942</span><br><span class="line">  y: 12.2474937439</span><br><span class="line">  z: 0.839443683624</span><br></pre></td></tr></table></figure>
</li>
<li><p>Navigation boundary (optional): 话题<code>navigation_boundary</code>，<code>geometry_msgs::PolygonStamped</code>的消息， 在<code>map</code>坐标系。 <strong>默认没有发布</strong>，订阅者是<code>localPlanner</code></p>
</li>
</ul>
<p><code>system_real_robot.launch</code>中的部分：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find local_planner)/launch/local_planner.launch&quot;</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;cameraOffsetZ&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg cameraOffsetZ)&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;goalX&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg vehicleX)&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;goalY&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg vehicleY)&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这个launch其实就是<code>localPlanner</code> 和 <code>pathFollower</code>两个节点，再加两个tf转换<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;vehicleTransPublisher&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-$(arg sensorOffsetX) -$(arg sensorOffsetY) 0 0 0 0 /sensor /vehicle 1000&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sensorTransPublisher&quot;</span> <span class="attr">args</span>=<span class="string">&quot;0 0 $(arg cameraOffsetZ) -1.5707963 0 -1.5707963 /sensor /camera 1000&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>节点<code>localPlanner</code>一直在发布话题<code>path</code>，可以将源码中的宏<code>PLOTPATHSET</code>改为0，最好是做成ROS Param.</p>
<p>只有<code>path follower</code>会发布<code>cmd_vel</code>，在机器人前往目标点的过程中， local planner会不断的对比机器人当前位置和目标点位置的差距，根据这个差值去控制机器人的直线速度和转向速度，最终不断逼近目标点。</p>
<p>代码中常出现的<code>laserCloud</code>和<code>vehicleX</code>都是在<code>map</code>坐标系下</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/01/16/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%BC%A0%E6%A5%AB%E7%9A%84autonomous_exploration/%E7%A6%BB%E7%BA%BF%E7%9A%84%E5%89%8D%E5%90%91%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF%E5%92%8C%E4%BD%93%E7%B4%A0%E7%BD%91%E6%A0%BC/">离线的前向三次样条曲线和体素网格</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-01-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/CMU%E7%9A%84autonomous-exploration/">CMU的autonomous_exploration</a></span><div class="content"><p>Matlab文件<code>path_generator.m</code>的目的是生成3个ply文件和<code>correspondences.txt</code>。<strong>这里就是一个可优化的方向。</strong></p>
<p>生成的的是3个离线的曲线，也就是<code>local_planner\paths</code>的<code>startPaths.ply</code>, <code>pathList.ply</code>,  <code>paths.ply</code>。  这3个文件都在<code>localPlanner.cpp</code>的main函数里使用</p>
<p><code>startPaths.ply</code>文件的文件头<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ply</span><br><span class="line">format ascii 1.0</span><br><span class="line">element vertex 707  <span class="comment"># 点的总数</span></span><br><span class="line">property <span class="built_in">float</span> x</span><br><span class="line">property <span class="built_in">float</span> y</span><br><span class="line">property <span class="built_in">float</span> z</span><br><span class="line">property int group_id</span><br><span class="line">end_header</span><br></pre></td></tr></table></figure><br>然后是很多的点，形式是<code>0.842435 -0.113153 0.000000 2</code>，依次是x,y,z,索引。可以用<code>Cloud Compare</code>打开<br><img src="https://s2.loli.net/2021/12/28/kxCJTmw5UK4eF2L.png" alt="startPaths.ply"><br>记录第一次采样的路径点，7个路径组，每个有101个点。每个都是三次样条曲线，根据Matlab中设置的参数，对称的每条路径依次偏移9°，每条路径有101个点，即<code>0:0.01:1</code>，按说起始点都是<code>(0,0)</code>，也就是共用了原点，但是从<code>CloudCompare</code>里看，点数还是707，起点的y坐标相差很小很小，我认为这是Matlab的浮点数误差导致生成了7个起点<br><img src="https://s2.loli.net/2022/02/14/P34rJAH9CoIY1G7.png" alt=""><br>代码中对应函数<code>readStartPaths</code>：读取文件<code>startPaths.ply</code>，把其中的点都放入点云类型的变量<code>startPaths</code></p>
<p>同理还有<code>paths.ply</code><br><img src="https://s2.loli.net/2022/02/10/t7VxvmATp2GWKUI.png" alt="paths.ply"><br>记录三次采样生成的所有路径点，仔细数一数，共有7x7x7=343条路径(第二次采样的路径组分成的7个不应统计)，<font size="4" color="blue"> 这和论文里说的35x35=1225不同了。  </font>每条路径有301个点，最右边的点，也就是x最大的点是<code>(3, 0)</code>。最上方的点大约<code>(1.679, 2.486)</code><br>代码中对应函数<code>readPaths</code>: 读取文件<code>paths.ply</code>，把其中的点都放入点云类型的变量<code>paths</code>，但考虑 <code>pointSkipNum</code></p>
<p>后两段段还是三次样条曲线，但生成的方式有所改变，不再是简单的<code>1:0.01:2</code>的遍历，而是对角度做了一定比例的缩放，并不是偏移-54°，而是偏移-44.55°和-55.96°。公式比较复杂，就不深入研究了</p>
<p>以最下方的曲线为例，三段的最后一个点的坐标如下：<br><img src="https://s2.loli.net/2022/02/13/v3JQmqHXnSfpG1L.png" alt="第1段的最后一个点.png"><br><img src="https://s2.loli.net/2022/02/13/q4BlaTIzJQpuorP.png" alt="第2段的最后一个点.png"><br><img src="https://s2.loli.net/2022/02/13/OCSdraZbhDYkjTE.png" alt="第3段的最后一个点.png"></p>
<p><br></p>
<p><img src="https://s2.loli.net/2022/02/10/jspP6ISmKrEAYMQ.png" alt="pathList.ply"><br>该文件记录了每条路径的最后一个路径点，共7x7x7=343个点<br>代码中对应函数<code>readPathList</code>: 读取文件<code>pathList.ply</code>，只加入变量<code>pathList</code> 和 <code>endDirPathList</code></p>
<h2 id="体素网格的生成"><a href="#体素网格的生成" class="headerlink" title="体素网格的生成"></a>体素网格的生成</h2><p><code>path_generator.m</code>中的部分如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于碰撞检查，使用覆盖了传感器范围的体素网格。</span></span><br><span class="line"><span class="comment"># 根据样条距离，传感器范围为 3.2*4.5 ,在该区域生成体素网格，在这里考虑了车辆半径的遮挡</span></span><br><span class="line"></span><br><span class="line">voxelSize = <span class="number">0.02</span>;</span><br><span class="line">searchRadius = <span class="number">0.45</span>;</span><br><span class="line"><span class="comment"># 根据pathList的形状确定的尺寸，比模拟路径的范围稍大点</span></span><br><span class="line">offsetX = <span class="number">3.2</span>;</span><br><span class="line">offsetY = <span class="number">4.5</span>;</span><br><span class="line"><span class="comment"># offsetX / voxelSize</span></span><br><span class="line">voxelNumX = <span class="number">161</span>;</span><br><span class="line"><span class="comment"># 这里是 offsetY * 2 / voxelSize, 体素范围关于x轴对称</span></span><br><span class="line">voxelNumY = <span class="number">451</span>;</span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">&#x27;\nPreparing voxels\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">indPoint = <span class="number">1</span>;</span><br><span class="line">voxelPointNum = voxelNumX * voxelNumY;</span><br><span class="line"> <span class="comment"># 一个有很多行 只有2列的矩阵</span></span><br><span class="line">voxelPoints = zeros(voxelPointNum, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在外层循环中，从外向内计算，同采样的路径一样，靠近车体的位置Y的宽度也会随着scaleY减小</span></span><br><span class="line"><span class="keyword">for</span> indX = <span class="number">0</span> : voxelNumX - <span class="number">1</span></span><br><span class="line">    x = offsetX - voxelSize * indX;</span><br><span class="line">    scaleY = x / offsetX + searchRadius / offsetY * (offsetX - x) / offsetX;</span><br><span class="line">    <span class="keyword">for</span> indY = <span class="number">0</span> : voxelNumY - <span class="number">1</span></span><br><span class="line">        y = scaleY * (offsetY - voxelSize * indY);</span><br><span class="line"></span><br><span class="line">        voxelPoints(indPoint, <span class="number">1</span>) = x;</span><br><span class="line">        voxelPoints(indPoint, <span class="number">2</span>) = y;</span><br><span class="line">        </span><br><span class="line">        indPoint  = indPoint + <span class="number">1</span>;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有坐标都存到了 voxelPoints, zeros(voxelPointNum, 1)相当于扩展了一列 0</span></span><br><span class="line">plot3(voxelPoints(:, <span class="number">1</span>), voxelPoints(:, <span class="number">2</span>), zeros(voxelPointNum, <span class="number">1</span>), <span class="string">&#x27;k.&#x27;</span>);</span><br><span class="line">pause(<span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><br>其实这里很简单，逐个计算<code>voxelPoints</code>，发现它是下图，<code>x</code>是一个点，点的间距只有0.02<br><img src="https://s2.loli.net/2022/02/10/JOLMW2gTjBxmrSw.png" alt="voxelPoints的范围"></p>
<p>matlab运行结果得到 fig图 如下，如果放大，会发现是密密麻麻的点<br><img src="https://s2.loli.net/2022/02/11/smdMVRp6QIj1Czk.jpg" alt="体素网格.jpg"></p>
<p>再放大，会发现前向的模拟路径在里面<br><img src="https://s2.loli.net/2022/02/11/DTtvB93kHgVG7WJ.png" alt=""><br>之所以把体素建模为梯形而不是三角形，应该是在起始点考虑了车辆的宽度。</p>
<h2 id="correspondences表"><a href="#correspondences表" class="headerlink" title="correspondences表"></a>correspondences表</h2><p><code>correspondences.txt</code>在代码中的<code>readCorrespondences</code>函数使用</p>
<p><code>path_generator.m</code>中的代码如下：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fprintf(<span class="string">&#x27;\nCollision checking\n&#x27;</span>);</span><br><span class="line"><span class="comment"># rangesearch（X,Y,r）：寻找X集合中的点，其与 Y 集合中的点的距离小于r</span></span><br><span class="line"><span class="comment"># 这里就是寻找 paths 的点 和 体素集合中的点中小于搜索半径的点集合</span></span><br><span class="line"><span class="comment"># 记录路径点附近的所有体素网格</span></span><br><span class="line">[ind, dis] = rangesearch(pathAll(<span class="number">1</span> : <span class="number">2</span>, :)<span class="string">&#x27;, voxelPoints, searchRadius);</span></span><br><span class="line"><span class="string">    # ...... 剩余的省略</span></span><br></pre></td></tr></table></figure><br>直接看文件，每行第一个数是体素网格的索引，即<code>0~72610</code>。 每行最后一个数是-1，在<code>readCorrespondences</code>函数会看到这是作为判断该网格是否有对应的路径。  二者中间就是<code>pathList</code>的<code>pathID</code>，范围<code>0~342</code><br>程序运行时，路径被放置在体素中心的障碍物所遮挡。 在这里，考虑以车辆的半径来计算遮挡，当然不是Matlab里的0.45</p>
<p><img src="https://s2.loli.net/2022/02/12/YafdNoCnp6qQHU3.png" alt="放大后的体素网格和路径，最右边"><br>最右边的一堆体素网格没有任何路径，这就是txt文件中只有网格索引和-1的情况。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/01/12/SLAM%E5%B7%A5%E5%85%B7/Autoware%E5%AE%89%E8%A3%85/">Autoware安装</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-01-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SLAM%E5%B7%A5%E5%85%B7/">SLAM工具</a></span><div class="content"><p>主要参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhao5269/article/details/106827618">Ubuntu18.04下的源码安装和配置</a></p>
<p>需要先安装好 <code>ROS Melodic</code>, <code>Qt 5.12.0</code>(至少 5.9.5 版本), <code>OpenCV 4.0</code>（至少 3.0 版本），先不安装<br><code>CUDA 10.0</code></p>
<p>执行<code>sudo apt-get install ros-melodic-jsk-rviz-plugins</code>，避免一个报错</p>
<h2 id="安装-Autoware-1-14-0（至少1-12-0版本）"><a href="#安装-Autoware-1-14-0（至少1-12-0版本）" class="headerlink" title="安装 Autoware 1.14.0（至少1.12.0版本）"></a>安装 Autoware 1.14.0（至少1.12.0版本）</h2><p>先安装依赖项<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">sudo apt install -y python-catkin-pkg python-rosdep ros-<span class="variable">$ROS_DISTRO</span>-catkin</span><br><span class="line"></span><br><span class="line">sudo apt install -y python3-pip python3-colcon-common-extensions python3-setuptools python3-vcstool</span><br><span class="line"></span><br><span class="line">pip3 install -U setuptools</span><br></pre></td></tr></table></figure></p>
<p>再下载源码和依赖项<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p autoware.ai/src</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> autoware.ai</span><br><span class="line"></span><br><span class="line">wget -O autoware.ai.repos <span class="string">&quot;https://raw.githubusercontent.com/Autoware-AI/autoware.ai/1.12.0/autoware.ai.repos&quot;</span></span><br><span class="line"></span><br><span class="line">vcs import src &lt; autoware.ai.repos</span><br><span class="line"></span><br><span class="line">rosdep update</span><br><span class="line">rosdep install -y --from-paths src --ignore-src --rosdistro <span class="variable">$ROS_DISTRO</span></span><br></pre></td></tr></table></figure><br>因为网络问题可能下载失败，不过我已经下载好了源码，直接解压到src即可，这样就不用第三和第四步了。<br>执行最后一步时可能又有几个依赖项下载失败，也已经下载好了，解压<code>festival等5个依赖性.zip</code>后，逐个安装deb文件即可。之后继续执行最后一步，还需要几分钟才完成。</p>
<p>安装编译工具<code>colcon</code>:  <code>sudo apt install python3-colcon-common-extensions</code></p>
<p>然后就开始编译了， 若已经配置好了 CUDA<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AUTOWARE_COMPILE_WITH_CUDA=1 colcon build --cmake-args -DCMAKE_BUILD_TYPE=Release</span><br></pre></td></tr></table></figure><br>若没有CUDA支持，只使用 CPU：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colcon build --cmake-args -DCMAKE_BUILD_TYPE=Release</span><br></pre></td></tr></table></figure></p>
<p>如果<code>opencv</code>使用的是ROS的3.2，可能会出现三个报错<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">error: ‘CV_WINDOW_AUTOSIZE’ <span class="function">was <span class="keyword">not</span> declared in <span class="keyword">this</span> scope</span></span><br><span class="line"><span class="function">          <span class="title">cv::namedWindow</span><span class="params">(<span class="string">&quot;CameraSimulator Color Viewer&quot;</span>,CV_WINDOW_AUTOSIZE)</span></span>;</span><br><span class="line">                                                         ^~~~~~~~~~~~~~~~~~</span><br><span class="line">/home/user/autoware.ai/src/autoware/utilities/kitti_player/src/kitti_player.cpp:<span class="number">879</span>:<span class="number">60</span>: note: suggested alternative: ‘CV_MINOR_VERSION’</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法： 改为 1</span></span><br><span class="line"></span><br><span class="line">/home/user/autoware.ai/src/autoware/utilities/kitti_player/src/kitti_player.cpp:<span class="number">889</span>:<span class="number">60</span>: error: ‘CV_LOAD_IMAGE_UNCHANGED’ was <span class="keyword">not</span> declared in <span class="keyword">this</span> scope</span><br><span class="line">          cv_image00 = cv::<span class="built_in">imread</span>(full_filename_image00, CV_LOAD_IMAGE_UNCHANGED);</span><br><span class="line">这是由于opencv高版本弃用  CV_LOAD_IMAGE_UNCHANGED  这一参数导致的</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法： 改为 -1</span></span><br><span class="line"></span><br><span class="line">/home/user/autoware.ai/src/autoware/utilities/kitti_player/src/kitti_player.cpp:<span class="number">986</span>:<span class="number">60</span>: error: ‘  CV_LOAD_IMAGE_GRAYSCALE  ’ was <span class="keyword">not</span> declared in <span class="keyword">this</span> scope</span><br><span class="line">          cv_image04 = cv::<span class="built_in">imread</span>(full_filename_image04, CV_LOAD_IMAGE_GRAYSCALE);</span><br><span class="line"><span class="comment">// 解决方法： 改为 0</span></span><br></pre></td></tr></table></figure></p>
<p>继续编译会又有错误：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fatal error: opencv2/contrib/contrib.hpp: No such file or directory</span><br><span class="line">   <span class="comment">#include &lt;opencv2/contrib/contrib.hpp&gt;</span></span><br><span class="line"></span><br><span class="line">cmake -DOPENCV_EXTRA_MODULES_PATH=/home/user/autoware/opencv_contrib-4.x/modules &lt;opencv_source_directory&gt;</span><br></pre></td></tr></table></figure><br>这又是opencv的问题，所以最好还是安装opencv4.0</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/01/12/SLAM%E5%B7%A5%E5%85%B7/OpenCV%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%A4%9A%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/">OpenCV的安装和多版本切换</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-01-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SLAM%E5%B7%A5%E5%85%B7/">SLAM工具</a></span><div class="content"><ol>
<li><p>从OpenCV的github release下载，然后解压</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> opencv-4.2.0</span><br><span class="line">mkdir build  </span><br><span class="line"><span class="built_in">cd</span> build  </span><br><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span> ..  </span><br><span class="line">make</span><br><span class="line">sudo make install </span><br></pre></td></tr></table></figure>
<p>添加路径库 <code>sudo vim /etc/ld.so.conf.d/opencv.conf</code>，打开了一个新文档，在里面写入<code>/usr/local/lib</code> </p>
</li>
<li><p>配置环境变量<code>sudo vim /etc/profile</code>，在后面添加以下内容</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PKG_CONFIG_PATH=<span class="variable">$PKG_CONFIG_PATH</span>:/usr/<span class="built_in">local</span>/lib/pkgconfig  </span><br><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH  </span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>3.测试<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="comment"># opencv的源码目录</span></span><br><span class="line"><span class="built_in">cd</span> opencv/samples/cpp/example_cmake</span><br><span class="line">cmake .</span><br><span class="line">make</span><br><span class="line">./opencv_example</span><br></pre></td></tr></table></figure><br>如果弹出一个视频窗口，有文字hello,opencv，代表安装成功</p>
<ol>
<li>检查是否有多个OpenCV版本<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">locate libopencv_video.so</span><br><span class="line"></span><br><span class="line">/usr/lib/x86_64-linux-gnu/libopencv_video.so</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libopencv_video.so.3.2</span><br><span class="line">/usr/lib/x86_64-linux-gnu/libopencv_video.so.3.2.0</span><br><span class="line"></span><br><span class="line">/usr/<span class="built_in">local</span>/lib/libopencv_video.so</span><br><span class="line">/usr/<span class="built_in">local</span>/lib/libopencv_video.so.4.2</span><br><span class="line">/usr/<span class="built_in">local</span>/lib/libopencv_video.so.4.2.0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>如果你需要在Python3环境下使用OpenCV，那么<code>sudo pip3 install opencv-python</code>，python后不用加3。对于在Python环境中使用,比如说查看版本<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cyp@cyp:~$  python</span><br><span class="line">Python 3.6.7 (default, Oct 22 2018, 11:32:17) </span><br><span class="line">[GCC 8.2.0] on linux</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; import cv2 as cv</span><br><span class="line">&gt;&gt;&gt; cv.__version__</span><br><span class="line"><span class="string">&#x27;4.1.0&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在使用g++编译使用opencv的C++程序时，使用 <code>g++ &lt;cpp_code&gt; pkg-config opencv --libs --cflags opencv</code> 也可以使用cmake编译</p>
<ol>
<li>使用指定的版本</li>
</ol>
<p>在opencv编译好后，所在目录中一般会有一个叫OpenCVConfig.cmake的文件，这个文件中指定了CMake要去哪里找OpenCV，其.h文件在哪里等，比如其中一行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Provide the include directories to the caller </span></span><br><span class="line"><span class="built_in">set</span>(OpenCV_INCLUDE_DIRS <span class="string">&quot;/home/ubuntu/src/opencv-3.1.0/build&quot;</span> <span class="string">&quot;/home/ubuntu/src/opencv-3.1.0/include&quot;</span> <span class="string">&quot;/home/ubuntu/src/opencv-3.1.0/include/opencv&quot;</span>) </span><br></pre></td></tr></table></figure><br>只要让CMake找到这个文件，这个文件就指定了Opencv的所有路径，因此设置OpenCV_DIR为包含OpenCVConfig.cmake的目录，如在C++工程CMakeLists.txt中添加:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(OpenCV_DIR <span class="string">&quot;/home/ubuntu/src/opencv-3.1.0/build&quot;</span>)</span><br></pre></td></tr></table></figure><br>因此，我们期望使用哪个版本的Opencv，只要找到对应的OpenCVConfig.cmake文件，并且将其路径添加到工程的CMakeLists.txt中即可了。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/12/27/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%BC%A0%E6%A5%AB%E7%9A%84autonomous_exploration/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E6%A8%A1%E5%9D%97(%E4%B8%89)%20pathFollower/">路径规划模块(三) pathFollower</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-12-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/CMU%E7%9A%84autonomous-exploration/">CMU的autonomous_exploration</a></span><div class="content"><h2 id="话题"><a href="#话题" class="headerlink" title="话题"></a>话题</h2><p><code>joy</code>话题类型是<code>sensor_msgs/Joy</code>，发布者<code>rvizGA</code>，订阅者有:</p>
<ul>
<li>pathFollower</li>
<li>terrainAnalysisExt</li>
<li>localPlanner</li>
<li>terrainAnalysis</li>
</ul>
<p>Rviz上发布<code>waypoint</code>后，得到的<code>joy</code>消息，而且每次是相同的：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">header:</span><br><span class="line">  seq: 0</span><br><span class="line">  stamp:</span><br><span class="line">    secs: 1640595487</span><br><span class="line">    nsecs: 707291876</span><br><span class="line">  frame_id: <span class="string">&quot;waypoint_tool&quot;</span></span><br><span class="line">axes: [0.0, 0.0, -1.0, 0.0, 1.0, 1.0, 0.0, 0.0]</span><br><span class="line">buttons: [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]</span><br></pre></td></tr></table></figure></p>
<p>查看<code>joystickHandler</code>函数，发现<code>joySpeed</code> 和 <code>joySpeedRaw</code> 都会被赋值为 1</p>
<p>话题<code>speed</code>也没有发布者，提供给用户，类型<code>std_msgs::Float32</code>，订阅者是<code>pathFollower</code>和<code>localPlanner</code>，目前看不出使用的必要。  </p>
<p>话题<code>stop</code>提供给用户，用于停止车的行走，类型<code>std_msgs::Int8</code></p>
<p><code>vehicleSpeed</code>逐步增加，也就是说输出速度是逐渐增加的</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/12/19/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%BC%A0%E6%A5%AB%E7%9A%84autonomous_exploration/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E6%A8%A1%E5%9D%97(%E5%9B%9B)%20local%20planner%E6%89%80%E7%94%A8%E5%8F%82%E6%95%B0/">路径规划模块(四) local planner所用参数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-12-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/CMU%E7%9A%84autonomous-exploration/">CMU的autonomous_exploration</a></span><div class="content"><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">string pathFolder;     <span class="comment">//  使用matlab生成路径集合的文件路径</span></span><br><span class="line"><span class="keyword">double</span> vehicleLength = <span class="number">0.9</span>;        <span class="comment">//  车辆的长度，单位m</span></span><br><span class="line"><span class="keyword">double</span> vehicleWidth = <span class="number">0.6</span>;         <span class="comment">//  车辆的宽度，单位m</span></span><br><span class="line"><span class="keyword">double</span> sensorOffsetX = <span class="number">0</span>;          <span class="comment">//  传感器坐标系与车体中心的偏移量</span></span><br><span class="line"><span class="keyword">double</span> sensorOffsetY = <span class="number">0</span>;          <span class="comment">//  传感器坐标系与车体中心的偏移量</span></span><br><span class="line"><span class="keyword">bool</span> twoWayDrive = <span class="literal">true</span>;           <span class="comment">//  双向驱动</span></span><br><span class="line"><span class="keyword">double</span> laserVoxelSize = <span class="number">0.05</span>;      <span class="comment">//  降采样体素栅格叶大小</span></span><br><span class="line"><span class="keyword">double</span> terrainVoxelSize = <span class="number">0.2</span>;     <span class="comment">//  降采样体素栅格叶大小</span></span><br><span class="line"><span class="keyword">bool</span> useTerrainAnalysis = <span class="literal">false</span>;   <span class="comment">//  是否使用地面分割后的点云信息</span></span><br><span class="line"><span class="keyword">bool</span> checkObstacle = <span class="literal">true</span>;          </span><br><span class="line"><span class="keyword">bool</span> checkRotObstacle = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">double</span> adjacentRange = <span class="number">3.5</span>;        <span class="comment">//  裁剪点云时的距离</span></span><br><span class="line"><span class="keyword">double</span> obstacleHeightThre = <span class="number">0.2</span>;   <span class="comment">//  障碍物高度阈值, 调整以account for terrain cloud thickness</span></span><br><span class="line"><span class="keyword">double</span> groundHeightThre = <span class="number">0.1</span>;     <span class="comment">//  地面高度阈值</span></span><br><span class="line"><span class="keyword">double</span> costHeightThre = <span class="number">0.1</span>;       <span class="comment">//  计算路径惩罚得分的权重</span></span><br><span class="line"><span class="keyword">double</span> costScore = <span class="number">0.02</span>;           <span class="comment">//  最小惩罚得分</span></span><br><span class="line"><span class="keyword">bool</span> useCost = <span class="literal">false</span>;   </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> laserCloudStackNum = <span class="number">1</span>;   <span class="comment">// 缓存的激光点云帧数量</span></span><br><span class="line"><span class="keyword">int</span> laserCloudCount = <span class="number">0</span>;            <span class="comment">// 当laserCloudStackNum = 1时,暂时没用到</span></span><br><span class="line"><span class="keyword">int</span> pointPerPathThre = <span class="number">2</span>;     <span class="comment">// 每条路径需要有几个被遮挡的点</span></span><br><span class="line"><span class="keyword">double</span> minRelZ = - <span class="number">0.5</span>;        <span class="comment">// 未使用地面分割时，裁剪点云时的最小高度</span></span><br><span class="line"><span class="keyword">double</span> maxRelZ = <span class="number">0.25</span>;      <span class="comment">// 未使用地面分割时，裁剪点云时的最大高度</span></span><br><span class="line"><span class="keyword">double</span> maxSpeed = <span class="number">1.0</span>;      <span class="comment">// 最大速度</span></span><br><span class="line"><span class="keyword">double</span> dirWeight = <span class="number">0.02</span>;    <span class="comment">// 计算得分时转向角度的权重</span></span><br><span class="line"><span class="keyword">double</span> dirThre = <span class="number">90.0</span>;              <span class="comment">// 最大转向角度</span></span><br><span class="line"><span class="keyword">bool</span> dirToVehicle = <span class="literal">false</span>;          <span class="comment">// 是否以车辆为主方向计算被遮挡的路径</span></span><br><span class="line"><span class="keyword">double</span> pathScale = <span class="number">1.0</span>;      <span class="comment">// 路径尺度</span></span><br><span class="line"><span class="keyword">double</span> minPathScale = <span class="number">0.75</span>;         <span class="comment">// 最小路径尺度</span></span><br><span class="line"><span class="keyword">double</span> pathScaleStep = <span class="number">0.25</span>;        <span class="comment">// 路径尺度的调整步长</span></span><br><span class="line"><span class="keyword">bool</span> pathScaleBySpeed = <span class="literal">true</span>;       <span class="comment">// 是否根据速度调整路径尺度</span></span><br><span class="line"><span class="keyword">double</span> minPathRange = <span class="number">1.0</span>;          <span class="comment">// 最小路径距离</span></span><br><span class="line"><span class="keyword">double</span> pathRangeStep = <span class="number">0.5</span>;         <span class="comment">// 路径范围的调整步长</span></span><br><span class="line"><span class="keyword">bool</span> pathRangeBySpeed = <span class="literal">true</span>;       <span class="comment">// 是否根据速度调整路径的范围</span></span><br><span class="line"><span class="keyword">bool</span> pathCropByGoal = <span class="literal">true</span>;         <span class="comment">// 是否根据目标点+ goalClearRange 筛选点云数据</span></span><br><span class="line"><span class="keyword">bool</span> autonomyMode = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">double</span> autonomySpeed = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">double</span> goalClearRange = <span class="number">0.5</span>;        <span class="comment">// 当 pathCropByGoal = true 时,点云距离超过目标点+该值则不被处理</span></span><br><span class="line"><span class="keyword">double</span> goalX = <span class="number">0</span>;        <span class="comment">// 局部路径目标点</span></span><br><span class="line"><span class="keyword">double</span> goalY = <span class="number">0</span>;        <span class="comment">// 局部路径目标点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 离线路径的参数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> pathNum = <span class="number">343</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> groupNum = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">float</span> gridVoxelSize = <span class="number">0.02</span>;</span><br><span class="line"><span class="keyword">float</span> searchRadius = <span class="number">0.45</span>;</span><br><span class="line"><span class="keyword">float</span> gridVoxelOffsetX = <span class="number">3.2</span>;</span><br><span class="line"><span class="keyword">float</span> gridVoxelOffsetY = <span class="number">4.5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> gridVoxelNumX = <span class="number">161</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> gridVoxelNumY = <span class="number">451</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> gridVoxelNum = gridVoxelNumX * gridVoxelNumY;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/12/16/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%BC%A0%E6%A5%AB%E7%9A%84autonomous_exploration/5.%20terrain_analysis/">(五) terrain_analysis</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-12-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/CMU%E7%9A%84autonomous-exploration/">CMU的autonomous_exploration</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2021/12/16/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%BC%A0%E6%A5%AB%E7%9A%84autonomous_exploration/5.%20terrain_analysis/#more">Read more</a><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/50/">50</a><a class="extend next" rel="next" href="/page/3/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/02/18/exLTfbM3uFOq5SV.png)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>