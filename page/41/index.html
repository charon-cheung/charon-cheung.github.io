<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">554</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">49</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2024/11/12/x1aqcwUG3XDiskN.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/12/Matlab/Matlab%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/">Matlab常用操作</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Matlab/">Matlab</a></span><div class="content"><h2 id="matlab执行dos命令"><a href="#matlab执行dos命令" class="headerlink" title="matlab执行dos命令"></a>matlab执行dos命令</h2><p>dos函数： <code>dos(&#39;ping 192.168.0.109&#39;)</code></p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% ii  ---循环变量，也就是循环次数</span><br><span class="line">clc;clear;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ii = <span class="number">1</span>:<span class="number">10</span> </span><br><span class="line">  fprintf(<span class="string">&#x27;value of a: %d\n&#x27;</span>, ii);</span><br><span class="line">end</span><br><span class="line">  fprintf(<span class="string">&#x27;跳出循环后，value of a: %d\n&#x27;</span>, ii);</span><br></pre></td></tr></table></figure>
<p>控制表达式产生了一个1ⅹ10数组，所以语句1到n将会被重复执行10次。注意在循环体在最后一次执行后，循环系数将会一直为10。</p>
<h3 id="randn-和-rand-函数"><a href="#randn-和-rand-函数" class="headerlink" title="randn 和 rand 函数"></a>randn 和 rand 函数</h3><p>randn：产生正态分布的随机数或矩阵的函数</p>
<p>randn：产生均值为0，方差σ^2 = 1，标准差σ = 1的正态分布的随机数或矩阵的函数。</p>
<ul>
<li><p>Y = randn(n)：返回一个<code>n*n</code>的随机项的矩阵。如果n不是个数量，将返回错误信息。 <font size="4" color="blue"> n可以是0，此时为空矩阵  </font></p>
</li>
<li><p>Y = randn(m,n) 或 Y = randn([m n])： 返回一个<code>m*n</code>的随机项矩阵。</p>
</li>
</ul>
<p>产生一个随机分布的指定均值和方差的矩阵：将randn产生的结果乘以标准差，然后加上期望均值即可。例如：产生均值为0.6，方差为0.1的一个<code>5*5</code>的随机数方式如下：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">.6</span> + sqrt(<span class="number">0.1</span>) * randn(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p><strong>rand函数</strong>产生由在<code>(0, 1)</code>之间均匀分布的随机数组成的数组</p>
<ul>
<li><p>Y = rand(n):  返回一个<code>n*n</code>的随机矩阵如果n不是数量，则返回错误信息</p>
</li>
<li><p>Y = rand(m,n) 或 Y = rand([m n]):  返回一个m x n的随机矩阵</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/09/%E6%BF%80%E5%85%89SLAM/%E9%9B%B7%E8%BE%BE/laser_filters/">laser_filters</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/%E9%9B%B7%E8%BE%BE/">雷达</a></span><div class="content"><p><code>scan_tools</code>提供了一系列用于激光SLAM的工具,在github的分支只到indigo,所以无法从ros直接安装,但可以编译源码安装. 其中重要的有:</p>
<ul>
<li><p><strong>laser_scan_matcher</strong>: an incremental laser scan matcher, using Andrea Censi’s Canonical Scan Matcher implementation. It downloads and installs Andrea Censi’s Canonical Scan Matcher [1] locally.</p>
</li>
<li><p><strong>scan_to_cloud_converter</strong>: converts LaserScan to PointCloud messages.</p>
</li>
</ul>
<h2 id="laser-filters-过滤雷达数据"><a href="#laser-filters-过滤雷达数据" class="headerlink" title="laser_filters 过滤雷达数据"></a>laser_filters 过滤雷达数据</h2><p>过滤器的机制和代价地图是类似的，节点<code>scan_to_scan_filter_chain</code>相当于代价地图，每一个filter相当于地图的每一层，通过加载yaml而加载filter。</p>
<p>以range过滤器为例，修改<code>range_filter.yaml</code>如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scan_filter_chain:</span><br><span class="line">- name: box_filter</span><br><span class="line">  <span class="built_in">type</span>: laser_filters/LaserScanRangeFilter</span><br><span class="line">  params:</span><br><span class="line">    <span class="comment"># use_message_range_limits: false   # if not specified defaults to false</span></span><br><span class="line">    lower_threshold: 0.18  <span class="comment"># 默认0</span></span><br><span class="line">    upper_threshold: 0.22  <span class="comment"># 默认100000.0</span></span><br><span class="line">    lower_replacement_value: 0    <span class="comment"># 默认 NaN</span></span><br><span class="line">    upper_replacement_value: 999  <span class="comment"># 默认 NaN</span></span><br></pre></td></tr></table></figure><br>运行launch: <code>roslaunch laser_filters range_filter_example.launch</code>，里面就是节点<code>scan_to_scan_filter_chain</code>和yaml文件</p>
<p>结果查看<code>scan_filtered</code>话题，只显示出<code>0.18~0.22</code>距离的数据，太小的显示为0，太大的显示为999.</p>
<p>又比如使用<code>LaserScanAngularBoundsFilter</code>，只取-45°~45°内的scan，结果如下，<font color = blue size=4>要把laser坐标系的x轴放到水平向右的方向观察 </font>：</p>
<p><img src="https://i.loli.net/2020/07/28/JTmPLzMGa3OeuoB.png" alt="-45°至45°.png"></p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/fantasysolo/article/details/80732014?utm_medium=distribute.pc_feed_404.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_feed_404.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecas">scan_filtered的使用</a><br><a target="_blank" rel="noopener" href="http://wiki.ros.org/laser_filters">laser_filters</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/04/Matlab/Matlab%E8%AF%BB%E6%96%87%E4%BB%B6%E5%92%8C%E5%86%99%E6%96%87%E4%BB%B6/">Matlab读文件和写文件</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Matlab/">Matlab</a></span><div class="content"><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><p>txt文件里是这样的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-3.35 2.332 </span><br><span class="line">-3.18 1.876 </span><br><span class="line">-3.10 2.577 </span><br><span class="line">-3.51 2.991 </span><br></pre></td></tr></table></figure></p>
<p>可以这样画散点图，最后设置了坐标轴的范围：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line">data=load(<span class="string">&#x27;E:\data.txt&#x27;</span>);</span><br><span class="line">scatter(data(:,1),data(:,2))</span><br><span class="line">xlim([-6 4])</span><br><span class="line">ylim([-4 10])</span><br></pre></td></tr></table></figure><br><img src="https://i.loli.net/2020/04/04/wx1OgspKkrzCE5v.png" alt="散点图.png"></p>
<p>读点云文件画图：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = load(&#x27;cloud3d.dat&#x27;); %读入数据</span><br><span class="line">%x,y,z轴坐标</span><br><span class="line">x=A(:,1);</span><br><span class="line">y=A(:,2);</span><br><span class="line">z=A(:,3);</span><br><span class="line">scatter3(x,y,z);    %散点图</span><br><span class="line">[X,Y,Z]=griddata(x,y,z,linspace(min(x),max(x))&#x27;,linspace(min(y),max(y)),&#x27;v4&#x27;); %构造坐标点</span><br><span class="line">pcolor(X,Y,Z);</span><br><span class="line">shading interp;        %伪彩色图</span><br><span class="line">fcontourf(X,Y,Z);     %等高线图</span><br><span class="line">figure,surf(X,Y,Z);    %三维曲面</span><br></pre></td></tr></table></figure></p>
<h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fileID = fopen(<span class="string">&#x27;F:\test.ply&#x27;</span>, <span class="string">&#x27;w&#x27;</span>);</span><br><span class="line">fprintf(fileID, <span class="string">&#x27;ply\n&#x27;</span>);</span><br><span class="line">fprintf(fileID, <span class="string">&#x27;format ascii 1.0\n&#x27;</span>);</span><br><span class="line">fprintf(fileID, <span class="string">&#x27;property int path_id\n&#x27;</span>);</span><br><span class="line">fprintf(fileID, <span class="string">&#x27;property int group_id\n&#x27;</span>);</span><br><span class="line">fprintf(fileID, <span class="string">&#x27;end_header\n&#x27;</span>);</span><br><span class="line">fprintf(fileID, <span class="string">&#x27;%f %f %f %d %d\n&#x27;</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line">fclose(fileID);</span><br></pre></td></tr></table></figure>
<p>打开文件是：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ply</span><br><span class="line">format ascii 1.0</span><br><span class="line">property int path_id</span><br><span class="line">property int group_id</span><br><span class="line">end_header</span><br><span class="line">1.000000 2.000000 3.000000 4 5</span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/01/C++/C++%20%20%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/">函数指针</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E5%9F%BA%E7%A1%80/">C++ 基础</a></span><div class="content"><p>函数名就是个指针,它指向函数代码在内存中的首地址.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">double</span> <span class="params">(*FuncType)</span> <span class="params">(<span class="keyword">int</span> data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">FuncType ptr = func;</span><br><span class="line">cout &lt;&lt; <span class="built_in">ptr</span>(<span class="number">11</span>) &lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>第一行定义了一种函数指针,类型为<code>FuncType</code>,它指向的函数返回为 double, 形参为一个int. 然后定义了一个名为func的函数. </p>
<p><code>FuncType ptr = func;</code>是声明一个指针, 类型为 <code>FuncType</code>, 指向func函数. 接下来就可以拿ptr当函数用了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> id, FuncType foo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">foo</span>(<span class="number">110</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;id: &quot;</span>&lt;&lt;id&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">test</span>(<span class="number">1</span>, <span class="keyword">static_cast</span>&lt;FuncType&gt;(func) );</span><br></pre></td></tr></table></figure>
<p>定义一个函数test, 它第二个形参是类型为<code>FuncType</code>的函数指针. 调用时, 最好对第二个形参做转换, 这里用<code>static_cast</code>再合适不过.</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/25/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8/">抛出异常</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><p>异常是运行期出现的情况，编译不会报错。如果出现异常，它后面的代码不会执行，一般会显示<font color = orange size= 3> </font> The program has unexpectedly finished. &lt;/font&gt;。如果能处理好异常，就可以让后面的代码继续运行</p>
<p>throw就是抛出异常，后面可以接任何语句表示异常。比如<code>throw 123;</code>, <code>throw &quot;exception&quot;;</code></p>
<p>try里面的第一个语句必须包含throw，可以是个函数。之后的语句不再进行，直接进catch了</p>
<p>catch的参数是和throw一致的，比如下面的<code>const char*</code>，如果要catch任何类型，小括号内换成<code>...</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">division</span>(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;本句不执行&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span><br><span class="line">&#123;</span><br><span class="line">  cerr &lt;&lt; msg &lt;&lt; endl;	<span class="comment">// 输出错误用cerr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++ 提供了一系列标准的异常，定义在<exception>，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的。可以使用<code>catch(std::exception e)</code></p>
<p>一些第三方库也提供了异常，使用时要注意。比如log4cpp:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    log4cpp::PropertyConfigurator::<span class="built_in">configure</span>(config_base_path+<span class="string">&quot;setting.conf&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (log4cpp::ConfigureFailure&amp; f)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Configure Problem: &quot;</span> &lt;&lt; f.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>假如程序运行前没有配置文件，而且没有使用异常机制，后面的程序就没法运行了。这不一定是我们想要的，我们不一定要求log4cpp的运行，所以使用异常就很合适了。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/25/Linux%E5%9F%BA%E7%A1%80/ELF%E6%96%87%E4%BB%B6/">ELF文件及调试命令</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux%E5%9F%BA%E7%A1%80/">Linux基础</a></span><div class="content"><p>ELF文件有三种：可执行文件，so共享库，o目标文件</p>
<h2 id="打印文件校验和"><a href="#打印文件校验和" class="headerlink" title="打印文件校验和"></a>打印文件校验和</h2><p>二进制文件传输过程中有没有被损坏或者是否是同一个版本，看看校验和以及程序块计数:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># md5sum liblidar.so</span></span><br><span class="line">615f8ede92bb7cca3d559a46397474b6  liblidar.so</span><br></pre></td></tr></table></figure>
<h2 id="打印ELF文件中的可打印字符串-strings"><a href="#打印ELF文件中的可打印字符串-strings" class="headerlink" title="打印ELF文件中的可打印字符串  strings"></a>打印ELF文件中的可打印字符串  strings</h2><p>例如你在代码中存储了一个版本号信息，那么即使编译成elf文件后，仍然可以通过strings搜索其中的字符串甚至可以搜索某个.c文件是否编译在其中：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings elfFile| grep <span class="string">&quot;someString&quot;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="nm命令查看函数或者全局变量是否存在于elf文件"><a href="#nm命令查看函数或者全局变量是否存在于elf文件" class="headerlink" title="nm命令查看函数或者全局变量是否存在于elf文件"></a>nm命令查看函数或者全局变量是否存在于elf文件</h2><p>nm命令用于查看elf文件的符号信息。文件编译出来之后，我们可能不知道新增加的函数或者全局变量是否已经成功编译进去。这时候，我们可以使用nm命令来查看。当然也可以用来查看函数，比<code>strings</code>命令更精确</p>
<h2 id="查看文件段大小-size"><a href="#查看文件段大小-size" class="headerlink" title="查看文件段大小 size"></a>查看文件段大小 size</h2><p>可以通过size命令查看各段大小：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># size cmdTest</span></span><br><span class="line">text       data      bss      dec      hex  filename</span><br><span class="line">1319      560        8     1887      75f   cmdTest</span><br></pre></td></tr></table></figure>
<p>text段：正文段字节数大小<br>data段:包含静态变量和已经初始化的全局变量的数据段字节数大小<br>bss段：存放程序中未初始化的全局变量的字节数大小<br>当我们知道各个段的大小之后，如果有减小程序大小的需求，就可以有针对性的对elf文件进行优化处理。</p>
<h2 id="为elf文件瘦身-strip"><a href="#为elf文件瘦身-strip" class="headerlink" title="为elf文件瘦身  strip"></a>为elf文件瘦身  strip</h2><p>strip用于去掉elf文件中所有的符号信息：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls -al cmdTest</span></span><br><span class="line">-rwxr-xr-x 1 hyb root 9792 Sep 25 20:30 cmdTest <span class="comment">#总大小为9792字节</span></span><br><span class="line">strip cmdTest</span><br><span class="line">ls -al cmdTest</span><br><span class="line">-rwxr-xr-x 1 hyb root 6248 Sep 25 20:35 cmdTest<span class="comment">#strip之后大小为6248字节</span></span><br></pre></td></tr></table></figure><br>可以看到，“瘦身”之后，大小减少将近三分之一。但是要特别注意的是，“瘦身”之后的elf文件由于没有了符号信息，许多调试命令将无法正常使用，出现core dump时，问题也较难定位，因此只建议在正式发布时对其进行“瘦身”。</p>
<h2 id="查看elf文件信息-readelf"><a href="#查看elf文件信息-readelf" class="headerlink" title="查看elf文件信息 readelf"></a>查看elf文件信息 readelf</h2><p>readelf用于查看elf文件信息，它可以查看各段信息，符号信息等，<code>readelf -h cmdTest</code>是查看elf文件头信息：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  <span class="comment">#elf文件魔数字</span></span><br><span class="line">Class:                             ELF64  <span class="comment">#64位 elf文件</span></span><br><span class="line">Data:                              2<span class="string">&#x27;s complement, little endian#字节序为小端序</span></span><br><span class="line"><span class="string">Version:                           1 (current)</span></span><br><span class="line"><span class="string">OS/ABI:                            UNIX - System V #</span></span><br><span class="line"><span class="string">ABI Version:                       0</span></span><br><span class="line"><span class="string">Type:                              EXEC (Executable file)#目标文件类型</span></span><br><span class="line"><span class="string">Machine:                           Advanced Micro Devices X86-64 #目标处理器体系</span></span><br><span class="line"><span class="string">Version:                           0x1</span></span><br><span class="line"><span class="string">Entry point address:               0x400440  #入口地址</span></span><br><span class="line"><span class="string">Start of program headers:          64 (bytes into file)</span></span><br><span class="line"><span class="string">Start of section headers:          4456 (bytes into file)</span></span><br><span class="line"><span class="string">Flags:                             0x0</span></span><br><span class="line"><span class="string">Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">Size of program headers:           56 (bytes)</span></span><br><span class="line"><span class="string">Number of program headers:         9</span></span><br><span class="line"><span class="string">Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">Number of section headers:         28</span></span><br><span class="line"><span class="string">Section header string table index: 27</span></span><br></pre></td></tr></table></figure><br>从elf头信息中，我们可以知道该elf是64位可执行文件，运行在x86-64中，且字节序为小端序。另外，我们还注意到它的入口地址是<code>0x400440(_start)</code>，而不是<code>400540(main)</code>。也就是说，我们的程序运行并非从main开始。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.yanbinghu.com/2019/10/13/54745.html"></a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/25/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/operator()/">operator()</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>   <span class="title">operator</span><span class="params">()</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;Foo operator&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val*<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo f;</span><br><span class="line"><span class="built_in">f</span>();    <span class="comment">// Foo operator</span></span><br><span class="line">cout&lt;&lt; <span class="built_in">f</span>(<span class="number">5</span>) &lt;&lt;endl;  <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<p>Foo是定义了调用操作符()的类,它的对象就相当于函数名,因此<code>operator()</code>取名叫函数对象</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> dist;</span><br><span class="line">    <span class="keyword">double</span> confidence;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= ( <span class="keyword">double</span> d ) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span>(dist &lt;  d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= ( Data&amp; d ) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span>(dist &lt;=  d.dist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Data a, b;</span><br><span class="line">a.dist = <span class="number">1</span>;</span><br><span class="line">a.confidence = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">b.dist = <span class="number">1.3</span>;</span><br><span class="line">b.confidence = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a &lt;= <span class="number">1.0</span>)</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot; 00000 &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span>(a &lt;= b)</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot; 11111 &quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/18/%E6%BF%80%E5%85%89SLAM/%E9%9B%B7%E8%BE%BE/%E9%9B%B7%E8%BE%BE%E7%9A%84%E8%AE%BE%E5%A4%87%E5%8F%82%E6%95%B0/">单线雷达的设备参数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/%E9%9B%B7%E8%BE%BE/">雷达</a></span><div class="content"><p>大多数雷达都是TOF测量法，只有深度信息，没有相机那样的纹理信息，也就没有视觉SLAM的运算负荷。</p>
<p>目前常见的激光雷达都是旋转扫描式的，内部长期处于旋转中的机械结构会给系统带来不稳定性，在颠簸震动时影响尤其明显。固态激光雷达的逐步成熟可能会为激光SLAM扳回这项劣势。</p>
<p>激光雷达的使用寿命问题已经被解决，能够保证长时间使用不会出现故障。比如在连续工作情况下，RPLIDAR-A2的设计使用寿命可长达5年以上。</p>
<p>雷达的光线遇到大雾、烟尘会受到遮挡，影响性能。</p>
<h2 id="测试材质"><a href="#测试材质" class="headerlink" title="测试材质"></a>测试材质</h2><p>选用雷达需要判断雷达是否适用于自己的场合，所以根据需要在以下场景进行测试</p>
<ul>
<li><p>大理石瓷砖。 应用场景参考：酒店大堂、走廊、室外墙壁</p>
</li>
<li><p>玻璃。 应用场景参考：玻璃门窗，办公大厅、玻璃柜台。 激光会穿过透明玻璃，从而造成一定概率的漏检。可以增加一些辅助反射手段，比如粘贴磨砂贴纸，或配合其他非光学的传感器作为补充。 <strong>雷达有时会穿透玻璃，有时不会，所以临时在玻璃上贴磨砂纸。</strong></p>
</li>
<li><p>不锈钢板。 应用场景参考：电梯、生产车间、港口码头</p>
</li>
<li><p>反光条。 应用场景参考：医院、生产车间、酒店大堂</p>
</li>
</ul>
<h2 id="误差源"><a href="#误差源" class="headerlink" title="误差源"></a>误差源</h2><ul>
<li><p>发送和接收激光束的精确耗时误差，也就是计时设备的精度问题</p>
</li>
<li><p>目标材质的反射值特性，比如全黑的材料吸收了光的大部分能量，使得反射量极低；或者像镜子一样的材料会将大部分光反射到其它地方</p>
</li>
<li><p>运动畸变：由于激光雷达在跟随自动驾驶车辆前进的同时，对周围环境进行扫描建模，也就是说车辆相对于周围的环境是运动的，导致对环境测量的实际位置与真实位置存在偏差。但是扫描频率高，速度低时，可以不必考虑。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/05/07/ICpiBQHvzquXkJj.png" alt=""></p>
<h2 id="测距范围"><a href="#测距范围" class="headerlink" title="测距范围"></a>测距范围</h2><p>指雷达能够测量的距离范围。如果实际障碍距离超出最大值，那么雷达数据会标记为无效点（不是距离为0）。市面上2D雷达最近距离也至少几厘米</p>
<p>实际情况下，雷达测距的最大值有可能因为工作环境而产生变化。雷达要想测距，需要接收到反射的激光。所以官方在测距范围这一项上添加了备注：“基于白色70%反射率物体”。</p>
<p>如果是吸收激光比较厉害的物体，例如黑色的表面又几乎不反光的物体，会导致反射光强度很弱，那么距离稍微远点，可能就测距失败了，这时候，该物体即使在标出的12米范围内同样无法测出。针对类似这样的物体，相当于实际测距的最大值变小了。透明的玻璃也是同样原因。</p>
<p>不过因为不同的物体和环境差异太大了，所以厂商也不太可能将全部情况测试一遍，更多的时候需要靠自己来实验，看是否能够适用实际的工作环境。</p>
<h2 id="扫描角度"><a href="#扫描角度" class="headerlink" title="扫描角度"></a>扫描角度</h2><p>思岚雷达是360°扫描的。有些雷达例如SICK的一些雷达，扫描角度只有220°。 实际使用，通常也不需要完全的360°，特别是雷达放在结构的中间层，因为有结构固定装置的存在，必然会有遮挡。</p>
<h2 id="测距分辨率"><a href="#测距分辨率" class="headerlink" title="测距分辨率"></a>测距分辨率</h2><p>分辨率和精度是两个不同的概念，按照上述参数的意思，更准确来说应该指的是测距精度。</p>
<p>RPLIDAR的精度并不是恒定的一个百分比，简单的解释是，距离越远，反射光受到的干扰越大，自然精度下降了。实际上，不同批次的雷达精度之间也有一定的差异。正因为这些不确定性，官方文档给的是较保守的值。</p>
<p>1.5m范围内小于0.5mm的精度还是可以的，1.5米处约为万分之三点三。<br>当在最大距离12米的时候，如果精度下降到最差的1%，则误差为0.12m，也能接受。</p>
<h2 id="扫描频率"><a href="#扫描频率" class="headerlink" title="扫描频率"></a>扫描频率</h2><p><img src="https://i.loli.net/2020/03/18/6tNElCuaoWwJhcG.png" alt="扫描频率.png"><br>衡量雷达一秒钟能转多少圈，直接改叫雷达转速也是可以的。</p>
<p>转速实际上跟雷达数据更新周期是挂钩的，比如说典型的10Hz，那就是说转一圈的时间大概是100ms，那么雷达数据差不多也是100ms一帧。 要跟<code>scan</code>话题的发布频率区分开，后者跟计算机性能有关。</p>
<p><code>LMS1xx</code>系列的扫描频率是25～50Hz，角度分辨率为<code>0.25°～0.50°</code><br><code>LMS5xx</code>系列的扫描频率是25～100Hz，角度分辨率为<code>0.1667°～1°</code></p>
<p>雷达自身的旋转是有方向的，大部分雷达都是逆时针旋转，与ROS中规定的一样，也有少部分雷达是顺时针旋转的，只不过使用起来有点不方便。</p>
<h2 id="角度分辨率"><a href="#角度分辨率" class="headerlink" title="角度分辨率"></a>角度分辨率</h2><p>正常来说，雷达转一圈，这一圈得到的测量点是均匀分布的，每个点之间间隔的角度就是所谓的角度分辨率了。</p>
<p>角度分辨率越小说明雷达转一圈得到的点数越多。例如，角度分辨率是0.45，则一圈是800个点，角度分辨率是0.9，则一圈是400个点。</p>
<p>不过，实际的角度分辨率其实不一定是固定的，即两个点之间的间距不一定是相同的，不过都在给出的分辨率范围内。在ROS中，雷达数据的标准格式认为角度分辨率是固定的，为了符合ROS标准，雷达的ROS驱动实际上做了角度补偿，将输出点修正为均匀分布的。</p>
<h2 id="数据的强度"><a href="#数据的强度" class="headerlink" title="数据的强度"></a>数据的强度</h2><p>激光雷达的激光点是有能量的，不同品牌激光点的能量也不同。当能量太小时，远距离情况下可能存在返回不了数据的情况。</p>
<p>可以等阳光或者使用光束照射到墙面上，激光雷达再去看被光照射到的墙面，对比这时的点云效果。可以用照度仪测量此时的光强度。倍加福雷达的点云效果在高强度情况下非常好，不愧是用于反光板的雷达。<br><img src="https://i.loli.net/2021/05/07/kvqoJwYV3ItgWmd.png" alt=""></p>
<h2 id="数据的精度"><a href="#数据的精度" class="headerlink" title="数据的精度"></a>数据的精度</h2><p>这是最重要的一个指标，表示激光雷达的数据跳动情况。现在一般厂商的雷达的精度都是2%。也就是100m的情况下，点的跳动幅度为2cm。但是，实际感觉能达到这个精度的雷达不是很多。</p>
<h2 id="multi-echo"><a href="#multi-echo" class="headerlink" title="multi-echo"></a>multi-echo</h2><p>multi-echo可以分析每个测量光束的两个回波信号，这样在雨雪天可以提供可靠的测量结果。一般激光打到玻璃上会有部分穿透，导致测量不准，multi-echo使激光从玻璃上返回来，还能从玻璃后面的墙上返回来。</p>
<p>有的雷达具备这种特性，比如<code>SICK-LMS111</code></p>
<p><br></p>
<p><img src="https://i.loli.net/2020/07/17/hifrG8DxmdnAXTJ.png" alt="A2雷达.png"></p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/tiancailx/article/details/110141867">从零开始搭二维激光SLAM —- 激光雷达数据效果对比</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/VOm_h4WYREsvz7rYfOKIiA">LakiBeam1雷达</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/16/C++/C++%20%20%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/STL%E6%80%BB%E7%BB%93/">STL总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/">C++ 模板与STL</a></span><div class="content"><h3 id="查找速度"><a href="#查找速度" class="headerlink" title="查找速度"></a>查找速度</h3><p>对序列式容器，如果元素已经排好序，那么查找速度可以达到logN的时间复杂度；如果是无序，只能是N</p>
<p>对关联容器，底层是红黑树，总能达到logN</p>
<h3 id="有在任意位置插入元素的需求；-大量添加新元素的需求"><a href="#有在任意位置插入元素的需求；-大量添加新元素的需求" class="headerlink" title="有在任意位置插入元素的需求； 大量添加新元素的需求"></a>有在任意位置插入元素的需求； 大量添加新元素的需求</h3><p>最好用list，不要使用vector, deque</p>
<h3 id="元素的排序"><a href="#元素的排序" class="headerlink" title="元素的排序"></a>元素的排序</h3><p>遍历元素的时候，序列容器输出的顺序和插入的顺序是一致的，关联容器就不一定了</p>
<p>sort()函数是快速排序的分段递归版本</p>
<p>关联容器的插入删除效率一般比用其他序列容器高(list除外)，因为不需要做内存拷贝和内存移动</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/15/C++/C++%20%20%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8set%E5%92%8Cmap/">关联式容器set和map</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/">C++ 模板与STL</a></span><div class="content"><p>STL 标准库提供了 4 种关联式容器，分别为 map、set、multimap、multiset</p>
<p><img src="https://s2.loli.net/2022/02/16/elb3D1QFEnmAoIv.png" alt=""></p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set的元素有序不重复，而且能根据元素的值自动进行排序。set中的键值不能直接修改，只能先删除再插入。底层采用红黑树。</p>
<p>set不支持随机访问，只能使用迭代器去访问。由于set放入一个元素就会调整这个元素的位置，把它放到合适的位置，所以set中只有一个insert插入操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;set 的 size：&quot;</span>&lt;&lt;  s.<span class="built_in">size</span>() &lt;&lt;endl;  <span class="comment">// 5</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;set 中的第一个元素是 ：&quot;</span>&lt;&lt;  *s.<span class="built_in">begin</span>()&lt;&lt;endl;  <span class="comment">// 1</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;set 中的最后一个元素是:&quot;</span>&lt;&lt;  *s.<span class="built_in">end</span>()&lt;&lt;endl;   <span class="comment">// 5</span></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=s.<span class="built_in">begin</span>(); it!=s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt; *it &lt;&lt;endl;</span><br><span class="line">&#125;    <span class="comment">// 1  2  3  4  5</span></span><br><span class="line"><span class="comment">//    s.clear();</span></span><br><span class="line">s.<span class="built_in">erase</span>(++s.<span class="built_in">begin</span>());</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;       after erase begin&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(it=s.<span class="built_in">begin</span>(); it!=s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt; *it &lt;&lt;endl;</span><br><span class="line">&#125;	 <span class="comment">// 1  3  4  5</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;lower bound: &quot;</span>&lt;&lt;*s.<span class="built_in">lower_bound</span>(<span class="number">5</span>)&lt;&lt;endl;  <span class="comment">// 5</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;upper bound: &quot;</span>&lt;&lt;*s.<span class="built_in">upper_bound</span>(<span class="number">5</span>)&lt;&lt;endl;  <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">empty</span>())</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;set is empty !&quot;</span> &lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>multiset底层也是红黑树，但允许有重复数据</p>
<h2 id="map-和-unordered-map"><a href="#map-和-unordered-map" class="headerlink" title="map 和 unordered_map"></a>map 和 unordered_map</h2><p>map适合存储一个数据字典，并要求方便地根据key找value。Map节点有一个Key和Value两个元素，Key不重复，Value可以重复。map可以通过key改变value的值</p>
<p>底层也是红黑树，所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此它的插入删除查找的时间复杂度为O(logN)</p>
<p>map支持随机访问(<code>at</code>函数和<code>[]</code>)，这是set没有的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, string&gt; m;</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">4</span>, <span class="string">&quot;d&quot;</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">5</span>, <span class="string">&quot;e&quot;</span>));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; m.<span class="built_in">upper_bound</span>(<span class="number">3</span>)-&gt;second &lt;&lt;endl;   <span class="comment">// 大于</span></span><br><span class="line">cout &lt;&lt; m.<span class="built_in">lower_bound</span>(<span class="number">3</span>)-&gt;second &lt;&lt;endl;   <span class="comment">// 不小于</span></span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d</span><br><span class="line">c</span><br></pre></td></tr></table></figure></p>
<p><strong>缺点</strong>： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间<br><br></p>
<p><code>unordered_map</code>内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的，但查找速度非常的快。  <strong>缺点</strong>：哈希表的建立比较耗费时间。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/40/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/40/">40</a><span class="page-number current">41</span><a class="page-number" href="/page/42/">42</a><span class="space">&hellip;</span><a class="page-number" href="/page/56/">56</a><a class="extend next" rel="next" href="/page/42/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2024/11/12/x1aqcwUG3XDiskN.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2025 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>