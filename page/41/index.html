<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">600</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">50</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/30/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%9B%9B)%E8%BF%90%E5%8A%A8%E6%A8%A1%E5%9E%8B/">源码分析(四)运动模型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/">amcl和粒子滤波</a></span><div class="content"><p>在AMCL中，里程计是作为状态预测器存在的，通过接受当前的控制信号，从<strong>上一帧机器人状态对这一帧机器人状态进行预测，并与当前观测的结果对当前预测进行加权打分</strong>。所以通过输入和输出我们知道，里程计在AMCL中的作用就是根据当前控制信号更新上一帧的能表征机器人状态的粒子集合。</p>
<p>给机器人一个初始位姿，粒子才根据初始位姿进行初始化分布，才会进行更新(<code>UpdateAction函数</code>)，否则不会有<code>amcl_pose</code>话题输出，而更新依赖于读取到传感器数据发生变化，如在amcl中里程计的数据变化等，也就是机器人的运动</p>
<h2 id="工具函数和类"><a href="#工具函数和类" class="headerlink" title="工具函数和类"></a>工具函数和类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 两个处理角度的函数，保证角度都在(-π，π] 的范围内 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如 30°的弧度,代入后基本还是得30°的弧度</span></span><br><span class="line"><span class="comment">// 但是对于210°, 代入得到的是-150°的弧度值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">normalize</span><span class="params">(<span class="keyword">double</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">atan2</span>(<span class="built_in">sin</span>(z),<span class="built_in">cos</span>(z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于240和30的弧度,返回-150的弧度</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">angle_diff</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> d1, d2;</span><br><span class="line">  a = <span class="built_in">normalize</span>(a);</span><br><span class="line">  b = <span class="built_in">normalize</span>(b);</span><br><span class="line">  d1 = a-b;</span><br><span class="line">  d2 = <span class="number">2</span>*M_PI - <span class="built_in">fabs</span>(d1);</span><br><span class="line">  <span class="keyword">if</span>(d1 &gt; <span class="number">0</span>)</span><br><span class="line">    d2 *= <span class="number">-1.0</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">fabs</span>(d1) &lt; <span class="built_in">fabs</span>(d2))</span><br><span class="line">    <span class="keyword">return</span>(d1);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in"><span class="keyword">return</span></span>(d2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向量，成员为[x,y,θ]</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">double</span> v[<span class="number">3</span>];</span><br><span class="line">&#125; <span class="keyword">pf_vector_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Odometric sensor data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AMCLOdomData</span> :</span> <span class="keyword">public</span> AMCLSensorData</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Odometric pose</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">pf_vector_t</span> pose;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Change in odometric pose</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">pf_vector_t</span> delta;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个粒子的采样信息，只有位姿和权重</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// Pose represented by this sample</span></span><br><span class="line">  <span class="keyword">pf_vector_t</span> pose;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Weight for this pose</span></span><br><span class="line">  <span class="keyword">double</span> weight;</span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">pf_sample_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从零均值的高斯分布获得随机值，标准差为sigma</span></span><br><span class="line"><span class="comment">// We use the polar form of the Box-Muller transformation</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pf_ran_gaussian</span><span class="params">(<span class="keyword">double</span> sigma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> x1, x2, w, r;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123; r = <span class="built_in">drand48</span>(); &#125; <span class="keyword">while</span> (r==<span class="number">0.0</span>);</span><br><span class="line">    x1 = <span class="number">2.0</span> * r - <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123; r = <span class="built_in">drand48</span>(); &#125; <span class="keyword">while</span> (r==<span class="number">0.0</span>);</span><br><span class="line">    x2 = <span class="number">2.0</span> * r - <span class="number">1.0</span>;</span><br><span class="line">    w = x1*x1 + x2*x2;</span><br><span class="line">  &#125; <span class="keyword">while</span>(w &gt; <span class="number">1.0</span> || w==<span class="number">0.0</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span>(sigma * x2 * <span class="built_in">sqrt</span>(<span class="number">-2.0</span>*<span class="built_in">log</span>(w)/w));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="laserReceived中的准备工作"><a href="#laserReceived中的准备工作" class="headerlink" title="laserReceived中的准备工作"></a>laserReceived中的准备工作</h2><p>下面来看回调函数<code>laserReceived</code>中的运动模型准备工作，我们需要的是<code>odata</code>，它的类型就是上面的<code>AMCLOdomData</code>，以delta成员为例，它的赋值顺序是： odata.delta &lt;—- delta &lt;—- pose(当前位姿)和pf<em>odom_pose</em>(上一次位姿)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得雷达数据时刻的odom坐标系中的坐标,赋值给pose</span></span><br><span class="line"><span class="keyword">pf_vector_t</span> pose;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">getOdomPose</span>(latest_odom_pose_, pose.v[<span class="number">0</span>], pose.v[<span class="number">1</span>], pose.v[<span class="number">2</span>],</span><br><span class="line">              laser_scan-&gt;header.stamp, base_frame_id_))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Couldn&#x27;t determine robot&#x27;s pose associated with laser scan&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pf_vector_t</span> delta = <span class="built_in">pf_vector_zero</span>();</span><br><span class="line"><span class="comment">// 完成初始化后执行</span></span><br><span class="line"><span class="keyword">if</span>(pf_init_)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 位姿相对上一次的变化， pf_odom_pose_就是上一时刻的位姿</span></span><br><span class="line">delta.v[<span class="number">0</span>] = pose.v[<span class="number">0</span>] - pf_odom_pose_.v[<span class="number">0</span>];</span><br><span class="line">delta.v[<span class="number">1</span>] = pose.v[<span class="number">1</span>] - pf_odom_pose_.v[<span class="number">1</span>];</span><br><span class="line">delta.v[<span class="number">2</span>] = <span class="built_in">angle_diff</span>(pose.v[<span class="number">2</span>], pf_odom_pose_.v[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否更新粒子滤波器，位移需要大于参数update_min_d， 角度需要大于参数update_min_a</span></span><br><span class="line"><span class="keyword">bool</span> update = <span class="built_in">fabs</span>(delta.v[<span class="number">0</span>]) &gt; d_thresh_ ||</span><br><span class="line">              <span class="built_in">fabs</span>(delta.v[<span class="number">1</span>]) &gt; d_thresh_ ||</span><br><span class="line">              <span class="built_in">fabs</span>(delta.v[<span class="number">2</span>]) &gt; a_thresh_;</span><br><span class="line">update = update || m_force_update;</span><br><span class="line">m_force_update=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the laser update flags</span></span><br><span class="line"><span class="keyword">if</span>(update)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; lasers_update_.<span class="built_in">size</span>(); i++)</span><br><span class="line">    lasers_update_[i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> force_publication = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 第一次执行laserReceived时执行, 之前的handleMapMessage里还是false</span></span><br><span class="line"><span class="comment">// 如果里程计的数据显示机器人已经发生了明显的位移或者旋转，标记所有的雷达更新为true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 难道这里只在开始运行一次 ???</span></span><br><span class="line"><span class="keyword">if</span>(!pf_init_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 上一次滤波器更新的位姿 </span></span><br><span class="line">    pf_odom_pose_ = pose;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 滤波器现在初始化了</span></span><br><span class="line">    pf_init_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Should update sensor data</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; lasers_update_.<span class="built_in">size</span>(); i++)</span><br><span class="line">      lasers_update_[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    force_publication = <span class="literal">true</span>;</span><br><span class="line">    resample_count_ = <span class="number">0</span>; 	<span class="comment">// 重采样次数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 刚启动amcl时不执行,机器人移动后执行, 更新滤波器</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pf_init_ &amp;&amp; lasers_update_[laser_index])</span><br><span class="line">&#123;</span><br><span class="line">    AMCLOdomData odata;</span><br><span class="line">    odata.pose = pose;</span><br><span class="line">    odata.delta = delta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一帧位姿粒子状态pf和当前传感器信息，更新滤波器</span></span><br><span class="line">    odom_-&gt;<span class="built_in">UpdateAction</span>(pf_, (AMCLSensorData*)&amp;odata);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> resampled = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>到此就是算法的准备工作了, <code>pf_</code>是粒子滤波器，在<code>handleMapMessage</code>中创建和初始化</p>
<h2 id="UpdateAction"><a href="#UpdateAction" class="headerlink" title="UpdateAction"></a>UpdateAction</h2><p>接下来就是运动模型的算法了，对应《概率机器人》103页：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply the action model</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AMCLOdom::UpdateAction</span><span class="params">(<span class="keyword">pf_t</span> *pf, AMCLSensorData *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  AMCLOdomData *ndata;</span><br><span class="line">  ndata = (AMCLOdomData*) data;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the new sample poses</span></span><br><span class="line">  <span class="keyword">pf_sample_set_t</span> *set;</span><br><span class="line">  <span class="comment">// 确立当前的粒子集合，我们要产生的是一堆有位姿的粒子</span></span><br><span class="line">  set = pf-&gt;sets + pf-&gt;current_set;</span><br><span class="line">  <span class="comment">// 上一时刻的位姿</span></span><br><span class="line">  <span class="keyword">pf_vector_t</span> old_pose = <span class="built_in">pf_vector_sub</span>(ndata-&gt;pose, ndata-&gt;delta);</span><br><span class="line">  <span class="comment">// 与103页的各个delta量对应</span></span><br><span class="line">    <span class="keyword">double</span> delta_rot1, delta_trans, delta_rot2;</span><br><span class="line">    <span class="keyword">double</span> delta_rot1_hat, delta_trans_hat, delta_rot2_hat;</span><br><span class="line">    <span class="keyword">double</span> delta_rot1_noise, delta_rot2_noise;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相较于于书上，在计算delta _rot1时，多了个判定条件以位移是否小于1cm作为判断条件</span></span><br><span class="line">    <span class="comment">// 如果里程计量得机器人位移小于1cm，delta _rot1就置为0</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sqrt</span>(ndata-&gt;delta.v[<span class="number">1</span>]*ndata-&gt;delta.v[<span class="number">1</span>] + </span><br><span class="line">            ndata-&gt;delta.v[<span class="number">0</span>]*ndata-&gt;delta.v[<span class="number">0</span>]) &lt; <span class="number">0.01</span>)</span><br><span class="line">      delta_rot1 = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      delta_rot1 = <span class="built_in">angle_diff</span>(<span class="built_in">atan2</span>(ndata-&gt;delta.v[<span class="number">1</span>], ndata-&gt;delta.v[<span class="number">0</span>]),</span><br><span class="line">                              old_pose.v[<span class="number">2</span>]);</span><br><span class="line">    delta_trans = <span class="built_in">sqrt</span>(ndata-&gt;delta.v[<span class="number">0</span>]*ndata-&gt;delta.v[<span class="number">0</span>] +</span><br><span class="line">                       ndata-&gt;delta.v[<span class="number">1</span>]*ndata-&gt;delta.v[<span class="number">1</span>] );</span><br><span class="line">    delta_rot2 = <span class="built_in">angle_diff</span>(ndata-&gt;delta.v[<span class="number">2</span>], delta_rot1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We want to treat backward and forward motion symmetrically for the</span></span><br><span class="line">    <span class="comment">// noise model to be applied below.  The standard model seems to assume forward motion.</span></span><br><span class="line">    <span class="comment">// 取了两次旋转角的锐角</span></span><br><span class="line">    delta_rot1_noise = std::<span class="built_in">min</span>(<span class="built_in">fabs</span>(<span class="built_in">angle_diff</span>(delta_rot1,<span class="number">0.0</span>)),</span><br><span class="line">                                <span class="built_in">fabs</span>(<span class="built_in">angle_diff</span>(delta_rot1,M_PI)));</span><br><span class="line">    delta_rot2_noise = std::<span class="built_in">min</span>(<span class="built_in">fabs</span>(<span class="built_in">angle_diff</span>(delta_rot2,<span class="number">0.0</span>)),</span><br><span class="line">                                <span class="built_in">fabs</span>(<span class="built_in">angle_diff</span>(delta_rot2,M_PI)));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用一定数量的粒子来表征这个区域，然后对这些粒子进行采样来尽可能多的逼近机器人的真实值</span></span><br><span class="line">	<span class="comment">// 下面还是书上的公式，我们需要的是sample</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; set-&gt;sample_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 指针形式, 会给set的samples都赋值</span></span><br><span class="line">      <span class="keyword">pf_sample_t</span>* sample = set-&gt;samples + i;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Sample pose differences，pf_ran_gaussian函数：从零平均高斯分布中随机抽取，带有标准差sigma</span></span><br><span class="line">      <span class="comment">// 将这两个角度带入pf_ran_gaussian()进行高斯采样，也就是书103页的sample()函数。</span></span><br><span class="line">      <span class="comment">// 对每个粒子，不同的信息就是高斯采样产生的，其他部分不变</span></span><br><span class="line">      delta_rot1_hat = <span class="built_in">angle_diff</span>(delta_rot1,</span><br><span class="line">                      <span class="built_in">pf_ran_gaussian</span>(<span class="keyword">this</span>-&gt;alpha1*delta_rot1_noise*delta_rot1_noise + <span class="keyword">this</span>-&gt;alpha2*delta_trans*delta_trans)  );</span><br><span class="line"></span><br><span class="line">      delta_trans_hat = delta_trans - </span><br><span class="line">              <span class="built_in">pf_ran_gaussian</span>(<span class="keyword">this</span>-&gt;alpha3*delta_trans*delta_trans +</span><br><span class="line">                              <span class="keyword">this</span>-&gt;alpha4*delta_rot1_noise*delta_rot1_noise +</span><br><span class="line">                              <span class="keyword">this</span>-&gt;alpha4*delta_rot2_noise*delta_rot2_noise);</span><br><span class="line"></span><br><span class="line">      delta_rot2_hat = <span class="built_in">angle_diff</span>(delta_rot2,</span><br><span class="line">                          <span class="built_in">pf_ran_gaussian</span>(<span class="keyword">this</span>-&gt;alpha1*delta_rot2_noise*delta_rot2_noise +</span><br><span class="line">                        <span class="keyword">this</span>-&gt;alpha2*delta_trans*delta_trans) );</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Apply sampled update to particle pose, 对初始预测的修正</span></span><br><span class="line">      sample-&gt;pose.v[<span class="number">0</span>] += delta_trans_hat * </span><br><span class="line">              <span class="built_in">cos</span>(sample-&gt;pose.v[<span class="number">2</span>] + delta_rot1_hat);</span><br><span class="line">      sample-&gt;pose.v[<span class="number">1</span>] += delta_trans_hat * </span><br><span class="line">              <span class="built_in">sin</span>(sample-&gt;pose.v[<span class="number">2</span>] + delta_rot1_hat);</span><br><span class="line">      sample-&gt;pose.v[<span class="number">2</span>] += delta_rot1_hat + delta_rot2_hat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/25/%E6%BF%80%E5%85%89SLAM/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88/%E4%BD%BF%E7%94%A8robot_pose_ekf%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88/">修改robot_pose_ekf实现里程计融合IMU</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88/">多传感器融合</a></span><div class="content"><p>Each source gives a pose estimate and a covariance. The sources operate at different rates and with different latencies. A source can appear and disappear over time, and the node will automatically detect and use the available sensors </p>
<p>给滤波器节点提供信息的所有传感器源都有自己的参考坐标系，并且随着时间推移都可能出现漂移现象。因此，每个传感器发出来的绝对位姿不能直接对比。 </p>
<p><code>robot_pose_ekf</code>使用每个传感器的相对位姿差异来更新扩展卡尔曼滤波器，用松耦合方式融合不同传感器信息实现位姿估计。</p>
<p>在位姿本身上发布协方差是没有用的，而是传感器源发布协方差如何随时间变化，即速度的协方差。使用对世界的观测（例如，测量到已知墙壁的距离）将减少机器人位姿的不确定性；但是这是定位而不是里程计。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>编译前先安装<code>orocos-bfl</code></p>
<p>校正好IMU,因为融合后的效果就是要看imu的校准度</p>
<p>注释掉StatusPublisher.cpp中的<code>sendTransform(tf::StampedTransform(transform, current_time.fromSec(base_time_), &quot;odom&quot;, &quot;base_footprint&quot;));</code>  因为ekf包会为我们处理好这部分tf，所以不需要我们发布odom变换了。但是保留<code>odom</code>话题的发布</p>
<h2 id="修改-robot-pose-ekf-launch"><a href="#修改-robot-pose-ekf-launch" class="headerlink" title="修改 robot_pose_ekf.launch"></a>修改 robot_pose_ekf.launch</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_pose_ekf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_pose_ekf&quot;</span> <span class="attr">name</span>=<span class="string">&quot;robot_pose_ekf&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;output_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;odom_ekf&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;base_footprint_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;base_footprint&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;freq&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30.0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;sensor_timeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1.0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_used&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_data&quot;</span> <span class="attr">value</span>=<span class="string">&quot;odom&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;imu_used&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;imu_data&quot;</span> <span class="attr">value</span>=<span class="string">&quot;imu&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;vo_used&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;/robot_pose_ekf/odom_combined&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/odom_ekf&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>freq：滤波器更新和发布频率。注意频率高仅仅意味着一段时间可以获得更多机器人位姿信息，但是并不表示可以提高位姿估计的精度。</p>
</li>
<li><p>sensor_timeout：当传感器停止向滤波器发送信息时，滤波器在没有传感器的情况下等待多长时间才重新开始工作。</p>
</li>
<li><p>odom_used, imu_used, vo_used：确认是否输入。</p>
</li>
</ul>
<p>启动之后,发布一下tf树,看看各坐标系名称是否正确,而且注意<code>odom_ekf</code>是不是<code>robot_pose_ekf</code>发布的，它提供的tf变换是： <code>odom_ekf --&gt; base_footprint</code>。 我们最终要实现的目标TF关系是： <code>odom_ekf --&gt; base_footprint --&gt; base_link</code></p>
<p>启动launch: <code>roslaunch robot_pose_ekf robot_pose_ekf.launch</code><br><img src="https://s2.loli.net/2023/01/13/6o1NYmOhxcvpjlK.png" alt="节点"><br>为了查看ekf包是否正常工作，可以用下面代码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /robot_pose_efk/get_status</span><br></pre></td></tr></table></figure></p>
<h2 id="协方差问题"><a href="#协方差问题" class="headerlink" title="协方差问题"></a>协方差问题</h2><p><code>robot_pose_ekf</code>不输出协方差信息，但要求输入协方差，协方差是<font size =3 color=blue>on velocity level</font>。接收的odometry数据格式错误的问题，一般是由于底盘发布的odometry数据的协方差矩阵默认为0矩阵。解决的方法由两种：一种是底盘对协方差矩阵进行初始化；另一种方法在<code>robot_pose_ekf</code>中添加判断，如果接收到的odometry信息的协方差矩阵没有进行初始化，则进行初始化。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Arkapravo/turtlebot/blob/master/turtlebot_node/src/turtlebot_node/covariances.py">turtlebot_node</a>对odom的协方差矩阵设置为<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ODOM_POSE_COVARIANCE = [<span class="number">1e-3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">                        <span class="number">0</span>, <span class="number">1e-3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e6</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e6</span>, <span class="number">0</span>,</span><br><span class="line">                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e3</span>]</span><br><span class="line"></span><br><span class="line">ODOM_TWIST_COVARIANCE = [<span class="number">1e-3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">                         <span class="number">0</span>, <span class="number">1e-3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                         <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                         <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e6</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                         <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e6</span>, <span class="number">0</span>,</span><br><span class="line">                         <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e3</span>]</span><br></pre></td></tr></table></figure><br><a target="_blank" rel="noopener" href="https://zacdeng.github.io/2020/08/03/racecar%E4%BB%BF%E7%9C%9F%E7%AB%9E%E8%B5%9B%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89-%20AMCL%E4%B8%8E%E5%B0%8F%E8%BD%A6%E5%AE%9A%E4%BD%8D/#rf2o-laser-odometry">这篇文章</a>也提出了几个例子</p>
<p>注意imu信息的协方差矩阵中代表机器人航向角的分量方差为1e-6，而里程计信息的协方差矩阵中机器人姿态分量的协方差为1e3，两个值相差很大。在进行EKF融合时，会更“相信”imu提供的姿态信息，因为其方差更小。比如机器人在转动过程中轮子发生了打滑，用编码器推算出的姿态一直在旋转，而实际姿态（主要由IMU测量得到）却没发生太大变化，这种情况就需要使用信息融合方法来减小误差。<font size="4" color="blue"> 协方差矩阵中的参数设置非常重要，要根据传感器手册或者实际使用测量来确定。</font></p>
<p>这里的协方差矩阵就是&lt;&lt;概率机器人&gt;&gt;154页的<code>Vt*Mt*VtT</code>, 根据之前速度积分的模型,我们已知的是ωt,Δt,θ</p>
<p>只有a1~a4还未知,它们的说明在《概率机器人》103页，<font size="4" color="orange"> 似乎不对： </font>这里就涉及到粒子滤波和AMCL了,其实它们就是AMCL的四个参数,即里程计的四个噪声分量. 我们在使用AMCL定位前就要调节这四个参数, 有了这四个参数,就能算出里程计的协方差矩阵了.</p>
<p>随着机器人的移动，其位姿的不确定性越来越大。随着时间的流逝，协方差将无限增长。<code>robot_pose_ekf</code>会在每个传感器更新数据前重置协方差， 所以发布的协方差是the increase in covariance over the past time interval. 这个时间间隔不是不变的，它取决于传感器的测量速度和什么时候完成．</p>
<p>try adjusting the process noise vs. the measurement covariance for the state variables you’re fusing. Lower covariance in the measurement and higher process noise will mean that the filter trusts your sensors more. Otherwise, the filter will prefer to stick with its predictions</p>
<p><br></p>
<p>里程计消息的协方差平时可以没有,但是如果要用到卡尔曼滤波做融合,就必须有,否则到<code>OdomEstimation::addMeasurement</code>会报错，那里是判断协方差矩阵的对角线元素<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] [1519539033.600801081]: Covariance specified <span class="keyword">for</span> measurement on topic wheelodom is zero</span><br></pre></td></tr></table></figure><br>但是小强中的里程计协方差矩阵赋值大部分是0<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CarOdom.pose.covariance =  boost::assign::<span class="built_in">list_of</span>(var_len)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(var_len)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">999</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">999</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">999</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(var_angle);</span><br></pre></td></tr></table></figure><br>因此修改<code>robot_pose_ekf/src/odom_estimation_node.cpp</code>中的函数<code>OdomEstimationNode::odomCallback</code>如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">6</span>; j++)</span><br><span class="line">    <span class="built_in">odom_covariance_</span>(i+<span class="number">1</span>, j+<span class="number">1</span>) = odom-&gt;pose.covariance[<span class="number">6</span>*i+j];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// manually set covariance untile imu sends covariance</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">imu_covariance_</span>(<span class="number">1</span>,<span class="number">1</span>) == <span class="number">0.0</span>)  <span class="comment">// 或者不用 if</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">SymmetricMatrix <span class="title">measNoiseOdom_Cov</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">  measNoiseOdom_Cov = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">measNoiseOdom_Cov</span>(<span class="number">1</span>,<span class="number">1</span>) = <span class="built_in">pow</span>(<span class="number">0.01221</span>,<span class="number">2</span>);  <span class="comment">// = 0.01221 meters / sec</span></span><br><span class="line">  <span class="built_in">measNoiseOdom_Cov</span>(<span class="number">2</span>,<span class="number">2</span>) = <span class="built_in">pow</span>(<span class="number">0.01221</span>,<span class="number">2</span>);  <span class="comment">// = 0.01221 meters / sec</span></span><br><span class="line">  <span class="built_in">measNoiseOdom_Cov</span>(<span class="number">3</span>,<span class="number">3</span>) = <span class="built_in">pow</span>(<span class="number">0.01221</span>,<span class="number">2</span>);  <span class="comment">// = 0.01221 meters / sec</span></span><br><span class="line">  <span class="built_in">measNoiseOdom_Cov</span>(<span class="number">4</span>,<span class="number">4</span>) = <span class="built_in">pow</span>(<span class="number">0.007175</span>,<span class="number">2</span>);  <span class="comment">// = 0.41 degrees / sec</span></span><br><span class="line">  <span class="built_in">measNoiseOdom_Cov</span>(<span class="number">5</span>,<span class="number">5</span>) = <span class="built_in">pow</span>(<span class="number">0.007175</span>,<span class="number">2</span>);  <span class="comment">// = 0.41 degrees / sec</span></span><br><span class="line">  <span class="built_in">measNoiseOdom_Cov</span>(<span class="number">6</span>,<span class="number">6</span>) = <span class="built_in">pow</span>(<span class="number">0.007175</span>,<span class="number">2</span>);  <span class="comment">// = 0.41 degrees / sec</span></span><br><span class="line">&#125;</span><br><span class="line">my_filter_.<span class="built_in">addMeasurement</span>(<span class="built_in">StampedTransform</span>(odom_meas_.<span class="built_in">inverse</span>(), odom_stamp_, base_footprint_frame_, <span class="string">&quot;wheelodom&quot;</span>), odom_covariance_);</span><br></pre></td></tr></table></figure><br>这是仿照源码中的函数<code>imuCallback</code>做的修改</p>
<p>如果协方差太大，那么说明机器人不太依靠里程计．协方差矩阵具体值可以考虑设置为精度的二次方。工程中确保odom的协方差矩阵对角线元素不均为0，则robot_pose_ekf即可工作。</p>
<h2 id="源码的坐标系错误"><a href="#源码的坐标系错误" class="headerlink" title="源码的坐标系错误"></a>源码的坐标系错误</h2><p>使用rviz观看滤波后的行走轨迹，结果报错：<br><img src="https://i.loli.net/2020/05/23/BAwtu9NfZ3sQW4I.png" alt="rviz里的ekf_dom_path报错.png"><br>它居然要求的是odom坐标系，但是查看tf树，坐标关系是正确的<code>odom_combined --&gt; base_footprint</code>，没有odom了。</p>
<p>使用echo查看/robot_pose_ekf/odom_combined话题，发现header里的frame_id: “odom”，看来是哪个地方发布错了。 从robot_pose_ekf源码里查找，发现<code>OdomEstimation::getEstimate(geometry_msgs::PoseWithCovarianceStamped&amp; estimate)</code>中，有这样一句<code>estimate.header.frame_id = &quot;odom&quot;;</code>，按说新的坐标系是<code>odom_combined</code>，不知为什么这里还是<code>odom</code>，只能认为是源码写错了。</p>
<p>参考:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/EAIBOT/article/details/51405152">turtlebot所用的里程计和IMU协方差是手动设置的</a><br><a target="_blank" rel="noopener" href="https://answers.ros.org/question/11682/robot_pose_ekf-with-an-external-sensor/?answer=17402#post-id-17402">ROS answer的回答</a><br><a target="_blank" rel="noopener" href="http://xxty.fun/2019/08/12/ROS%E5%B0%8F%E8%BD%A6%EF%BC%9Arobot_pose_ekf%E8%9E%8D%E5%90%88%E9%87%8C%E7%A8%8B%E8%AE%A1%E4%BF%A1%E6%81%AF/">XiaoXiaoTao博客</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/25/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8/">抛出异常</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><p>异常是运行期出现的情况，编译不会报错。如果出现异常，它后面的代码不会执行，一般会显示<font color = orange size= 3> </font> The program has unexpectedly finished. &lt;/font&gt;。如果能处理好异常，就可以让后面的代码继续运行</p>
<p>throw就是抛出异常，后面可以接任何语句表示异常。比如<code>throw 123;</code>, <code>throw &quot;exception&quot;;</code></p>
<p>try里面的第一个语句必须包含throw，可以是个函数。之后的语句不再进行，直接进catch了</p>
<p>catch的参数是和throw一致的，比如下面的<code>const char*</code>，如果要catch任何类型，小括号内换成<code>...</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">division</span>(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;本句不执行&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span><br><span class="line">&#123;</span><br><span class="line">  cerr &lt;&lt; msg &lt;&lt; endl;	<span class="comment">// 输出错误用cerr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++ 提供了一系列标准的异常，定义在<exception>，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的。可以使用<code>catch(std::exception e)</code></p>
<p>一些第三方库也提供了异常，使用时要注意。比如log4cpp:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    log4cpp::PropertyConfigurator::<span class="built_in">configure</span>(config_base_path+<span class="string">&quot;setting.conf&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (log4cpp::ConfigureFailure&amp; f)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Configure Problem: &quot;</span> &lt;&lt; f.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>假如程序运行前没有配置文件，而且没有使用异常机制，后面的程序就没法运行了。这不一定是我们想要的，我们不一定要求log4cpp的运行，所以使用异常就很合适了。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/25/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/operator()/">operator()</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>   <span class="title">operator</span><span class="params">()</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;Foo operator&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val*<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo f;</span><br><span class="line"><span class="built_in">f</span>();    <span class="comment">// Foo operator</span></span><br><span class="line">cout&lt;&lt; <span class="built_in">f</span>(<span class="number">5</span>) &lt;&lt;endl;  <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<p>Foo是定义了调用操作符()的类,它的对象就相当于函数名,因此<code>operator()</code>取名叫函数对象</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/21/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/MQTT(%E4%BA%8C)%20QtMqtt%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%8E%B0%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/">MQTT(二) QtMqtt客户端实现发布订阅</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/">第三方库</a></span><div class="content"><p>代码在<a target="_blank" rel="noopener" href="https://github.com/charon-cheung/MQTT_Client">这里</a>，网上的示例是<a target="_blank" rel="noopener" href="https://github.com/emqx/qmqtt">这个</a>，但是我发现现在的QtMqtt已经变换很大，之前的API很多已经不能使用了</p>
<p>值得注意的是，客户端不能在构造函数里订阅话题，因为客户端在connected信号对应的槽函数里才连接成功，所以订阅也应该换到槽函数或者自己做的按钮里</p>
<p>MQTT的通信可以在wireshark里读取，可以直接解析MQTT的数据包：<br><img src="https://i.loli.net/2020/03/22/sR7NwdvrjLHnp4m.png" alt="发布话题test到客户端"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/21/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/MQTT(%E4%B8%80)%20%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8CQt%E5%BA%93/">MQTT (一) 配置服务器和Qt库</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/">第三方库</a></span><div class="content"><h2 id="安装服务器"><a href="#安装服务器" class="headerlink" title="安装服务器"></a>安装服务器</h2><p>配置安装看<a target="_blank" rel="noopener" href="https://www.qingtingip.com/h_298196.html">ubuntu安装MQTT服务器 + windows安装MQTT客户端</a>，主要是三个安装命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装服务端</span></span><br><span class="line">sudo apt-get install mosquitto</span><br><span class="line"><span class="comment">#安装客户端 （订阅sub  与 发布pub）</span></span><br><span class="line">sudo apt-get install mosqutitto-client</span><br><span class="line"><span class="comment">#安装调试器</span></span><br><span class="line">sudo apt-get install mosquitto-dbg </span><br></pre></td></tr></table></figure></p>
<ul>
<li>订阅话题test: mosquitto_sub -t test </li>
<li>发布消息到话题test: mosquitto_pub -t test -m “hello world” </li>
</ul>
<h2 id="编译Qt库QtMqtt"><a href="#编译Qt库QtMqtt" class="headerlink" title="编译Qt库QtMqtt"></a>编译Qt库QtMqtt</h2><p>Qt现在支持MQTT了， 但是很坑的是还需要自己编译，我用的是Qt5.14，从网上找了好几个版本都编译出问题，看了不知道多少博客，最后终于编译成功了。</p>
<p>从<a target="_blank" rel="noopener" href="https://github.com/qt/qtmqtt">Github官方仓库</a>下载5.14.0，解压到<code>F:\MyCpp\qtmqtt-5.14.0</code>，打开后编译，结果会报错，这是因为头文件的问题。在<code>qtmqtt-5.14.0\src\mqtt\mqtt.pro</code>中添加一行<font color = blue size =3> INCLUDEPATH += F:\MyCpp\qtmqtt-5.14.0 </font>，然后qmake, 编译。应该就成功了。</p>
<p>新建的测试程序<code>MQTT_Client</code>，然后将<code>qtmqtt-5.14.0\src\mqtt</code>文件夹中的所有头文件放到一个文件夹<code>QtMqtt</code>，然后放到程序的根目录。到编译生成的文件夹，将<code>lib</code>和<code>include</code>文件夹也放到<code>MQTT_Client</code>根目录，其中的文件Qt5Mqtt.dll.debug可以删除。</p>
<p>编辑<code>MQTT_Client.pro</code>，添加下面内容：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INCLUDEPATH += $<span class="variable">$PWD</span></span><br><span class="line">DEPENDPATH += $<span class="variable">$PWD</span>/include</span><br><span class="line"></span><br><span class="line">win32:CONFIG(release, debug|release): LIBS += -L$<span class="variable">$PWD</span>/lib/ -lQt5Mqtt</span><br><span class="line"><span class="keyword">else</span>:win32:CONFIG(debug, debug|release): LIBS += -L$<span class="variable">$PWD</span>/lib/ -lQt5Mqtt</span><br></pre></td></tr></table></figure></p>
<p>现在程序就可以用QtMqtt了，但是最好能让mqtt跟Qt自身库一样使用，也就是在pro文件中添加<code>QT += mqtt</code>即可，这样才叫优雅。参考<a href="">如何让第三方库和Qt自身库一样使用</a></p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29350001/article/details/76680646">搭建MQTT服务器及测试</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yexiaopeng/p/8542894.html">Qt官方MQTT库的配置</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/18/%E6%BF%80%E5%85%89SLAM/%E9%9B%B7%E8%BE%BE/%E9%9B%B7%E8%BE%BE%E7%9A%84%E8%AE%BE%E5%A4%87%E5%8F%82%E6%95%B0/">单线雷达的设备参数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/%E9%9B%B7%E8%BE%BE/">雷达</a></span><div class="content"><p>大多数雷达都是TOF测量法，只有深度信息，没有相机那样的纹理信息，也就没有视觉SLAM的运算负荷。</p>
<p>目前常见的激光雷达都是旋转扫描式的，内部长期处于旋转中的机械结构会给系统带来不稳定性，在颠簸震动时影响尤其明显。固态激光雷达的逐步成熟可能会为激光SLAM扳回这项劣势。</p>
<p>激光雷达的使用寿命问题已经被解决，能够保证长时间使用不会出现故障。比如在连续工作情况下，RPLIDAR-A2的设计使用寿命可长达5年以上。</p>
<p>雷达的光线遇到大雾、烟尘会受到遮挡，影响性能。</p>
<h2 id="测试材质"><a href="#测试材质" class="headerlink" title="测试材质"></a>测试材质</h2><p>选用雷达需要判断雷达是否适用于自己的场合，所以根据需要在以下场景进行测试</p>
<ul>
<li><p>大理石瓷砖。 应用场景参考：酒店大堂、走廊、室外墙壁</p>
</li>
<li><p>玻璃。 应用场景参考：玻璃门窗，办公大厅、玻璃柜台。 激光会穿过透明玻璃，从而造成一定概率的漏检。可以增加一些辅助反射手段，比如粘贴磨砂贴纸，或配合其他非光学的传感器作为补充。 <strong>雷达有时会穿透玻璃，有时不会，所以临时在玻璃上贴磨砂纸。</strong></p>
</li>
<li><p>不锈钢板。 应用场景参考：电梯、生产车间、港口码头</p>
</li>
<li><p>反光条。 应用场景参考：医院、生产车间、酒店大堂</p>
</li>
</ul>
<h2 id="误差源"><a href="#误差源" class="headerlink" title="误差源"></a>误差源</h2><ul>
<li><p>发送和接收激光束的精确耗时误差，也就是计时设备的精度问题</p>
</li>
<li><p>目标材质的反射值特性，比如全黑的材料吸收了光的大部分能量，使得反射量极低；或者像镜子一样的材料会将大部分光反射到其它地方</p>
</li>
<li><p>运动畸变：由于激光雷达在跟随自动驾驶车辆前进的同时，对周围环境进行扫描建模，也就是说车辆相对于周围的环境是运动的，导致对环境测量的实际位置与真实位置存在偏差。但是扫描频率高，速度低时，可以不必考虑。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/05/07/ICpiBQHvzquXkJj.png" alt=""></p>
<h2 id="测距范围"><a href="#测距范围" class="headerlink" title="测距范围"></a>测距范围</h2><p>指雷达能够测量的距离范围。如果实际障碍距离超出最大值，那么雷达数据会标记为无效点（不是距离为0）。市面上2D雷达最近距离也至少几厘米</p>
<p>实际情况下，雷达测距的最大值有可能因为工作环境而产生变化。雷达要想测距，需要接收到反射的激光。所以官方在测距范围这一项上添加了备注：“基于白色70%反射率物体”。</p>
<p>如果是吸收激光比较厉害的物体，例如黑色的表面又几乎不反光的物体，会导致反射光强度很弱，那么距离稍微远点，可能就测距失败了，这时候，该物体即使在标出的12米范围内同样无法测出。针对类似这样的物体，相当于实际测距的最大值变小了。透明的玻璃也是同样原因。</p>
<p>不过因为不同的物体和环境差异太大了，所以厂商也不太可能将全部情况测试一遍，更多的时候需要靠自己来实验，看是否能够适用实际的工作环境。</p>
<h2 id="扫描角度"><a href="#扫描角度" class="headerlink" title="扫描角度"></a>扫描角度</h2><p>思岚雷达是360°扫描的。有些雷达例如SICK的一些雷达，扫描角度只有220°。 实际使用，通常也不需要完全的360°，特别是雷达放在结构的中间层，因为有结构固定装置的存在，必然会有遮挡。</p>
<h2 id="测距分辨率"><a href="#测距分辨率" class="headerlink" title="测距分辨率"></a>测距分辨率</h2><p>分辨率和精度是两个不同的概念，按照上述参数的意思，更准确来说应该指的是测距精度。</p>
<p>RPLIDAR的精度并不是恒定的一个百分比，简单的解释是，距离越远，反射光受到的干扰越大，自然精度下降了。实际上，不同批次的雷达精度之间也有一定的差异。正因为这些不确定性，官方文档给的是较保守的值。</p>
<p>1.5m范围内小于0.5mm的精度还是可以的，1.5米处约为万分之三点三。<br>当在最大距离12米的时候，如果精度下降到最差的1%，则误差为0.12m，也能接受。</p>
<h2 id="扫描频率"><a href="#扫描频率" class="headerlink" title="扫描频率"></a>扫描频率</h2><p><img src="https://i.loli.net/2020/03/18/6tNElCuaoWwJhcG.png" alt="扫描频率.png"><br>衡量雷达一秒钟能转多少圈，直接改叫雷达转速也是可以的。</p>
<p>转速实际上跟雷达数据更新周期是挂钩的，比如说典型的10Hz，那就是说转一圈的时间大概是100ms，那么雷达数据差不多也是100ms一帧。 要跟<code>scan</code>话题的发布频率区分开，后者跟计算机性能有关。</p>
<p><code>LMS1xx</code>系列的扫描频率是25～50Hz，角度分辨率为<code>0.25°～0.50°</code><br><code>LMS5xx</code>系列的扫描频率是25～100Hz，角度分辨率为<code>0.1667°～1°</code></p>
<p>雷达自身的旋转是有方向的，大部分雷达都是逆时针旋转，与ROS中规定的一样，也有少部分雷达是顺时针旋转的，只不过使用起来有点不方便。</p>
<h2 id="角度分辨率"><a href="#角度分辨率" class="headerlink" title="角度分辨率"></a>角度分辨率</h2><p>正常来说，雷达转一圈，这一圈得到的测量点是均匀分布的，每个点之间间隔的角度就是所谓的角度分辨率了。</p>
<p>角度分辨率越小说明雷达转一圈得到的点数越多。例如，角度分辨率是0.45，则一圈是800个点，角度分辨率是0.9，则一圈是400个点。</p>
<p>不过，实际的角度分辨率其实不一定是固定的，即两个点之间的间距不一定是相同的，不过都在给出的分辨率范围内。在ROS中，雷达数据的标准格式认为角度分辨率是固定的，为了符合ROS标准，雷达的ROS驱动实际上做了角度补偿，将输出点修正为均匀分布的。</p>
<h2 id="数据的强度"><a href="#数据的强度" class="headerlink" title="数据的强度"></a>数据的强度</h2><p>激光雷达的激光点是有能量的，不同品牌激光点的能量也不同。当能量太小时，远距离情况下可能存在返回不了数据的情况。</p>
<p>可以等阳光或者使用光束照射到墙面上，激光雷达再去看被光照射到的墙面，对比这时的点云效果。可以用照度仪测量此时的光强度。倍加福雷达的点云效果在高强度情况下非常好，不愧是用于反光板的雷达。<br><img src="https://i.loli.net/2021/05/07/kvqoJwYV3ItgWmd.png" alt=""></p>
<h2 id="数据的精度"><a href="#数据的精度" class="headerlink" title="数据的精度"></a>数据的精度</h2><p>这是最重要的一个指标，表示激光雷达的数据跳动情况。现在一般厂商的雷达的精度都是2%。也就是100m的情况下，点的跳动幅度为2cm。但是，实际感觉能达到这个精度的雷达不是很多。</p>
<h2 id="multi-echo"><a href="#multi-echo" class="headerlink" title="multi-echo"></a>multi-echo</h2><p>multi-echo可以分析每个测量光束的两个回波信号，这样在雨雪天可以提供可靠的测量结果。一般激光打到玻璃上会有部分穿透，导致测量不准，multi-echo使激光从玻璃上返回来，还能从玻璃后面的墙上返回来。</p>
<p>有的雷达具备这种特性，比如<code>SICK-LMS111</code></p>
<p><br></p>
<p><img src="https://i.loli.net/2020/07/17/hifrG8DxmdnAXTJ.png" alt="A2雷达.png"></p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/tiancailx/article/details/110141867">从零开始搭二维激光SLAM —- 激光雷达数据效果对比</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/VOm_h4WYREsvz7rYfOKIiA">LakiBeam1雷达</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/16/C++/C++%20%20%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/STL%E6%80%BB%E7%BB%93/">STL总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/">C++ 模板与STL</a></span><div class="content"><h3 id="查找速度"><a href="#查找速度" class="headerlink" title="查找速度"></a>查找速度</h3><p>对序列式容器，如果元素已经排好序，那么查找速度可以达到logN的时间复杂度；如果是无序，只能是N</p>
<p>对关联容器，底层是红黑树，总能达到logN</p>
<h3 id="有在任意位置插入元素的需求；-大量添加新元素的需求"><a href="#有在任意位置插入元素的需求；-大量添加新元素的需求" class="headerlink" title="有在任意位置插入元素的需求； 大量添加新元素的需求"></a>有在任意位置插入元素的需求； 大量添加新元素的需求</h3><p>最好用list，不要使用vector, deque</p>
<h3 id="元素的排序"><a href="#元素的排序" class="headerlink" title="元素的排序"></a>元素的排序</h3><p>遍历元素的时候，序列容器输出的顺序和插入的顺序是一致的，关联容器就不一定了</p>
<p>sort()函数是快速排序的分段递归版本</p>
<p>关联容器的插入删除效率一般比用其他序列容器高(list除外)，因为不需要做内存拷贝和内存移动</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/15/C++/C++%20%20%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8set%E5%92%8Cmap/">关联式容器set和map</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/">C++ 模板与STL</a></span><div class="content"><p>STL 标准库提供了 4 种关联式容器，分别为 map、set、multimap、multiset</p>
<p><img src="https://s2.loli.net/2022/02/16/elb3D1QFEnmAoIv.png" alt=""></p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set的元素有序不重复，而且能根据元素的值自动进行排序。set中的键值不能直接修改，只能先删除再插入。底层采用红黑树。</p>
<p>set不支持随机访问，只能使用迭代器去访问。由于set放入一个元素就会调整这个元素的位置，把它放到合适的位置，所以set中只有一个insert插入操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;set 的 size：&quot;</span>&lt;&lt;  s.<span class="built_in">size</span>() &lt;&lt;endl;  <span class="comment">// 5</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;set 中的第一个元素是 ：&quot;</span>&lt;&lt;  *s.<span class="built_in">begin</span>()&lt;&lt;endl;  <span class="comment">// 1</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;set 中的最后一个元素是:&quot;</span>&lt;&lt;  *s.<span class="built_in">end</span>()&lt;&lt;endl;   <span class="comment">// 5</span></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=s.<span class="built_in">begin</span>(); it!=s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt; *it &lt;&lt;endl;</span><br><span class="line">&#125;    <span class="comment">// 1  2  3  4  5</span></span><br><span class="line"><span class="comment">//    s.clear();</span></span><br><span class="line">s.<span class="built_in">erase</span>(++s.<span class="built_in">begin</span>());</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;       after erase begin&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(it=s.<span class="built_in">begin</span>(); it!=s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt; *it &lt;&lt;endl;</span><br><span class="line">&#125;	 <span class="comment">// 1  3  4  5</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;lower bound: &quot;</span>&lt;&lt;*s.<span class="built_in">lower_bound</span>(<span class="number">5</span>)&lt;&lt;endl;  <span class="comment">// 5</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;upper bound: &quot;</span>&lt;&lt;*s.<span class="built_in">upper_bound</span>(<span class="number">5</span>)&lt;&lt;endl;  <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">empty</span>())</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;set is empty !&quot;</span> &lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>multiset底层也是红黑树，但允许有重复数据</p>
<h2 id="map-和-unordered-map"><a href="#map-和-unordered-map" class="headerlink" title="map 和 unordered_map"></a>map 和 unordered_map</h2><p>map适合存储一个数据字典，并要求方便地根据key找value。Map节点有一个Key和Value两个元素，Key不重复，Value可以重复。map可以通过key改变value的值</p>
<p>底层也是红黑树，所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此它的插入删除查找的时间复杂度为O(logN)</p>
<p>map支持随机访问(<code>at</code>函数和<code>[]</code>)，这是set没有的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, string&gt; m;</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">4</span>, <span class="string">&quot;d&quot;</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">5</span>, <span class="string">&quot;e&quot;</span>));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; m.<span class="built_in">upper_bound</span>(<span class="number">3</span>)-&gt;second &lt;&lt;endl;   <span class="comment">// 大于</span></span><br><span class="line">cout &lt;&lt; m.<span class="built_in">lower_bound</span>(<span class="number">3</span>)-&gt;second &lt;&lt;endl;   <span class="comment">// 不小于</span></span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d</span><br><span class="line">c</span><br></pre></td></tr></table></figure></p>
<p><strong>缺点</strong>： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间<br><br></p>
<p><code>unordered_map</code>内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的，但查找速度非常的快。  <strong>缺点</strong>：哈希表的建立比较耗费时间。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/13/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/(%E4%BA%8C)%20%E7%BB%BC%E8%BF%B0,%20%E8%AF%9D%E9%A2%98%E5%92%8C%E6%9C%8D%E5%8A%A1/">(二) 综述, 话题和服务</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/">原理和配置</a></span><div class="content"><p>Cartographer是基于图优化的SLAM，采用误差累计少，计算成本低的<code>Scan to Map</code>匹配方式，而不是造成误差快速累积和计算成本高的scan to scan匹配。整个算法分为局部SLAM和全局SLAM，两部分都对雷达观测的位姿进行了优化。</p>
<p>虽然cartographer适用于2D和3D两种情况，但3D情况下，cartographer用的不如LOAM多</p>
<h2 id="订阅的话题"><a href="#订阅的话题" class="headerlink" title="订阅的话题"></a>订阅的话题</h2><p>节点<code>cartographer_node</code>订阅的话题是：<code>scan</code>, <code>tf</code>, <code>tf_static</code>。 <code>cartographer_node</code>的launch需要增加remap，因为它接受的话题名称和我们现有的话题可能不一致：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;scan&quot;</span>  <span class="attr">to</span>=<span class="string">&quot;/scan&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;odom&quot;</span>  <span class="attr">to</span>=<span class="string">&quot;/xqserial_server/Odom&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;imu&quot;</span>   <span class="attr">to</span>=<span class="string">&quot;/xqserial_server/IMU&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><br>所有相关的话题名称都定义在<code>node_constants.h</code></p>
<h2 id="cartographer-node-发布的话题"><a href="#cartographer-node-发布的话题" class="headerlink" title="cartographer_node 发布的话题"></a>cartographer_node 发布的话题</h2><ul>
<li><p>scan_matched_points2, 类型<code>sensor_msgs/PointCloud2</code>, <code>scan-to-submap</code>匹配的2D点云数据，这个云可以根据配置进行滤波和投影。是<code>scan</code>话题的大部分，不会包括行走的人的轮廓</p>
</li>
<li><p>submap_list, 类型<code>cartographer_ros_msgs/SubmapList</code>，所有轨迹的所有submaps的列表，成员：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header</span><br><span class="line">cartographer_ros_msgs/SubmapEntry[] submap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其中submap的类型如下</span></span><br><span class="line">int32 trajectory_id</span><br><span class="line">int32 submap_index</span><br><span class="line">int32 submap_version</span><br><span class="line">geometry_msgs/Pose pose</span><br></pre></td></tr></table></figure>
<p>话题包括一个子图的ID list(包括轨迹ID和子图index)，以及子图的全局位姿。</p>
</li>
</ul>
<p>发布话题的源码流程是 <code>Node::PublishSubmapList</code> —— <code>MapBuilderBridge::GetSubmapList()</code> —— <code>PoseGraph2D::GetAllSubmapPoses()</code>  —— <code>PoseGraph2D::GetSubmapDataUnderLock</code> —— <code>PoseGraph2D::ComputeLocalToGlobalTransform</code></p>
<ul>
<li><code>trajectory_node_list</code>，类型为<code>visualization_msgs/MarkerArray</code>，即轨迹路径node列表，代码是</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Node::PublishTrajectoryNodeList</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> ::ros::WallTimerEvent&amp; unused_timer_event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (trajectory_node_list_publisher_.<span class="built_in">getNumSubscribers</span>() &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    carto::<span class="function">common::MutexLocker <span class="title">lock</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    trajectory_node_list_publisher_.<span class="built_in">publish</span>(</span><br><span class="line">        map_builder_bridge_.<span class="built_in">GetTrajectoryNodeList</span>()  );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>constraint_list: 类型为<code>visualization_msgs/MarkerArray</code>，约束列表</p>
</li>
<li><p>landmark_poses_list: 类型为<code>visualization_msgs/MarkerArray</code>，路标点位姿列表</p>
</li>
</ul>
<p>节点 <code>cartographer_occupancy_grid_node</code> 发布话题 <code>map</code>(栅格地图)， 订阅<code>submap_list [cartographer_ros_msgs/SubmapList]</code>。 <code>cartographer_occupancy_grid_node</code> 节点将子图转换为ROS的地图格式</p>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><ul>
<li>submap_query (cartographer_ros_msgs/SubmapQuery)： 查询submap的服务，输入的是<code>trajectory_id</code> 和 <code>submap_index</code><br><img src="https://i.loli.net/2020/08/03/j4FWEl8GIfer2dJ.png" alt="call submap_query"><br><img src="https://i.loli.net/2020/08/03/EkAOlJWTapY6x7D.png" alt=""></li>
</ul>
<h3 id="start-trajectory"><a href="#start-trajectory" class="headerlink" title="start_trajectory"></a>start_trajectory</h3><p>类型<code>cartographer_ros_msgs/StartTrajectory</code>，通过将其传感器主题和轨迹选项指定为二进制编码的原型来启动另一个轨迹。返回指定的轨迹ID。</p>
<p><code>StartTrajectory.srv</code>:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string   configuration_directory</span><br><span class="line">string   configuration_basename</span><br><span class="line">bool   use_initial_pose</span><br><span class="line">geometry_msgs/Pose   initial_pose</span><br><span class="line">int32   relative_to_trajectory_id</span><br><span class="line">---</span><br><span class="line">cartographer_ros_msgs/StatusResponse   status</span><br><span class="line">int32   trajectory_id</span><br></pre></td></tr></table></figure></p>
<p>命令稍微长了点:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /start_trajectory <span class="string">&quot;configuration_directory: &#x27;/home/user/carto_ws/src/cartographer_ros/cartographer_ros/configuration_files&#x27;</span></span><br><span class="line"><span class="string">configuration_basename: &#x27;localization.lua&#x27;</span></span><br><span class="line"><span class="string">use_initial_pose: true</span></span><br><span class="line"><span class="string">initial_pose:</span></span><br><span class="line"><span class="string">  position: &#123;x: 5.211, y: 5.617, z: 0.0&#125;</span></span><br><span class="line"><span class="string">  orientation: &#123;x: 0.0, y: 0.0, z: 0.689, w: 0.725&#125;</span></span><br><span class="line"><span class="string">relative_to_trajectory_id: 0&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>出错的地方可能会在<code>relative_to_trajectory_id</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">status:</span><br><span class="line">  code: 5</span><br><span class="line">  message: <span class="string">&quot;Trajectory 6 doesn&#x27;t exist.&quot;</span></span><br><span class="line"></span><br><span class="line">status:</span><br><span class="line">  code: 3</span><br><span class="line">  message: <span class="string">&quot;Trajectory 5 is in &#x27;DELETED&#x27; state.&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>加载 frozen state 意味着不插入no pose graph constraints. 一条frozen trajectory和它的子图不受 optimization影响</p>
<h3 id="finish-trajectory"><a href="#finish-trajectory" class="headerlink" title="finish_trajectory"></a>finish_trajectory</h3><p>类型<code>cartographer_ros_msgs/FinishTrajectory</code>: Finish 一个给定ID的轨迹，方式是运行最终的图优化。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int32 trajectory_id</span><br><span class="line">---</span><br><span class="line">cartographer_ros_msgs/StatusResponse status</span><br></pre></td></tr></table></figure>
<p>命令<code>rosservice call finish_trajectory &quot;trajectory_id: 5&quot;</code>，得到这样的结果:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">status:</span><br><span class="line">  code: 3</span><br><span class="line">  message: <span class="string">&quot;Topics are already used by another trajectory.&quot;</span></span><br><span class="line">trajectory_id: 0</span><br></pre></td></tr></table></figure></p>
<h3 id="trajectory-query"><a href="#trajectory-query" class="headerlink" title="trajectory_query"></a>trajectory_query</h3><ul>
<li>get_trajectory_states (cartographer_ros_msgs/GetTrajectoryStates):  返回所有轨迹的ID和状态， 可以用于从单独的节点观察Cartographer的状态。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">cartographer_ros_msgs/StatusResponse   status</span><br><span class="line">cartographer_ros_msgs/TrajectoryStates  trajectory_states</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>命令<code>rosservice call /get_trajectory_states &quot;&#123;&#125;&quot;</code>，比如得到这样的结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">status:</span><br><span class="line">  code: 0</span><br><span class="line">  message: <span class="string">&#x27;&#x27;</span></span><br><span class="line">trajectory_states:</span><br><span class="line">  header:</span><br><span class="line">    seq: 0</span><br><span class="line">    stamp:</span><br><span class="line">      secs: 1612232712</span><br><span class="line">      nsecs:  41338148</span><br><span class="line">    frame_id: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  trajectory_id: [0, 1, 2, 3, 4, 5]</span><br><span class="line">  trajectory_state: [2, 2, 2, 2, 2, 0]</span><br></pre></td></tr></table></figure></p>
<p><code>trajectory_state</code>的枚举值也就是<font color = blue size=4> 轨迹的四种状态对应:  ACTIVE, FINISHED, FROZEN, DELETED</font></p>
<ul>
<li>write_state (cartographer_ros_msgs/WriteState): 将当前内部状态写入磁盘到文件名。用于保存pbstream文件，此文件可用作<code>assets_writer_main</code>的输入，以生成概率网格，X-Rays或PLY文件等资源</li>
</ul>
<h3 id="read-metrics"><a href="#read-metrics" class="headerlink" title="read_metrics"></a>read_metrics</h3><p>类型<code>(cartographer_ros_msgs/ReadMetrics)</code>， 返回Cartographer的所有内部指标的最新值。运行时度量标准的集合(collection of runtime metrics)是可选的，必须使用节点中的<code>-collect_metrics</code>命令行标志激活:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;cartographer_node&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;cartographer_ros&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">&quot;cartographer_node&quot;</span> <span class="attr">args</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">          -configuration_directory $(find cartographer_ros)/configuration_files</span></span></span><br><span class="line"><span class="string"><span class="tag">          -configuration_basename map.lua</span></span></span><br><span class="line"><span class="string"><span class="tag">          -collect_metrics true&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;scan&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/scan_rectified&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;odom&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/odom&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果没有加<code>-collect_metrics</code>标志，<code>rosservice call /read_metrics &quot;&#123;&#125;&quot;</code>的结果:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">status:</span><br><span class="line">  code: 14</span><br><span class="line">  message: <span class="string">&quot;Collection of runtime metrics is not activated.&quot;</span></span><br><span class="line">metric_families: []</span><br><span class="line">timestamp:</span><br><span class="line">  secs: 1612333336</span><br><span class="line">  nsecs: 359502516</span><br></pre></td></tr></table></figure></p>
<h2 id="需要的tf变换"><a href="#需要的tf变换" class="headerlink" title="需要的tf变换"></a>需要的tf变换</h2><p>必须提供从所有传入传感器数据帧到配置的<code>tracking_frame</code>和<code>published_frame</code>的转换。通常，这些是由robot_state_publisher或static_transform_publisher定期发布的。</p>
<h2 id="发布的tf变换"><a href="#发布的tf变换" class="headerlink" title="发布的tf变换"></a>发布的tf变换</h2><p>提供<code>map_frame</code>和 <code>published_frame</code>之间的转换。如果在Lua中启用了<code>provide_odom_frame</code>，则将提供配置的<code>odom_frame</code>和<code>published_frame</code>之间的连续（不受循环闭包影响）转换。</p>
<h2 id="其他节点"><a href="#其他节点" class="headerlink" title="其他节点"></a>其他节点</h2><p><img src="https://i.loli.net/2020/07/20/yG6YpBRhMjvrVWS.png" alt="cartographer_ros的所有节点.png"></p>
<ul>
<li>cartographer_rosbag_validate</li>
</ul>
<p>可以检测bag中的错误，使用：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun cartographer_ros cartographer_rosbag_validate -bag_filename &lt;bag filename&gt;</span><br></pre></td></tr></table></figure><br>比如会有这样的结果：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">E0722 <span class="number">22</span>:<span class="number">11</span>:<span class="number">01.138546</span>  <span class="number">3442</span> rosbag_validate_main.cc:<span class="number">389</span>] IMU data (frame_id: <span class="string">&quot;imu&quot;</span>) has a large gap, largest <span class="keyword">is</span> <span class="number">0.064731</span> s, recommended <span class="keyword">is</span> [<span class="number">0.0005</span>, <span class="number">0.005</span>]s <span class="keyword">with</span> no jitter.</span><br><span class="line">I0722 <span class="number">22</span>:<span class="number">11</span>:<span class="number">01.139314</span>  <span class="number">3442</span> rosbag_validate_main.cc:<span class="number">398</span>] Time delta histogram <span class="keyword">for</span> consecutive messages on topic <span class="string">&quot;/IMU_data&quot;</span> (frame_id: <span class="string">&quot;imu&quot;</span>):</span><br><span class="line">Count: <span class="number">27679</span>  Min: <span class="number">0.000144</span>  Max: <span class="number">0.064731</span>  Mean: <span class="number">0.005027</span></span><br><span class="line">[<span class="number">0.000144</span>, <span class="number">0.006602</span>)    					    Count: <span class="number">27445</span> (<span class="number">99.154594</span>%)    Total: <span class="number">27445</span> (<span class="number">99.154594</span>%)</span><br><span class="line">[<span class="number">0.006602</span>, <span class="number">0.013061</span>)                            Count: <span class="number">181</span> (<span class="number">0.653925</span>%)  Total: <span class="number">27626</span> (<span class="number">99.808517</span>%)</span><br><span class="line">[<span class="number">0.013061</span>, <span class="number">0.019520</span>)                            Count: <span class="number">42</span> (<span class="number">0.151740</span>%)   Total: <span class="number">27668</span> (<span class="number">99.960258</span>%)</span><br><span class="line">[<span class="number">0.019520</span>, <span class="number">0.025979</span>)                            Count: <span class="number">7</span> (<span class="number">0.025290</span>%)    Total: <span class="number">27675</span> (<span class="number">99.985550</span>%)</span><br><span class="line">[<span class="number">0.025979</span>, <span class="number">0.032437</span>)                            Count: <span class="number">3</span> (<span class="number">0.010839</span>%)    Total: <span class="number">27678</span> (<span class="number">99.996384</span>%)</span><br><span class="line">[<span class="number">0.032437</span>, <span class="number">0.038896</span>)                            Count: <span class="number">0</span> (<span class="number">0.000000</span>%)    Total: <span class="number">27678</span> (<span class="number">99.996384</span>%)</span><br><span class="line">[<span class="number">0.038896</span>, <span class="number">0.045355</span>)                            Count: <span class="number">0</span> (<span class="number">0.000000</span>%)    Total: <span class="number">27678</span> (<span class="number">99.996384</span>%)</span><br><span class="line">[<span class="number">0.045355</span>, <span class="number">0.051814</span>)                            Count: <span class="number">0</span> (<span class="number">0.000000</span>%)    Total: <span class="number">27678</span> (<span class="number">99.996384</span>%)</span><br><span class="line">[<span class="number">0.051814</span>, <span class="number">0.058272</span>)                            Count: <span class="number">0</span> (<span class="number">0.000000</span>%)    Total: <span class="number">27678</span> (<span class="number">99.996384</span>%)</span><br><span class="line">[<span class="number">0.058272</span>, <span class="number">0.064731</span>]                            Count: <span class="number">1</span> (<span class="number">0.003613</span>%)    Total: <span class="number">27679</span> (<span class="number">100.000000</span>%)</span><br></pre></td></tr></table></figure><br>需要的时间范围是[0.0005, 0.005]，但是看给出的范围列表，只有第一个还算在这个范围里，剩下约1%不合要求。</p>
<ul>
<li>cartographer_pbstream_map_publisher</li>
</ul>
<p>一个简单的节点，它从序列化的Cartographer状态（pbstream格式）创建静态占用网格。如果实时更新不重要，它是占用网格节点的有效替代方案。  发布话题：map (nav_msgs/OccupancyGrid)，只发布一次</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/40/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/40/">40</a><span class="page-number current">41</span><a class="page-number" href="/page/42/">42</a><span class="space">&hellip;</span><a class="page-number" href="/page/60/">60</a><a class="extend next" rel="next" href="/page/42/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2023 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>