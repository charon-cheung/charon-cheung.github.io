<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">598</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">55</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/09/18/hCro9MUd6JjRe1Q.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/13/%E5%9F%BA%E4%BA%8EUWB%E7%9A%84%E8%B7%9F%E9%9A%8F%E5%AF%BC%E8%88%AA/3.%20%E8%B7%9F%E9%9A%8F%E5%AF%BC%E8%88%AA%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/">(三) 跟随导航中的问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E4%BA%8EUWB%E7%9A%84%E8%B7%9F%E9%9A%8F%E5%AF%BC%E8%88%AA/">基于UWB的跟随导航</a></span><div class="content"><h2 id="发目标后，车不动，直接Goal-Reached"><a href="#发目标后，车不动，直接Goal-Reached" class="headerlink" title="发目标后，车不动，直接Goal Reached"></a>发目标后，车不动，直接Goal Reached</h2><p><img src="https://i.loli.net/2021/11/09/RTDzpAdLElqbj1h.png" alt="发目标后，直接Goal Reached"><br>看目标位姿没有什么异常，查到源码，其实就是<code>xy_goal_tolerance</code>设置成4太大了，比起点和目标的间距还大</p>
<h2 id="不加载地图，出现传感器原点出范围"><a href="#不加载地图，出现传感器原点出范围" class="headerlink" title="不加载地图，出现传感器原点出范围"></a>不加载地图，出现传感器原点出范围</h2><p><img src="https://i.loli.net/2021/11/09/cavh4oVms1LwQz7.png" alt="传感器原点出了地图范围.png"><br>其实还能继续导航，暂时不处理</p>
<h2 id="关里程计后，车仍然导航，但路径不正常"><a href="#关里程计后，车仍然导航，但路径不正常" class="headerlink" title="关里程计后，车仍然导航，但路径不正常"></a>关里程计后，车仍然导航，但路径不正常</h2><p>因为电机驱动器的程序有时出问题，会获取不到里程计，此时就会报错。在正常情况下，手动关闭里程计进行测试，但车继续导航，路径很奇怪，可能会撞障碍。没有了里程计，在代价地图里无法正常获取<code>robot_pose</code>，当然路径不对了。<br><img src="https://i.loli.net/2021/11/11/p7u9atPowI8KAv5.png" alt=""><br>报错在<code>MoveBase::makePlan</code>里，继续追溯到<code>MoveBase::planThread()</code>的部分<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> gotPlan = n.<span class="built_in">ok</span>() &amp;&amp; <span class="built_in">makePlan</span>(temp_goal, *planner_plan_);</span><br><span class="line"><span class="keyword">if</span>(gotPlan)</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(state_==PLANNING)</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(state_ == CONTROLLING)</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><br>加日志发现报错的内容不在上面三个情况里，这倒很意外，由于此时获取不到在代价地图里的全局坐标系的位姿，再加一个情况，处理方式是<code>resetState</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">getRobotPose</span>(odom_global_pose, planner_costmap_ros_))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;couldn&#x27;t get robot pose in global costmap, stop car !&quot;</span>);</span><br><span class="line">  <span class="built_in">resetState</span>();</span><br><span class="line">  runPlanner_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="车在跑了一定范围后找不到全局路径"><a href="#车在跑了一定范围后找不到全局路径" class="headerlink" title="车在跑了一定范围后找不到全局路径"></a>车在跑了一定范围后找不到全局路径</h2><p><img src="https://i.loli.net/2021/11/11/LjF59tsqfoWJ3U2.png" alt="报错"><br>找到报错的地方是 <code>MoveBase::planThread</code> —— <code>GlobalPlanner::makePlan</code> —— <code>found_legal</code>为false<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> gotPlan = n.<span class="built_in">ok</span>() &amp;&amp; <span class="built_in">makePlan</span>(temp_goal, *planner_plan_);</span><br><span class="line"><span class="keyword">if</span>(gotPlan)</span><br><span class="line">    ......</span><br><span class="line"><span class="comment">//if we didn&#x27;t get a plan and we are in the planning state (the robot isn&#x27;t moving)</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(state_==PLANNING)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">ROS_DEBUG_NAMED</span>(<span class="string">&quot;move_base_plan_thread&quot;</span>,<span class="string">&quot;No Plan...&quot;</span>);</span><br></pre></td></tr></table></figure><br>原来是全局代价地图的大量的代价值没有被及时清除，导致目标在障碍物里<br><img src="https://i.loli.net/2021/11/11/79oanXtm6kZH215.png" alt="清除了大部分的代价值.png"><br><img src="https://i.loli.net/2021/11/11/4KMkY2oDh5Z6wWH.png" alt="代价值一直没有清除.png"></p>
<p>导航一段时间，rviz显示如下，开始以为是渲染问题，后来发现是真的代价值<br><img src="https://i.loli.net/2021/11/09/HIlrnJPqxOpEhWT.png" alt=""><br><img src="https://i.loli.net/2021/11/09/mApMTcQXYE1gwBF.png" alt=""><br>原来是之前修改<code>MoveBase::makePlan</code>时，根据失败次数清除代价地图时的问题，因此不再限制超出最大次数后不清理，只对<code>min_clear_</code>做判断；也不在清除后sleep</p>
<h2 id="跟随时，反向旋转"><a href="#跟随时，反向旋转" class="headerlink" title="跟随时，反向旋转"></a>跟随时，反向旋转</h2><p>基本上是目标的朝向突变， 所以对发布的目标朝向限制在<code>[-65°, 65°]</code>。<br><img src="https://i.loli.net/2021/11/13/LOSRPTniAWyrCkJ.png" alt="正确的.png"><br><img src="https://i.loli.net/2021/11/13/FrbZDtaQCBYyc34.png" alt="突变后的.png"></p>
<p>偶尔也会发x<0的目标，应避免，另外目标点的处理可能缩减过多：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ym = (dis - <span class="number">4</span>)/ dis * Ym</span><br><span class="line">Xm = (dis - <span class="number">4</span>)/ dis * Xm</span><br></pre></td></tr></table></figure></p>
<h2 id="UWB在近距离，车不能跟随旋转"><a href="#UWB在近距离，车不能跟随旋转" class="headerlink" title="UWB在近距离，车不能跟随旋转"></a>UWB在近距离，车不能跟随旋转</h2><p>之前的代码对<code>move_base_simple/goal</code>为0的情况都pass了，再恢复又好了。但是位姿朝向不稳定的问题有时仍造成异常。 在低速模式下，加大角速度和角加速度，跟随旋转效果明显提升</p>
<p><br></p>
<h2 id="人突然走到车后，但UWB的x坐标没有负值"><a href="#人突然走到车后，但UWB的x坐标没有负值" class="headerlink" title="人突然走到车后，但UWB的x坐标没有负值"></a>人突然走到车后，但UWB的x坐标没有负值</h2><p>机器人在避障过程中可能会旋转，也可能人突然从前面走到车靠后的地方(出了±70°的范围)，这两种情况导致目标出现在UWB基站后方。但这个型号的UWB的X坐标没有负值，无法区分前后信息，机器人会继续向前行走。 </p>
<h2 id="UWB在车高速行走时，位姿还是会不稳定"><a href="#UWB在车高速行走时，位姿还是会不稳定" class="headerlink" title="UWB在车高速行走时，位姿还是会不稳定"></a>UWB在车高速行走时，位姿还是会不稳定</h2><p>以上两个问题都使用<code>yolo_pose</code>融合的方法解决。即增加摄像头，与UWB和雷达在同一条竖直线上，间距只有几厘米。人穿上黄衣服，摄像头识别人的位姿做<code>yolo_pose</code>，其特点是</p>
<ul>
<li>范围比UWB小，不足20米</li>
<li>稳定性一直更好，尤其在近距离比UWB更稳定更准确</li>
<li>在不远不近的距离，大致在<code>5~15米</code>范围内，二者的稳定性和准确性没有差别</li>
</ul>
<p>这样就可以使用<code>yolo_pose</code>弥补稳定性和近距离的位姿准确性。</p>
<p><code>yolo_pose</code>的频率大，约3Hz。但是<code>uwb_pose</code>的频率只有2Hz。</p>
<p>两个位姿的朝向<br><img src="https://s2.loli.net/2021/12/04/BmSwDy3PaLigdEO.png" alt="uwb和yolo的位姿朝向 1.png"><br><img src="https://s2.loli.net/2021/12/04/erdgDFRBbHToVW2.png" alt="uwb和yolo的位姿朝向 2.png"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/13/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/%E9%9A%9C%E7%A2%8D%E5%B1%826%20%20%E5%8A%A0%E9%80%9F%E6%B8%85%E9%99%A4%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E9%9A%9C%E7%A2%8D/">障碍层6 加速清除代价地图中的障碍</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content"><h2 id="雷达无法及时清除代价地图中的障碍"><a href="#雷达无法及时清除代价地图中的障碍" class="headerlink" title="雷达无法及时清除代价地图中的障碍"></a>雷达无法及时清除代价地图中的障碍</h2><p>使用代价地图时，会出现由于激光雷达测距的局限性，代价地图中的障碍会不能及时清除。 比如有行人走过会拖出一个条状障碍或者雷达扫描到障碍仍不能清除。问题根源在于某些激光雷达测的距离超过极限，会没有相对应的数据。 </p>
<p>不同的激光雷达的情况不一样。所以<code>costmap</code>的源码不可能处理所有的情况。 在测不到数据时， sick雷达，返回的是inf。国内一些雷达，在未测到数据时，返回的是0.0 或者默认的最大值。</p>
<p>代码在障碍层的<code>ObstacleLayer::laserScanValidInfCallback</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; message.ranges.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">float</span> range = message.ranges[ i ];</span><br><span class="line">  <span class="keyword">if</span> ( (!std::<span class="built_in">isfinite</span>(range) &amp;&amp; range &gt; <span class="number">0</span>)  )</span><br><span class="line">  &#123;</span><br><span class="line">    message.ranges[ i ] = message.range_max - epsilon;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码处理了每一个激光的数据，如果是激光的点是最大的距离(不是 finite)，那么将这个点设置为比最大距离小十分之一毫米。看来程序作者也考虑到了这个问题，当激光的距离等于最大的距离的时候会出现障碍物无法清除的现象，但是作者不可能对所有雷达出现数据invalid的情况都做判断，这就需要自己加了。</p>
<p>有两种已知的雷达数据invalid的情况:</p>
<ul>
<li><p>雷达在超出量程或没数据时返回0，上面的if判断加入  <code>|| range ==0.0</code>，</p>
</li>
<li><p>雷达的数据超出量程后设为大于range_max的值，而不是inf，比如量程位30m的HOKUYO激光雷达，超量程后会返回65.33m。这样也不在上面的if判断里，加入<code>range &gt;= range_max</code></p>
</li>
</ul>
<p><strong>最后还要在通用代价地图中设置<code>inf_is_valid</code>参数为true</strong></p>
<font color = blue size = 4>  但是这只适用于单线雷达，如果是多线雷达或相机的深度点云，回调函数就是 pointCloud2Callback，不能用这个方法了。</font>


<h2 id="地图分辨率高于激光雷达分辨率"><a href="#地图分辨率高于激光雷达分辨率" class="headerlink" title="地图分辨率高于激光雷达分辨率"></a>地图分辨率高于激光雷达分辨率</h2><p>在<code>costmap_common_params.yaml</code>中有两个配置参数<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obstacle_range: 2.5  //只有障碍物在这个范围内才会被标记</span><br><span class="line">raytrace_range: 3    //这个范围内不存在的障碍物都会被清除</span><br></pre></td></tr></table></figure><br>当<code>raytrace_range = 3</code>时，假设激光雷达的角分辨率是1，即360度每一度一个激光点时，每个激光点之间的距离大约是0.052(1x3.14/180 x3), 如果此时地图的分辨率是0.01，在靠近激光点附近有一个障碍物，但是始终在激光雷达两条射线之间的话，也就是始终没有扫描到的话，那这个障碍始终无法被清除掉。所以参数<code>raytrace_range</code>不是越大越好</p>
<p>我们知道代价地图实际上是一定分辨率的方格图，两条射线如下图所示，根据<strong>bresenham2D</strong>算法找到经过的蓝色方格，这些方格的代价值会置为<code>FREE_SPACE</code>。但实际上黄色方格也应该置为<code>FREE_SPACE</code>，但是因为角分辨率不足而没有扫射到，这就是问题的由来。<br><img src="https://i.loli.net/2021/11/09/U5KIhSez2VkngPm.png" alt="示意图"></p>
<p>解决方法首先是买好雷达，角分辨率一定要好。</p>
<p>清除障碍物是<code>ObstacleLayer::raytraceFreespace</code>，<br><code>raytraceLine(marker, x0, y0, x1, y1, cell_raytrace_range);</code> 会将所有在(x0,y0)&gt;&gt;(x1,y1)之间的所有cell标记为<code>FREE_SPACE</code></p>
<p><code>updateRaytraceBounds</code>会根据测量的距离，更新扩张<code>(min_x, min_y, max_x, max_y)</code></p>
<p><code>updateBounds</code> 在根据测量数据完成 clear 操作之后，就开始了mark 操作，对每个测量到的点，标记为obstacle</p>
<p>修改清除代价值的规则，即<code>ObstacleLayer::raytraceFreespace</code>，把一个激光点做十字形扩展：<br><img src="https://i.loli.net/2021/11/09/UM2fgSe1FRKyckv.png" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cloud.points.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> wx = cloud.points[i].x;</span><br><span class="line">    <span class="keyword">double</span> wy = cloud.points[i].y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ROS_INFO(&quot;laser scan wx = %.2f, wy = %.2f&quot;, wx, wy);</span></span><br><span class="line">    <span class="comment">//在检测到的点周围生成6x6的点，</span></span><br><span class="line">    <span class="keyword">double</span> inflate_dx = <span class="number">0.01</span>, inflate_dy = <span class="number">0.01</span>; <span class="comment">//在原来点的位置膨胀的尺度</span></span><br><span class="line">    std::vector&lt; std::pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; &gt; inflate_pts;</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx +    <span class="number">0</span>      , wy +     <span class="number">0</span>     ));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx -    <span class="number">0</span>      , wy - inflate_dy));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx - inflate_dx, wy -     <span class="number">0</span>     ));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx + <span class="number">0</span>         , wy + inflate_dy));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx + inflate_dx, wy +     <span class="number">0</span>      ));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx -    <span class="number">0</span>        , wy - <span class="number">2</span>*inflate_dy));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx - <span class="number">2</span>*inflate_dx, wy -     <span class="number">0</span>     ));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx +    <span class="number">0</span>        , wy + <span class="number">2</span>*inflate_dy));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx + <span class="number">2</span>*inflate_dx, wy +     <span class="number">0</span>      ));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx -    <span class="number">0</span>        , wy - <span class="number">3</span>*inflate_dy));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx - <span class="number">3</span>*inflate_dx, wy -     <span class="number">0</span>     ));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx +    <span class="number">0</span>        , wy + <span class="number">3</span>*inflate_dy));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx + <span class="number">3</span>*inflate_dx, wy +     <span class="number">0</span>      ));  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实质上增加一个循环</span></span><br><span class="line">    std::vector&lt; std::pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; &gt;::iterator inflate_iter;</span><br><span class="line">    <span class="keyword">for</span>(inflate_iter = inflate_pts.<span class="built_in">begin</span>(); inflate_iter != inflate_pts.<span class="built_in">end</span>(); inflate_iter++)</span><br><span class="line">    &#123;</span><br><span class="line">      wx = (*inflate_iter).first;</span><br><span class="line">      wy = (*inflate_iter).second;</span><br><span class="line">            ......</span><br><span class="line">      <span class="function">MarkCell <span class="title">marker</span><span class="params">(costmap_, FREE_SPACE)</span></span>;</span><br><span class="line">      <span class="comment">// and finally... we can execute our trace to clear obstacles along that line</span></span><br><span class="line">      <span class="comment">//最终raytraceLine(marker, x0, y0, x1, y1, cell_raytrace_range); </span></span><br><span class="line">      <span class="comment">//会将所有在(x0,y0)&gt;&gt;(x1,y1)之间的所有cell标记为FREE_SPACE。</span></span><br><span class="line">      <span class="built_in">raytraceLine</span>(marker, x0, y0, x1, y1, cell_raytrace_range);</span><br><span class="line">      <span class="comment">//而updateRaytraceBounds 会根据测量的距离，更新扩张（min_x, min_y, max_x, max_y）。</span></span><br><span class="line">      <span class="built_in">updateRaytraceBounds</span>(ox, oy, wx, wy, clearing_observation.raytrace_range_, min_x, min_y, max_x, max_y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="move-base中自动清除代价地图"><a href="#move-base中自动清除代价地图" class="headerlink" title="move_base中自动清除代价地图"></a>move_base中自动清除代价地图</h2><p><code>move_base.cpp</code>修改<code>MoveBase::makePlan</code>，在多次找不到全局路径时，清除代价地图，其实跟<code>clear_costmaps</code>服务端的代码是一样的。一开始我还在<code>move_base</code>里定义了客户端函数，在规划失败太多时发起service请求<code>move_base/clear_costmaps</code>，后来发现服务端的代码就在<code>move_base</code>里，就两行：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!planner_-&gt;<span class="built_in">makePlan</span>(start, goal, plan) || plan.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">ROS_DEBUG_NAMED</span>(<span class="string">&quot;move_base&quot;</span>,<span class="string">&quot;Failed to find a  plan to point (%.2f, %.2f)&quot;</span>, </span><br><span class="line">    goal.pose.position.x, goal.pose.position.y);</span><br><span class="line"></span><br><span class="line">  failed_num++;</span><br><span class="line">  <span class="keyword">if</span>(failed_num &gt; min_clear_ )</span><br><span class="line">  &#123;</span><br><span class="line">    controller_costmap_ros_-&gt;<span class="built_in">resetLayers</span>();</span><br><span class="line">    planner_costmap_ros_-&gt;<span class="built_in">resetLayers</span>();</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;\033[44;37m clear costmaps done ! \033[0m&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>min_clear_</code>是我自定义的参数<code>min_clear</code>的赋值，默认是4。</p>
<p><code>failed_num</code>在构造函数中初始化为0，这是当然的。 另外注意<code>failed_num</code>在 <code>MoveBase::executeCb</code>开头置为0，因为这里是收到新目标的地方。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43259286/article/details/107205695?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link">激光点做圆形扩展</a></p>
<h2 id="客户端发起清除代价地图的请求"><a href="#客户端发起清除代价地图的请求" class="headerlink" title="客户端发起清除代价地图的请求"></a>客户端发起清除代价地图的请求</h2><p>有时全局代价地图还是不能及时清除，但是又不能使用上面自动清除的方法。考虑在客户端(python 程序)发目标点时，先发起<code>move_base/clear_costmaps</code>服务，让<code>move_base</code>清除一次，这样效果好多了。我开始是修改<code>planThread</code>和<code>executeCb</code>函数，但是这两个函数在路径规划时并不是只运行一次，多次运行会清除过多，会撞障碍；如果清除后执行sleep，又使机器人表现卡顿。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/04/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/%E9%9A%9C%E7%A2%8D%E5%B1%825%20%20%E4%BB%8E%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE%E6%B8%85%E9%99%A4%E9%9A%9C%E7%A2%8D/">障碍层5  raytraceFreespace从代价地图清除障碍</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content"><p>在上一篇的<code>UpdateBounds</code>函数最后到了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clearing_observations.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">raytraceFreespace</span>(clearing_observations[i], min_x, min_y, max_x, max_y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://i.loli.net/2021/11/15/i79yefxSj3lzVgY.png" alt="流程"></p>
<p>清理传感器到障碍物间的cell，会首先处理测量值越界的问题，然后调用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MarkCell <span class="title">marker</span><span class="params">(costmap_, FREE_SPACE)</span></span>;</span><br><span class="line"><span class="comment">// and finally... we can execute our trace to clear obstacles along that line</span></span><br><span class="line"><span class="built_in">raytraceLine</span>(marker, x0, y0, x1, y1, cell_raytrace_range);</span><br><span class="line"><span class="built_in">updateRaytraceBounds</span>(ox, oy, wx, wy, clearing_observation.raytrace_range_, min_x, min_y, max_x, max_y);</span><br></pre></td></tr></table></figure><br>最终<code>raytraceLine(marker, x0, y0, x1, y1, cell_raytrace_range);</code> 会将所有在<code>(x0,y0)&gt;&gt;(x1,y1)</code>之间的所有cell标记为<code>FREE_SPACE</code>。而<code>updateRaytraceBounds</code> 会根据测量的距离，更新扩张<code>（min_x, min_y, max_x, max_y）</code><br><code>updateBounds</code>在根据测量数据完成 clear 操作之后，就开始了mark 操作，对每个测量到的点，标记为obstacle ：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> px = cloud.points[i].x, py = cloud.points[i].y, pz = cloud.points[i].z;</span><br><span class="line"></span><br><span class="line">......省略</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> index = <span class="built_in">getIndex</span>(mx, my);</span><br><span class="line">costmap_[index] = LETHAL_OBSTACLE;</span><br><span class="line"><span class="built_in">touch</span>(px, py, min_x, min_y, max_x, max_y);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.loli.net/2021/07/14/s2UD3i8wOE4zPCo.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @brief  Given distance in the world, convert it to cells</span></span><br><span class="line"><span class="comment"> * @param  world_dist: The world distance</span></span><br><span class="line"><span class="comment"> * @return The equivalent cell distance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Costmap2D::cellDistance</span><span class="params">(<span class="keyword">double</span> world_dist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> cells_dist = <span class="built_in">max</span>(<span class="number">0.0</span>, <span class="built_in">ceil</span>(world_dist / resolution_));</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)cells_dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarkCell</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MarkCell</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>* costmap, <span class="keyword">unsigned</span> <span class="keyword">char</span> value) :</span><br><span class="line">      <span class="built_in">costmap_</span>(costmap), <span class="built_in">value_</span>(value)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> offset)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    costmap_[offset] = value_;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>* costmap_;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> value_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="updateCosts"><a href="#updateCosts" class="headerlink" title="updateCosts"></a>updateCosts</h2><p>代价地图中每个cell可用255个不同值中任何一个值，可是下层数据结构仅需要3个值。具体来说，每个cell仅需要3个值来表示cell的3种状态：free，occupied，unknown。 当投影到代价地图时候，每种状态被赋一个特定的代价值，也就是说<font size="4" color="blue"> 每个cell的cost值是由这个cell对应的各层中对应的cell的状态进行加权得到的。 </font> 如果列有一定量的占用就被赋代价值。 如果存储的障碍物信息是3D的，需要将每一列的障碍物信息投影成2D后才能放入到代价地图。</p>
<p>更新障碍地图代价，将机器人足迹范围内设置为 <code>FREE_SPACE</code>，并且在 bound 范围内将本层障碍地图的内容合并到主地图上。</p>
<p>障碍物层是将传感器检测到的点云投影到地图中，不同的传感器来源会分别存到Observation类中。只要遍历存储Observation的容器，将检测到的点云的每个点分别投影到地图中，将对应的网格的代价值设为<code>LETHAL_OBSTACLE</code>，实现函数在<code>ObstacleLayer::updateBounds</code>中：</p>
<p>清除代价地图的方式也很好理解，以单线激光雷达的激光线为例子，当激光线发射出去之后，在某处检测到一个障碍物，那说明：从发射的地方至某处之间是free的，那么这之间的旧的障碍物应当被删除，这之间网格的代价值应当被修改为free</p>
<p>可能是Bresenham2D的round off error(舍入误差)造成的. It marks a particular cell as obstacle but the next time when the sensor reading changes instantaneously, it no longer traces it through the same path and hence, the blob seem remains in the costmap.</p>
<p>added 2 lines of code to the Bresenham2D algorithm. This basically clears the cell to the left and right of the grid through which the Line segment constructed by the algorithm passes. This results in loosing some resolution of the map, but the solution works pretty well in real life application</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A 2D implementation of Bresenham&#x27;s raytracing algorithm, applies an action </span></span><br><span class="line"><span class="comment">// at each step template&lt;class ActionType&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bresenham2D</span><span class="params">( ActionType at, <span class="keyword">unsigned</span> <span class="keyword">int</span> abs_da, <span class="keyword">unsigned</span> <span class="keyword">int</span> abs_db, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">int</span> error_b, <span class="keyword">int</span> offset_a, <span class="keyword">int</span> offset_b, <span class="keyword">unsigned</span> <span class="keyword">int</span> offset, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">unsigned</span> <span class="keyword">int</span> max_length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> end = std::<span class="built_in">min</span>(max_length, abs_da);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; end; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">at</span>(offset);</span><br><span class="line">    <span class="built_in">at</span>(offset+<span class="number">1</span>); <span class="comment">// **ADDED THIS LINE**</span></span><br><span class="line">    <span class="built_in">at</span>(offset<span class="number">-1</span>); <span class="comment">// **ADDED THIS LINE**</span></span><br><span class="line">    offset += offset_a;</span><br><span class="line">    error_b += abs_db;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)error_b &gt;= abs_da)</span><br><span class="line">    &#123;</span><br><span class="line">      offset += offset_b;</span><br><span class="line">      error_b -= abs_da;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">at</span>(offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/04/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/map_server%E5%8A%A0%E8%BD%BD%E4%B8%8D%E5%90%8C%E5%A4%A7%E5%B0%8F%E5%9C%B0%E5%9B%BE%E7%9A%84%E5%BD%B1%E5%93%8D/">map_server加载不同大小地图的影响</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content"><h2 id="小地图"><a href="#小地图" class="headerlink" title="小地图"></a>小地图</h2><p>加载小地图，目标点出了地图范围时，导航会失败，<code>GlobalPlanner::makePlan</code>出现报警:</p>
<font color = orange size=4>The robot's start position is off the global costmap. Planning will always fail, are you sure the robot has been properly localized? </font>

<p>这很容易理解，除了地图就到不了了</p>
<h2 id="大地图"><a href="#大地图" class="headerlink" title="大地图"></a>大地图</h2><p>加载一个空的 20000x20000 的地图，转成pgm格式，高达380M。结果加载时会在<code>map_server::loadMapFromFile</code>里报错： <font color = red size = 4>  [ERROR] failed to open image file “/home/dxr/ws/src/follow/map/big_blank.pgm”: Out of memory
 </font></p>
<p>原理是map_server使用<code>SDL</code>加载地图文件，这就把问题下降到SDL了。ubuntu18所用SDL版本是1.2，原因在源码<code>SDL_surface.c</code>里对地图宽和高做了限制<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SDL_Surface * <span class="title">SDL_CreateRGBSurface</span> <span class="params">(Uint32 flags,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> depth,</span></span></span><br><span class="line"><span class="params"><span class="function">      Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      ......</span><br><span class="line">  <span class="comment">/* Make sure the size requested doesn&#x27;t overflow our datatypes */</span></span><br><span class="line">  <span class="comment">/* Next time I write a library like SDL, I&#x27;ll use int for size. :) */</span></span><br><span class="line">  <span class="keyword">if</span> ( width &gt;= <span class="number">16384</span> || height &gt;= <span class="number">65536</span> ) &#123;</span><br><span class="line">    <span class="built_in">SDL_SetError</span>(<span class="string">&quot;Width or height is too large&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">      ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>到这里其实不用再研究了，不用想怎么改善SDL了。有些公司的处理方法是每次只加载一部分地图，这也是3D稠密和稀疏重建常用的方法</p>
<p>其实就算这里通过了，到move_base创建代价地图时，new分配了太多内存，还有可能出错</p>
<h2 id="不加载地图"><a href="#不加载地图" class="headerlink" title="不加载地图"></a>不加载地图</h2><p>最令人想不到的是还可以不加载地图，使用里程计，但此时无法规划路径。把全局代价地图的参数改的跟局部代价地图一样，去掉静态层，但是增大<code>rolling_window</code>的大小，也就是说使用一大一小的局部代价地图，然后就可以规划路径了，相当于以前只用局部代价地图避障。这看上去冗余，而且浪费计算机性能。<br><img src="https://i.loli.net/2021/11/04/8sQTD96qcWpHtYv.png" alt=""><br>如果不用全局代价地图，启动不报错，还是无法规划路径。原因在于<code>move_base.cpp</code>里对全局和局部代价地图都使用了，除非将源码中的全局代价地图部分删除，不过影响太大了。<br><br></p>
<p>不加载地图时，可以正常导航，但是代价值会累计很多，需要设置自动清除<br><img src="https://i.loli.net/2021/11/11/79oanXtm6kZH215.png" alt="清除了大部分的代价值.png"><br><img src="https://i.loli.net/2021/11/11/4KMkY2oDh5Z6wWH.png" alt="代价值一直没有清除.png"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/03/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/xsens%20IMU/">xsens IMU的使用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/">ROS机器人</a></span><div class="content"><p><code>roslaunch xsens_driver xsens_driver.launch</code></p>
<p>节点<code>xsens_driver</code>发布话题:</p>
<ul>
<li>/diagnostics [diagnostic_msgs/DiagnosticArray]</li>
<li>/imu/data [sensor_msgs/Imu]，  被节点<code>data_pretreat_node</code>订阅</li>
<li>/imu_data_str [std_msgs/String]</li>
<li>/time_reference [sensor_msgs/TimeReference]</li>
<li>/velocity [geometry_msgs/TwistStamped]</li>
</ul>
<p><code>xsens.bag</code>对应车先向前行驶，然后原地转约180°，然后再往回走。</p>
<p><img src="https://s2.loli.net/2021/12/08/lkSfcqKt7eDGWuA.png" alt="imu数据占用的带宽.png"></p>
<p>参考:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41469272/article/details/107512032">基于ros melodic 及 MTI-G-710测试</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/LSG_Down/article/details/81068114">Xsens MTi -1 姿态传感器恢复与MTI的通信的方法</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/10/31/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/python%E4%B8%AD%E4%BD%BF%E7%94%A8ROS%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/">python中使用ROS的注意点</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-10-31</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a></span><div class="content"><h2 id="python2-7和python3的冲突问题"><a href="#python2-7和python3的冲突问题" class="headerlink" title="python2.7和python3的冲突问题"></a>python2.7和python3的冲突问题</h2><p>之前在<a href="">ROS安装和编译等常见问题.md</a>提到了python3.8和python2.7冲突的问题，那次是不同文件可以分别用不同版本的python运行，但是如果同一个文件里用到了python的两个版本，那就不好解决了。</p>
<p>比如一个文件需要用到python3的函数，然后发现<code>import tf</code>报错，没法用tf了，因为<code>tf2_ros</code>是针对python2编译的，为了适应python3 (melodic)，进行如下步骤：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install python3-catkin-pkg-modules python3-rospkg-modules python3-empy</span><br><span class="line">Prepare catkin workspace</span><br><span class="line"></span><br><span class="line">mkdir -p ~/catkin_ws/src; <span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br><span class="line">wstool init</span><br><span class="line">wstool <span class="built_in">set</span> -y src/geometry2 --git https://github.com/ros/geometry2 -v 0.6.5</span><br><span class="line">wstool up</span><br><span class="line">rosdep install --from-paths src --ignore-src -y -r</span><br><span class="line">Finally compile <span class="keyword">for</span> Python 3</span><br><span class="line"></span><br><span class="line">catkin_make --cmake-args \</span><br><span class="line">            -DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">            -DPYTHON_EXECUTABLE=/usr/bin/python3 \</span><br><span class="line">            -DPYTHON_INCLUDE_DIR=/usr/include/python3.6m \</span><br><span class="line">            -DPYTHON_LIBRARY=/usr/lib/x86_64-linux-gnu/libpython3.6m.so</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br></pre></td></tr></table></figure></p>
<h2 id="让python支持中文注释"><a href="#让python支持中文注释" class="headerlink" title="让python支持中文注释"></a>让python支持中文注释</h2><p>在源文件的初始部分，而且必须放在第一行，添加<code>#coding=utf-8</code> 或者 <code>#coding=gbk</code> 或<code># -- coding: gb2312 --</code></p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://answers.ros.org/question/326226/importerror-dynamic-module-does-not-define-module-export-function-pyinit__tf2/">ImportError: dynamic module does not define module export function (PyInit__tf2)</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/10/27/%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E7%9A%84%E6%8E%A8%E5%AF%BC%201/">卡尔曼滤波的推导(一)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-10-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC/">算法推导</a></span><div class="content"><p>根据自己的情况，推导观测方程和雅克比矩阵</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/10/26/%E6%BF%80%E5%85%89SLAM/%E9%9B%B7%E8%BE%BE/%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE/">毫米波雷达</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-10-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/%E9%9B%B7%E8%BE%BE/">雷达</a></span><div class="content"><p>毫米波雷达：介于微波和红外线之间，频率范围10GHz—200GHz，毫米波的频段高于无线电，低于可见光和红外线，这是一个非常适合车载领域的频段，波长为毫米级。测距原理是把无线电波（雷达波/电磁波）发射出去，根据接收回波与发送之间的时间差测得目标位置距离数据。一般的探测距离在0-200米之间。安装也可以完全隐蔽，不影响车辆整体外观。因此毫米波雷达技术更适用于汽车防撞领域。</p>
<p>激光雷达：介于红外线和可见光之间，频率大致为100000GHz，波长为纳米级</p>
<p>毫米波雷达的探测距离受到频段损耗的直接制约（想要探测的远，就必须使用高频段雷达），也无法感知行人，并且对周边所有障碍物无法进行精准的建模。这一点就大不如激光雷达。</p>
<p>激光雷达发射的电磁波是一条直线，主要以光粒子发射为主要方法，而毫米波雷达发射出去的电磁波是一个锥状的波束，这个波段的天线主要以电磁辐射为主。</p>
<p>从抗干扰能力上来讲，由于激光雷达通过发射光束进行探测，受环境影响较大，光束受遮挡后就不能正常使用，因此无法在雨雪雾霾天，沙尘暴等恶劣天气中开启，而毫米波的引导头穿透雾、烟、灰尘的能力强，因此可以在糟糕的天气中探测，在这一点上毫米波雷达更胜一筹。</p>
<p>激光雷达获取的数据量远超毫米波雷达，所以需要更高性能的处理器来处理数据，成本高了，售价自然就更贵了。</p>
<p>一般毫米波雷达的数据格式就是z=(a,r,s)，其中a表示物体相对于汽车的角度，r表示和汽车之间的距离，s表示径向速度。而一次扫描会有很多的物体，结果就会变成 (z1, z2, z3…)。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/10/22/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%85%A8%E5%B1%80%E8%B7%AF%E5%BE%84/%E5%85%A8%E5%B1%80%E8%B7%AF%E5%BE%84%E4%B8%8D%E6%AD%A3%E5%B8%B8%E7%9A%84%E8%A7%84%E5%88%92%E5%A4%B1%E8%B4%A5/">全局路径不正常的规划失败</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-10-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%85%A8%E5%B1%80%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/">全局路径算法</a></span><div class="content"><p>精灵2所用全局路径的参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">planner_window_x: <span class="number">0.0</span></span><br><span class="line">planner_window_y: <span class="number">0.0</span></span><br><span class="line">default_tolerance: <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">publish_scale: <span class="number">100</span></span><br><span class="line">planner_costmap_publish_frequency: <span class="number">0.0</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.loli.net/2021/10/22/XZNH9QPWKsdBh76.png" alt="全局路径很奇怪.png"><br><img src="https://i.loli.net/2021/10/22/1Pb3XQe5Tnv8Mjk.png" alt="全局路径失败时的报错.png"><br><img src="https://i.loli.net/2021/10/25/YoQAJSDxRZdnrzw.png" alt="全局路径规划失败"></p>
<p>看代码<code>GlobalPlanner::makePlan</code>中的<code>if (found_legal)</code>部分，再看<code>GlobalPlanner::getPlanFromPotential</code>函数，继续定位到<code>path_maker_-&gt;getPath</code>。这里就需要看<code>path_maker</code>是什么东西，在文件中发现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (use_grid_path)   <span class="comment">// 参数</span></span><br><span class="line">    <span class="comment">//栅格路径，从终点开始找上下或左右4个中最小的栅格直到起点</span></span><br><span class="line">    path_maker_ = <span class="keyword">new</span> <span class="built_in">GridPath</span>(p_calc_);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">//梯度路径，从周围八个栅格中找到下降梯度最大的点</span></span><br><span class="line">path_maker_ = <span class="keyword">new</span> <span class="built_in">GradientPath</span>(p_calc_);</span><br></pre></td></tr></table></figure><br><code>use_grid_path</code>默认是false，所以一般用<code>GradientPath</code>，最终看<code>GradientPath::getPath</code>为什么返回false</p>
<p>将<code>if (fabs(nx - start_x) &lt; .5 &amp;&amp; fabs(ny - start_y) &lt; .5)</code> 中的0.5改为1</p>
<p>查来查去，终于发现其实就是全局代价地图里，本来就处于障碍的附近，所以规划如此奇怪。只是换到了室外环境，不习惯看全局代价地图了<br><img src="https://i.loli.net/2021/10/25/Cv9ncJuRMY4IoeU.png" alt=""></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/10/21/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Synchronizer%E8%BF%9B%E8%A1%8C%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/">message_filters::Synchronizer进行时间同步</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-10-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><p>多传感器数据融合的时候，由于各个传感器采集数据的频率的不同，例如odom 50Hz、Imu 100Hz、camera 25Hz，需要将传感器数据进行时间同步后才能进行融合。</p>
<p>分别订阅不同的需要融合的传感器的主题，通过<code>TimeSynchronizer</code>统一接收多个主题，只有在所有的topic都有相同的时间戳时，才会产生一个同步结果的回调函数，在回调函数里处理同步时间后的数据。</p>
<p>注意: 只有多个主题都有数据的时候才可以触发回调函数。如果其中一个主题的发布节点崩溃了，则整个回调函数永远无法触发回调。 <strong>频率一般趋于和最低的频率一样。</strong> 当多个主题频率一致的时候，回调函数的频率(融合后的频率)可能会小于订阅主题的频率。</p>
<p><code>message_filters::Synchronizer</code>省去了不同线程(回调函数)之间的同步问题，两线程的数据直接放到一个回调里处理。 但是它对传感器数据进行时间同步后，回调函数里的两个话题的时间戳会完全一样，纳秒级的相同。这是经过了ROS的调整，但有时候可能不是我们想要的。</p>
<p>对齐传感信息时间戳有两种方式, 一种是时间戳完全对齐 <strong>ExactTime Policy</strong>, 另一种是时间戳相近 <strong>ApproximateTime Policy</strong>, 前者更为严格, 但有时会没有结果而无法进行回调函数。所以一般还是用后者</p>
<p><a target="_blank" rel="noopener" href="http://wiki.ros.org/message_filters">message_filters</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/long5683/p/13223458.html">message_filters::Synchronizer的使用</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21830903/article/details/106532143">传感器数据之间的时间同步问题</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/13/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/60/">60</a><a class="extend next" rel="next" href="/page/15/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/09/18/hCro9MUd6JjRe1Q.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>