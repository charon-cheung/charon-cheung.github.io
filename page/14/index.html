<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">559</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">49</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2024/11/12/x1aqcwUG3XDiskN.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2023/03/04/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E9%9A%9C%E7%A2%8D%E7%BA%A6%E6%9D%9F%E5%92%8C%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8E%A8%E5%AF%BC/">障碍约束和雅格比矩阵的推导</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/">TEB算法</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E5%90%84%E7%B1%BB%E7%BA%A6%E6%9D%9F%E5%8F%8A%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5/">各类约束及雅格比矩阵</a></span><div class="content"><p>障碍约束定义的误差函数表示机器人到障碍的最小距离。 $ \min \textrm{penaltyBelow}( dist2point ) \cdot weight $. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VertexPose* bandpt = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> VertexPose*&gt;(_vertices[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// calculateDistance(const PoseSE2&amp; current_pose, const Obstacle* obstacle) 计算机器人到障碍物的距离</span></span><br><span class="line"><span class="comment">// current_pose为当前机器人的位姿。</span></span><br><span class="line"><span class="keyword">double</span> dist = robot_model_-&gt;<span class="built_in">calculateDistance</span>(bandpt-&gt;<span class="built_in">pose</span>(), _measurement);</span><br><span class="line">_error[<span class="number">0</span>] = <span class="built_in">penaltyBoundFromBelow</span>(dist, cfg_-&gt;obstacles.min_obstacle_dist, cfg_-&gt;optim.penalty_epsilon);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cfg_-&gt;optim.obstacle_cost_exponent != <span class="number">1.0</span> &amp;&amp; cfg_-&gt;obstacles.min_obstacle_dist &gt; <span class="number">0.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  _error[<span class="number">0</span>] = cfg_-&gt;obstacles.min_obstacle_dist * std::<span class="built_in">pow</span>(_error[<span class="number">0</span>] / cfg_-&gt;obstacles.min_obstacle_dist, </span><br><span class="line">  										cfg_-&gt;optim.obstacle_cost_exponent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>obstacle_cost_exponent</code>和<code>min_obstacle_dist</code>的设置，一般都会进入if情况。 注意 max cost (before weighting) is the same as the straight line version and that all other costs are below the straight line (for positive exponent), so it may be necessary to increase weight_obstacle and/or the inflation_weight when using larger exponents.</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/03/04/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E6%97%B6%E9%97%B4%E7%BA%A6%E6%9D%9F%E5%92%8Ckinematics%E7%BA%A6%E6%9D%9F%E5%8F%8A%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8E%A8%E5%AF%BC/">时间约束和kinematics约束及雅格比矩阵的推导</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/">TEB算法</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E5%90%84%E7%B1%BB%E7%BA%A6%E6%9D%9F%E5%8F%8A%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5/">各类约束及雅格比矩阵</a></span><div class="content"><h2 id="时间约束"><a href="#时间约束" class="headerlink" title="时间约束"></a>时间约束</h2><p><code>EdgeTimeOptimal</code>类太简单了，误差函数 <code>_error[0] = timediff-&gt;dt();</code>，优化 <script type="math/tex">\Delta T_i</script>，那么对其求偏导，显然只有一个矩阵，一个元素 1 ： <code>_jacobianOplusXi( 0 , 0 ) = 1;</code></p>
<h2 id="kinematics-约束"><a href="#kinematics-约束" class="headerlink" title="kinematics 约束"></a>kinematics 约束</h2><p>两个误差方程，一个是 non-holonomic约束， ：<br><img src="https://s2.loli.net/2023/03/09/fA3hlesp26nZrN7.png" alt=""><br>初始配置<script type="math/tex">x_i</script>和方向<script type="math/tex">d_i,d_{i+1}</script>之间的角度<script type="math/tex">\theta _i</script> 必须等于配置<script type="math/tex">x_{i+1}</script>和方向<script type="math/tex">d_i,d_{i+1}</script>之间的夹角，即<script type="math/tex">\theta _i = \theta_{i+1}</script></p>
<p>根据二维叉积 A×B=|A| |B|⋅sinα 得到<br><img src="https://s2.loli.net/2023/03/09/XRLQ2BNg1Mu8VfE.png" alt=""><br>所以代码中的目标函数写成</p>
<script type="math/tex; mode=display">|(cos{\theta_1}+cos{\theta_2})(y_2-y_1) - (sin{\theta_1}+sin{\theta_2})(x_2-x_1) |</script><p>另一个是 positive-drive-direction约束</p>
<script type="math/tex; mode=display">-(x_2-x_1)cos{\theta_1} -(y_2-y_1)sin{\theta_1}</script><p>两个configure，所以两个雅格比，维度明显是 2x3，两个误差方程分别对(x, y, angle)求偏导，源码里的求导很简单，还不如速度约束的求导复杂，就不写过程了。</p>
<p>值得注意的是绝对值的求导结果会用<code>sign</code>函数表示。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/03/04/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E5%8A%A0%E9%80%9F%E5%BA%A6%E7%BA%A6%E6%9D%9F%E5%8F%8A%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8E%A8%E5%AF%BC/">加速度约束和雅格比矩阵的推导</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/">TEB算法</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E5%90%84%E7%B1%BB%E7%BA%A6%E6%9D%9F%E5%8F%8A%E9%9B%85%E6%A0%BC%E6%AF%94%E7%9F%A9%E9%98%B5/">各类约束及雅格比矩阵</a></span><div class="content"><p>默认为5元边约束。 但是包含3个类：<code>EdgeAcceleration</code>, <code>EdgeAccelerationStart</code>, <code>EdgeAccelerationGoal</code>，后两个为3元边</p>
<p><script type="math/tex">\frac{error}{cost}</script> 向量的维度是2，第一个元素代表线加速度，第二个是角加速度。<br><code>EdgeAccelerationStart()</code> and <code>EdgeAccelerationGoal()</code> 用于边界值</p>
<p>加速度约束和速度约束类似，不过变成两段圆弧和角度差、两个时间差、两个线速度和角速度。两个线速度的差除以两个时间差之和就是加速度。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> vel1 = dist1 / dt1-&gt;<span class="built_in">dt</span>();</span><br><span class="line"><span class="keyword">double</span> vel2 = dist2 / dt2-&gt;<span class="built_in">dt</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> acc_lin  = (vel2 - vel1)*<span class="number">2</span> / ( dt1-&gt;<span class="built_in">dt</span>() + dt2-&gt;<span class="built_in">dt</span>() );</span><br><span class="line">_error[<span class="number">0</span>] = <span class="built_in">penaltyBoundToInterval</span>(acc_lin,cfg_-&gt;robot.acc_lim_x, cfg_-&gt;optim.penalty_epsilon);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> omega1 = angle_diff1 / dt1-&gt;<span class="built_in">dt</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> omega2 = angle_diff2 / dt2-&gt;<span class="built_in">dt</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> acc_rot  = (omega2 - omega1)*<span class="number">2</span> / ( dt1-&gt;<span class="built_in">dt</span>() + dt2-&gt;<span class="built_in">dt</span>() );</span><br><span class="line">_error[<span class="number">1</span>] = <span class="built_in">penaltyBoundToInterval</span>(acc_rot,cfg_-&gt;robot.acc_lim_theta, cfg_-&gt;optim.penalty_epsilon);</span><br></pre></td></tr></table></figure></p>
<h3 id="起点的加速度约束"><a href="#起点的加速度约束" class="headerlink" title="起点的加速度约束"></a>起点的加速度约束</h3><p>注意：起点加速度约束和终点加速度约束都是3元边。</p>
<p>对于起点的加速度约束，源码有以下变化:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInitialVelocity</span><span class="params">(<span class="keyword">const</span> geometry_msgs::Twist&amp; vel_start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_measurement = &amp;vel_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_ASSERT_MSG</span>(cfg_ &amp;&amp; _measurement, </span><br><span class="line"><span class="string">&quot;You must call setTebConfig() and setInitialVelocity() on EdgeAccelerationStart()&quot;</span>);</span><br><span class="line">vel1 = _measurement-&gt;linear.x;</span><br><span class="line">omega1 = _measurement-&gt;angular.z;</span><br></pre></td></tr></table></figure><br>其他全一样，对于终点的加速度约束，则是<code>vel2</code>和<code>omega2</code>换成了<code>_measurement</code>的成员。那么这个<code>_measurement</code>从何而来？</p>
<p>在<code>TebOptimalPlanner::plan</code>里有一段:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (start_vel)</span><br><span class="line">  <span class="built_in">setVelocityStart</span>(*start_vel);</span><br><span class="line"><span class="keyword">if</span> (free_goal_vel)</span><br><span class="line">  <span class="built_in">setVelocityGoalFree</span>();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  vel_goal_.first = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>setVelocityStart</code>给起始速度赋值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::pair&lt;bool, geometry_msgs::Twist&gt;  vel_start_;</span></span><br><span class="line"><span class="comment">// 注意vel_start_ 和 vel_start 不同</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TebOptimalPlanner::setVelocityStart</span><span class="params">(<span class="keyword">const</span> geometry_msgs::Twist&amp; vel_start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vel_start_.first = <span class="literal">true</span>;</span><br><span class="line">  vel_start_.second.linear.x = vel_start.linear.x;</span><br><span class="line">  vel_start_.second.linear.y = vel_start.linear.y;</span><br><span class="line">  vel_start_.second.angular.z = vel_start.angular.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后到了<code>AddEdgesAcceleration</code>里添加起始加速度约束，才用到<code>vel_start_</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vel_start_.first)</span><br><span class="line">&#123;</span><br><span class="line">  EdgeAccelerationStart* acceleration_edge = <span class="keyword">new</span> EdgeAccelerationStart;</span><br><span class="line">  acceleration_edge-&gt;<span class="built_in">setVertex</span>(<span class="number">0</span>,teb_.<span class="built_in">PoseVertex</span>(<span class="number">0</span>));</span><br><span class="line">  acceleration_edge-&gt;<span class="built_in">setVertex</span>(<span class="number">1</span>,teb_.<span class="built_in">PoseVertex</span>(<span class="number">1</span>));</span><br><span class="line">  acceleration_edge-&gt;<span class="built_in">setVertex</span>(<span class="number">2</span>,teb_.<span class="built_in">TimeDiffVertex</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="comment">// 这里就是上面的 setInitialVelocity, _measurement 就是 vel_start_.second</span></span><br><span class="line">  acceleration_edge-&gt;<span class="built_in">setInitialVelocity</span>(vel_start_.second);</span><br><span class="line">  acceleration_edge-&gt;<span class="built_in">setInformation</span>(information);</span><br><span class="line">  acceleration_edge-&gt;<span class="built_in">setTebConfig</span>(*cfg_);</span><br><span class="line">  optimizer_-&gt;<span class="built_in">addEdge</span>(acceleration_edge);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>AddEdgesAcceleration</code>然后添加普通的加速度约束，再就是终点的加速度约束，这里就奇怪了，相应的<code>setVelocityGoal</code>函数没有调用的地方，这里是<code>vel_goal_.second</code>唯一赋值的地方。即使<code>free_goal_vel</code>为false，也没有赋值，意思是终点的速度为0？</p>
<p>雅格比矩阵的推导可以参照速度约束的，不同的地方是这次把角度单独拿出来了，这样有了8个雅格比<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_jacobianOplus[<span class="number">0</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// conf1</span></span><br><span class="line">_jacobianOplus[<span class="number">1</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// conf2</span></span><br><span class="line">_jacobianOplus[<span class="number">2</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// conf3</span></span><br><span class="line">_jacobianOplus[<span class="number">3</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">// deltaT1</span></span><br><span class="line">_jacobianOplus[<span class="number">4</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">// deltaT2</span></span><br><span class="line">_jacobianOplus[<span class="number">5</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">// angle1</span></span><br><span class="line">_jacobianOplus[<span class="number">6</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">// angle2</span></span><br><span class="line">_jacobianOplus[<span class="number">7</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">// angle3</span></span><br></pre></td></tr></table></figure><br>既然拿出了角度，那么对<code>conf</code>的雅格比矩阵的维度就变成了 2x2，不是2x3。两个误差函数，一个是线速度的，一个是角速度的</p>
<p><font size="4" color="blue"> 代码中的 double aux0 = 2/sum_time_inv; 错了  </font> 应当是 <code>double aux0 = 2/sum_time;</code><br><img src="https://s2.loli.net/2023/03/04/UWQmsEB4AHIGSOr.png" alt="J[0](0,0)的推导过程"><br>其他项以此类推</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/03/03/SLAM%E5%B7%A5%E5%85%B7/g2o%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8/">g2o的详细使用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SLAM%E5%B7%A5%E5%85%B7/">SLAM工具</a></span><div class="content"><p>G2O 与ceres风格不同，它是专门用于进行图优化的库，提供了大量预先定义的节点和边供用户调用。</p>
<p>曲线拟合的例子其实不太适合用来理解g2o，它涉及的顶点只有一个，边是一元边，有很多个。还是用图优化的例子更容易理解。</p>
<p>TEB算法的<code>base_teb_edges.h</code>, <code>g2o_types\vertex_pose.h</code> 和 <code>g2o_types\vertex_timediff.h</code>很有学习价值，以及<code>edge_obstacle.h</code>, <code>edge_shortest_path.h</code>, <code>edge_velocity.h</code></p>
<h2 id="顶点"><a href="#顶点" class="headerlink" title="顶点"></a>顶点</h2><p>最基础的<code>BaseVertex</code>类，<code>template &lt;int D, typename T&gt; class BaseVertex</code>，</p>
<ul>
<li>D: minimal dimension of the vertex, 例如 3 for rotation in 3D. D并非是顶点（更确切的说是状态变量）的维度，而是其在流形空间（manifold）的最小表示</li>
<li>T: 节点估计值的类型,例如 Quaternion for rotation in 3D</li>
</ul>
<p>g2o本身内部定义了一些常用的顶点类型</p>
<ul>
<li>VertexSE2 : public BaseVertex<3, SE2>  // 2D pose Vertex, (x,y,theta)</li>
<li>VertexSE3 : public BaseVertex<6, Isometry3> //6d vector (x,y,z,qx,qy,qz) (注意不管四元数的 w)</li>
<li>VertexPointXY : public BaseVertex<2, Vector2></li>
<li>VertexPointXYZ : public BaseVertex<3, Vector3></li>
<li>VertexSBAPointXYZ : public BaseVertex<3, Vector3></li>
<li>VertexSE3Expmap : public BaseVertex<6, SE3Quat></li>
</ul>
<p>如果我们需要的顶点类型这里面没有，就得自己定义了</p>
<p>重新定义顶点一般需要考虑重写如下函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 读盘、存盘函数，一般情况下不需要进行读/写操作的话，仅仅声明一下，作为空函数</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">(std::istream&amp; is)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">write</span><span class="params">(std::ostream&amp; os)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">number_t</span>* update)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="setToOriginImpl-和-estimate"><a href="#setToOriginImpl-和-estimate" class="headerlink" title="setToOriginImpl 和 _estimate"></a>setToOriginImpl 和 <code>_estimate</code></h3><p><code>setToOriginImpl</code>：顶点重置函数，设定被优化变量的原始值。有时可以不用实现。具体来说就是初始化成员变量 <code>_estimate</code>，<font size="4" color="blue">  <code>_estimate</code>的类型就是继承 <code>BaseVertex</code>时的模板参数  </font></p>
<p>如果<code>_estimate</code>是<code>Eigen::Vector3d</code>，那么<code>setToOriginImpl</code>的内容可以是: <code>_estimate &lt;&lt; 0,0,0;</code>。 如果是<code>PoseSE2</code>， <code>_estimate</code>的赋值可以这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_estimate.<span class="built_in">position</span>() = position;</span><br><span class="line">_estimate.<span class="built_in">x</span>() = x;</span><br><span class="line">_estimate.<span class="built_in">y</span>() = y;</span><br><span class="line">_estimate.<span class="built_in">theta</span>() = theta;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _estimate.<span class="built_in">setZero</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="oplusImpl"><a href="#oplusImpl" class="headerlink" title="oplusImpl"></a>oplusImpl</h3><p>顶点更新函数。非常重要的一个函数，主要用于优化过程中增量 △x 的计算。我们根据增量方程计算出增量之后，就是通过这个函数对估计值进行调整的，因此这个函数的内容一定要重视。</p>
<p>比较简单的类型是这样实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// double 也可以换成 number_t</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">( <span class="keyword">const</span> <span class="keyword">double</span>* update )</span> <span class="comment">// 更新</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">// update为增量△m 迭代的时候，估计值 m= m + △m, m是向量（a,b,c）</span></span><br><span class="line">    _estimate += Eigen::<span class="built_in">Vector3d</span>(update);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>* update)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _estimate.<span class="built_in">plus</span>(update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>李代数的类<code>VertexSE3Expmap</code>，上面两个函数是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setToOriginImpl</span><span class="params">()</span> </span>&#123;    <span class="comment">// 重置</span></span><br><span class="line">    _estimate = <span class="built_in">SE3Quat</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">oplusImpl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">number_t</span>* update_)</span>  </span>&#123;</span><br><span class="line">    <span class="function">Eigen::Map&lt;<span class="keyword">const</span> Vector6&gt; <span class="title">update</span><span class="params">(update_)</span></span>;</span><br><span class="line">    <span class="comment">//更新方式 类似于左扰动？</span></span><br><span class="line">    <span class="built_in">setEstimate</span>(SE3Quat::<span class="built_in">exp</span>(update)*<span class="built_in">estimate</span>());        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="边"><a href="#边" class="headerlink" title="边"></a>边</h2><p>g2o自带的边</p>
<ul>
<li>EdgeSE3ProjectXYZ: public  BaseBinaryEdge<2, Vector2d, VertexSBAPointXYZ, VertexSE3Expmap></li>
<li>EdgeSE3ProjectXYZOnlyPose: public  BaseUnaryEdge<2, Vector2d, VertexSE3Expmap></li>
<li>EdgeSE3Expmap : public BaseBinaryEdge<6, SE3Quat, VertexSE3Expmap, VertexSE3Expmap></li>
</ul>
<font size="4" color="blue"> 仅优化一个变量的时候选择单边  </font>

<p>以一元边为例<code>template &lt;int D, typename E, typename VertexXi&gt; class BaseUnaryEdge : public BaseEdge&lt;D,E&gt;</code>。</p>
<ul>
<li>D 表示测量值的维度 </li>
<li>E 表示测量值的数据类型</li>
<li>VertexXi，VertexXj 分别表示不同顶点的类型。（一元边只有一个顶点）</li>
</ul>
<p>例如，<code>BaseBinaryEdge&lt;2, Vector2D, VertexSBAPointXYZ, VertexSE3Expmap&gt;</code>是个二元边。2是说测量值是2维的，也就是图像的像素坐标x,y的差值，对应测量值的类型是Vector2D，两个顶点也就是优化变量分别是三维点 VertexSBAPointXYZ，和李群位姿VertexSE3Expmap。</p>
<ul>
<li><p>read，write：分别是读盘、存盘函数，一般情况下不需要进行读/写操作的话，仅仅声明一下就可以</p>
</li>
<li><p>computeError函数：非常重要，是使用当前顶点的值计算的测量值与真实的测量值之间的误差</p>
</li>
<li><p>linearizeOplus函数：非常重要，是在当前顶点的值下，该误差对优化变量的偏导数，也就是我们说的Jacobian。</p>
</li>
</ul>
<p>重要的成员变量：</p>
<ul>
<li><p><code>_measurement</code>：存储观测值</p>
</li>
<li><p><code>_error</code>：存储computeError() 函数计算的误差</p>
</li>
<li><p><code>_vertices[]</code>：存储顶点信息，比如二元边的话，<code>_vertices[]</code> 的大小为2，存储顺序和调用setVertex(int, vertex) 是设定的int有关（0 或1）</p>
</li>
<li><p>setId(int)： 来定义边的编号（决定了在H矩阵中的位置）</p>
</li>
<li><p>setMeasurement(type) 函数来定义观测值</p>
</li>
<li><p>setVertex(int, vertex) 来定义顶点</p>
</li>
<li><p><code>setInformation()</code> 来定义协方差矩阵的逆</p>
</li>
</ul>
<p>最重要的就是<code>computeError()</code>，<code>linearizeOplus()</code>两个函数了。如果我们没有给出雅可比，g2o也会进行数值求导，但是会比重写的雅可比慢。<font size="4" color="blue"> 雅克比矩阵的维度为 <strong>误差维度 × 优化变量的维度</strong>  </font>，两个函数一般是这样的形式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeError</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    _error = _measurement - Something;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">linearizeOplus</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _jacobianOplusXi(pos, pos) = something;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    _jocobianOplusXj(pos, pos) = something;</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure><br>雅格比矩阵要针对每个顶点求解，上面说的维度是每个顶点求解的维度。比如边的类型继承<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VertexPose</span> :</span> <span class="keyword">public</span> g2o::BaseVertex&lt;<span class="number">6</span>, Sophus::SE3d&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeProjection</span> :</span> <span class="keyword">public</span> g2o::BaseUnaryEdge&lt;<span class="number">2</span>, Eigen::Vector2d, VertexPose&gt;</span><br></pre></td></tr></table></figure><br>由于是一元边，那么只针对一个顶点求解，误差维度是边的第一个模板类型2，优化变量的维度是顶点的第一个模板参数6.</p>
<p>TEB算法中的<code>class EdgeVelocity : public BaseTebMultiEdge&lt;2, double&gt;</code>，是三元边，两个<code>VertexPose</code>顶点，类型<code>PoseSE2</code>。顶点<code>VertexTimeDiff</code>，类型double。对于前者，雅格比矩阵是 2x3，对后者是 2x1，也就是如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_jacobianOplus[<span class="number">0</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// conf1</span></span><br><span class="line">_jacobianOplus[<span class="number">1</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// conf2</span></span><br><span class="line">_jacobianOplus[<span class="number">2</span>].<span class="built_in">resize</span>(<span class="number">2</span>,<span class="number">1</span>); <span class="comment">// deltaT</span></span><br></pre></td></tr></table></figure></p>
<p>对于边<code>class G2O_TYPES_SBA_API EdgeProjectXYZ2UV : public  BaseBinaryEdge&lt;2, Vector2D, VertexSBAPointXYZ, VertexSE3Expmap&gt;</code>，这是二元边，雅格比包含两部分，维度分别为 2x3 和 2x6. 后一个顶点的类型是李群。可以这样写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相对 _jacobianOplus[2] 的另一种写法</span></span><br><span class="line">_jacobianOplusXi(<span class="number">0</span>,<span class="number">0</span>) =</span><br><span class="line">......</span><br><span class="line">_jacobianOplusXj(<span class="number">0</span>,<span class="number">0</span>) = </span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<h2 id="removeEdge"><a href="#removeEdge" class="headerlink" title="removeEdge()"></a>removeEdge()</h2><p><code>removeEdge</code> 和 <code>removeVertex</code>只有在ORB-SLAM中看到。</p>
<p>After running optimize() once, I am finding a high number of outliers. Is there any way to delete a single edge out of the graph and run optimize again, or do I have to construct it again?</p>
<p>The method <code>removeEdge()</code> removes the edge from a graph and unlinks it from all of the vertices it was attached to. After you call it on your edges, I think you need to call <code>initializeOptimization()</code> to reset all of g2o’s internal data structures to the new graph configuration. You should then be able to call <code>optimize()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector&lt;g2o::EdgeSim3ProjectXYZ*&gt; vpEdges12;</span></span><br><span class="line"><span class="comment">// 剔除一些误差大的边</span></span><br><span class="line"><span class="comment">// Check inliers</span></span><br><span class="line"><span class="keyword">int</span> nBad=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;vpEdges12.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    g2o::EdgeSim3ProjectXYZ* e12 = vpEdges12[i];</span><br><span class="line">    g2o::EdgeInverseSim3ProjectXYZ* e21 = vpEdges21[i];</span><br><span class="line">    <span class="keyword">if</span>(!e12 || !e21)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(e12-&gt;<span class="built_in">chi2</span>()&gt;th2 || e21-&gt;<span class="built_in">chi2</span>()&gt;th2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> idx = vnIndexEdge[i];</span><br><span class="line">        vpMatches1[idx]=<span class="keyword">static_cast</span>&lt;MapPoint*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">        optimizer.<span class="built_in">removeEdge</span>(e12);</span><br><span class="line">        optimizer.<span class="built_in">removeEdge</span>(e21);</span><br><span class="line">        vpEdges12[i]=<span class="keyword">static_cast</span>&lt;g2o::EdgeSim3ProjectXYZ*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">        vpEdges21[i]=<span class="keyword">static_cast</span>&lt;g2o::EdgeInverseSim3ProjectXYZ*&gt;(<span class="literal">NULL</span>);</span><br><span class="line">        nBad++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="setLevel-int-level"><a href="#setLevel-int-level" class="headerlink" title="setLevel(int level)"></a>setLevel(int level)</h2><p>也是在ORB-SLAM中用到</p>
<p>优化完成后，对每一条边都进行检查，剔除误差较大的边（认为是错误的边），并设置setLevel为0，即下次不再对该边进行优化</p>
<p>setLevel(int ) is useful when you call <code>optimizer.initializeOptimization(int )</code>. If you assign <code>initializeOptimization(0)</code>, the optimizer will include all edges up to <strong>level 0</strong> in the optimization, and edges set to <strong>level &gt;=1</strong> will not be included</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于卡方检验计算出的阈值（假设测量有一个像素的偏差）</span></span><br><span class="line"><span class="comment">// 第二个判断条件，用于检查构成该边的MapPoint在该相机坐标系下的深度是否为正？</span></span><br><span class="line"><span class="keyword">if</span>(e-&gt;<span class="built_in">chi2</span>()&gt;<span class="number">5.991</span> || !e-&gt;<span class="built_in">isDepthPositive</span>())</span><br><span class="line">&#123;</span><br><span class="line">    e-&gt;<span class="built_in">setLevel</span>(<span class="number">1</span>);<span class="comment">// 不优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/02/27/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E8%8C%83%E6%95%B0/">范数及求导</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-02-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a></span><div class="content"><p><code>||x||</code> 是 1 范数</p>
<p><img src="https://s2.loli.net/2023/02/27/v3zkxDic42Jh1om.png" alt=" "></p>
<p>2范数其实就是：列向量 x,  2范数为 <script type="math/tex">\sqrt{x^Tx}</script></p>
<p>2范数为 <script type="math/tex">\phi(x) =||Ax- \overrightarrow {b} ||_2</script></p>
<p>对 x 求导<br><img src="https://s2.loli.net/2023/02/27/uqj9y2M1ckU37dW.png" alt=" "></p>
<p>如果是求雅格比，<br><img src="https://s2.loli.net/2023/02/27/IJZ4vVckAtCpFTW.png" alt=" "><br>也就是只需求f(x)的雅格比，再转置。</p>
<p><br></p>
<p>再看矩阵的范数</p>
<ul>
<li><p>0 范数:  矩阵中非零元素的个数</p>
</li>
<li><p>1 范数: 又称为 列和范数，将每列元素进行绝对值求和，取最大值</p>
</li>
<li><p><script type="math/tex">\infin</script> 范数: 又称为 列和范数，将每列元素进行绝对值求和，取最大值</p>
</li>
<li><p>2 范数: 公式为 <script type="math/tex">\sqrt{\lambda_{max}(A^TA) }</script>， 其中 <script type="math/tex">\lambda_{max}(A^TA)</script> 表示 <script type="math/tex">A^TA</script>的最大特征值。 2范数可以用来判断一个矩阵是不是病态矩阵</p>
</li>
</ul>
<p>2范数是由向量范数诱导而来，F范数是直接定义，是两种不同的度量方式。F范数可以比较真实的矩阵和估计的矩阵值之间的误差。<br><img src="https://s2.loli.net/2023/03/27/HgmrFxQyu1Mpa49.png" alt=""></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/02/01/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/C++%E7%9A%84%E5%90%84%E7%A7%8D%E6%8A%A5%E9%94%99%E5%92%8C%E6%8A%A5%E8%AD%A6/">C++的各种报错和报警</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-02-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><p>还是Qt的环境好，很多时候，不用编译直接就提示有错误。</p>
<ul>
<li>报错invalid new-expression of abstract class type </li>
</ul>
<p>有的编译器也会报错 <strong>error: allocating an object of abstract class type ‘child’</strong>。说明基类中有纯虚函数没有实现，必须在派生类实现所有纯虚函数，不使用派生类时是看不出来的。</p>
<ul>
<li>marked ‘override’, but does not override</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName1</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Parent&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Parent&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName1</span><span class="params">(<span class="keyword">double</span> x)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Sub&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getName2</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Sub&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类的同名函数和基类的参数类型不同，而且多了<code>const</code>。如果没有<code>override</code>，那么是派生类新加的函数，但是添加<code>override</code>，编译器认为基类有同名函数，但是没发现，所以报错。</p>
<p>如果是重写基类方法，建议使用override标识符，让编译器检查出可能的错误，从而避免无意的错误。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/01/24/PCL%E7%82%B9%E4%BA%91/PCL%E4%B8%AD%E7%9A%84NDT/">PCL中的NDT</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-01-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/PCL%E7%82%B9%E4%BA%91/">PCL点云</a></span><div class="content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_cloud.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/PCLPointCloud2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/common/transforms.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/console/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl_ros/point_cloud.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/io/pcd_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/registration/ndt.h&gt;</span>      <span class="comment">//NDT(正态分布)配准类头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/filters/approximate_voxel_grid.h&gt;</span>   <span class="comment">//滤波类头文件  （使用体素网格过滤器处理的效果比较好）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/visualization/pcl_visualizer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/thread.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pcl::PointXYZ PointType;</span><br><span class="line"><span class="keyword">typedef</span> pcl::PointCloud&lt;PointType&gt; PointCloud;</span><br><span class="line"><span class="keyword">typedef</span> pcl::PointCloud&lt;PointType&gt;::Ptr PointCloudPtr;</span><br><span class="line"><span class="keyword">typedef</span> pcl::PointCloud&lt;PointType&gt;::ConstPtr PointCloudConstPtr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;test_ndt&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">    <span class="function">PointCloudPtr <span class="title">target_cloud</span><span class="params">(<span class="keyword">new</span> PointCloud)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(pcl::io::loadPCDFile&lt;PointType&gt;(<span class="string">&quot;/home/user/test_nodes/src/test_pcl/room_scan1.pcd&quot;</span>, *target_cloud) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;load pcd file error !&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;load target pcl &quot;</span> &lt;&lt; target_cloud-&gt;<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; points&quot;</span> &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="function">PointCloudPtr <span class="title">input_cloud</span><span class="params">(<span class="keyword">new</span> PointCloud)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(pcl::io::loadPCDFile&lt;PointType&gt;(<span class="string">&quot;/home/user/test_nodes/src/test_pcl/room_scan2.pcd&quot;</span>, *input_cloud) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;load pcd file error !&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;load target pcl &quot;</span> &lt;&lt; input_cloud-&gt;<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; points&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">PointCloudPtr <span class="title">filtered_cloud</span><span class="params">(<span class="keyword">new</span> PointCloud)</span></span>;</span><br><span class="line">    pcl::VoxelGrid&lt;PointType&gt; filter;</span><br><span class="line">    filter.<span class="built_in">setLeafSize</span>(<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>);</span><br><span class="line">    filter.<span class="built_in">setInputCloud</span>(input_cloud);</span><br><span class="line">    filter.<span class="built_in">filter</span>(*filtered_cloud);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after filtered, input cloud has &quot;</span>&lt;&lt; filtered_cloud-&gt;<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; points&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    pcl::NormalDistributionsTransform&lt;PointType, PointType&gt;::<span class="function">Ptr <span class="title">ndt_ptr</span><span class="params">(<span class="keyword">new</span> pcl::NormalDistributionsTransform&lt;PointType, PointType&gt;() )</span></span>;</span><br><span class="line">    ndt_ptr-&gt;<span class="built_in">setMaximumIterations</span>(<span class="number">35</span>);</span><br><span class="line">    ndt_ptr-&gt;<span class="built_in">setTransformationEpsilon</span>(<span class="number">0.01</span>);</span><br><span class="line">    ndt_ptr-&gt;<span class="built_in">setStepSize</span>(<span class="number">0.1</span>);</span><br><span class="line">    ndt_ptr-&gt;<span class="built_in">setResolution</span>(<span class="number">0.1</span>);</span><br><span class="line">    ndt_ptr-&gt;<span class="built_in">setInputSource</span>(filtered_cloud);</span><br><span class="line">    ndt_ptr-&gt;<span class="built_in">setInputTarget</span>(target_cloud);</span><br><span class="line"></span><br><span class="line">    <span class="function">Eigen::AngleAxisf <span class="title">init_rotation</span> <span class="params">(<span class="number">0.6931</span>, Eigen::Vector3f::UnitZ ())</span></span>;</span><br><span class="line">    <span class="function">Eigen::Translation3f <span class="title">init_translation</span> <span class="params">(<span class="number">1.79387</span>, <span class="number">0.720047</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    Eigen::Matrix4f init_guess = (init_translation * init_rotation).<span class="built_in">matrix</span> ();</span><br><span class="line"></span><br><span class="line">    <span class="function">PointCloudPtr <span class="title">output_cloud</span><span class="params">(<span class="keyword">new</span> PointCloud)</span></span>;</span><br><span class="line">    ndt_ptr-&gt;<span class="built_in">align</span>(*output_cloud, init_guess);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;output cloud points size: &quot;</span>&lt;&lt; output_cloud-&gt;<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ndt transform: &quot;</span>&lt;&lt; endl &lt;&lt; ndt_ptr-&gt;<span class="built_in">getFinalTransformation</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;score: &quot;</span>&lt;&lt; ndt_ptr-&gt;<span class="built_in">getFitnessScore</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    pcl::<span class="built_in">transformPointCloud</span>(*input_cloud, *output_cloud, ndt_ptr-&gt;<span class="built_in">getFinalTransformation</span>() );</span><br><span class="line">    pcl::io::<span class="built_in">savePCDFileASCII</span>(<span class="string">&quot;/home/user/test_nodes/src/test_pcl/final.pcd&quot;</span>, *output_cloud );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化点云可视化对象</span></span><br><span class="line">    <span class="function">boost::shared_ptr&lt;pcl::visualization::PCLVisualizer&gt;</span></span><br><span class="line"><span class="function">    <span class="title">viewer_final</span> <span class="params">(<span class="keyword">new</span> pcl::visualization::PCLVisualizer (<span class="string">&quot;3D Viewer&quot;</span>))</span></span>;</span><br><span class="line">    viewer_final-&gt;<span class="built_in">setBackgroundColor</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">//设置背景颜色为黑色</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对目标点云着色可视化 (red).</span></span><br><span class="line">    pcl::<span class="function">visualization::PointCloudColorHandlerCustom&lt;pcl::PointXYZ&gt;</span></span><br><span class="line"><span class="function">    <span class="title">target_color</span> <span class="params">(target_cloud, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    viewer_final-&gt;addPointCloud&lt;pcl::PointXYZ&gt; (target_cloud, target_color, <span class="string">&quot;target cloud&quot;</span>);</span><br><span class="line">    viewer_final-&gt;<span class="built_in">setPointCloudRenderingProperties</span> (pcl::visualization::PCL_VISUALIZER_POINT_SIZE,</span><br><span class="line">                                                    <span class="number">1</span>, <span class="string">&quot;target cloud&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对转换后的源点云着色 (green)可视化.</span></span><br><span class="line">    pcl::<span class="function">visualization::PointCloudColorHandlerCustom&lt;pcl::PointXYZ&gt;</span></span><br><span class="line"><span class="function">    <span class="title">output_color</span><span class="params">(output_cloud, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>)</span></span>;</span><br><span class="line">    viewer_final-&gt;addPointCloud&lt;pcl::PointXYZ&gt; (output_cloud, output_color, <span class="string">&quot;output cloud&quot;</span>);</span><br><span class="line">    viewer_final-&gt;<span class="built_in">setPointCloudRenderingProperties</span> (pcl::visualization::PCL_VISUALIZER_POINT_SIZE,</span><br><span class="line">                                                    <span class="number">1</span>, <span class="string">&quot;output cloud&quot;</span>);</span><br><span class="line">    <span class="comment">// 启动可视化</span></span><br><span class="line">    viewer_final-&gt;<span class="built_in">addCoordinateSystem</span> (<span class="number">1.0</span>);  <span class="comment">//显示XYZ指示轴</span></span><br><span class="line">    viewer_final-&gt;<span class="built_in">initCameraParameters</span> ();   <span class="comment">//初始化摄像头参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待直到可视化窗口关闭</span></span><br><span class="line">    <span class="keyword">while</span> (!viewer_final-&gt;<span class="built_in">wasStopped</span> ())</span><br><span class="line">    &#123;</span><br><span class="line">      viewer_final-&gt;<span class="built_in">spinOnce</span> (<span class="number">101</span>);</span><br><span class="line">      boost::this_thread::<span class="built_in">sleep</span> (boost::posix_time::<span class="built_in">microseconds</span> (<span class="number">100000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三个迭代终止条件设置：</p>
<ol>
<li><code>setMaximumIterations(30)</code>:  设置最大的迭代次数。 一般来说在这个限制值之前，优化程序会在epsilon（最大容差）变换阀值下终止，添加最大迭代次数限制能够增加程序的鲁棒性阻止了它在错误的方向上运行时间过长</li>
<li><code>setTransformationEpsilon</code>:  终止条件设置最小转换差异，设置前后两次迭代的转换矩阵的最大容差<code>epsilion</code>，在变换中Epsilon参数分别从长度和弧度，定义了变换矢量<code>[x, y, z, roll, pitch, yaw]</code>的最小许可的递增量，一旦两次迭代小于这个最大容差，则认为已经收敛到最优解，默认值为：0 </li>
<li><code>setEuclideanFitnessEpsilon</code>:  设置前后两次迭代的点对的欧式距离均值的最大容差，迭代终止条件之三，默认值为：<code>-std::numeric_limits::max</code></li>
</ol>
<p>把<code>setTransformationEpsilon</code>的参数从0.01改为0.001，FitnessScore 只有细微变化，而且相对之前有时变大有时变小。但是改为0.1，FitnessScore与0.01时相比，也是有大有小。迭代次数不管怎么调整，FitnessScore毫无变化，可见确实是以epsilon为优先终止条件。</p>
<ul>
<li><p><code>setStepSize(0.1)</code>:   <code>More-Thuente</code>线搜索设置最大步长，即设置牛顿法优化的最大步长。当你靠近最优解时该算法会缩短迭代步长，在最大步长将会在较少的迭代次数下遍历较大的距离，但是却有过度迭代和在不符合要求的局部最小值处结束的风险。 <font size="4" color="blue"> 调试的经验 </font>：step的话可以先放大后变小。</p>
</li>
<li><p><code>setResolution(1.0);</code>:   设置网格化时立方体的边长，网格大小设置在NDT中非常重要，太大会导致精度不高，太小导致内存过高，并且只有两幅点云相差不大的情况才能匹配。它需要足够大，每个体素包含与点有关的统计数据，平均值，协方差等。每个体素至少包含6个点，但小到足以唯一地描述环境。<font size="4" color="blue"> 调试的经验 </font>：resolution在追求精度的情况下最好与点密度相等或者低一个数量级,这里是激光点云，所以设了1米</p>
</li>
<li><p><code>getFitnessScore()</code>：欧几里得适合度得分 FitnessScore ，该分数计算为从输出云到目标云中最近点的距离的平方。分数越大，准确率越低，配准效果也就越差。 </p>
</li>
</ul>
<p><code>align</code>函数中，<code>output_cloud</code>保存变换后的<code>input_cloud</code>，它和<code>target_cloud</code>其实很相近了。但是它不能作为最终的源点云变换，因为上面对<code>input_cloud</code>进行了滤波处理，所以又经过<code>pcl::transformPointCloud(*input_cloud, *output_cloud, ndt_ptr-&gt;getFinalTransformation() );</code>获得未经滤波的<code>output_cloud</code></p>
<p>注意的地方：</p>
<ul>
<li>开始做体素滤波，栅格太大，过滤太多，最后的<code>output_cloud</code>和<code>target_cloud</code>看着不太契合</li>
<li>只对源点云进行滤波，减少其数据量，而目标点云不需要滤波处理</li>
</ul>
<p><img src="https://s2.loli.net/2023/01/24/GQrtxKvyBD6h172.png" alt=""><br><img src="https://s2.loli.net/2023/01/24/7zXp54O8FSA3tyM.png" alt=""></p>
<p>参考: <a target="_blank" rel="noopener" href="https://github.com/I-am-Unique/ZH-Useful/blob/master/pointcloud_transform.cpp">参考程序</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/01/16/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20constraint_list%20%E8%AF%9D%E9%A2%98/">深入分析 constraint_list 话题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-01-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>这个话题是显示所有的约束，包括同一轨迹和不同轨迹的Inter约束，Intra约束。</p>
<p>以<code>Inter constraints, different trajectories</code> 和 <code>Inter residuals, different trajectories</code>为例进行分析，内容如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个点的 z为0.0，省略</span></span><br><span class="line">header: </span><br><span class="line">  seq: 0</span><br><span class="line">  stamp: </span><br><span class="line">    secs: 1673860622</span><br><span class="line">    nsecs: 104007813</span><br><span class="line">  frame_id: <span class="string">&quot;map&quot;</span></span><br><span class="line">ns: <span class="string">&quot;Inter constraints, different trajectories&quot;</span></span><br><span class="line"><span class="comment"># 12个点，有6个点相同或极为接近</span></span><br><span class="line">points: </span><br><span class="line">  - </span><br><span class="line">    x: 2.93968786067</span><br><span class="line">    y: -1.41820975755</span><br><span class="line">  - </span><br><span class="line">    x: 3.44855066169</span><br><span class="line">    y: -1.24014780956</span><br><span class="line">  - </span><br><span class="line">    x: -0.000569545301176</span><br><span class="line">    y: 0.00522600210993</span><br><span class="line">  - </span><br><span class="line">    x: 3.4816963258</span><br><span class="line">    y: -1.19978045681</span><br><span class="line">  - </span><br><span class="line">    x: 3.45484823588</span><br><span class="line">    y: -1.19817846586</span><br><span class="line">  - </span><br><span class="line">    x: 3.78063457495</span><br><span class="line">    y: -1.54584384415</span><br><span class="line">  - </span><br><span class="line">    x: 3.45484823588</span><br><span class="line">    y: -1.19817846586</span><br><span class="line">  - </span><br><span class="line">    x: 4.61884003257</span><br><span class="line">    y: -1.49287256215</span><br><span class="line">  - </span><br><span class="line">    x: 3.45484823588</span><br><span class="line">    y: -1.19817846586</span><br><span class="line">  - </span><br><span class="line">    x: 4.6545497049</span><br><span class="line">    y: -1.84995755765</span><br><span class="line">  -</span><br><span class="line">    x: 3.45484823588</span><br><span class="line">    y: -1.19817846586</span><br><span class="line">  - </span><br><span class="line">    x: 4.91335613134</span><br><span class="line">    y: -2.16836009999</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">- </span><br><span class="line">header: </span><br><span class="line">  seq: 0</span><br><span class="line">  stamp: </span><br><span class="line">    secs: 1673860622</span><br><span class="line">    nsecs: 104007813</span><br><span class="line">  frame_id: <span class="string">&quot;map&quot;</span></span><br><span class="line">ns: <span class="string">&quot;Inter residuals, different trajectories&quot;</span></span><br><span class="line"><span class="comment"># 12个点，有些点很接近，结果构成的线很短</span></span><br><span class="line">points: </span><br><span class="line">  - </span><br><span class="line">    x: 3.44855066169</span><br><span class="line">    y: -1.24014780956</span><br><span class="line">  - </span><br><span class="line">    x: 3.47573816704</span><br><span class="line">    y: -1.1999840042</span><br><span class="line">  - </span><br><span class="line">    x: 3.4816963258</span><br><span class="line">    y: -1.19978045681</span><br><span class="line">  - </span><br><span class="line">    x: 3.47896481246</span><br><span class="line">    y: -1.20118000282</span><br><span class="line">  - </span><br><span class="line">    x: 3.78063457495</span><br><span class="line">    y: -1.54584384415</span><br><span class="line">  - </span><br><span class="line">    x: 3.80065304682</span><br><span class="line">    y: -1.55796489639</span><br><span class="line">  - </span><br><span class="line">    x: 4.61884003257</span><br><span class="line">    y: -1.49287256215</span><br><span class="line">  - </span><br><span class="line">    x: 4.65790271882</span><br><span class="line">    y: -1.44107978827</span><br><span class="line">  - </span><br><span class="line">    x: 4.6545497049</span><br><span class="line">    y: -1.84995755765</span><br><span class="line">  - </span><br><span class="line">    x: 3.00991092288</span><br><span class="line">    y: -2.53605574275</span><br><span class="line">  - </span><br><span class="line">    x: 4.91335613134</span><br><span class="line">    y: -2.16836009999</span><br><span class="line">  - </span><br><span class="line">    x: 3.11523021674</span><br><span class="line">    y: -2.61951559764</span><br></pre></td></tr></table></figure><br>源码中可以看到Rviz显示的是<code>LINE_LIST</code>类型的<code>visualization_msgs::Marker</code>，这里要提一下Rviz显示的线类型，如下<br><img src="https://s2.loli.net/2023/01/16/rXfQmt3UbFcNiHP.png" alt=""><br><code>LINE_LIST</code>是两两连接而成的线段，在carto这里，点数一定为偶数。把上面消息内容，没两个点的坐标连线，就可以得到Rviz里的显示<br><img src="https://s2.loli.net/2023/01/16/JAbvHKWM83Nzl2L.png" alt=""><br>黄线有6条，水绿线有2条比较长，仔细还能看到3条很短的，最后一条在坐标系附近，肉眼已经看不到。Inter约束和residual个数相同，有一个共同的端点原因可以看源码。</p>
<p>看<code>MapBuilderBridge::GetConstraintList</code>源码部分有些跳过了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> trajectory_node_poses =</span><br><span class="line">    map_builder_-&gt;<span class="built_in">pose_graph</span>()-&gt;<span class="built_in">GetTrajectoryNodePoses</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> submap_poses = map_builder_-&gt;<span class="built_in">pose_graph</span>()-&gt;<span class="built_in">GetAllSubmapPoses</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> constraints = map_builder_-&gt;<span class="built_in">pose_graph</span>()-&gt;<span class="built_in">constraints</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; constraint : constraints)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> submap_it = submap_poses.<span class="built_in">find</span>(constraint.submap_id);</span><br><span class="line">    <span class="keyword">if</span> (submap_it == submap_poses.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; submap_pose = submap_it-&gt;data.pose;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> node_it = trajectory_node_poses.<span class="built_in">find</span>(constraint.node_id);</span><br><span class="line">    <span class="keyword">if</span> (node_it == trajectory_node_poses.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; trajectory_node_pose = node_it-&gt;data.global_pose;</span><br><span class="line">    <span class="keyword">const</span> Rigid3d constraint_pose = submap_pose * constraint.pose.zbar_ij;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inter constraints, different trajectories  线段的两个端点</span></span><br><span class="line">    constraint_marker-&gt;points.<span class="built_in">push_back</span>(</span><br><span class="line">        <span class="built_in">ToGeometryMsgPoint</span>(submap_pose.<span class="built_in">translation</span>()));</span><br><span class="line">    constraint_marker-&gt;points.<span class="built_in">push_back</span>(</span><br><span class="line">        <span class="built_in">ToGeometryMsgPoint</span>(constraint_pose.<span class="built_in">translation</span>()));</span><br><span class="line">    <span class="comment">// Inter residuals, different trajectories  线段的两个端点</span></span><br><span class="line">    residual_marker-&gt;points.<span class="built_in">push_back</span>(</span><br><span class="line">        <span class="built_in">ToGeometryMsgPoint</span>(constraint_pose.<span class="built_in">translation</span>()));</span><br><span class="line">    residual_marker-&gt;points.<span class="built_in">push_back</span>(</span><br><span class="line">        <span class="built_in">ToGeometryMsgPoint</span>(trajectory_node_pose.<span class="built_in">translation</span>()));</span><br></pre></td></tr></table></figure><br>从最后可以看出，共同的端点是<code>constraint_pose</code>，<code>map</code>坐标系下。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/01/08/SLAM%E5%B7%A5%E5%85%B7/ceres%205%20%E6%A0%B8%E5%87%BD%E6%95%B0/">ceres 5 核函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-01-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SLAM%E5%B7%A5%E5%85%B7/">SLAM工具</a></span><div class="content"><p>核函数：某个数据点的残差过大的时候，降低其权重。以曲线拟合为例，<br><img src="https://s2.loli.net/2023/01/08/kuwZiFUoPMvIJNp.png" alt=""><br>我们拟合点的时候，显然希望红线而不是黄线，outlier可以抛弃。</p>
<p>残差大于0.1则降低其权重<br><code>ceres::LossFunction *loss_function = new ceres::HuberLoss(0.1);</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/01/03/cmake%20qmake/CMake%20%E5%90%84%E7%A7%8D%E6%8A%A5%E9%94%99%E6%8A%A5%E8%AD%A6/">CMake 各种报错报警</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-01-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cmake-qmake/">cmake/qmake</a></span><div class="content"><ul>
<li>integer_sequence’ is not a member of ‘std’</li>
</ul>
<p>编译工程时报错<font size="4" color="orange"> integer_sequence’ is not a member of ‘std’ </font><br>CMake中添加  <code>set(CMAKE_CXX_FLAGS  &quot;-std=c++14&quot;)</code></p>
<ul>
<li>std::make_unique的报错</li>
</ul>
<p>在CMake<code>3.16</code>版本编译<code>std::make_unique</code>部分的代码，没有报错。在<code>3.10</code>版本上编译却报错了，在<code>CMakeLists.txt</code>加入<code>set(CMAKE_CXX_STANDARD 14)</code>后才成功。</p>
<ul>
<li>CMake Deprecation Warning at CMakeLists.txt:1 (cmake_minimum_required): Compatibility with CMake &lt; 2.8.12 will be removed from a future version of CMake</li>
</ul>
<p>我升级CMake后出现的报警，虽然不影响，但是一旦工程多了以后，这个报警会很烦人。只需要修改<code>cmake_minimum_required (VERSION 3.19.0)</code></p>
<p>但是有时<code>CMakeLists</code>太多了，不可能一一去修改，使用sed命令集体修改：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&quot;s/2.8.3/3.19/g&quot;</span> `grep 2.8.3 -rl . --include=<span class="string">&quot;*.txt&quot;</span> `</span><br></pre></td></tr></table></figure><br>这个命令不要滥用，否则可能更改过多</p>
<ul>
<li>涉及PCL的一个警告</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMake Warning (dev) at /usr/local/share/cmake-<span class="number">3.17</span>/Modules/FindPackageHandleStandardArgs.cmake:<span class="number">272</span> (message):</span><br><span class="line">  The package name passed to `find_package_handle_standard_args` (PCL_KDTREE)</span><br><span class="line">  does not <span class="keyword">match</span> the name of the calling package (PCL).  This can lead to</span><br><span class="line">  problems in calling code that expects `find_package` result variables</span><br><span class="line">  (e.g., `_FOUND`) to follow a certain pattern.</span><br></pre></td></tr></table></figure>
<p>在<code>find_package(PCL REQUIRED)</code>之前加上<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(NOT DEFINED CMAKE_SUPPRESS_DEVELOPER_WARNINGS)</span><br><span class="line">    <span class="built_in">set</span>(CMAKE_SUPPRESS_DEVELOPER_WARNINGS 1 CACHE INTERNAL <span class="string">&quot;No dev warnings&quot;</span>)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure></p>
<ul>
<li>No rule to make target</li>
</ul>
<p>有时明明写好了，但编译会出现报错，看上去是<code>CMakeLists</code>中没有编译规则<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">make[2]: *** No rule to make target &#x27;package/CMakeFiles/test_bin.dir/build&#x27;。 停止。</span><br><span class="line">CMakeFiles/Makefile2:3192: recipe for target &#x27;package/CMakeFiles/test_bin.dir/all&#x27; failed</span><br><span class="line">make[1]: *** [package/CMakeFiles/test_bin.dir/all] Error 2</span><br><span class="line">Makefile:138: recipe for target &#x27;all&#x27; failed</span><br><span class="line">make: *** [all] Error 2</span><br><span class="line">Invoking &quot;make -j4 -l4&quot; failed</span><br></pre></td></tr></table></figure><br>此时再重新编译仍然报错，只要把<code>CMakeLists</code>改一下，再编译就通过了</p>
<ul>
<li>CMakeCache 报错</li>
</ul>
<p>执行编译时报错:<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMake Error: The current CMakeCache.txt directory /home/user/common/build/CMakeCache.txt is different than the directory /home/user/space/build where CMakeCache.txt was created. This may result in binaries being created in the wrong place. If you are <span class="keyword">not</span> sure, reedit the CMakeCache.txt</span><br></pre></td></tr></table></figure><br>将当前工程的<code>CMakeCache</code>全删除再编译<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm $(find -name *.txt | grep CMakeCache)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>unrecognized command line option -msse</li>
</ul>
<p>这是因为在arm平台上不存在SSE指令集的，在x86平台才会有，因此需要在<code>CMakLists</code>文件中把<code>—msse</code>字样的都注释掉</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/13/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/56/">56</a><a class="extend next" rel="next" href="/page/15/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2024/11/12/x1aqcwUG3XDiskN.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2025 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>