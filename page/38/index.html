<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">609</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">52</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2024/11/12/x1aqcwUG3XDiskN.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move_base%20%E5%88%86%E6%9E%90/%E5%AF%BC%E8%88%AA%E7%9B%B8%E5%85%B3%E7%9A%84%E8%8A%82%E7%82%B9%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/">导航相关的节点和动态库之间的关系</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move-base%E5%88%86%E6%9E%90/">move_base分析</a></span><div class="content"><p>注意<code>devel/lib</code>里的so文件权限是<code>rwxrwxr-x</code>，<code>install/lib</code>里的so文件权限是<code>rw-r--r--</code></p>
<p>节点move_base由很多库链接,一部分是<code>/opt/ros/kinetic</code>目录的ROS基本库文件,另一部分是<code>/usr/lib/x86_64-linux-gnu</code>的系统库文件,除此之外的重要库文件只有:</p>
<ul>
<li>libmove_base.so</li>
<li>libbase_local_planner.so</li>
<li>libcostmap_2d.so</li>
<li>libvoxel_grid.so</li>
<li>libteb_local_planner.so</li>
</ul>
<p>同理,<code>libmove_base.so</code>的重要链接库:</p>
<ul>
<li>libbase_local_planner.so</li>
<li>libcostmap_2d.so</li>
<li>libvoxel_grid.so</li>
</ul>
<p>依次检查其他库文件,由于<code>base_local_planner</code>一般不修改,所以重要的其实就是<code>libmove_base.so</code>, <code>libcostmap_2d.so</code>, <code>libvoxel_grid.so</code></p>
<p>主要的库文件，比较大的几个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">11M   libmove_base.so</span><br><span class="line"><span class="number">8.</span>5M  liblayers.so</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>1M  libcostmap_2d.so</span><br><span class="line"><span class="number">2.</span>3M  libteb_local_planner.so</span><br><span class="line"><span class="number">2.</span>0M  move_base/move_base</span><br></pre></td></tr></table></figure></p>
<h2 id="libteb-local-planner-so"><a href="#libteb-local-planner-so" class="headerlink" title="libteb_local_planner.so"></a>libteb_local_planner.so</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">add_library( teb_local_planner</span><br><span class="line"></span><br><span class="line">   src/timed_elastic_band.cpp</span><br><span class="line">   src/optimal_planner.cpp</span><br><span class="line">   src/obstacles.cpp</span><br><span class="line">   src/visualization.cpp</span><br><span class="line">   src/recovery_behaviors.cpp</span><br><span class="line">   src/teb_config.cpp</span><br><span class="line">   src/homotopy_class_planner.cpp</span><br><span class="line">   src/teb_local_planner_ros.cpp</span><br><span class="line">   src/graph_search.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>更新teb算法的so文件，不能只更新<code>libteb_local_planner.so</code>，而是包含以下文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libbase_local_planner.so libmove_base.so libcostmap_2d.so libvoxel_grid.so liblayers.so libteb_local_planner.so</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><code>libcostmap_2d.so</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add_library(  costmap_2d</span><br><span class="line"></span><br><span class="line">  src/array_parser.cpp</span><br><span class="line">  src/costmap_2d.cpp</span><br><span class="line">  src/observation_buffer.cpp</span><br><span class="line">  src/layer.cpp</span><br><span class="line">  src/layered_costmap.cpp</span><br><span class="line">  src/costmap_2d_ros.cpp</span><br><span class="line">  src/costmap_2d_publisher.cpp</span><br><span class="line">  src/costmap_math.cpp</span><br><span class="line">  src/footprint.cpp</span><br><span class="line">  src/costmap_layer.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p><br><br><br><code>liblayers.so</code>:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add_library( layers  </span><br><span class="line"></span><br><span class="line">  plugins/inflation_layer.cpp</span><br><span class="line">  plugins/obstacle_layer.cpp</span><br><span class="line">  plugins/static_layer.cpp</span><br><span class="line">  plugins/voxel_layer.cpp</span><br><span class="line">  src/observation_buffer.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="https://s2.loli.net/2023/09/18/3hERsg2bfQTdGH9.png" alt=""></p>
<p><code>move_base</code>运行时出错，可能是安装问题，更可能是链接问题，确保<code>libtf.so</code>是<code>/opt/ros/</code>的那个，它还会链接<code>libtf2_ros.so</code> 和 <code>libtf2.so</code>，它们也应该是<code>/opt/ros/</code>的</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE3%20%20%E4%BB%A3%E4%BB%B7%E5%80%BC%E5%92%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BD%AE%E5%BB%93%E7%9A%84%E5%85%B3%E7%B3%BB/">代价地图(三) 代价值和机器人轮廓的关系</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content"><p>costmap中，机器人需要避开区域包括3类：</p>
<ol>
<li><p>静态地图中的障碍物，适合描述整个静态场景的静止障碍物信息，如墙面、固定不动的桌柜等，对应<code>StaticLayer</code>，一旦在costmap中加入static_map,即使地图中的障碍物后来移走了，该区域在costmap中依然存在，机器人仍然会避开该区域。</p>
</li>
<li><p>传感器观察到的障碍物，适合描述运动的障碍物，如行人、小车、移动位置的桌椅等。通过传感器激光实时扫描到的障碍物<code>ObstacleLayer</code>。这一块障碍物信息是不断变化的，对于运动小车的实时避障是很有帮助的。</p>
</li>
<li><p>自定义障碍物，禁止行驶区域</p>
</li>
</ol>
<p><br><br><img src="https://i.loli.net/2020/11/01/qzrJhU1VK3D7RLI.png" alt=""><br>二维costmap地图示例如图上所示。红色单元表示代价地图中的障碍物，蓝色单元表示由机器人内切半径来计算膨胀的障碍物，红色多边形表示机器人的垂直投影（footprint），浅灰色代表已知且未被占用的区域，深灰色代表未知区域。为了避免机器人与障碍碰撞，footprint不能与红色相交，机器人的中心不能穿过蓝色</p>
<p>定义了5个具体的值衡量机器人的状态<br><img src="https://i.loli.net/2020/11/01/I79j3x5FytE8ePY.png" alt=""></p>
<p>上图共分为五个部分:（下面的红色框图是机器人的轮廓，旁边的黑框是上图的映射位置）</p>
<ol>
<li>Lethal（致命的）:机器人的中心与该网格的中心重合，此时机器人必然与障碍物冲突。枚举值254</li>
<li>Inscribed（内切）：网格的外切圆与机器人的轮廓内切，此时机器人也必然与障碍物冲突。 枚举值253</li>
<li>Possibly circumscribed（外切）：网格的外切圆与机器人的轮廓外切，此时机器人相当于靠在障碍物附近，所以不一定冲突。</li>
<li>Freespace（自由空间）：没有障碍物的空间。枚举值0</li>
<li>Unknown（未知）：未知的空间。 枚举值255</li>
</ol>
<p>代价地图采用网格的形式，分为三种状态：占用（有障碍物）、无用（空闲的）、未知。每个网格的值如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NO_INFORMATION = <span class="number">255</span>;</span><br><span class="line">LETHAL_OBSTACLE = <span class="number">254</span>;</span><br><span class="line">INSCRIBED_INFLATED_OBSTACLE = <span class="number">253</span>;</span><br><span class="line">FREE_SPACE = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><br><strong>注意252和127没有定义</strong></p>
<p><br></p>
<ul>
<li><p><code>cost_lethal</code> 代价值254，机器人中心在一个cell里，这肯定发生碰撞</p>
</li>
<li><p><code>cost_inscribed</code> 代价值253，机器人中心所在的cell与障碍物的距离小于机器人的内切圆半径，还是肯定碰撞，cell的代价值大于等于<code>inscribed cost</code></p>
</li>
<li><p><code>cost_possibly_circumscribed</code> 使用机器人的外接圆半径作为 <strong>cutoff distance</strong>. 机器人中心所在cell到障碍物距离小于机器人外切圆半径，但是大于内切圆半径。 如果机器人中心所在的cell大于等于这个值，是否碰撞要取决于机器人的朝向</p>
</li>
</ul>
<p><strong>possibly</strong>这个词表示不一定真是一个obstacle cell，而是用户自定义一个代价值的情况。比如，如果用户想让机器人应对避开一段特定的区域，应当向那段区域的代价地图插入自定义的代价值，而不考虑任何障碍物。</p>
<p>尽管128也在上图中，但真实的代价值受内切圆半径和外接圆半径的影响，对于源码在<code>InflationLayer::computeCost</code>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @brief  Given a distance, compute a cost.</span></span><br><span class="line"><span class="comment"> * @param  distance The distance from an obstacle in cells</span></span><br><span class="line"><span class="comment"> * @return A cost value for the distance */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">computeCost</span><span class="params">(<span class="keyword">double</span> distance)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> cost = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (distance == <span class="number">0</span>)</span><br><span class="line">    cost = LETHAL_OBSTACLE;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (distance * resolution_ &lt;= inscribed_radius_)</span><br><span class="line">    cost = INSCRIBED_INFLATED_OBSTACLE;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// make sure cost falls off by Euclidean distance</span></span><br><span class="line">    <span class="keyword">double</span> euclidean_distance = distance * resolution_;</span><br><span class="line">    <span class="keyword">double</span> factor = <span class="built_in">exp</span>(<span class="number">-1.0</span> * weight_ * (euclidean_distance - inscribed_radius_));</span><br><span class="line">    cost = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)((INSCRIBED_INFLATED_OBSTACLE - <span class="number">1</span>) * factor);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="障碍层-膨胀层"><a href="#障碍层-膨胀层" class="headerlink" title="障碍层  膨胀层"></a>障碍层  膨胀层</h2><p>Obstacle Map Layer：障碍层，用于动态的记录传感器感知到的障碍物信息。</p>
<p>Inflation Layer：膨胀层，在以上两层地图上进行膨胀（向外扩张），以避免机器人的撞上障碍物。膨胀是一个从占用cell代价值从内切障碍过渡到FREE的过程，距离cell越远代价越小，膨胀层会把障碍物代价膨胀直到该半径为止。</p>
<p>到实际障碍物距离<code>dist</code>，<script type="math/tex">内切半径 < dist < 内切半径+膨胀半径</script>. 在内切圆半径到膨胀半径之间的所有cell，可以使用如下公式来计算膨胀代价：</p>
<script type="math/tex; mode=display">cost = 253\ e^{-cost\_scale\_factor*(dist - inscribed\_radius)}</script><p>如果<code>cost_scaling_factor</code>默认10，膨胀半径默认0.55，那么cost最小约为1</p>
<p><img src="https://s2.loli.net/2023/08/28/bPz7JWw8VSZi6mI.png" alt=" "></p>
<ul>
<li>cost_scaling_factor: 膨胀过程中应用到代价值的比例因子，默认10。从上面公式可以看出，增大比例因子会降低代价。10对应的代价值降低速度很快</li>
</ul>
<p><img src="https://i.loli.net/2020/11/06/rS6ov8nGOR32iZw.png" alt="内切圆半径0.255，不同代价系数对应的代价曲线"></p>
<ul>
<li>inflation_radius:膨胀半径，默认0.55. 膨胀层会把障碍物代价膨胀直到该半径为止，一般将该值设置为机器人底盘的直径大小。如果太小，车就会贴着障碍走，或者说容易撞到障碍物就需要增大该值，若经常无法通过狭窄地方就减小该值。</li>
</ul>
<p><img src="https://i.loli.net/2020/11/03/bygjtSlNdmzBYqJ.png" alt="增大膨胀半径，cost_scaling_factor=0.7"><br><img src="https://i.loli.net/2020/11/03/g1pjA7ioTEcwlZG.png" alt="cost_scaling_factor=65"><br><img src="https://i.loli.net/2020/11/03/CJtobcx9YniNFRK.png" alt="cost_scaling_factor=1"><br><img src="https://i.loli.net/2020/11/03/jpzMG6ZHhNxvQEd.png" alt="cost_scaling_factor=25"><br><img src="https://i.loli.net/2020/11/03/9IDVZ5aY1WPOFjE.png" alt="默认cost_scaling_factor=10"></p>
<p>减小<code>cost_scaling_factor</code>，使代价值增大，rviz里的膨胀层变为粉色。如果这个参数很大很大，代价值趋近于0，也就是FREE。如果很小，代价值趋近于253，相当于放大了内切障碍值。<code>cost_scaling_factor</code>越小，膨胀层越趋近粉色，反之趋近蓝色。</p>
<p>查看话题<code>/move_base/local_costmap/costmap_updates</code>，会发现一些数值变大</p>
<p><strong>全局代价地图一般膨胀较多，使机器人转弯顺利。</strong> 但是局部代价可以不用膨胀层，这是因为TEB已有障碍物膨胀功能。  <font color = blue size=4>增大<code>cost_scaling_factor</code>和减小膨胀半径可以使机器人容易进窄通道，但一般是调整TEB，这两个参数不修改。</font></p>
<p><br></p>
<p>添加了静态层、障碍层、膨胀层的代价地图是这样的：<br><img src="https://i.loli.net/2020/11/01/aGEMh27qtwVm5PB.png" alt=""></p>
<p>如果代价地图不添加膨胀层，结果是这样：<br><img src="https://i.loli.net/2020/11/01/i3o4MFUwGJhOLZY.png" alt=""></p>
<p>但是加不加障碍层，看上去没有变化， <strong>目前无法在rviz里直接可视化每一层</strong>，只能添加或去除后观察</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/Matlab/Matlab%E7%94%BB%E5%9B%BE/">Matlab画图</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Matlab/">Matlab</a></span><div class="content"><p>对于画图函数，如果用plot函数参数没有用符号标记参数的话，会自动把离散的点连接起来，<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plot(x, y)</span><br><span class="line"><span class="comment"># 指定x y的坐标范围</span></span><br><span class="line">xlim([-<span class="number">15</span> <span class="number">15</span>])</span><br><span class="line">ylim([-<span class="number">12</span> <span class="number">12</span>])</span><br></pre></td></tr></table></figure></p>
<h2 id="画离散点"><a href="#画离散点" class="headerlink" title="画离散点"></a>画离散点</h2><p>如果设置了点的符号标记参数，就可以使用plot函数画离散的点图：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span>:<span class="number">10</span>;</span><br><span class="line">y=<span class="number">1</span>:<span class="number">10</span>;</span><br><span class="line">plot(x,y,<span class="string">&#x27;.&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="将多个函数曲线在同一张图显示"><a href="#将多个函数曲线在同一张图显示" class="headerlink" title="将多个函数曲线在同一张图显示"></a>将多个函数曲线在同一张图显示</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">x=0:0.01:4;  % x从1到4，绘图采样间隔为0.01</span><br><span class="line">y1=252*exp(-10*(x-radius));</span><br><span class="line">y1=10*x+3;</span><br><span class="line">y2=exp(2*x);</span><br><span class="line">y3=sin(x)</span><br><span class="line"></span><br><span class="line">plot(x,y1,<span class="string">&#x27;o-&#x27;</span>,<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);   %画出图形</span><br><span class="line">hold on;  	%继续画图</span><br><span class="line">plot(x,y2,<span class="string">&#x27;s-&#x27;</span>,<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>);</span><br><span class="line">hold on;  	%继续画图</span><br><span class="line">plot(x,y3,<span class="string">&#x27;*-&#x27;</span>,<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line"></span><br><span class="line">grid on;     % 添加网格，这是用默认的最小标度画出的网格</span><br><span class="line">axis([-5 10 -10 50]);     % x轴的范围是[-5, 10], y轴范围[-10,50]</span><br><span class="line"></span><br><span class="line">xlabel(<span class="string">&#x27;时间&#x27;</span>);     %设置X轴含义：时间</span><br><span class="line">ylabel(<span class="string">&#x27;目标&#x27;</span>);   %设置X轴含义：零件数</span><br><span class="line"></span><br><span class="line">legend(<span class="string">&#x27;y1&#x27;</span>,<span class="string">&#x27;y2&#x27;</span>,<span class="string">&#x27;y3&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>一个图中画多个曲线记得使用hold on，否则之前画的曲线将会被覆盖掉！</p>
<p>标识号曲线有两种方法：(1)通过不同的颜色；(2)通过不同的线形；<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">颜色          定义符  </span><br><span class="line"></span><br><span class="line">红色          R（red）</span><br><span class="line">兰色          b(blue)</span><br><span class="line">青色          c(cyan)</span><br><span class="line">黄色          y(yellow)</span><br><span class="line">黑色          k(black)</span><br><span class="line">白色          w(white)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线形            符号</span><br><span class="line"></span><br><span class="line">实线             -</span><br><span class="line">圈圈             o</span><br><span class="line">正方形           s</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/%E5%B8%B8%E7%94%A8%E7%9A%84tf%E5%91%BD%E4%BB%A4/">tf话题和常用的tf命令</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a></span><div class="content"><p>TF发布的话题一般有两种: <code>tf</code> 和 <code>tf_static</code></p>
<p><code>tf</code>是只要有节点发布就会有消息， <code>tf_static</code>是在已知的坐标发生变化或有新的节点订阅的时候才会发布新的消息</p>
<h2 id="tf-话题"><a href="#tf-话题" class="headerlink" title="tf 话题"></a>tf 话题</h2><p>录制数据集时一定要录这个话题</p>
<h2 id="tf-static-话题"><a href="#tf-static-话题" class="headerlink" title="tf_static 话题"></a>tf_static 话题</h2><p><code>tf_static</code>是静态转换， 和<code>tf</code>的格式一样， any transform on this topic can be considered true for all time. Internally any query for a static transform will return true.</p>
<p><code>tf_static</code>的发布者使用latched topics, the <code>tf2_ros</code> <code>static_transform_publisher</code> does this correctly. Note: avoid multiple latched static transform publishers on /tf_static in the same process, because with multiple latched publishers within the same node only one will latch correctly.</p>
<p>比如这样的，echo只有这一条结果<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">transforms: </span><br><span class="line">  - </span><br><span class="line">    header: </span><br><span class="line">      seq: <span class="number">0</span></span><br><span class="line">      stamp: </span><br><span class="line">        secs: <span class="number">1652186247</span></span><br><span class="line">        nsecs:  <span class="number">41763935</span></span><br><span class="line">      frame_id: <span class="string">&quot;base_link&quot;</span></span><br><span class="line">    child_frame_id: <span class="string">&quot;move_link&quot;</span></span><br><span class="line">    transform: </span><br><span class="line">      translation: </span><br><span class="line">        x: <span class="number">0.0</span></span><br><span class="line">        y: <span class="number">0.0</span></span><br><span class="line">        z: <span class="number">0.0</span></span><br><span class="line">      rotation: </span><br><span class="line">        x: <span class="number">0.0</span></span><br><span class="line">        y: <span class="number">0.0</span></span><br><span class="line">        z: <span class="number">0.0</span></span><br><span class="line">        w: <span class="number">1.0</span></span><br><span class="line">  - </span><br><span class="line">    header: </span><br><span class="line">      seq: <span class="number">0</span></span><br><span class="line">      stamp: </span><br><span class="line">        secs: <span class="number">1652186247</span></span><br><span class="line">        nsecs:  <span class="number">41846600</span></span><br><span class="line">      frame_id: <span class="string">&quot;base_link&quot;</span></span><br><span class="line">    child_frame_id: <span class="string">&quot;shelf_link&quot;</span></span><br><span class="line">    transform: </span><br><span class="line">      translation: </span><br><span class="line">        x: <span class="number">0.0</span></span><br><span class="line">        y: <span class="number">0.0</span></span><br><span class="line">        z: <span class="number">0.0</span></span><br><span class="line">      rotation: </span><br><span class="line">        x: <span class="number">0.0</span></span><br><span class="line">        y: <span class="number">0.0</span></span><br><span class="line">        z: <span class="number">0.0</span></span><br><span class="line">        w: <span class="number">1.0</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<ol>
<li>rosrun tf view_frames</li>
</ol>
<p>当启动ROS程序后，如果想查看存在的所有坐标系转换关系，可以使用命令<code>rosrun tf view_frames</code>，结果会在当前目录生成pdf文件：<br><img src="https://c2.staticflickr.com/8/7850/46490602034_1924870de3_b.jpg" alt=""><br>顺便说一下，打开pdf的命令为<code>evince frames.pdf</code></p>
<ol>
<li>rosrun rqt_tf_tree rqt_tf_tree</li>
</ol>
<p>跟上一个命令差不多，区别是直接打开一个pdf文件，但不会保存</p>
<p>在仿真环境下，使用<code>rostopic hz tf</code>，发现tf的频率是40Hz左右，这个数值是各个tf变化叠加的结果，使用<code>rqt_tf_tree</code>可以看到<br><img src="https://i.loli.net/2020/11/01/ZdnNrFjezJoAtay.png" alt="11-01__105511.png"></p>
<p>有些转换可能显示average rate有数值，但是buffer 和 recent transform都是0，这种其实没有发生tf，所以不能算数。</p>
<p><br><br>左上角还有一个<code>clear buffer</code>按钮，<code>Buffer length</code>会清零<br><code>Buffer length</code>表示<code>tf buffer</code>中有几秒的数据可使用，<code>rqt_tf_tree</code>中是10秒，<code>view frames</code>大约5秒</p>
<ol>
<li>tf_echo</li>
</ol>
<p>本命令用来查看两个坐标系之间的实时转换，需要5秒钟：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun tf tf_echo /turtle1 /turtle2  　//turtle1是parent坐标系, turtle2是child</span><br></pre></td></tr></table></figure><br><img src="https://c2.staticflickr.com/8/7834/40261688443_57d3ca29b1_b.jpg" alt=""></p>
<ol>
<li>rqt_tf_tree</li>
</ol>
<p><code>rosrun rqt_tf_tree rqt_tf_tree</code>显示一个带界面的tf图显示工具，不必等待，然后可以另存为svg,png等格式<br>结果发现刷新按钮不好用，当tf树改变后，刷新有时没有改变显示，有时工具无法响应了</p>
<ol>
<li>launch文件中的应用</li>
</ol>
<p>如果要让两个坐标系建立转换关系，常常在launch文件中添加<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">args</span>=<span class="string">&quot;-0.24 0 0.295 1.571 0 -1.571 /base_link /camera 10&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;tf&quot;</span> <span class="attr">name</span>=<span class="string">&quot;base_link_to_camera&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><br>这个节点就是以<code>base_link</code>为parent坐标系，向<code>camera</code>转换的欧拉角形式。前三个参数是x,y,z三个方向的位移，之后的三个参数是yaw,pitch,roll，然后是parent坐标系和child坐标系，最后是隔多长时间发送一次变换，一般取100(ms)。另一种形式就是四元数形式，也就是将第4~6参数换为qx,qy,qz,qw。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/15/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/tf_prefix%E5%92%8C%E5%A4%9A%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%BA%94%E7%94%A8/">tf_prefix和多机器人的应用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a></span><div class="content"><p>为了支持多个“相似”的机器人，tf使用tf_prefix参数。没有tf_prefix参数，帧名<code>base_link</code>将解析为<code>/base_link</code></p>
<p>如果tf_prefix参数设置为<code>robot1</code>，<code>base_link</code>将解析为<code>/robot1/base_link</code>。这在运行多机器人时是最有用的，否则这些机器人将在其frame_ids中具有名称冲突。</p>
<p>源码其实很简单:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">getPrefixParam</span><span class="params">(ros::NodeHandle &amp; nh)</span>\</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::string param; </span><br><span class="line">   <span class="keyword">if</span> (!nh.<span class="built_in">searchParam</span>(<span class="string">&quot;tf_prefix&quot;</span>, param)) </span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; </span><br><span class="line">   </span><br><span class="line">   std::string return_val;</span><br><span class="line">   nh.<span class="built_in">getParam</span>(param, return_val);</span><br><span class="line">   <span class="keyword">return</span> return_val;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>一般用法是:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span> <span class="attr">ns</span>=<span class="string">&quot;robot_1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;tf_prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;robot_1&quot;</span>/&gt;</span></span><br><span class="line">  ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>tf2不再支持<code>tf_prefix</code>. <code>my_frame</code>和<code>/my_frame</code>是不同的坐标系名称, tf2不接受以<code>/</code>开头的坐标系名称,否则会报<code>tf2::InvalidArgument exception</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/11/09/C++/C++%20%20%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">编程技巧</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E5%9F%BA%E7%A1%80/">C++ 基础</a></span><div class="content"><h2 id="对浮点数进行四舍五入"><a href="#对浮点数进行四舍五入" class="headerlink" title="对浮点数进行四舍五入"></a>对浮点数进行四舍五入</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getEstimate</span><span class="params">(<span class="keyword">float</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in"><span class="keyword">int</span></span>(a + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="double-只取小数点后两位"><a href="#double-只取小数点后两位" class="headerlink" title="double 只取小数点后两位"></a>double 只取小数点后两位</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">0.2500000500001</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="built_in">floor</span>(d * <span class="number">10000.000f</span> + <span class="number">0.5</span>) / <span class="number">10000.000f</span>;</span><br></pre></td></tr></table></figure>
<h2 id="回调函数的降频功能"><a href="#回调函数的降频功能" class="headerlink" title="回调函数的降频功能"></a>回调函数的降频功能</h2><p>这是从gmapping里学的，cartographer里也有，但是更复杂了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> laser_count_ = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> throttle_scans_ = <span class="number">5</span>;  <span class="comment">// 自定义的值</span></span><br><span class="line">SlamGMapping::<span class="built_in">laserCallback</span>(<span class="keyword">const</span> sensor_msgs::LaserScan::ConstPtr&amp; scan)</span><br><span class="line">&#123;</span><br><span class="line">  laser_count_++;</span><br><span class="line">  <span class="keyword">if</span> ((laser_count_ % throttle_scans_) != <span class="number">0</span>)  <span class="comment">// 判断是否降频</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// ... 主要代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="在终端显示带颜色和风格的文字"><a href="#在终端显示带颜色和风格的文字" class="headerlink" title="在终端显示带颜色和风格的文字"></a>在终端显示带颜色和风格的文字</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// color指定颜色BLACK, RED, GREEN, YELLOW, BLUE, WHITE, option指定文字风格BOLD, REGULAR, UNDERLINE.</span></span><br><span class="line"><span class="keyword">const</span> std::string RESET = <span class="string">&quot;\033[0m&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> std::string BLACK = <span class="string">&quot;0m&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> std::string RED = <span class="string">&quot;1m&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> std::string GREEN = <span class="string">&quot;2m&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> std::string YELLOW = <span class="string">&quot;3m&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> std::string BLUE = <span class="string">&quot;4m&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> std::string WHITE = <span class="string">&quot;7m&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> std::string BOLD = <span class="string">&quot;\033[1;3&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> std::string REGULAR = <span class="string">&quot;\033[0;3&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> std::string UNDERLINE = <span class="string">&quot;\033[4;3&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> std::string BACKGROUND = <span class="string">&quot;\033[4&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">colouredString</span><span class="params">(std::string str, std::string colour, std::string option)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> time_now = ros::Time::<span class="built_in">now</span>().<span class="built_in">toSec</span>();</span><br><span class="line">  std::string time_string = std::<span class="built_in">to_string</span>(time_now);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + time_string + <span class="string">&quot;]: &quot;</span> + option + colour + str + RESET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生成极值"><a href="#生成极值" class="headerlink" title="生成极值"></a>生成极值</h2><p>C++11中，std::numeric_limits为模板类，在库编译平台提供基础算术类型的极值等属性信息，取代传统C语言，所采用的预处理常数。比较常用的使用是对于给定的基础类型用来判断在当前系统上的最大值、最小值。需包含<limits>头文件。</p>
<p><code>std::numeric_limits&lt;double&gt;::max();</code>的结果是一个很大的数字</p>
<h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><ul>
<li><p><code>hypot()</code>用来求三角形的斜边长，其原型为：<code>double hypot(double x, double y);</code>，需要<code>#include &lt;stdio.h&gt;</code></p>
</li>
<li><p><code>fabs</code>函数是求绝对值的函数，函数原型是<code>extern float fabs(float x)</code>，需要<code>#include &lt;math.h&gt;</code></p>
</li>
</ul>
<p>对double/float数据，一定要使用fabs函数。如果用了abs，就会出现bug，因为返回也是int</p>
<h2 id="反正切函数求角度"><a href="#反正切函数求角度" class="headerlink" title="反正切函数求角度"></a>反正切函数求角度</h2><p><code>atan2</code>返回给定的 X 及 Y 坐标值的反正切值。反正切的角度值等于 X 轴与通过原点和给定坐标点 (Y坐标, X坐标) 的直线之间的夹角。结果以弧度表示并介于<code>-pi</code>到<code>pi</code>之间（不包括<code>-pi</code>）。 </p>
<p>而<code>atan(a/b)</code>的取值范围介于<code>-pi/2</code>到<code>pi/2</code>之间，不包括±pi/2</p>
<h2 id="生成27个三维向量，每个可取-1-0-1，一共27种组合"><a href="#生成27个三维向量，每个可取-1-0-1，一共27种组合" class="headerlink" title="生成27个三维向量，每个可取-1,0,1，一共27种组合"></a>生成27个三维向量，每个可取-1,0,1，一共27种组合</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span> * <span class="number">3</span> * <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> a = (i / <span class="number">9</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = ((i % <span class="number">9</span>) / <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = ((i % <span class="number">9</span>) % <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">killNode</span><span class="params">(std::string nodeName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> status;</span><br><span class="line">  string cmd = <span class="string">&quot;rosnode kill &quot;</span>+nodeName;</span><br><span class="line">  status = <span class="built_in">system</span>(cmd.<span class="built_in">data</span>());</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">-1</span> == status)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// system func error</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))    <span class="comment">//返回一个非零值, 正常退出</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">ROS_INFO</span>(<span class="string">&quot;child process exit done: %d&quot;</span>, <span class="built_in">WEXITSTATUS</span>(status) );</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">WEXITSTATUS</span>(status);   <span class="comment">// rosnode kill done, exit status value</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">ROS_WARN</span>(<span class="string">&quot;child process exit abnormally&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">getCmdResult</span><span class="params">(<span class="keyword">const</span> string &amp;strCmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">10240</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  FILE *pf = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span>( (pf = <span class="built_in">popen</span>(strCmd.<span class="built_in">c_str</span>(), <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  string strResult;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">fgets</span>(buf, <span class="keyword">sizeof</span> buf, pf))</span><br><span class="line">  &#123;</span><br><span class="line">    strResult += buf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pclose</span>(pf);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> iSize =  strResult.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span>(iSize &gt; <span class="number">0</span> &amp;&amp; strResult[iSize - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)  <span class="comment">// linux</span></span><br><span class="line">  &#123;</span><br><span class="line">    strResult = strResult.<span class="built_in">substr</span>(<span class="number">0</span>, iSize - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ros::Time 转为年月日的string</span></span><br><span class="line"><span class="function">std::string <span class="title">stampToString</span><span class="params">(<span class="keyword">const</span> ros::Time&amp; stamp, <span class="keyword">const</span> std::string format=<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> output_size = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">char</span> output[output_size];</span><br><span class="line">  std::<span class="keyword">time_t</span> raw_time = <span class="keyword">static_cast</span>&lt;<span class="keyword">time_t</span>&gt;(stamp.sec);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">timeinfo</span> =</span> <span class="built_in">localtime</span>(&amp;raw_time);</span><br><span class="line">  std::<span class="built_in">strftime</span>(output, output_size, format.<span class="built_in">c_str</span>(), timeinfo);</span><br><span class="line">  std::stringstream ss; </span><br><span class="line">  ss &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">9</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; stamp.nsec;  </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> fractional_second_digits = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(output) + <span class="string">&quot;.&quot;</span> + ss.<span class="built_in">str</span>().<span class="built_in">substr</span>(<span class="number">0</span>, fractional_second_digits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tf2_ros::Buffer buff;</span><br><span class="line"><span class="function">tf2_ros::TransformListener <span class="title">listener</span><span class="params">(buff)</span></span>;</span><br><span class="line"></span><br><span class="line">geometry_msgs::PoseStamped  point_in, point_out;</span><br><span class="line">point_in.header.frame_id = <span class="string">&quot;laser_link&quot;</span>;</span><br><span class="line">point_in.header.stamp = ros::<span class="built_in">Time</span>(<span class="number">0</span>);</span><br><span class="line">point_in.pose =    <span class="comment">//赋值</span></span><br><span class="line"><span class="comment">// buff跟上面的使用一样， 返回的point_out是point_in在 parent坐标系 的坐标</span></span><br><span class="line">point_out = buff.<span class="built_in">transform</span>(point_in, point_out, <span class="string">&quot;map&quot;</span>, ros::<span class="built_in">Duration</span>(<span class="number">0.3</span>) );</span><br></pre></td></tr></table></figure>
<h2 id="获得Linux命令的结果"><a href="#获得Linux命令的结果" class="headerlink" title="获得Linux命令的结果"></a>获得Linux命令的结果</h2><p>比如输入<code>ls</code>，返回当前目录的文件名<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">getCmdResult</span><span class="params">(<span class="keyword">const</span> string &amp;strCmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">10240</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  FILE *pf = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span>( (pf = <span class="built_in">popen</span>(strCmd.<span class="built_in">c_str</span>(), <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  string strResult;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">fgets</span>(buf, <span class="keyword">sizeof</span> buf, pf))</span><br><span class="line">  &#123;</span><br><span class="line">    strResult += buf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pclose</span>(pf);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> iSize =  strResult.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span>(iSize &gt; <span class="number">0</span> &amp;&amp; strResult[iSize - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)  <span class="comment">// linux</span></span><br><span class="line">  &#123;</span><br><span class="line">    strResult = strResult.<span class="built_in">substr</span>(<span class="number">0</span>, iSize - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/18/%E7%9B%B8%E6%9C%BA/%E4%BB%8EROS%E9%85%8D%E7%BD%AErealsense%E7%9A%84%E5%8F%82%E6%95%B0/">从ROS配置realsense的参数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E7%9B%B8%E6%9C%BA/">相机</a></span><div class="content"><h2 id="使用json配置realsense的参数-非rosparam"><a href="#使用json配置realsense的参数-非rosparam" class="headerlink" title="使用json配置realsense的参数(非rosparam)"></a>使用json配置realsense的参数(非rosparam)</h2><p>今天使用realsense时，发现有个参数需要修改<br><img src="https://i.loli.net/2020/10/15/lWn3xzM1CiyZtQX.png" alt="Set Point.png"><br>这个参数可以修正因反光而导致的错误，也就是把稍微凸起的地面当做障碍物，适当减小这个参数可以实现。</p>
<p>这个界面在realsense viewer中，但问题是如何在ROS中做到，它在rosparam中没有对应的参数。查来查去，在github的issue里发现了解决方法。realsense已经提供了一种<code>visual preset</code>文件，其实是个json文件，可以对很多参数设置，而且realsense的launch文件中已经定义了json文件的路径，比如<code>rs_camera.launch</code>:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;json_file_path&quot;</span>      <span class="attr">default</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>realsense提供的所有json文件在<a target="_blank" rel="noopener" href="https://github.com/IntelRealSense/librealsense/wiki/D400-Series-Visual-Presets">这里</a>，我们需要的参数在<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/wiki/IntelRealSense/librealsense/d400_presets/DefaultPreset_D435.json">DefaultPreset_D435.json</a>，也就是第一个参数：<code>&quot;aux-param-autoexposure-setpoint&quot;: &quot;400&quot;</code>，修改它的值后，把json文件的路径填到上面launch参数那里，启动launch就可以实现了。不过不能动态调整参数。</p>
<h2 id="配置点云的滤波器"><a href="#配置点云的滤波器" class="headerlink" title="配置点云的滤波器"></a>配置点云的滤波器</h2><p><code>rs_camera.launch</code>的参数是比较全的，<code>demo_pointcloud.launch</code>比较少。</p>
<p>现在介绍<code>filters</code>这个参数，在launch中没有赋值:<code>&lt;arg name=&quot;filters&quot;  default=&quot;&quot;/&gt;</code></p>
<p>pointcloud: 点云话题是<code>/camera/depth/color/points</code>. 点云的texture可以在<code>rqt_reconfigure</code>里修改，或者用参数<code>pointcloud_texture_stream</code>和<code>pointcloud_texture_index</code>修改</p>
<p>The depth FOV and the texture FOV are not similar. By default, pointcloud is limited to the section of depth containing the texture. You can have a full depth to pointcloud, coloring the regions beyond the texture with zeros, by setting allow_no_texture_points to true.</p>
<p>可以配置的滤波器如下:</p>
<ul>
<li>disparity, convert depth to disparity before applying other filters and back.</li>
<li>spatial，filter the depth image spatially.</li>
<li>temporal，filter the depth image temporally.</li>
<li>hole_filling，apply hole-filling filter.</li>
<li>decimation，reduces depth scene complexity.</li>
</ul>
<p>所有滤波器的说明在<a target="_blank" rel="noopener" href="https://github.com/IntelRealSense/librealsense/blob/master/doc/post-processing-filters.md">这里</a></p>
<p>给参数<code>filters</code>赋值，必须有<code>pointcloud</code>，再增加滤波器，用逗号隔开。比如 <code>disparity,spatial,pointcloud</code></p>
<p>滤波器的相关的源码在<code>base_realsense_node.cpp</code></p>
<ul>
<li><p><code>BaseRealSenseNode::setupFilters()</code>, 读取参数<code>filters</code>，把所有滤波器名称都插入容器<code>_filters</code></p>
</li>
<li><p><code>BaseRealSenseNode::publishPointCloud()</code>, 发布滤波后的点云</p>
</li>
</ul>
<p>参考:<br><a target="_blank" rel="noopener" href="https://github.com/IntelRealSense/realsense-ros">realsense-ros 滤波器</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Dontla/article/details/103574458">CSDN Realsense D435 Post-processing filters</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/18/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/ROS%E7%89%88%E6%9C%AC%E4%B8%8D%E5%85%BC%E5%AE%B9%E4%BA%A7%E7%94%9F%E7%9A%84TransformListenerWrapper%E9%97%AE%E9%A2%98/">tf的疑难问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a></span><div class="content"><h2 id="ROS版本不兼容产生的TransformListenerWrapper问题"><a href="#ROS版本不兼容产生的TransformListenerWrapper问题" class="headerlink" title="ROS版本不兼容产生的TransformListenerWrapper问题"></a>ROS版本不兼容产生的TransformListenerWrapper问题</h2><p><code>AmclNode</code>类中有这样一段：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use a child class to get access to tf2::Buffer class inside of tf_</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TransformListenerWrapper</span> :</span> <span class="keyword">public</span> tf::TransformListener</span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> tf2_ros::Buffer &amp;<span class="title">getBuffer</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> tf2_buffer_;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这是Kinetic的版本，但是在Melodic里没有这一段了，这是ROS版本兼容问题，在Kinetic里用不了这个结构体了。搜索发现<code>getBuffer</code>只有在<code>AmclNode::runFromBag</code>里调用，因为平时不用bag仿真时测试AMCL，所以这句话可以注释掉。</p>
<h2 id="“map”-passed-to-lookupTransform-argument-target-frame-does-not-exist"><a href="#“map”-passed-to-lookupTransform-argument-target-frame-does-not-exist" class="headerlink" title="“map” passed to lookupTransform argument target_frame does not exist"></a>“map” passed to lookupTransform argument target_frame does not exist</h2><p>解决方法： 先加上<code>listener.waitForTransform</code>，再<code>lookupTransform</code></p>
<p>The listener’s buffer, which carries all information about recent transformation, is literally empty. Therefore, any transform which looks-up the buffer does not find the frames it needs. It is good practice to wait for some time after the listener has been created so that the buffer can fill up. But instead of just sleeping, tf use <code>waitForTransform</code></p>
<p>参考: <a target="_blank" rel="noopener" href="https://answers.ros.org/question/192570/tftransformlistenertransformpose-exception-target_frame-does-not-exist/"></a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/20/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E5%9D%90%E6%A0%87%E7%B3%BB%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/">坐标系空间转换</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a></span><div class="content"><p>机器人SLAM问题中涉及到平移和旋转，平移是在欧氏空间中，连续的平移变换只需要向量相加。 可是旋转是在非欧空间了，连续的旋转变换就是矩阵连续右乘</p>
<p>右手坐标系：x向前(roll)，y向左(pitch)，z向上(yaw)</p>
<h2 id="用矩阵表示绕某轴旋转"><a href="#用矩阵表示绕某轴旋转" class="headerlink" title="用矩阵表示绕某轴旋转"></a>用矩阵表示绕某轴旋转</h2><p><img src="https://s2.loli.net/2023/01/19/QRagYNKoc2x54GB.png" alt=""></p>
<h2 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h2><p>坐标系A变换到B，从坐标系B到坐标系A的旋转矩阵的每一列，都是{B}的坐标轴单位向量在{A}中的表示<br><img src="https://i.loli.net/2020/09/04/RuIYGCytabgMZDo.png" alt=""><br>旋转矩阵R是一个行列式为1的正交矩阵，而且行向量和列向量的长度都为1，所以它的转置就是它的逆，而逆矩阵就可以将坐标系旋转回来。<br>R的每一行就是{A}的坐标轴单位向量在{B}中的表示。<br>SO(n)是特殊正交群，这个集合由n维空间的旋转矩阵组成。  SO(3)指三维空间的旋转。<br><img src="https://i.loli.net/2020/09/04/RKUsCZrv76zDO4P.png" alt=""></p>
<h2 id="变换矩阵"><a href="#变换矩阵" class="headerlink" title="变换矩阵"></a>变换矩阵</h2><script type="math/tex; mode=display">T =\left[ \begin{matrix}   R & t \\   0 & 1 \\ \end{matrix}  \right]</script><p>左上角为旋转矩阵，右侧为平移向量，这种矩阵又称为特殊欧氏群</p>
<script type="math/tex; mode=display">SE(3) = \left \{T =\left[ \begin{matrix}   R & t \\   0 & 1 \\ \end{matrix}  \right] \in \mathbb{R}^{4\times4} \ | R\in SO(3), t\in \mathbb{R}^3  \right \}</script><p>逆矩阵的形式 <script type="math/tex">\left[ \begin{matrix}   R & t \\   0 & 1 \\ \end{matrix}  \right]^{-1} \ = \left[ \begin{matrix}   R^T & -R^Tt \\   0 & 1 \\ \end{matrix}  \right]</script></p>
<p>如果一个点的坐标是 <script type="math/tex">P(x,y,z)</script>，那么点作T变换后的坐标就写作 <script type="math/tex">R*P + t</script>，按齐次矩阵和坐标形式计算就可得到。</p>
<h2 id="Censi-公式"><a href="#Censi-公式" class="headerlink" title="Censi 公式"></a>Censi 公式</h2><p>我习惯用Censi论文的公式，还可以用<code>Grisetti</code>派系的<br><img src="https://i.loli.net/2020/09/20/hsubLed7priFZmS.jpg" alt="坐标系示意图.jpg"><br><img src="https://i.loli.net/2020/09/20/YzpFTi8yEwqHhf5.jpg" alt="圆加和圆减.jpg"><br><img src="https://i.loli.net/2020/09/20/WbSvxUlGwCHNzgF.png" alt=""></p>
<script type="math/tex; mode=display">\quad\quad\quad\quad\quad\quad \vec{a} \oplus \vec{b} = \vec{c}</script><p>$\quad\quad\quad\quad\quad\quad\quad\Downarrow$</p>
<script type="math/tex; mode=display">\begin{pmatrix} a_x \\ a_y \\ a_{\theta} \end{pmatrix} + \left[ \begin{matrix}   cos_{a_\theta} & -sin_{a_\theta} & 0 \\  sin_{a_\theta} & cos_{a_\theta} & 0 \\ 0 & 0 & 1\end{matrix}  \right] *  \begin{pmatrix} b_x \\ b_y \\ b_{\theta} \end{pmatrix} = \begin{pmatrix} c_x \\ c_y \\ c_{\theta} \end{pmatrix}</script><p>其实这里就是 <script type="math/tex">Rp + t</script> ，只是在二维平面，R就是绕Z轴旋转的旋转矩阵形式。</p>
<h2 id="左乘和右乘"><a href="#左乘和右乘" class="headerlink" title="左乘和右乘"></a>左乘和右乘</h2><p>左乘是行变换，右乘是列变换。这是因为习惯上来说，空间中的向量用列向量表示，用矩阵左乘列向量，就是把它在空间当中变换。</p>
<p>若绕静坐标系（世界坐标系）旋转，则左乘，也是<strong>变换矩阵 x 坐标矩阵</strong>。 在固定坐标系下，一个点 <script type="math/tex">p</script> 经过一个旋转矩阵<script type="math/tex">R_1</script>，再经过一个旋转 <script type="math/tex">R_2</script> ，总共旋转 <script type="math/tex">R_2 * R_1 * p</script>，这是左乘。 向量旋转中的右乘本没必要，甚至会引起人误解。</p>
<p>若是绕动态坐标系旋转（自身建立一个坐标系），则右乘，也就是<strong>坐标矩阵 x 变换矩阵</strong>。 </p>
<p>即左乘是相对于坐标值所在的坐标系（世界坐标系）下的三个坐标轴进行旋转变换，右乘则是以当前点为旋转中心，进行旋转变换。</p>
<font size="4" color="blue"> 车在全局坐标系中运动，这可以看做绕固定轴旋转的过程，是左乘矩阵  </font>

<p>具体去看文章： <a href="https://charon-cheung.github.io/2019/06/11/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E6%AC%A7%E6%8B%89%E8%A7%92%EF%BC%8C%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%EF%BC%8C%E6%97%8B%E8%BD%AC%E5%90%91%E9%87%8F%EF%BC%8C%E5%9B%9B%E5%85%83%E6%95%B0/#%E5%9B%9B%E5%85%83%E6%95%B0">欧拉角，旋转矩阵，旋转向量，四元数</a></p>
<p>图优化里的相对位姿是由右乘获得的，即节点 $X_i$ 和 $X_j$ 之间的相对位姿是</p>
<script type="math/tex; mode=display">Z_{ij} = X_i^{-1}*X_j</script><p>常用的公式 <script type="math/tex">P_c=R_c∗P_w+t_c</script> 是把点P从<script type="math/tex">w</script>坐标系转换到 <script type="math/tex">c</script> 坐标系，由于旋转时，两个坐标系原点还是重合的，我们说经过了平移后，平移向量 <script type="math/tex">t_c</script> 是从坐标系 <script type="math/tex">w</script>坐标系指向 <script type="math/tex">c</script> </p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://www.pianshen.com/article/17351558785/">cartographer中公式的推导</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/03/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%8F%91%E5%B8%83%E8%80%85%E7%9A%84latch%E6%9C%BA%E5%88%B6/">发布者的latch机制</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><p>这个就是最常用的advertise函数的最后一个参数，原型： <code>advertise (const std::string &amp;topic, uint32_t queue_size, bool latch=false)</code></p>
<p>是否锁存。某些话题并不是会以某个频率发布，比如<code>/map</code>这个topic，只有在初次订阅或者地图更新这两种情况下，才会向<code>/map</code>发布消息，这里就用到了锁存。</p>
<p>锁存的作用就是，将发布者最后一次发布的消息保存下来，然后把它自动发送给后来的订阅者。这种方式非常适合变动较慢、相对固定的数据（例如地图），然后只发布一次，相比于同样的消息不定的发布，锁存的方式既可以减少通信中对带宽的占用，也可以减少消息资源维护的开销。</p>
<p>查看gmapping中的函数<code>SlamGMapping::startLiveSlam()</code>，发现三个话题都是 latched：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">entropy_publisher_ = private_nh_.advertise&lt;std_msgs::Float64&gt;(<span class="string">&quot;entropy&quot;</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">sst_ = node_.advertise&lt;nav_msgs::OccupancyGrid&gt;(<span class="string">&quot;map&quot;</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">sstm_ = node_.advertise&lt;nav_msgs::MapMetaData&gt;(<span class="string">&quot;map_metadata&quot;</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p><code>latch=true</code>，发布消息一次或几次，然后设法阻塞程序(常常用spin()，这里只是阻塞，跟订阅无关)，订阅者仍然能收到阻塞之前发布的消息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ros::<span class="built_in">init</span>(argc,argv, <span class="string">&quot;Pub&quot;</span>);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">ros::Publisher pub_latch_true = nh.advertise&lt;std_msgs::Int8&gt;(<span class="string">&quot;topic_latch_true&quot;</span>, <span class="number">50</span>, <span class="literal">true</span>);</span><br><span class="line">ros::Publisher pub_latch_false = nh.advertise&lt;std_msgs::Int8&gt;(<span class="string">&quot;topic_latch_false&quot;</span>, <span class="number">50</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">std_msgs::Int8 msg;</span><br><span class="line">msg.data = <span class="number">2</span>;</span><br><span class="line">pub_latch_true.<span class="built_in">publish</span>(msg);</span><br><span class="line">pub_latch_false.<span class="built_in">publish</span>(msg);</span><br><span class="line"><span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line">  ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">  rate.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>运行程序后等一会，运行<code>rostopic echo topic_latch_false</code>，什么也没有。运行<code>rostopic echo topic_latch_true</code>，会收到<code>data=2</code>的消息。  即使先运行两个echo，再运行发布者，结果也是如此</p>
<p><code>bool Publisher::isLatched () const</code> 用于判断是否latch</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/37/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><span class="page-number current">38</span><a class="page-number" href="/page/39/">39</a><span class="space">&hellip;</span><a class="page-number" href="/page/61/">61</a><a class="extend next" rel="next" href="/page/39/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2024/11/12/x1aqcwUG3XDiskN.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2025 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>