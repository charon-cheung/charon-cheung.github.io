<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">517</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">46</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/02/18/exLTfbM3uFOq5SV.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/13/%E8%A7%86%E8%A7%89SLAM/Kinect%20v1%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E9%85%8D%E7%BD%AE%E8%B0%83%E8%AF%95/">Kinect v1的配置调试</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%A7%86%E8%A7%89SLAM/">视觉SLAM</a></span><div class="content"><p>深度相机是能直接输出深度的相机，有的是通过软件算法间接计算深度，有的是用物理方法测量深度；RGB-D相机除了深度图还输出彩色图。</p>
<p>下面就是一张深度图：<br><img src="https://live.staticflickr.com/65535/49529758366_7e637256d6.jpg" alt=""><br>这是用<code>ImageJ</code>打开的，每个像素点的值代表距离，<strong>物理距离=像素值 / 尺度因子</strong>，不同相机的尺度因子是不同的，</p>
<p>目前RGBD深度摄像头获取深度图像的方法主要有立体视觉，激光雷达测距和结构光三大类。</p>
<ol>
<li><p>立体视觉。获取深度信息，指的是通过获取同一场景不同视角的多张图像，利用图像的匹配和一定的三维重建算法来计算场景对象的深度信息，如利用处同一轴线上的两个摄像头获取场景对象的两张视差图以及相机的内参和外参数计算深度信息的双目摄像头。</p>
</li>
<li><p>激光雷达测距则采用TOF 技术（Timeof flight，飞行时间），它通过记录光源投射到每个像素点的光线发射与反射间的相位变化来计算光线飞行时间，进而计算光源到每个像素点的距离，比如微软推出的最新的 Kinect 2代(京东价格1459)。</p>
</li>
</ol>
<p>TOF优点：</p>
<ul>
<li>通过调节发射脉冲的频率改变测量距离</li>
<li>测量精度不会随着测量距离的增大而降低</li>
<li>抗干扰能力强</li>
<li>适合距离远的场合(无人驾驶，AR)</li>
</ul>
<p>缺点：</p>
<ul>
<li>功耗大</li>
<li>分辨率低</li>
<li>深度图质量差</li>
</ul>
<ol>
<li>结构光：获取深度数据的方式是通过结构光投射器向物体表面投射可控制的光点、光线或者光面，就Kinect而言，其通过一个红外散斑发射器发射红外光束，光束碰到障碍物后反射回深度摄像头，然后通过返回散斑之间的几何关系计算距离。其实，Kinect的深度摄像头就是一个装了滤波片的普通摄像头，只对红外光成像的摄像头（可以这么认为）。相比双目相机通过软件计算距离来说深度相机可以节省大量的时间。 比如Kinect 1和IphoneX。 结构光又分几类：</li>
</ol>
<ul>
<li>单目结构光： 一个红外发射器和一个红外接收器</li>
<li>双目结构光： 一个红外发射器和两个红外接收器，得到两个红外图</li>
</ul>
<p>结构光法是为解决双目匹配问题而产生的，解决对环境光照的敏感问题，夜晚也可用，主动投影已知图案</p>
<p>RGBD相机的缺点：</p>
<ul>
<li>不适合室外</li>
<li>受深黑色物体、(半)透明物体、镜面反射物体、视差影响</li>
<li>功耗大</li>
<li>分辨率低</li>
<li>使用多个时会互相干扰</li>
<li>深黑色物体可以吸收大量的红外光导致测量不准</li>
</ul>
<p>物体呈现的颜色： 物体对不同波长的光具有选择性的吸收，进而决定物体 本身的颜色<br>白光中的光是互补的，一束白光通过溶液时，黄光会被吸收，结果只剩下对应得蓝光，溶液就表现出蓝色<br><img src="https://live.staticflickr.com/65535/49529758346_b5c795886c_z.jpg" alt=""></p>
<p>看下图的例子：色卡到摄像头的距离固定，接受的红外光形成散斑图，但是色卡右下角的黑色实际没接收到红外光，不同颜色对红外光的吸收是不同的，尤其深黑色物体。<br><img src="https://i.loli.net/2020/02/13/RcrQL78ajDUhSl4.png" alt="色卡.png"></p>
<p>再看下图的例子：椅子靠背是黑色，吸收了红外光，所以深度图上没有值<br><img src="https://i.loli.net/2020/02/13/tHMWg9Yl8uoFAVN.png" alt="椅子.png"></p>
<ul>
<li>(半)透明物体、镜面反射物体的影响: 漫反射是多个角度清晰成像的基础，镜面发射容易发生过曝光或欠曝光。对光滑物体，很难检测到，只能调整到某个角度测量。当物体表面超过一定的光滑度时，深度相机测量精度会急剧下降，设置测量失败(没有深度值)</li>
</ul>
<p>看下图的例子：左边椅子虽然是黑色，但是不光滑。桌子既是黑色又光滑，所以几乎没有深度值<br><img src="https://i.loli.net/2020/02/13/k1S6NDLJAaWhjMw.png" alt="光滑桌面.png"></p>
<ul>
<li>由于结构光深度相机的发射端和接收端有一定间距，因此在物体的边缘有明显视差</li>
</ul>
<p><img src="https://i.loli.net/2020/02/13/pEgDbumQeYlsMG9.png" alt="边缘.png"></p>
<h2 id="Kinect-1"><a href="#Kinect-1" class="headerlink" title="Kinect 1"></a>Kinect 1</h2><p>Kinect v1的Depth传感器，采用了<code>Light Coding</code>的方式，读取投射的红外线pattern，通过pattern的变形来取得Depth的信息。为此，Depth传感器分为投射红外线pattern的IR Projector（左）和读取的这个的IR Camera（右）。红外线（Infrared Radiation），简称IR。还有Depth传感器中间还搭载了Color Camera</p>
<p><img src="https://live.staticflickr.com/65535/49529935241_5ba37e018b_z.jpg" alt=""><br><img src="https://live.staticflickr.com/65535/47907938531_95db78701b_b.jpg" alt=""><br>Kinect 1目前已经停产，但是可以在淘宝上买到二手的，我发现的一家只有300多。</p>
<p>Kinect 1的缺点：需要使用自己的适配器，供电上有一个220v转12v的电源转换器，不可拆卸。如果用到移动机器人上，需要将线剪断，接到12v电源上。如果只是在固定端使用，就不需要进行改动。因为Kinect主要面向是游戏开发，固定在一个位置就行。</p>
<p>kinect深度图左边黑点一直闪， 有测量噪声，而且深度相机的测量噪声随着测量距离的变大而变大</p>
<h3 id="安装和运行驱动"><a href="#安装和运行驱动" class="headerlink" title="安装和运行驱动"></a>安装和运行驱动</h3><p><code>openni_launch</code>包已经不适用ROS-Kinetic了，应该用<code>freenect_launch</code>，它与<code>openni_launch</code>做到了最大限度的兼容：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y libfreenect-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get -y install ros-kinetic-freenect-camera ros-kinetic-camera-calibration ros-kinetic-freenect-stack  ros-kinetic-freenect-launch</span><br></pre></td></tr></table></figure></p>
<p>然后运行<code>roslaunch freenect_launch freenect.launch</code>，终端里会出现告警信息：<br><img src="https://i.loli.net/2019/11/26/ZkYhenJcbrdjGI3.png" alt=""><br>显然这是在找标定文件，一个是RGB的，一个是深度的，稍后需要标定然后把文件放到提示中的目录．</p>
<h2 id="话题"><a href="#话题" class="headerlink" title="话题"></a>话题</h2><p>下面这些话题是我们经常使用的<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/camera/depth/image</span><br><span class="line">/camera/depth/image_raw</span><br><span class="line">/camera/depth/points : 无颜色点云. 使用`PCL`对单个点进行处理</span><br><span class="line">/camera/ir/image_raw</span><br><span class="line">/camera/rgb/image_color</span><br><span class="line">/camera/rgb/image_raw</span><br></pre></td></tr></table></figure><br>如果是realsense相机，还有一个<code>/camera/depth/color/points</code>话题，可到驱动处查看配置</p>
<ul>
<li>RGB图像：/camera/rgb/image_color</li>
</ul>
<p>消息类型<code>sensor_msgs/Image</code><br>OPENCV数据格式：Mat<br>图像尺寸：<code>640*480</code><br>像素数据类型：8UC3</p>
<ul>
<li>深度图像：/camera/depth/image</li>
</ul>
<p>消息类型<code>sensor_msgs/Image</code><br>OPENCV数据格式：Mat<br>图像尺寸：<code>640*480</code><br>像素数据类型：32FC1<br>小端<br>data数组长度 1228800</p>
<ul>
<li>点云数据（无整合RGB）: /camera/depth/points</li>
</ul>
<p>ROS数据格式：sensor_msgs/Image<br>PCL点云库数据格式：pcl::PointCloud<pcl::PointXYZ><br>图像尺寸：有序点云，<code>640*480</code><br>像素数据类型：double，每个像素实际是32位浮点，单位米</p>
<p>运行<code>rqt</code>，然后到话题列表里选择<code>/camera/rgb/image_color</code>和<code>/camera/depth/image</code>，会显示彩色图像和深度图像，选择<code>/camera/depth/disparity</code>话题是视差图</p>
<h3 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h3><p>图像保存方法是最右测按钮，直接保存即可。如果是在无界面环境下保存，就要用<code>image_view</code>包的节点<code>image_saver</code>。可以从流媒体中保存<code>jpg/png</code>文件(也就是<code>sensor_msgs/Image</code>话题)。</p>
<p>比如保存深度图：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding参数默认是bgr8, save_all_image参数默认true，会一直保存</span></span><br><span class="line">rosrun image_view image_saver image:=/camera/depth/image_raw _encoding:=16UC1 _filename_format:=<span class="string">&quot;image%03i.png&quot;</span></span><br></pre></td></tr></table></figure><br>保存的文件名是<code>image000.png</code>形式，但问题是它会不断保存当前图片，因为是以订阅话题形式运行节点。 如果只保存一次，我们就需要将<code>save_all_image</code>参数设置为false，而且用service形式，<code>rosservice list</code>发现有一个<code>/image_saver_1581905204960559926/save</code>，显然是跟时间戳对应的，有时会出现多个这样的话题，所以要注意区分是哪个图片。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosrun image_view image_saver image:=/camera/depth/image_raw _encoding:=16UC1 _filename_format:=<span class="string">&quot;image%03i.png&quot;</span> _save_all_image:=<span class="literal">false</span></span><br><span class="line">rosservice call /image_saver_1581905064980209474/save</span><br></pre></td></tr></table></figure></p>
<p>此外还有节点<code>extract_images</code>也是用于保存图片，用法类似；<code>video_recorder</code>用于录像</p>
<p>Kinect获取到的深度图一定要用png格式存储，而不能用jpg。深度图像的是12位的，jpg只能存储8位，PNG支持16位。jpg格式属于有损压缩，而png为无损压缩。</p>
<h3 id="使用rviz显示"><a href="#使用rviz显示" class="headerlink" title="使用rviz显示"></a>使用rviz显示</h3><p>打开rviz后，修改“Fixed Frame”为<code>/camera_depth_optical_frame</code>，接着点击add添加PointCloud2类型，修改topic，如下图所示<br><img src="https://live.staticflickr.com/65535/49529783221_b5a1f5d63a_n.jpg" alt="话题配置"></p>
<p>效果是这样的，视角不好，得自己调整<br><img src="https://live.staticflickr.com/65535/49529279898_367fe66a23_w.jpg" alt=""></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果没有图像显示可以使用<code>rostopic echo</code>命令看看是否有数据流出来，如果切换rgb和ir太快，可能会在终端报错：<br><img src="https://i.loli.net/2019/11/26/YqwvIenKRQag6rZ.png" alt=""></p>
<p><code>freenect_launch</code>中还有一些文件可以根据需要运行最少的节点，同时可以避免一些不必要的警告</p>
<ul>
<li><p>freenect-xyz.launch: provides the pointcloud /camera/depth/points. Disables device registration.</p>
</li>
<li><p>freenect-registered-xyzrgb.launch: provides the pointcloud /camera/depth_registered/points. Enables device registration. </p>
</li>
</ul>
<p>在rviz中打算观察点云时，话题部分有报错<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">For frame [camera_depth_optical_frame]: No transform to fixed frame [odom].  TF error: [Could not find a connection between &#x27;odom&#x27; and &#x27;camera_depth_optical_frame&#x27; because they are not part of the same tree.Tf has two or more unconnected trees.]</span><br></pre></td></tr></table></figure></p>
<p>参考：<br><a target="_blank" rel="noopener" href="http://res.percipio.xyz/doc/PCP_DS_FM810_CN.pdf">图漾FM510的参数</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/SFM2020/article/details/83002133">史上最详尽的RGB-D传感器选型</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/12/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/%E4%B8%8A%E4%BD%8D%E6%9C%BA-ROS%E9%80%9A%E4%BF%A1/">上位机-ROS通信</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/">ROS机器人</a></span><div class="content"><p>因为要求在Windows上间接运行ROS的程序, 采用的通信方式是Web API. Web API可以使用任何类型的通信协议，数据交互格式为XML以及JSON。但主要是JSON,因为它比XML更加轻量，这就是使得JSON在解析速率方面更快，对带宽的要求更低。实际使用的还是Http的GET方式,所以把ROS程序做成CGI的形式, 放到mini-httpd的网络目录里供windows调用</p>
<p>Web API的客户端系统（调用者）和服务系统（提供者）彼此独立，调用者可以轻易的使用不同的语言（Java，Python，Ruby等）进行API的调用。</p>
<p>Web API的测试工具是<strong>POSTMAN</strong>, 在Windows和Linux平台下均有</p>
<p>这里要多说一些内容, 机器人上用到的Web API通信比较多,如果自己在文档上总结,不太方便且容易出错,看到仙知机器人使用Swagger总结的很好: <a target="_blank" rel="noopener" href="https://dev.seer-robotics.com/web-api/">RoboRoute Web API 使用手册</a></p>
<p><code>Swagger</code>是一款<code>RESTFUL</code>接口的文档在线自动生成+功能测试功能软件，随着现在许多公司实现了前后端分离，swagger越来越受欢迎了。swagger是有两个版本的，而且区别还挺大的，一个是swagger-ui也就是swagger1;还有一个是springfox-swagger也就是swagger2. 推荐用前者.</p>
<p>Swagger UI 提供了一个可视化的UI页面展示描述文件。接口的调用方、测试、项目经理等都可以在该页面中对相关接口进行查阅和做一些简单的接口请求。该项目支持在线导入描述文件和本地部署UI项目。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/12/C++/Boost/noncopyable%E7%B1%BB/">noncopyable类</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/Boost/">Boost</a></span><div class="content"><p>Boost中有一个noncopyable类,它把copy构造函数和赋值运算符都声明为private,可以让自定义的类继承它</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">noncopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="built_in">noncopyable</span>() &#123;&#125;</span><br><span class="line">  ~<span class="built_in">noncopyable</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:  <span class="comment">// emphasize the following members are private</span></span><br><span class="line">  <span class="built_in">noncopyable</span>( <span class="keyword">const</span> noncopyable&amp; );</span><br><span class="line">  <span class="keyword">const</span> noncopyable&amp; <span class="keyword">operator</span>=( <span class="keyword">const</span> noncopyable&amp; );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面拷贝构造函数和赋值构造函数都声明为private，这样不论什么派生方式，子类对此都是无权访问的，从而达到禁止拷贝的目的。</p>
<p>构造函数为什么声明成protected呢？ 首先肯定不能为private，不然无法构造子类实例。<br>如果为public，那么外部是可以创建noncopyable这么一个实例的，可是这个实例是完全没有意义的，我们用不到,该类只有在被继承之后才有意义。<br>所以此处声明为protected才是合适的，既保证外部无法直接构造一个无意义的noncopyable实例，又不影响构造子类实例。</p>
<p><strong>但是如果派生类继承它之后,又定义自己的copy构造和赋值运算符，调用者还是能够通过赋值和copy构造等手段来产生一个新的对象,这种情况干脆不要继承noncopyable类</strong></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/12/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/union%E5%92%8C%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF/">union和大端小端</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><p>大端: 低位的数据存放在高地址,高位的数据存放在低地址<br>小端: 低位的数据存放在低地址,高位的数据存放在高地址</p>
<p>现在的CPU一般都是小端. 网络编程中,TCP/IP统一采用大端方式传送数据，所以有时我们也会把大端方式称之为<strong>网络字节序</strong></p>
<p>结合union理解这个概念比较容易,看下面程序:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">my</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> bytes[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">my un;</span><br><span class="line">un.a = <span class="number">135201034</span>;</span><br><span class="line"><span class="comment">// a为4个字节, 二进制表示就是: 00001000  00001111  00000001  00001010</span></span><br><span class="line"><span class="comment">// 分别转化为十进制就是 8   15   1   10</span></span><br><span class="line"><span class="keyword">int</span> a0 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(un.bytes[<span class="number">0</span>]) ;</span><br><span class="line"><span class="keyword">int</span> a1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(un.bytes[<span class="number">1</span>]) ;</span><br><span class="line"><span class="keyword">int</span> a2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(un.bytes[<span class="number">2</span>]) ;</span><br><span class="line"><span class="keyword">int</span> a3 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(un.bytes[<span class="number">3</span>]) ;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt; <span class="string">&quot;address a0: &quot;</span>&lt;&lt; &amp;a0 &lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;a0 &lt;&lt;endl;</span><br><span class="line">cout&lt;&lt; <span class="string">&quot;address a1: &quot;</span>&lt;&lt; &amp;a1 &lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;a1 &lt;&lt;endl;</span><br><span class="line">cout&lt;&lt; <span class="string">&quot;address a2: &quot;</span>&lt;&lt; &amp;a2 &lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;a2 &lt;&lt;endl;</span><br><span class="line">cout&lt;&lt; <span class="string">&quot;address a3: &quot;</span>&lt;&lt; &amp;a3 &lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;a3 &lt;&lt;endl;</span><br></pre></td></tr></table></figure><br>联合体占了4个字节,对a赋值后,显然bytes数组要分担这4个字节的数据,这里为了表示清楚,把每个bytes又转为int(四个字节),我们知道数组的内存地址占用是连续的，而且第一个元素在低地址，依次为高地址。</p>
<p>运行结果:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">address a0: 0x7fff768cc180  10</span><br><span class="line">address a1: 0x7fff768cc184  1</span><br><span class="line">address a2: 0x7fff768cc188  15</span><br><span class="line">address a3: 0x7fff768cc18c  8</span><br></pre></td></tr></table></figure><br>可以看出转换后,每个占了4字节,低地址的a0对应的是a的低8位,所以说这里是小端. 如果是大端, 地址和数据的对应关系就要倒过来.</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/12/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88(%E4%B8%80)%20unique_ptr/">智能指针(一) unique_ptr</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><p>智能指针三个优点:</p>
<ul>
<li>明确资源的所有权</li>
<li>避免忘记delete</li>
<li>更好地handle exception (Effective C++ 中的条款)</li>
</ul>
<p>智能指针类重载了解除引用运算符<code>（*）</code>和成员选择运算符<code>（-&gt;）</code>,同时为了能够在堆中管理各种类型，几乎所有的智能指针都是模板类，包含其功能的泛型实现。</p>
<p>C++11 中的<code>auto_ptr</code>已经废弃. 现有的 unique_ptr，shared_ptr，weak_ptr和原生指针加起来构成了指针的完整四件套。它们都在头文件<code>&lt;memory&gt;</code>里面,最常用的是原生指针（没所有权语义的时候），其次是<code>unique_ptr</code>，后两个除非特定场合需求，能不用就不用。 拷贝shared_ptr、 weak_ptr都涉及到<code>atomic</code>操作，其开销比起拷贝、解引用一个指针都是大很多的。</p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p><code>unique_ptr</code>代表的是专属所有权，之所以叫这个名字，是因为它只能指向一个对象，即当它指向其他对象时，之前所指向的对象会被摧毁,不能进行复制操作只能进行移动操作。两个<code>unique_ptr</code>也不能指向一个对象. 看源码发现，拷贝构造函数和赋值运算符都加了delete:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>(<span class="keyword">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">unique_ptr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><br>强行使用会报错: <img src="https://live.staticflickr.com/65535/49476286518_bd22217c4c_z.jpg" alt=""></p>
<p>这里需要注意:  <font color = blue size=4>既然不能拷贝, 就不能在函数中将unique_ptr作为参数了，因为传参是一个产生副本的过程，用 move(unique_ptr)取代 </font></p>
<p>如果想要把一个<code>unique_ptr</code>的内存交给另外一个<code>unique_ptr</code>对象管理, 只能使用<code>std::move</code>转移当前对象的所有权。转移之后，当前对象不再持有此内存，新的对象将获得专属所有权</p>
<p><code>unique_ptr</code>和原生指针的大小是一样的，内存上没有任何的额外消耗，性能是最优的</p>
<p>如果没有为<code>unique_ptr</code>指定指向对象，get()返回0</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() &#123; cout&lt;&lt; <span class="string">&quot;construct&quot;</span> &lt;&lt;endl; &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; cout&lt;&lt; <span class="string">&quot;destruct&quot;</span> &lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test())</span></span>;</span><br><span class="line">cout&lt;&lt; <span class="string">&quot;p1: &quot;</span>&lt;&lt;p1.<span class="built_in">get</span>()&lt;&lt;endl;      <span class="comment">// 0x19b7c20</span></span><br><span class="line"><span class="comment">// std::unique_ptr&lt;Test&gt; p2(p1)   // 错误用法, 不支持拷贝构造函数</span></span><br><span class="line">std::unique_ptr&lt;Test&gt; p2 = std::<span class="built_in">move</span>(p1);</span><br><span class="line"><span class="comment">// 转移所有权到p2</span></span><br><span class="line">cout&lt;&lt; <span class="string">&quot;p1: &quot;</span>&lt;&lt;p1.<span class="built_in">get</span>()&lt;&lt;endl;   <span class="comment">// 0</span></span><br><span class="line">cout&lt;&lt; <span class="string">&quot;p2: &quot;</span>&lt;&lt;p2.<span class="built_in">get</span>()&lt;&lt;endl&lt;&lt;endl;    <span class="comment">// 0x19b7c20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p2释放所有权, 只剩p3原生指针</span></span><br><span class="line"><span class="comment">// release并不会摧毁其指向的对象，不执行析构,与reset不同</span></span><br><span class="line">Test* p3 = p2.<span class="built_in">release</span>();</span><br><span class="line">cout&lt;&lt; <span class="string">&quot;after release &quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt; <span class="string">&quot;p2: &quot;</span>&lt;&lt;p2.<span class="built_in">get</span>()&lt;&lt;endl;      <span class="comment">// 0</span></span><br><span class="line">cout&lt;&lt; <span class="string">&quot;p3: &quot;</span>&lt;&lt;p3 &lt;&lt;endl&lt;&lt;endl;    <span class="comment">// 0x19b7c20</span></span><br></pre></td></tr></table></figure>
<p><code>move</code>不执行析构，否则新的智能指针无法指向对象了.</p>
<h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><p><code>reset</code>有两种用法</p>
<ul>
<li><p>如果不加参数，就会销毁对象(执行析构函数)，重置智能指针</p>
</li>
<li><p>如果加原生指针做参数，就会先销毁原来指向的对象，然后指向原生指针指向的对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Test* p3 = <span class="keyword">new</span> <span class="built_in">Test</span>();</span><br><span class="line"><span class="function">std::unique_ptr&lt;Test&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> Test())</span></span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;p4: &quot;</span>&lt;&lt;p4.<span class="built_in">get</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">p4.<span class="built_in">reset</span>(p3);</span><br><span class="line">cout&lt;&lt; <span class="string">&quot;after reset &quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt; <span class="string">&quot;p4: &quot;</span>&lt;&lt;p4.<span class="built_in">get</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt; <span class="string">&quot;p3: &quot;</span>&lt;&lt;p3 &lt;&lt;endl;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>运行结果:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">construct   // p3</span><br><span class="line">construct   // p4</span><br><span class="line">p4: 0x7adc50</span><br><span class="line">destruct   // </span><br><span class="line">after reset </span><br><span class="line">p4: 0x7acc20</span><br><span class="line">p3: 0x7acc20</span><br><span class="line">destruct</span><br></pre></td></tr></table></figure></p>
<p>需要注意:  <font color = blue size=4>release不执行析构, reset执行析构 </font></p>
<h3 id="自定义删除器"><a href="#自定义删除器" class="headerlink" title="自定义删除器"></a>自定义删除器</h3><p>unique_ptr的定义删除器方式和shared_ptr不同,因为模板的参数不同,前者还需要指定删除器类型. </p>
<p>原型有:</p>
<ul>
<li>std::unique_ptr<T,D> up(t,d);</li>
<li>std::unique_ptr<T,D> up(d);  // 空的指针</li>
</ul>
<p>T为指针管理的对象类型, D为删除器类型, t为管理的对象, d为删除器函数名称</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myclose</span><span class="params">(Test* t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;close func&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test t;</span><br><span class="line"><span class="function">std::unique_ptr&lt;Test, <span class="title">decltype</span><span class="params">(myclose)</span>*&gt; <span class="title">p1</span><span class="params">(&amp;t, myclose)</span></span>;</span><br></pre></td></tr></table></figure>
<p>运行结果:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">construct</span><br><span class="line">close func</span><br><span class="line">destruct</span><br></pre></td></tr></table></figure><br><code>decltype</code>用于获取myclose的类型, <code>*</code>表面它是一个指针类型,即函数指针.</p>
<p><font color = orange size=4> make_unique 不是‘std’的成员 </font>， 原因是<code>make_unique</code>为C++14才特有的， 如果使用gcc版本小于6.2，编译就会报错，vs2015  msvc 也可以</p>
<p>参考: <a target="_blank" rel="noopener" href="https://www.cyhone.com/articles/right-way-to-use-cpp-smart-pointer/">C++ 智能指针的正确使用方式</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/21/C++/C++%20%20%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/%E9%93%BE%E8%A1%A8%E7%A8%8B%E5%BA%8F/">链表程序</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/">C++ 模板与STL</a></span><div class="content"><p>单链表程序如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkedList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    LinkedList* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LinkedList* root, *second, *third;</span><br><span class="line">root = <span class="keyword">new</span> LinkedList;</span><br><span class="line">second = <span class="keyword">new</span> LinkedList;</span><br><span class="line">third = <span class="keyword">new</span> LinkedList;</span><br><span class="line"></span><br><span class="line">root-&gt;data = <span class="number">10</span>;</span><br><span class="line">root-&gt;next = second;</span><br><span class="line">second-&gt;data = <span class="number">20</span>;</span><br><span class="line">second-&gt;next = third;</span><br><span class="line">third-&gt;data = <span class="number">30</span>;</span><br><span class="line">third-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">LinkedList* guy = <span class="keyword">new</span> LinkedList;</span><br><span class="line">guy-&gt;data = <span class="number">90</span>;</span><br><span class="line">guy-&gt;next = second-&gt;next;</span><br><span class="line">second-&gt;next = guy;</span><br><span class="line"><span class="keyword">while</span>(root)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt; root-&gt;data &lt;&lt;endl;</span><br><span class="line">    root = root-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/16/C++/C++%20%20%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/deque%20%20queue/">deque  queue</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/">C++ 模板与STL</a></span><div class="content"><p>deque可以看做是<code>vector</code>和<code>list</code>的折中容器，类似vector，它支持随机访问(其实是假象)，即支持<code>[]</code>以及<code>at()</code>，但是性能没有vector好。</p>
<p>deque和vector的区别：</p>
<ol>
<li>在头部插入删除元素的时间复杂度是O(1)</li>
<li>没有容量的概念，所以没有<code>reserve</code>, <code>capacity</code>函数。因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，不像 vector 那样，当旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间</li>
</ol>
<p>deque还是不如list的任何位置插入删除，它的中间部分插入和删除元素和vector一样，时间复杂度还是<code>O(n)</code>。所以没有list的<code>reverse</code>函数</p>
<h2 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h2><p>这下问题就来了，既然没有<code>reserve</code>和<code>capacity</code>，显然它和vector的底层机制不同。</p>
<p>deque采用类似索引的结构管理内存，采用一块所谓的map(<font color = blue size =3>不是数据结构的map </font>)作为<strong>中控器</strong>，map是一块连续的内存空间，每个元素(称之为<strong>节点</strong>)都是指针，指向另一块连续的线性空间，称为<strong>缓冲区</strong>，map实际上是指针的指针<code>T**</code>。<br><img src="https://i.loli.net/2020/01/21/3jXPYMQlN4ZOJce.png" alt="deque数据结构"><br>deque的迭代器包含4个：</p>
<ul>
<li><p>cur：迭代器当前所指元素</p>
</li>
<li><p>first：此迭代器所指的缓冲区的头</p>
</li>
<li><p>last：缓冲区尾</p>
</li>
<li><p>node：指向管控中心</p>
</li>
</ul>
<p>deque的最初状态是有一个缓冲区，调用clear函数的作用就会清除整个deque，释放所有空间而只保留一个缓冲区。如果调用erase清楚某个元素，而这个元素是所在缓冲区唯一的元素，会将此缓冲区释放。<br><br></p>
<p>与vector不同，deque的内存大小是可缩减的。deque的内存区块不再被使用时，会被释放。</p>
<p>deque维护start和finish两个迭代器，分别指向第一缓冲区的第一个元素和最后一个缓冲区的最后元素的下一个位置。它还要记住当前map的大小，如果map的节点不足，就需要重新配置。<br><br></p>
<p>为了指定缓冲区的大小，必须指定  <strong>alloc</strong> 为空间配置器。比如指定数据int类型，缓冲区大小为4的deque: <code>deque&lt;int, alloc, 4&gt;</code>。 map的初始大小至少是8，最多是<strong>所需节点数+2</strong>，按刚才的例子，要存放50个元素，就需要13个节点，那么map的初始大小就是15。  如果插入的元素太多，map会不够大，需要扩充，和vector的内存扩充一样，先配置一块更大的，把原来的节点全拷贝过来，再释放原来的map。  对于平时的空间扩充，如果缓冲区中还有备用的空间，那么直接使用备用的空间；否则另外配置一个缓冲区，将其信息记录到缓冲区地址表里</p>
<p>在除了首尾两端的其他地方插入和删除元素，都将会导致指向deque元素的任何pointers、references、iterators失效。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><p>deque的元素存取和迭代器操作会比vector稍微慢一些，因为它的内部结构会多一个间接过程</p>
</li>
<li><p>deque迭代器是特殊的指针，而不是vector那样的一般指针，它需要在不同的区块之间跳转</p>
</li>
<li><p>不支持对内存分配时机的控制，也就是没有reserve</p>
</li>
<li><p>缓冲区的内存地址是连续的，但不同缓冲区之间不是连续的</p>
</li>
<li><p>中间添加元素，会使迭代器、指针、引用失效</p>
</li>
<li><p>头尾添加元素，现有元素的内存地址不变，指针和引用不失效，但迭代器可能失效，因为可能分配新的内存块</p>
</li>
</ul>
<h2 id="最好采用deque的情形"><a href="#最好采用deque的情形" class="headerlink" title="最好采用deque的情形"></a>最好采用deque的情形</h2><ul>
<li><p>需要在两端插入和删除元素</p>
</li>
<li><p>随机访问元素的情况较少，主要是访问两端元素</p>
</li>
<li><p>要求容器释放不再使用的元素</p>
</li>
</ul>
<p>cartographer中的成员变量，凡是以<code>queue</code>结尾的，基本都是deque类型。 比如<code>timed_pose_queue</code>，它的使用只有<code>back</code>, <code>front</code>, <code>pop_back</code>, <code>pop_front</code>几个函数，根本没有用到遍历和随机访问</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;std::unique_ptr&lt;Constraint&gt;&gt;   constraints_;</span><br><span class="line">constraints_.<span class="built_in">emplace_back</span>();</span><br><span class="line"><span class="keyword">auto</span>* <span class="keyword">const</span> constraint = &amp;constraints_.<span class="built_in">back</span>();</span><br></pre></td></tr></table></figure>
<p>constraints_是个vector，可先添加一个空元素，然后再对最后一个元素进行赋值，其实为添加一个新元素（cartographer中很多都是如此做法，目的可减省一个变量空间和赋值时间）</p>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p>单向队列中的数据是先进先出，queue只是进一步封装别的数据结构，并提供自己的接口，如果不指定容器，默认是用deque来作为其底层数据结构的</p>
<p>单向队列一共6个常用函数<code>front()</code>、<code>back()</code>、<code>push()</code>、<code>pop()</code>、<code>empty()</code>、<code>size()</code>，不支持随机访问，所以没有<code>[]</code>运算符和<code>at</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;  q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">qDebug</span>()&lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;  &quot;</span>&lt;&lt; q.<span class="built_in">empty</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt;q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; q.<span class="built_in">back</span>() ;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt;q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; q.<span class="built_in">back</span>() ;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4    <span class="literal">false</span></span><br><span class="line">1    4</span><br><span class="line">2    4</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/14/C++/C++%20%20%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/list%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/">list</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/">C++ 模板与STL</a></span><div class="content"><p>list底层数据结构为双向链表，以结点为单位存放数据，结点的地址在内存中不连续，每次插入或删除一个元素，就增加或释放一个元素空间，占用内存比vector多</p>
<p>list不支持随机访问，适用于对象数量变化频繁，插入和删除频繁。随机访问元素的时间复杂度为O(n)，插入删除为O(1)，后两者只需要改变元素的指针</p>
<p>list删除迭代器时，其后面的迭代器都不会失效，将前面和后面连接起来即可。</p>
<p>list插入和删除数据，需要对现有数据进行遍历，但在首部插入数据，效率很高。</p>
<p><font color = blue size =3> list的迭代器不是普通指针，因为节点在内存中不是连续存在的。</font>它是一个结构体，内部有一个普通指针指向节点，实现递增递减、解引用、取值等运算符。</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;<span class="keyword">int</span>&gt; list1=&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">39</span>,<span class="number">1</span>&#125;;</span><br><span class="line">std::list&lt;<span class="keyword">int</span>&gt; list2=&#123;<span class="number">7</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line">cout&lt;&lt; list1.<span class="built_in">size</span>()&lt;&lt;endl;		<span class="comment">// 5</span></span><br><span class="line">list1 = list2;		<span class="comment">// 直接赋值</span></span><br><span class="line">cout&lt;&lt; list1.<span class="built_in">size</span>()&lt;&lt;endl;		<span class="comment">// 4 </span></span><br><span class="line"></span><br><span class="line">list&lt;<span class="keyword">int</span>&gt;::iterator ite;</span><br><span class="line"><span class="keyword">for</span>(ite=list1.<span class="built_in">begin</span>(); ite!=list1.<span class="built_in">end</span>(); ite++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt; *ite &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序和反转"><a href="#排序和反转" class="headerlink" title="排序和反转"></a>排序和反转</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;<span class="keyword">int</span>&gt; list1=&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">39</span>,<span class="number">1</span>&#125;;</span><br><span class="line">list1.<span class="built_in">sort</span>();</span><br><span class="line"><span class="built_in">print</span>(list1);		<span class="comment">// 1  2  4  5  39</span></span><br><span class="line">list1.<span class="built_in">reverse</span>();</span><br><span class="line"><span class="built_in">print</span>(list1);		<span class="comment">// 39  5  4  2  1</span></span><br></pre></td></tr></table></figure>
<p><code>merge</code>函数有点问题，<code>list1.merge(list2);</code>应当是将list2与list1合并再排序，但是我发现list2插入到了list1中间的部分，把list1分割开了，可能是编译器的问题，最好还是不要使用。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p>对list中连续而相同的元素去重，移除到只剩一个，不连续的不处理</p>
</li>
<li><p>clear 函数的作用是清楚整个list的所有节点， 析构节点的对象，释放节点的空间</p>
</li>
<li><p>remove 函数的作用是将数值为value的所有元素移除</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/14/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E7%8B%84%E6%8B%89%E5%85%8B%E5%87%BD%E6%95%B0/">狄拉克函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a></span><div class="content"><p>狄拉克δ函数是在实数线上定义的一个广义函数或分布。它在除零以外的点上都等于零，且其在整个定义域上的积分等于1。δ函数有时可看作是在原点处无限高、无限细，但是总面积为1的一个尖峰。数学定义如下：<br><a target="_blank" rel="noopener" href="https://live.staticflickr.com/65535/49383566037_a45a5160f9_w.jpg"></a><br>上面的f(x)就可以表示为δ(x−x0)</p>
<p>在许多应用中，均将δ视为由在原点处有尖峰的函数所组成的序列的极限，而序列中的函数则可作为对δ函数的近似</p>
<p><a target="_blank" rel="noopener" href="https://live.staticflickr.com/65535/49382906718_e48a121e8c_z.jpg"></a><br><a target="_blank" rel="noopener" href="https://live.staticflickr.com/65535/49382906683_c9b2102669_w.jpg"></a><br>到了极限就是这样子：<br><a target="_blank" rel="noopener" href="https://live.staticflickr.com/65535/49383566127_bf40c13d92_z.jpg"></a></p>
<p>在概率论和统计学中，狄拉克函数往往以概率密度函数的身份，来代表一个离散分布或部分离散、部分连续的分布（概率密度函数一般只用作描述完全连续分布）。例如，设一组点x = {X1, …, Xn}，对应概率为p1, …,pn；由这些点所组成的离散分布的概率密度函数可以写作:<br><a target="_blank" rel="noopener" href="https://live.staticflickr.com/65535/49383389511_3b0e719413_n.jpg"></a><br>根据函数定义，很容易就能证明</p>
<p>参考：<a target="_blank" rel="noopener" href="http://wuli.wiki//online/Delta.html">狄拉克函数</a><br><a target="_blank" rel="noopener" href="https://www.wikiwand.com/zh-cn/%E7%8B%84%E6%8B%89%E5%85%8B%CE%B4%E5%87%BD%E6%95%B0#/%E6%A6%82%E7%8E%87%E8%AB%96_2">Wiki 狄拉克函数</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/12/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)%E6%80%BB%E4%BD%93%E9%80%BB%E8%BE%91/">源码分析(一) 总体逻辑</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/">amcl和粒子滤波</a></span><div class="content"><ul>
<li><p>局部定位：假定机器人有了初始位姿，通过增加运动噪声完成机器人定位。不确定性围绕在真实位姿附近，用单峰概率模拟，比如高斯分布。</p>
</li>
<li><p>全局定位： 不知道初始位姿，不确定定位误差的有界性。需要匹配定位，单峰概率难以模拟误差分布</p>
</li>
<li><p>机器人绑架： 全局定位的延伸，定位难度更大。机器人运行时被搬离原来位置，导致之前定位不准确。</p>
</li>
</ul>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p><img src="https://i.loli.net/2020/08/30/sCI2oG6kHlxim5M.png" alt="AMCL.png"></p>
<ul>
<li>初始化</li>
</ul>
<p>首先定义两个粒子集，开始都是空集，一个用于重采样缓冲的<code>set_a</code>，一个是最终需要的<code>set_b</code>，对每份粒子集合创建kdtree。算法的目的是用粒子集合来表示置信度。</p>
<p>先在AMCL里给定一个初始位姿值和协方差矩阵，粒子数为M。一开始，每一个粒子的权重值都是1/M，位姿的分布是一个高斯分布，每个粒子的初始位姿记做<code>(x,y,theta)</code>，其均值是AMCL的初始位姿，方差是从协方差矩阵获得的。将每个粒子插入到kdtree中，对粒子滤波器的粒子集进行聚类。</p>
<ul>
<li>运动模型</li>
</ul>
<p>概率模型是 <script type="math/tex">p(x_t\ | \ x_{t-1},\ u_t)</script>， 使用里程计模型进行估计。对每一个粒子更新位姿。位姿是从运动模型中采样获得的，机器人从t-1时刻运动到t时刻，获得相对运动参数<code>rot1,trans,rot2</code></p>
<p>最终，对于每个粒子的位姿， x加上相对平移量在x轴的分量(乘以cos), y加上相对平移量在y轴的分量， theta加上两次旋转的参数。这些分量除了跟rot1,trans,rot2有关，还跟AMCL中的四个运动噪声参数<code>alpha1~alpha4</code>有关</p>
<ul>
<li>测量模型</li>
</ul>
<p>概率模型是 <script type="math/tex">p(z_t\ | \ x_t)</script>，使用似然域模型，用于更新每一个粒子的权重。  </p>
<p>似然域测量模型认为测量的结果包含一个高斯分布噪声和随机噪声。<br>激光测量距离（x,y）变换到map坐标系。找到距离激光点最近的障碍，查表获得它们的最近距离dist。 这个dist也是高斯噪声的均值，所以dist越大，打到障碍物的可能性越小，则粒子不可信，权重越小。</p>
<p><script type="math/tex">\omega = \prod_{i=1}^N \left\{ z_{hit}*prob(dist_i, \sigma_{hit})+\frac{z_{rand}}{z_{max}}  \right\}\ \qquad \qquad</script>   N为一帧激光的点数</p>
<p>似然域测量模型比较理想，因此在场景有些变化，和动态人存在干扰的情况，估计的pose精度会下降。放大测量方差或许会有效果，最好要是能引入类似非线性优化中的核函数（损失函数）或许不错。</p>
<ul>
<li>失效恢复的准备</li>
</ul>
<p>把每个粒子添加到临时粒子集中，也就是说<code>set_a</code>内的粒子的权重是不同的，更新粒子集的平均权重。根据alpha_slow和alpha_fast计算短期和长期的似然平均</p>
<ul>
<li>重采样</li>
</ul>
<p>从缓冲的粒子集中替换所有粒子，抽取粒子的概率取决于粒子的权重，更新后的粒子集有很多粒子是重复的，而抛弃了大多数的低权重的粒子。</p>
<p>上面的算法还有两个问题： 1. 粒子重采样的退化问题；2. 固定的粒子群导致无用的计算，影响效率。</p>
<p>具体做法：开始处理每一个粒子，先生成一个(0,1)的随机数rand，如果 <code>rand&lt; w_diff = (1 - w_fast / w_slow)</code>，那么当前粒子的位姿是随机值。如果是 <code>&gt;=</code>，需要从<code>set_a</code>中寻找一个权重比较大的粒子。方法是：c[i]是第<code>1~i</code>个粒子的权重之和，如果第i+1个粒子的权重很大，那么<code>c[i+1] - c[i]</code>很大，i+1就是我们需要的粒子。</p>
<p>把上面找出的所有粒子添加到<code>set_b</code>，<code>set_b</code>的粒子个数是M，多数粒子是原来<code>set_a</code>中权重比较大的粒子，而且可能重复。让<code>set_b</code>中的粒子权重全是<code>1 / M</code></p>
<p>AMCL用到的算法:</p>
<ul>
<li>sample_motion_model_odometry</li>
<li>likelihood_field_range_finder_model</li>
<li>Augmented_MCL</li>
<li>KLD_Sampling_MCL</li>
</ul>
<p>还有一些剩余的内容，比如KD树，KLD采样</p>
<p><br></p>
<p>文件<code>amcl_node.cpp</code>最主要的几个函数是构造函数，handleMapMessage, laserReceived。尤其是最后一个</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p><code>sigintHandler</code>回调函数在关闭程序之前只有一句<code>amcl_node_ptr-&gt;savePoseToServer();</code>，也就是关闭前把最近一次的机器人位姿存入参数服务器，这就可以理解为什么关掉程序后，用<code>rosparam get</code>获得的<code>initial_pose_x</code>等位姿仍然是以前的。</p>
<p><code>amcl</code>根据输入参数来决定运行方式。从代码中可以看到amcl支持数据回放的，运行时只需要通过参数<code>--run-from-bag</code>指定bag文件即可</p>
<p>从main函数可以看出，amcl的所有业务逻辑都是由AmclNode类的构造函数完成</p>
<h2 id="AmclNode构造函数"><a href="#AmclNode构造函数" class="headerlink" title="AmclNode构造函数"></a>AmclNode构造函数</h2><p>通过参数服务器，根据launch文件里的大量参数，对各类变量赋值</p>
<p>成员函数<code>updatePoseFromServer</code>，该函数就是用来从参数服务器上获取机器人的初始位姿和位姿误差的协方差矩阵的。</p>
<p>发布<code>amcl_pose</code>和<code>particlecloud</code>两个主题，分别用于输出机器人位姿估计和粒子集合。</p>
<p>接着注册三个服务：<code>global_localization</code>用于获取机器人的全局定位，<code>request_nomotion_update</code>则用于手动的触发粒子更新并发布新的位姿估计，<code>set_map</code>用于设定机器人位姿和地图信息。 <strong>这几个平时都用不到</strong></p>
<p><br><br>接下来构建激光传感器的消息过滤器对象和tf2的过滤器，并注册回调函数laserReceived。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">laser_scan_sub_ = <span class="keyword">new</span> message_filters::Subscriber&lt;sensor_msgs::LaserScan&gt;(nh_, scan_topic_, <span class="number">100</span>);</span><br><span class="line">laser_scan_filter_ = <span class="keyword">new</span> tf::MessageFilter&lt;sensor_msgs::LaserScan&gt;(</span><br><span class="line">                                  *laser_scan_sub_, </span><br><span class="line">                                  *tf_, </span><br><span class="line">                                  odom_frame_id_, </span><br><span class="line">                                  <span class="number">100</span> );</span><br><span class="line">laser_scan_filter_-&gt;<span class="built_in">registerCallback</span>(boost::<span class="built_in">bind</span>(&amp;AmclNode::laserReceived,</span><br><span class="line">                                                 <span class="keyword">this</span>, _1));</span><br></pre></td></tr></table></figure><br>这里的message_filter为ROS系统提供了一些通用的消息过滤方法， 它对接收到的消息进行缓存，只有当满足过滤条件后才输出，在需要消息同步的时候应用比较多。这里主要是同时监听激光扫描消息和里程计坐标变换，同步两者的输出。 这一套路在GMapping中也有用到。</p>
<p>订阅用于初始化机器人位姿估计的主题<code>initialpose</code></p>
<p>根据运行参数<code>use_map_topic_</code>获取地图，或者订阅地图主题，或者通过<code>requestMap</code>请求<code>static_map</code>服务。因为一般取false，所以后面我们直接看<code>requestMap</code>函数，也就是如下逻辑：<br><img src="https://i.loli.net/2020/03/31/qX4dgajlT58Swix.png" alt=""><br>定义<code>m_force_update</code>为false，后面会用到</p>
<p>最后定义一个计时器用于每隔15s检查一次激光雷达的接收数据，如果期间没有收到新的数据给出告警</p>
<h3 id="requestMap-和-handleMapMessage"><a href="#requestMap-和-handleMapMessage" class="headerlink" title="requestMap 和 handleMapMessage"></a>requestMap 和 handleMapMessage</h3><p><code>requestMap</code>函数请求<code>static_map</code>服务成功后，调用函数<code>handleMapMessage</code>处理接收到的地图数据，进一步完成AmclNode的初始化工作，内容庞大的其实是handleMapMessage</p>
<p><code>handleMapMessage</code>的流程图在<a target="_blank" rel="noopener" href="https://live.staticflickr.com/65535/49379331342_b2dfde6972_b.jpg">这里</a></p>
<p>释放了与地图相关的内存和对象之后，通过函数convertMap将地图消息转换成amcl中的地图数据结构。</p>
<p>接着构建粒子滤波器对象，并完成初始化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建粒子滤波器对象</span></span><br><span class="line">pf_ = <span class="built_in">pf_alloc</span>(min_particles_,</span><br><span class="line">               max_particles_,</span><br><span class="line">               alpha_slow_,</span><br><span class="line">               alpha_fast_,</span><br><span class="line">               (<span class="keyword">pf_init_model_fn_t</span>)AmclNode::uniformPoseGenerator,</span><br><span class="line">               (<span class="keyword">void</span> *)map_ );</span><br><span class="line">pf_-&gt;pop_err = pf_err_;</span><br><span class="line">pf_-&gt;pop_z = pf_z_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从参数服务器获取初始位姿及方差放到pf中</span></span><br><span class="line"><span class="built_in">updatePoseFromServer</span>();</span><br><span class="line"><span class="keyword">pf_vector_t</span> pf_init_pose_mean = <span class="built_in">pf_vector_zero</span>();</span><br><span class="line">pf_init_pose_mean.v[<span class="number">0</span>] = init_pose_[<span class="number">0</span>];   <span class="comment">// initial_pose_x</span></span><br><span class="line">pf_init_pose_mean.v[<span class="number">1</span>] = init_pose_[<span class="number">1</span>];   <span class="comment">// initial_pose_y</span></span><br><span class="line">pf_init_pose_mean.v[<span class="number">2</span>] = init_pose_[<span class="number">2</span>];   <span class="comment">// initial_pose_a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pf_matrix_t</span> pf_init_pose_cov = <span class="built_in">pf_matrix_zero</span>();</span><br><span class="line">pf_init_pose_cov.m[<span class="number">0</span>][<span class="number">0</span>] = init_cov_[<span class="number">0</span>];</span><br><span class="line">pf_init_pose_cov.m[<span class="number">1</span>][<span class="number">1</span>] = init_cov_[<span class="number">1</span>];</span><br><span class="line">pf_init_pose_cov.m[<span class="number">2</span>][<span class="number">2</span>] = init_cov_[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化高斯粒子滤波器</span></span><br><span class="line"><span class="built_in">pf_init</span>(pf_, pf_init_pose_mean, pf_init_pose_cov);</span><br><span class="line">pf_init_ = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><br>这里面有两个重要函数<strong>pf_alloc</strong>和<strong>pf_init</strong></p>
<p>构建里程计对象，根据launch文件里的参数配置里程计模型</p>
<p>构建雷达传感器对象，根据运行参数<code>laser_model_type_</code>构建不同模型的雷达</p>
<p>最后考虑到，在接收到地图数据之前，有可能已经接收到了机器人的初始位姿，这里调用函数applyInitialPose处理</p>
<h3 id="pf-alloc"><a href="#pf-alloc" class="headerlink" title="pf_alloc"></a>pf_alloc</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new filter</span></span><br><span class="line"><span class="function"><span class="keyword">pf_t</span> *<span class="title">pf_alloc</span><span class="params">(<span class="keyword">int</span> min_samples, <span class="keyword">int</span> max_samples,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">double</span> alpha_slow, <span class="keyword">double</span> alpha_fast,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">pf_init_model_fn_t</span> random_pose_fn, <span class="keyword">void</span> *random_pose_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="keyword">pf_t</span> *pf;</span><br><span class="line">  <span class="keyword">pf_sample_set_t</span> *set;</span><br><span class="line">  <span class="keyword">pf_sample_t</span> *sample;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">srand48</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">  pf = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">pf_t</span>));</span><br><span class="line"></span><br><span class="line">  pf-&gt;random_pose_fn = random_pose_fn;</span><br><span class="line">  pf-&gt;random_pose_data = random_pose_data;</span><br><span class="line"></span><br><span class="line">  pf-&gt;min_samples = min_samples;</span><br><span class="line">  pf-&gt;max_samples = max_samples;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Control parameters for the population size calculation.  [err] is</span></span><br><span class="line">  <span class="comment">// the max error between the true distribution and the estimated</span></span><br><span class="line">  <span class="comment">// distribution.  [z] is the upper standard normal quantile for (1 -</span></span><br><span class="line">  <span class="comment">// p), where p is the probability that the error on the estimated</span></span><br><span class="line">  <span class="comment">// distrubition will be less than [err].</span></span><br><span class="line">  pf-&gt;pop_err = <span class="number">0.01</span>;</span><br><span class="line">  pf-&gt;pop_z = <span class="number">3</span>;</span><br><span class="line">  pf-&gt;dist_threshold = <span class="number">0.5</span>; </span><br><span class="line">  pf-&gt;current_set = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">  &#123;</span><br><span class="line">    set = pf-&gt;sets + j;</span><br><span class="line"></span><br><span class="line">    set-&gt;sample_count = max_samples;</span><br><span class="line">    set-&gt;samples = <span class="built_in">calloc</span>(max_samples, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">pf_sample_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; set-&gt;sample_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      sample = set-&gt;samples + i;</span><br><span class="line">      sample-&gt;pose.v[<span class="number">0</span>] = <span class="number">0.0</span>;</span><br><span class="line">      sample-&gt;pose.v[<span class="number">1</span>] = <span class="number">0.0</span>;</span><br><span class="line">      sample-&gt;pose.v[<span class="number">2</span>] = <span class="number">0.0</span>;</span><br><span class="line">      sample-&gt;weight = <span class="number">1.0</span> / max_samples;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">HACK:</span> is 3 times max_samples enough?</span></span><br><span class="line">    set-&gt;kdtree = <span class="built_in">pf_kdtree_alloc</span>(<span class="number">3</span> * max_samples);</span><br><span class="line"></span><br><span class="line">    set-&gt;cluster_count = <span class="number">0</span>;</span><br><span class="line">    set-&gt;cluster_max_count = max_samples;</span><br><span class="line">    set-&gt;clusters = <span class="built_in">calloc</span>(set-&gt;cluster_max_count, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">pf_cluster_t</span>));</span><br><span class="line"></span><br><span class="line">    set-&gt;mean = <span class="built_in">pf_vector_zero</span>();</span><br><span class="line">    set-&gt;cov = <span class="built_in">pf_matrix_zero</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pf-&gt;w_slow = <span class="number">0.0</span>;</span><br><span class="line">  pf-&gt;w_fast = <span class="number">0.0</span>;</span><br><span class="line">  pf-&gt;alpha_slow = alpha_slow;</span><br><span class="line">  pf-&gt;alpha_fast = alpha_fast;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//set converged to 0</span></span><br><span class="line">  <span class="built_in">pf_init_converged</span>(pf);</span><br><span class="line">  <span class="keyword">return</span> pf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pf-init"><a href="#pf-init" class="headerlink" title="pf_init"></a>pf_init</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the filter using a guassian</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pf_init</span><span class="params">(<span class="keyword">pf_t</span> *pf, <span class="keyword">pf_vector_t</span> mean, <span class="keyword">pf_matrix_t</span> cov)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">pf_sample_set_t</span> *set;</span><br><span class="line">  <span class="keyword">pf_sample_t</span> *sample;</span><br><span class="line">  <span class="keyword">pf_pdf_gaussian_t</span> *pdf;</span><br><span class="line">  </span><br><span class="line">  set = pf-&gt;sets + pf-&gt;current_set;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Create the kd tree for adaptive sampling</span></span><br><span class="line">  <span class="built_in">pf_kdtree_clear</span>(set-&gt;kdtree);</span><br><span class="line"></span><br><span class="line">  set-&gt;sample_count = pf-&gt;max_samples;</span><br><span class="line"></span><br><span class="line">  pdf = <span class="built_in">pf_pdf_gaussian_alloc</span>(mean, cov);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Compute the new sample poses</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; set-&gt;sample_count; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    sample = set-&gt;samples + i;</span><br><span class="line">    sample-&gt;weight = <span class="number">1.0</span> / pf-&gt;max_samples;</span><br><span class="line">    sample-&gt;pose = <span class="built_in">pf_pdf_gaussian_sample</span>(pdf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add sample to histogram</span></span><br><span class="line">    <span class="built_in">pf_kdtree_insert</span>(set-&gt;kdtree, sample-&gt;pose, sample-&gt;weight);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pf-&gt;w_slow = pf-&gt;w_fast = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pf_pdf_gaussian_free</span>(pdf);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Re-compute cluster statistics</span></span><br><span class="line">  <span class="built_in">pf_cluster_stats</span>(pf, set); </span><br><span class="line"></span><br><span class="line">  <span class="comment">//set converged to 0</span></span><br><span class="line">  <span class="built_in">pf_init_converged</span>(pf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/33/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><span class="page-number current">34</span><a class="page-number" href="/page/35/">35</a><span class="space">&hellip;</span><a class="page-number" href="/page/52/">52</a><a class="extend next" rel="next" href="/page/35/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/02/18/exLTfbM3uFOq5SV.png)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>