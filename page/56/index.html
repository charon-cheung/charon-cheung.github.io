<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">609</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">52</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2024/11/12/x1aqcwUG3XDiskN.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/24/C++/C++%20%20%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%92%8C%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/">模板类和模板函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/">C++ 模板与STL</a></span><div class="content"><p>定义模板类时，函数声明和实现都必须放在头文件里，否则编译失败，准确地讲，是在链接阶段报错．原因在于编译器虽然也编译了包含模板定义的源码文件，但是该文件仅仅是模板的定义，而并没有真正的实例化出具体的函数来。因此在链接阶段，编译器进行符号查找时，发现源码文件中的符号，在所有二进制文件中都找不到相关的定义，因此就报错了。<br>不过，函数的实现可以放在头文件的类外，不一定必须在类体内．</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gqtcgq/p/7181400.html">C++模板编译模型</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/23/C++/C++%20%20%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%92%8Callocator/">容器类和allocator</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/">C++ 模板与STL</a></span><div class="content"><p>new运算是先分配内存再执行构造函数，delete是先执行析构函数再释放内存。</p>
<p>STL allocator将这些操作做了精密分工：内存配置有<code>alloc::allocate()</code>负责，内存释放由<code>alloc::deallocate()</code>负责； 对象构造由<code>::construct()</code>负责，对象析构由<code>::destroy()</code>负责。</p>
<p>STL采用了两级配置器，当分配的空间大小超过128字节时，会使用第一级空间配置器，直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放；当分配的空间小于128字节时，为减少申请小内存造成的<strong>内存碎片和额外负担</strong>问题，将使用第二级空间配置器，它采用了内存池技术，通过16个<code>free-list</code>来配置和回收内存，free-list对内存的需求量按8的倍数处理，也就是16个free-list分别管理8,16,24……128字节的内存区块。</p>
<p><br></p>
<p>C++所有的标准容器类都接受一个allocator类作为其模板参数；这个参数有一个默认值，比如std::vector<int>是 vector<int,std:: allocator<int> &gt;的简写。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T, class Alloc = alloc&gt;  // 预设使用 alloc 为配置器</span><br><span class="line">class vector &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string s=<span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br></pre></td></tr></table></figure>
<p>结果报错： <font color = orange size= 3>cannot pass non-trivial object of type ‘std::string’ (aka ‘basic_string<char, char_traits<char>, allocator<char> &gt;’) to variadic function; expected type from format string was char* </font></p>
<p>也有可能不报错但是显示不正常，这跟编译器有关。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/22/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%A6%82%E4%BD%95%E8%AE%A9%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%B8%8Emain%E5%87%BD%E6%95%B0%E4%BA%92%E7%9B%B8%E4%BC%A0%E5%80%BC/">如何让回调函数与main函数互相传值</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><h3 id="在main函数中访问回调函数中处理的变量"><a href="#在main函数中访问回调函数中处理的变量" class="headerlink" title="在main函数中访问回调函数中处理的变量"></a>在main函数中访问回调函数中处理的变量</h3><p>做法是让类的成员函数做回调函数，在回调函数中处理相应变量，在main函数中实例化类，然后通过返回对象的成员进行访问<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Listener</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> theta1f;</span><br><span class="line">    <span class="keyword">double</span> theta2f;</span><br><span class="line">    <span class="keyword">double</span> theta3f;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> std_msgs::Float32MultiArray::ConstPtr&amp; msg)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Listener::callback</span><span class="params">(<span class="keyword">const</span> std_msgs::Float32MultiArray::ConstPtr&amp; msg)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    theta1f = msg-&gt;data[<span class="number">0</span>];</span><br><span class="line">    theta2f = msg-&gt;data[<span class="number">1</span>];</span><br><span class="line">    theta3f = msg-&gt;data[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;node&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">    Listener listener;</span><br><span class="line">    ros::Subscriber sub = nh.subscribe&lt;std_msgs::float32multiarray&gt;(<span class="string">&quot;topic_subscribed&quot;</span>, <span class="number">1</span>, &amp;Listener::callback, &amp;listener);</span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;This is theta1f: %.2f&quot;</span>, listener.theta1f);</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;This is theta2f: %.2f&quot;</span>, listener.theta2f);</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;This is theta2f: %.2f&quot;</span>, listener.theta2f);</span><br><span class="line">        loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br></p>
<h3 id="回调函数中访问main函数中的变量赋值"><a href="#回调函数中访问main函数中的变量赋值" class="headerlink" title="回调函数中访问main函数中的变量赋值"></a>回调函数中访问main函数中的变量赋值</h3><p>以前我都是用全局变量来实现，但这种方法总感觉不保险，后来发现ROS中有专门的解决方法，<code>NodeHandle::subscribe</code>有一个重载可以处理这种情况，用到了<code>boost::bind</code>，其实用<code>std::bind</code>也能实现。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;std_msgs/Int8.h&gt;</span></span></span><br><span class="line"><span class="comment">//回调函数里访问main中的一个结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span>        m;</span><br><span class="line">  <span class="keyword">double</span>     n;</span><br><span class="line">&#125; myStruct;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> std_msgs::Int8ConstPtr&amp; msg, myStruct p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;msg: %d&quot;</span>, msg-&gt;data);</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;m: %d&quot;</span>,p.m);</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;n: %f&quot;</span>,p.n);</span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc,argv, <span class="string">&quot;Sub&quot;</span>);</span><br><span class="line">  ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">  myStruct p;</span><br><span class="line">  p.m = <span class="number">7</span>;</span><br><span class="line">  p.n = <span class="number">1.85</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &quot;_1&quot; 是占位符，对应 void callback(const std_msgs::Int8ConstPtr&amp; msg, myStruct p)第一个参数</span></span><br><span class="line">  <span class="comment">/*  subscribe (</span></span><br><span class="line"><span class="comment">   * const std::string &amp;base_topic,</span></span><br><span class="line"><span class="comment">   * uint32_t queue_size,</span></span><br><span class="line"><span class="comment">   * const boost::function&lt; void(const std_msgs::Int8ConstPtr &amp;)&gt;   &amp;callback  )</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ros::Subscriber sub = nh.subscribe&lt;std_msgs::Int8&gt;(<span class="string">&quot;topic&quot;</span>, <span class="number">20</span>, boost::<span class="built_in">bind</span>(&amp;callback, _1, p) );</span><br><span class="line">  ros::<span class="built_in">spin</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>myStruct</code>是我自定义的结构体，在main函数里对其声明的变量赋值，回调的形参里多了它的变量。<br>其中subscribe函数的原型是这个：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">M</span> &gt;</span></span><br><span class="line">Subscriber ros::NodeHandle::<span class="built_in">subscribe</span>(<span class="keyword">const</span> std::string&amp; topic,</span><br><span class="line">	<span class="keyword">uint32_t</span>  	queue_size,</span><br><span class="line">	<span class="keyword">const</span> boost::function&lt; <span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> boost::shared_ptr&lt; M <span class="keyword">const</span> &gt; &amp;)&gt; &amp;  	callback,</span><br><span class="line">	<span class="keyword">const</span> VoidConstPtr &amp;  	tracked_object = <span class="built_in">VoidConstPtr</span>(),</span><br><span class="line">	<span class="keyword">const</span> TransportHints &amp;  	transport_hints = <span class="built_in">TransportHints</span>() </span><br><span class="line">) 	</span><br></pre></td></tr></table></figure><br><code>boost::function</code>对象能接受函数和仿函数， <code>boost::bind</code>创建了仿函数，包含了所有想传给回调函数的参数。</p>
<p>与平时的重载形式不同，这次要用到话题的模板类型，第三个形参不是回调函数的指针，而是<code>boost::bind</code>，其中<code>_1</code>是一个占位符，要传给回调函数参数，在发生函数调用时才接受实参；最后是结构体的变量。</p>
<p><strong>注意</strong>：回调函数第一个形参必须是<code>const std_msgs::Int8ConstPtr&amp;</code>形式，其他形式比如<code>const std_msgs::Int8Ptr&amp;</code>会报错，另外看到一篇博客说这里不能用引用，但是我用引用也没报错。对于回调函数<code>callback</code>，一般在bind里不用<code>&amp;</code>，但是用了也可以，因为bind可接受函数或函数指针</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://answers.ros.org/question/63991/how-to-make-callback-function-called-by-several-subscriber/?answer=63998#post-id-63998">How to make callback function called by several subscriber?</a><br><a target="_blank" rel="noopener" href="https://answers.ros.org/question/11810/how-to-pass-arguments-tofrom-subscriber-callback-functions/">How to pass arguments to/from subscriber callback functions</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/20/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E4%BD%BF%E7%94%A8ROS%20Service(%E4%BA%8C)/">使用ROS Service(二) 代码演示</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><h2 id="程序演示"><a href="#程序演示" class="headerlink" title="程序演示"></a>程序演示</h2><p>下面是我写的一个服务程序，服务文件<code>ctrl.srv</code>的构成为：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int8 cmd</span><br><span class="line">---</span><br><span class="line">bool ret</span><br></pre></td></tr></table></figure><br>客户端发出命令，如果cmd！=0，服务端会打开摄像头程序；如果cmd=0，服务端会关闭摄像头程序。</p>
<p><strong>注意</strong>：最好是将所有自定义的服务和消息文件放到一个单独的package里面，否则会出现一个package的修改会影响到另一个用到它的消息/服务的package的编译．</p>
<p><strong>新建srv文件后，容易忘记在CMakeLists里添加这个文件，导致编译失败</strong></p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;riki_msgs/ctrl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">control</span><span class="params">(riki_msgs::ctrl::Request &amp;req, riki_msgs::ctrl::Response &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.cmd==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;shutting down camera&quot;</span>);</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;rosnode kill /usb_cam&quot;</span>);</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;close camera done&quot;</span>);</span><br><span class="line">        res.ret = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;starting camera&quot;</span>);</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;roslaunch usb_cam usb_cam.launch &amp; &quot;</span>);</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;camera is up&quot;</span>);</span><br><span class="line">        res.ret = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;camServer&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    ros::ServiceServer server = nh.<span class="built_in">advertiseService</span>(<span class="string">&quot;control_cam&quot;</span>,control);</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;------ waiting for client&#x27;s request ------&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出服务端的程序与话题中的订阅者程序高度相似，<code>control</code>函数就是个回调函数。</p>
<p><code>system</code>函数调用<code>roslaunch</code>时，由于是在fork出的子进程里执行，launch的节点会一直阻塞不返回，在命令最后加&amp;，让子进程返回</p>
<p>service回调函数里只能<code>return true</code>或<code>false</code>，若return整数会导致客户端的<code>call</code>结果为false，但实际成功，这样会影响判断。</p>
<p>service客户端发命令后，出现报错 <font size=3 color = orange> ERROR: service [/service_name] responded with an error: b’’ </font>，原因在于service服务端的回调函数必须 <code>return true</code></p>
<p><br></p>
<p><code>advertiseService</code>的部分源码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ServiceManager::advertiseService</span><span class="params">(<span class="keyword">const</span> AdvertiseServiceOptions&amp; ops)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   boost::<span class="function">recursive_mutex::scoped_lock <span class="title">shutdown_lock</span><span class="params">(shutting_down_mutex_)</span></span>;</span><br><span class="line">   <span class="keyword">if</span> (shutting_down_)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   &#123;</span><br><span class="line">     boost::<span class="function">mutex::scoped_lock <span class="title">lock</span><span class="params">(service_publications_mutex_)</span></span>;</span><br><span class="line">     <span class="comment">// 如果service已经发布，就报错，然后返回，其实这里改成报警比较合适</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">isServiceAdvertised</span>(ops.service))</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Tried to advertise a service that is already advertised in this node [%s]&quot;</span>, ops.service.<span class="built_in">c_str</span>());</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果涉及到耗时的工作，回调函数应该这样写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">serviceCB</span><span class="params">(mow_msgs::task::Request &amp;req, mow_msgs::task::Response &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  res.ret = <span class="string">&quot;to charge&quot;</span>;</span><br><span class="line">  <span class="comment">// 耗时的工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果把耗时的工作放在<code>res</code>之前，那么客户端提前退出时(比如<code>ctrl+C</code>)，会报错没有收到返回值，虽然不影响，但是不优雅。</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;riki_msgs/ctrl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;controlCam&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;client need command&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    ros::ServiceClient client = nh.serviceClient&lt;riki_msgs::ctrl&gt;(<span class="string">&quot;control_cam&quot;</span>);</span><br><span class="line">    riki_msgs::ctrl srv;</span><br><span class="line">    srv.request.cmd = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(client.<span class="built_in">exists</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;service control_cam is up&quot;</span>);</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;service name:%s&quot;</span>,client.<span class="built_in">getService</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;service control_cam is not available&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(client.<span class="built_in">call</span>(srv))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;client calling srv !&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(srv.request.cmd&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Sending command start!&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Sending command stop!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;client calls srv failed !&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用成功以后才能获取response</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;服务端的返回值: &quot;</span>&lt;&lt;srv.response.ret&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>构建client的时候后面的路径要写绝对路径，有时候需要加个 /</strong></p>
<p>客户端的程序与话题发布者的程序高度相似，<code>exists()</code>检查服务端的服务是否启动，若未启动则返回。<code>call</code>调用了服务，成功会返回<code>true</code>，<strong>而且调用完成后，可以在客户端程序里获得服务端的返回值</strong></p>
<p>最后，先运行服务端，然后运行客户端，如果是<code>rosrun control_cam controlCam 1</code>则在服务端所在终端启动摄像头程序，若是0则关闭。</p>
<h2 id="另一种使用方式"><a href="#另一种使用方式" class="headerlink" title="另一种使用方式"></a>另一种使用方式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std_srvs::Empty srv;</span><br><span class="line">ros::service::<span class="built_in">call</span>(<span class="string">&quot;/move_base_node/clear_costmaps&quot;</span>, srv);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!ros::service::<span class="built_in">call</span>(<span class="string">&quot;static_map&quot;</span>, req, resp))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ROS_WARN</span>(<span class="string">&quot;Request for map failed; trying again...&quot;</span>);</span><br><span class="line">    <span class="function">ros::Duration <span class="title">d</span><span class="params">(<span class="number">0.5</span>)</span></span>;</span><br><span class="line">    d.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p><code>ros::ServiceClient</code>常用函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">call</span> <span class="params">(Service &amp;service)</span>  <span class="comment">//调用service，client发起通信。成功返回true</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exists</span> <span class="params">()</span>  <span class="comment">//检查相应名称的服务是否可用</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">std::string <span class="title">getService</span> <span class="params">()</span>  <span class="comment">//返回客户端通信的服务名称</span></span></span><br><span class="line"><span class="function"><span class="comment">// 单例模式</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> ServiceManagerPtr &amp;  <span class="title">instance</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span>    <span class="title">unadvertiseService</span> <span class="params">(<span class="keyword">const</span> std::string &amp;serv_name)</span></span></span><br></pre></td></tr></table></figure><br>如果要解除service，用法是<code>ros::ServiceManager::instance()::unadvertiseService</code>，也就是使用单例模式进行全局访问。 API说<code>isServiceAdvertised</code>可以判断某service是否发布，但可惜是private</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><br></p>
<p>切换算法时，会有个报警 <code>Tried to advertise a service that is already advertised in this node</code>。这个其实无任何影响，报警在ROS底层的源码，原因在于<code>GlobalPlanner::initialize</code>函数有一句:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make_plan_srv_ = private_nh.<span class="built_in">advertiseService</span>(<span class="string">&quot;make_plan&quot;</span>, &amp;GlobalPlanner::makePlanService, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><br>这里是已经注册了service，如果想要去掉这个报警，可以这样改:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string makePlanServiceName = <span class="string">&quot;/move_base/&quot;</span>+name+<span class="string">&quot;/make_plan&quot;</span>;</span><br><span class="line"></span><br><span class="line">ros::ServiceManager::<span class="built_in">instance</span>()-&gt;<span class="built_in">unadvertiseService</span>(makePlanServiceName);</span><br><span class="line">make_plan_srv_ = private_nh.<span class="built_in">advertiseService</span>(<span class="string">&quot;make_plan&quot;</span>, &amp;GlobalPlanner::makePlanService, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><br>其中的<code>bool ros::ServiceManager::unadvertiseService(const std::string&amp;  serv_name)</code>作用是 Unadvertise a service. This call unadvertises a service, <font size=3 color = blue> which must have been previously advertised, using advertiseService().  </font></p>
<h3 id="md5不匹配"><a href="#md5不匹配" class="headerlink" title="md5不匹配"></a>md5不匹配</h3><p>调用service时报错<code>md5不匹配</code>，其实是调用失败了，<code>call</code>的返回值是false，首先应检查客户端定义是否正确和服务是否存在:<br><img src="https://i.loli.net/2019/10/17/lj4rBwSn16LT2CP.png" alt=""></p>
<h3 id="客户端一直阻塞"><a href="#客户端一直阻塞" class="headerlink" title="客户端一直阻塞"></a>客户端一直阻塞</h3><p>我在<code>move_base.cpp</code>里写了一个函数 func，是rosservice的客户端，调用service <code>clear_costmaps</code>。在<code>MoveBase</code>的其他函数里，调用这个函数，结果发现会一直阻塞。后来注意到服务端程序就是<code>MoveBase::clearCostmapsService</code>，也就是在<strong>同一个类里</strong></p>
<p>客户端call service阻塞的原因只有两个：</p>
<ol>
<li>多个客户端call 同一个service，而服务端一次只能处理一个请求</li>
<li>服务端程序没有return值</li>
</ol>
<p>服务端程序是<code>MoveBase</code>的，而且有了返回值，那么只可能是第一个原因了。 </p>
<p>参考：<a target="_blank" rel="noopener" href="https://answers.ros.org/question/156721/blocking-service-callbacks/">blocking service callbacks</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/14/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/VMWare%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">VMWare常见问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/">常用工具</a></span><div class="content"><h3 id="无法进入图形界面"><a href="#无法进入图形界面" class="headerlink" title="无法进入图形界面"></a>无法进入图形界面</h3><p>![<a target="_blank" rel="noopener" href="https://live.staticflickr.com/7870/46689319155_bc1d198671_z.jpg">https://live.staticflickr.com/7870/46689319155_bc1d198671_z.jpg</a>]<br>![<a target="_blank" rel="noopener" href="https://live.staticflickr.com/7892/33727819068_7e69d575f5.jpg">https://live.staticflickr.com/7892/33727819068_7e69d575f5.jpg</a>]</p>
<p>1.Ctrl+ALt+F1（<code>F1~F5</code>都可以）进入控制台</p>
<p>2.输入用户名和密码进入系统；</p>
<p>3.依次输入以下命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/X11</span><br><span class="line"></span><br><span class="line">sudo cp xorg.conf.failsafe xorg.conf</span><br><span class="line"></span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure></p>
<h3 id="开机启动VMWare并启动指定系统"><a href="#开机启动VMWare并启动指定系统" class="headerlink" title="开机启动VMWare并启动指定系统"></a>开机启动VMWare并启动指定系统</h3><p>将VMWare的快捷方式放到<code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</code>，然后打开快捷方式，修改<code>目标</code>：<br><img src="https://live.staticflickr.com/7880/33727818958_a96131d6f7.jpg" alt=""></p>
<p>改成<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;....exe&quot;  -x  &quot;/path_to_system/Ubuntu 64.vmx&quot;</span><br></pre></td></tr></table></figure><br>其中x是小写，后面加vmx文件的路径，而且加双引号</p>
<h3 id="如何让虚拟机网段与主机相同"><a href="#如何让虚拟机网段与主机相同" class="headerlink" title="如何让虚拟机网段与主机相同"></a>如何让虚拟机网段与主机相同</h3><p>先用管理员身份打开VMWare，再打开<code>编辑-虚拟网络编辑器</code>，将网络做如图设置：桥接模式，并选择网卡为主机真实网卡。这样进入虚拟机后，IP就同主机了，设置成DHCP即可。<br><img src="https://live.staticflickr.com/7866/46889495164_d09d2df43e_b.jpg" alt=""></p>
<h3 id="无法打开虚拟机，提示要获得所有权，但还是失败"><a href="#无法打开虚拟机，提示要获得所有权，但还是失败" class="headerlink" title="无法打开虚拟机，提示要获得所有权，但还是失败"></a>无法打开虚拟机，提示要获得所有权，但还是失败</h3><p>很简单，删除虚拟机文件夹下的lck文件夹即可，映像被lck锁定了。应当是上次没有正常关闭虚拟机导致的</p>
<h3 id="硬盘空间太少"><a href="#硬盘空间太少" class="headerlink" title="硬盘空间太少"></a>硬盘空间太少</h3><p>向虚拟机复制文件就是先在cache文件夹里面生成一个同样的文件，并使用拷贝的方式将其拷贝到拖拽放置的目录中。因此，如果不进行清理的话，cache文件夹中产生的文件，并不会自动删除或者释放。</p>
<p>该文件夹位于用户目录下<code>/home/xxxx/.cache/vmware/drag_and_drop</code>进入文件夹，可以见到每一次拖拽产生的文件，都在子文件夹中有一份。直接删除便可以腾出海量的空间。</p>
<h2 id="vmware-tool安装后仍然不能复制的问题"><a href="#vmware-tool安装后仍然不能复制的问题" class="headerlink" title="vmware tool安装后仍然不能复制的问题"></a>vmware tool安装后仍然不能复制的问题</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo  mkdir /mnt/cdrom </span><br><span class="line">sudo apt-get install open-vm-tools-desktop -y</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<h2 id="VM虚拟机增加磁盘空间"><a href="#VM虚拟机增加磁盘空间" class="headerlink" title="VM虚拟机增加磁盘空间"></a>VM虚拟机增加磁盘空间</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liwenchaoCode/p/10421381.html">VM虚拟机增加磁盘空间</a></p>
<h2 id="VMWare-分辨率设置"><a href="#VMWare-分辨率设置" class="headerlink" title="VMWare 分辨率设置"></a>VMWare 分辨率设置</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuchangyin/article/details/104181864">参考链接</a></p>
<p><img src="https://s2.loli.net/2024/05/11/9fx3yWiCPdMu17n.png" alt="VMware连接USB设备，即使连接到了主机，也可切换到虚拟机"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/23/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/">ROS机器人的开发心得体会</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/">ROS机器人</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2019/03/23/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/20/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E4%BD%BF%E7%94%A8ROS%20Service(%E4%B8%80)%20%E6%9C%8D%E5%8A%A1%E5%92%8C%E8%AF%9D%E9%A2%98%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/">使用ROS Service(一) 服务和话题的区别，基本命令</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><h3 id="服务和话题"><a href="#服务和话题" class="headerlink" title="服务和话题"></a>服务和话题</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">特点</th>
<th style="text-align:center">Topic</th>
<th style="text-align:center">Service</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">通信方式</td>
<td style="text-align:center">异步通信</td>
<td style="text-align:center">同步通信</td>
</tr>
<tr>
<td style="text-align:center">通信模型</td>
<td style="text-align:center">Publish-Subscribe</td>
<td style="text-align:center">Request-Reply</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">多对多</td>
<td style="text-align:center">多对一</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">接收者接到数据会回调</td>
<td style="text-align:center">远程过程调用(RPC)服务器端的服务</td>
</tr>
<tr>
<td style="text-align:center">应用场景</td>
<td style="text-align:center">连续，高频的数据发布</td>
<td style="text-align:center">偶尔调用的功能</td>
</tr>
<tr>
<td style="text-align:center">举例</td>
<td style="text-align:center">激光雷达</td>
<td style="text-align:center">开关传感器，拍照，逆解计算</td>
</tr>
</tbody>
</table>
</div>
<font size="4" color="blue"> 由于是同步通信，service 的回调不能写复杂的、耗时长的业务  </font>

<h3 id="rosservice-call"><a href="#rosservice-call" class="headerlink" title="rosservice  call"></a>rosservice  call</h3><p><code>rosservice call addTwoNum 3 4</code>: 调用服务，<code>addTwoNum</code>是服务名称，<font color = blue size= 3> 名称不加引号</font>，3和4是服务中的req变量的值，注意必须按服务文件中的顺序赋值。</p>
<p>但上面是简单情况，srv文件稍微有点复杂时，就会怎么填也不对，个人认为这是ROS Service很失败的一个地方。<br>例如srv文件的请求部分是这样的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string request_string</span><br><span class="line">string album</span><br></pre></td></tr></table></figure><br>我试了很多种组合，都不正确。其实这种情况也好办，在<code>call srvname</code>之后直接Tab，会给出一个模板：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosservice call service_name &quot;request_string: &#x27;&#x27;</span><br><span class="line">album: &#x27;&#x27;&quot;</span><br></pre></td></tr></table></figure><br>我们要做的就是把内容填到单引号里面，不要再自己修改模板，否则容易出错。</p>
<p><code>call</code>执行成功时，终端不会有任何结果。但是经常出现这样的错误：<font color = orange size= 3> ERROR: service [/control_cam] responded with an error:  </font>，但程序执行没有问题。原因是 <font color = blue size=4>程序中对srv文件中的应答没有处理 </font></p>
<p>其他常用命令：</p>
<ul>
<li>rosservice list: 显示当前所有活动的服务</li>
<li>rosservice info addTwoNum: 显示服务的信息</li>
<li>rosservice type addTwoNum: 显示服务的变量类型</li>
</ul>
<p>其实服务的相关命令和话题的很类似</p>
<h3 id="ROS的服务类型"><a href="#ROS的服务类型" class="headerlink" title="ROS的服务类型"></a>ROS的服务类型</h3><p>启动乌龟节点时，有一个服务叫<code>clear</code>，类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rosservice type clear</span><br><span class="line"></span><br><span class="line">std_srvs/Empty</span><br></pre></td></tr></table></figure><br>看源码可知，服务的类型为空,这表明调用这个服务不需要参数（比如，请求不需要发送数据，响应也没有数据）．调用后，服务清除了turtlesim_node的背景上的轨迹，没有响应．</p>
<p><code>std_srvs</code>包还有两个服务：<code>std_srvs/Trigger</code>和<code>std_srvs/SetBool</code>，但是很不常用</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/11/%E8%84%9A%E6%9C%AC/locate%E5%92%8Cfind/">locate和find</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%84%9A%E6%9C%AC/">脚本</a></span><div class="content"><ul>
<li><p><code>locate</code>的速度比<code>find</code>快，因为它并不是真的查找文件，而是查数据库。</p>
</li>
<li><p>新建的文件，我们立即用<code>locate</code>命令去查找，一般是找不到的，因为数据库的更新不是实时的，而是每天</p>
</li>
<li><code>locate</code>命令所搜索的后台数据库在<code>/var/lib/mlocate</code>这个目录下，可能有些Linux系统位置不同，具体我们可以用<code>locate locate</code>查询</li>
<li><p>并不是所有的目录下的文件都会用<code>locate</code>命令搜索到，<code>/etc/updatedb.conf</code>这个配置文件中，配置了一些<code>locate</code>命令的一些规则。</p>
</li>
<li><p><code>updatedb</code>会大致每天运行，这是靠系统的crontab命令实现的</p>
</li>
<li><code>updatedb -U</code>：更新指定目录相关的数据库信息。默认是整个系统，耗时比较长，因此可以使用该参数，比如<code>sudo updatedb -U /home/user/</code></li>
</ul>
<p><code>updatedb</code>的配置文件 <code>/etc/updatedb.conf</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/updatedb.conf </span><br><span class="line">PRUNE_BIND_MOUNTS = <span class="string">&quot;yes&quot;</span></span><br><span class="line">PRUNEFS = <span class="string">&quot;9p afs anon_inodefs auto autofs bdev binfmt_misc cgroup cifs coda configfs cpuset debugfs devpts ecryptfs exofs fuse fuse.sshfs fusectl gfs gfs2 gpfs hugetlbfs inotifyfs iso9660 jffs2 lustre mqueue ncpfs nfs nfs4 nfsd pipefs proc ramfs rootfs rpc_pipefs securityfs selinuxfs sfs sockfs sysfs tmpfs ubifs udf usbfs fuse.glusterfs ceph fuse.ceph&quot;</span></span><br><span class="line">PRUNENAMES = <span class="string">&quot;.git .hg .svn&quot;</span></span><br><span class="line">PRUNEPATHS = <span class="string">&quot;/afs /media /mnt /net /sfs /tmp /udev /var/cache/ccache /var/lib/yum/yumdb /var/spool/cups /var/spool/squid /var/tmp /var/lib/ceph&quot;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>PRUNENAMES</code>   搜索时不搜索的文件类型</li>
<li><code>PRUNEPATHS</code>   搜索时不搜索的路径</li>
<li><code>PRUNE_BIND_MOUNTS = &quot;yes&quot;</code>    开启搜索限制</li>
<li><code>PRUNEFS</code>    搜索时不搜索的文件系统</li>
</ul>
<h2 id="locate-常用命令"><a href="#locate-常用命令" class="headerlink" title="locate 常用命令"></a>locate 常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">locate -c   <span class="comment"># 查询指定文件的数目。(c为count的意思)</span></span><br><span class="line">locate -e   <span class="comment"># 只显示当前存在的文件条目。(e为existing的意思)</span></span><br><span class="line">locate -i   <span class="comment"># 查找时忽略大小写区别</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正则表达式查找文件</span></span><br><span class="line">locate -r makefile$		<span class="comment"># 以makefile结尾的文件</span></span><br><span class="line">locate -r ^/home/user/		<span class="comment"># 以/home/user/开头的文件		</span></span><br></pre></td></tr></table></figure>
<p>从结果中取出词尾是<code>config2</code>的<br><img src="https://i.loli.net/2020/04/21/9EkIqjKB1Y86yXP.png" alt=""></p>
<p>注意：locate的结果可能是不存在的文件，这时最好用<code>locate -e</code></p>
<p>locate 查找文件<code>tree.xml</code>，也就是知道完整的文件名时，那么最好用 <code>locate  /tree.xml</code>，如果不加<code>/</code>，会显示<code>test_tree.xml</code>的结果</p>
<h2 id="find-常用命令"><a href="#find-常用命令" class="headerlink" title="find 常用命令"></a>find 常用命令</h2><p>查找当前目录中(包括子目录)所有扩展名为cfg的文件:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 或者 &#x27;*.cfg&#x27;</span></span><br><span class="line">find -name *.cfg</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><code>find . -name &#39;*.cpp&#39; -mmin -30</code>       当前目录下，最近30分钟修改的cpp文件</p>
</li>
<li><p><code>find . -name &#39;*.cpp&#39; -mtime 0</code>        当前目录下，最近24小时修改的cpp文件 </p>
</li>
<li><p><code>find . -type f -mtime 0</code>              当前目录下，最近24小时修改的常规文件</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/02/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E4%B9%8C%E9%BE%9F%E8%BF%BD%E4%B9%8C%E9%BE%9F%E7%A8%8B%E5%BA%8F/">深入解析乌龟追乌龟程序</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><p>ROS启动乌龟追乌龟程序用的是<code>roslaunch turtle_tf turtle_tf_demo.launch</code>，其内容如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sim&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtle_teleop_key&quot;</span> <span class="attr">name</span>=<span class="string">&quot;teleop&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Axes --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;scale_linear&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;double&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;scale_angular&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;double&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 针对两个乌龟的tf广播 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;turtle1_tf_broadcaster&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;turtle_tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtle_tf_broadcaster.py&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;false&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;turtle&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">value</span>=<span class="string">&quot;turtle1&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;turtle2_tf_broadcaster&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;turtle_tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtle_tf_broadcaster.py&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;false&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;turtle&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">value</span>=<span class="string">&quot;turtle2&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;turtle_pointer&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;turtle_tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtle_tf_listener.py&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;false&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>乌龟的程序,按下方向键,乌龟只走一段距离,是在cmd_vel的回调函数里更新乌龟的位置,取决于发布的twist消息和更新间隔dt,由Qt实现</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/02/26/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/tf(%E4%B8%80)/">tf(一) 概念和基本使用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-02-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><p>tf包处理的是任一个点在所有坐标系之间的坐标变换问题，它把各种转换关系建立在一个树结构上，树的每个节点是坐标系，每个坐标系可以有多个child，但只能有一个parent，转换只能是<strong>从parent向child</strong>。比如Tb-a表示坐标系a向b转换，也就是说a是parent，b是child，这个变换描述的就是child坐标系中的点在parent坐标系下的姿态。要实现这个变换，就是用child坐标系在parent坐标系下的描述（一个矩阵）去描述（乘以）这个点在child坐标系下的描述（坐标）。world参考系是tf树最顶端的父参考系</p>
<p>如果打算用tf解决你的坐标变换问题，请一定要先清晰的画出这棵树的结构，再开始写程序。比较重要的类是<code>tf::TransformBroadcaster</code>, <code>tf::TransformListener</code>, <code>tf::Transform</code>, <code>tf::StampedTransform</code></p>
<p>在tf的运行机制中，由于tf会把监听到的内容放到一个缓存中。我们通过<code>transformPose</code>获取变换关系，是通过查询这个缓存来实现的。获取的数据不能保证实时性，会有一定的延迟。也有可能无法获得，因此这个函数在运行过程中会抛出异常，所以这里使用try-catch语句捕获这个异常并返回。</p>
<h2 id="tf-TransformBroadcaster类"><a href="#tf-TransformBroadcaster类" class="headerlink" title="tf::TransformBroadcaster类"></a>tf::TransformBroadcaster类</h2><p><code>sendtransform</code>接口可以建立tf树，发布一个从已有的父坐标系到新的子坐标系的变换时，这棵树就会添加一个树枝，之后就是维护。TransformBroadcaster类就是一个publisher, 如果两个frame之间发生了相对运动，TransformBroadcaster类就会发布<code>TransformStamped</code>消息到tf话题，当多个节点向tf话题发消息时，就形成了tf树。</p>
<h2 id="tf-Transform"><a href="#tf-Transform" class="headerlink" title="tf::Transform"></a>tf::Transform</h2><p>建立坐标系之间的位移和旋转的关系，最后用于sendTransform函数。</p>
<p>它是一个坐标转换。成员有：<code>Matrix3x3  m_basis</code>，用<code>3*3</code>的矩阵表示旋转； <code>Vector3 m_origin</code>，用<code>3*1</code>的向量表示平移。</p>
<p>tf::Transform支持乘法运算符，实际的计算是先把旋转矩阵和平移量组合为<strong>变换矩阵</strong>，变换矩阵相乘后，再转换为<code>tf::Transform</code>类型</p>
<p><code>tf::Transform</code>类的重要函数如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matrix3x3 &amp;   <span class="title">getBasis</span> <span class="params">()</span>    <span class="comment">//Return the basis matrix for the rotation</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Vector3 &amp; <span class="title">getOrigin</span> <span class="params">()</span>  <span class="comment">//Return the origin vector translation</span></span></span><br><span class="line"><span class="function">Quaternion  <span class="title">getRotation</span> <span class="params">()</span>  <span class="comment">//Return a quaternion representing the rotation</span></span></span><br><span class="line"><span class="function">Transform   <span class="keyword">operator</span>* <span class="params">(<span class="keyword">const</span> Transform &amp;t)</span> <span class="keyword">const</span>  <span class="comment">//Return the product of this transform and the other.</span></span></span><br><span class="line"><span class="function">Transform   <span class="title">inverse</span> <span class="params">()</span>    <span class="comment">//Return the inverse of this transform</span></span></span><br></pre></td></tr></table></figure><br><code>inverse()</code>函数很有用，我们可以把上面程序中的<code>transform.getOrigin().x()</code>改成<code>transform.inverse().getOrigin().x()</code>就可以求出乌龟1在乌龟2坐标系中的坐标了。</p>
<p><code>tf::StampedTransform</code>类继承自<code>tf::Transform</code>，它多了两个重要变量就是<code>child_frame_id_</code>和<code>frame_id_</code>。</p>
<h2 id="tf-TransformListener"><a href="#tf-TransformListener" class="headerlink" title="tf::TransformListener"></a>tf::TransformListener</h2><p>监听一个父坐标系到子坐标系的变换，<code>waitForTransform</code>是监听转换关系，可以指定监听的时间或一直阻塞；<code>lookupTransform</code>紧随其后，获取 <code>tf::Transform</code></p>
<p>使用前需要<code>#include &lt;tf/transform_listener.h&gt;</code></p>
<p><code>TransformListener</code>构造函数有两个，常用的是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TransformListener::<span class="built_in">TransformListener</span>(</span><br><span class="line">    ros::Duration max_cache_time = ros::<span class="built_in">Duration</span>(DEFAULT_CACHE_TIME),  </span><br><span class="line">    <span class="keyword">bool</span> spin_thread = <span class="literal">true</span> </span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>平时用的是无参构造函数，其实是默认构造函数，如果指定缓存时间，就用<code>tf::TransformListener  tf_(ros::Duration(15) );</code>，<code>Costmap2DROS</code>中使用的tf缓存，根源是<code>move_base_node.cpp</code>中的<code>tf::TransformListener tf(ros::Duration(10) );</code></p>
<p>参考我写的程序<code>test_costmap</code>。开始，如果没有<code>map</code>—-&gt;<code>base_link</code>的TF转换，则报错<code>No Transform available Error</code>。此时发布TF变换，则不再报错。然后再关闭TF变换，<code>test_costmap</code>还能正常运行10s，然后报错 <code>Extrapolation Error</code></p>
<h3 id="transformPose"><a href="#transformPose" class="headerlink" title="transformPose"></a>transformPose</h3><p>原型是<code>void transformPose(const std::string &amp;target_frame, const geometry_msgs::PoseStamped &amp;stamped_in, geometry_msgs::PoseStamped &amp;stamped_out) const</code>，</p>
<p>target_frame就是你要把源pose转换成哪个frame上的pose。假如你的源pose的frame_id是”odom”，你想转到”map”上，那么target_frame写成“map”就可以了。stamped_in就是源pose，而stamped_out就是目标数据了，也就是转换完成的数据。需要注意的是，从参数上来看，转换时是不需要指定源frame_id的，这是因为它已经包含在了stamped_in中，换句话说，就是这个函数一个隐含的使用条件是，<strong>stamped_in中必须指明源pose属于哪个frame</strong></p>
<p>把odom坐标系的数据转换到map坐标系下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs::PoseStamped pose_odom;</span><br><span class="line">pose_odom.header = odom-&gt;header;</span><br><span class="line">pose_odom.pose = odom-&gt;pose.pose;</span><br><span class="line"></span><br><span class="line">geometry_msgs::PoseStamped pose_map;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    listener.<span class="built_in">transformPose</span>(<span class="string">&quot;map&quot;</span>, pose_odom, pose_map);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>( tf::TransformException ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ROS_WARN</span>(<span class="string">&quot;transfrom exception : %s&quot;</span>,ex.<span class="built_in">what</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有时会出现这样的报错： <font color = orange size=4> transfrom exception : “map” passed to lookupTransform argument target_frame does not exist </font>，但是使用<code>tf_echo</code>发现是正常的。需要检查代码是不是在回调函数里运行了， 不需要在回调函数里创建<code>TransformListener</code>对象， 将它作为类成员变量或者全局变量。 </p>
<p>全局变量是在main函数之前完成构造函数的，如果用到的类构造函数用到NodeHandle，就会报错。比如<code>tf::TransformListener</code>，解决方法是用全局指针，比如<code>boost::shared_ptr&lt;T&gt;</code>，然后在main函数的ros::init()之后指向一个对象。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://answers.ros.org/question/192570/tftransformlistenertransformpose-exception-target_frame-does-not-exist/">tf::TransformListener::transformPose [exception] target_frame does not exist</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/55/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/55/">55</a><span class="page-number current">56</span><a class="page-number" href="/page/57/">57</a><span class="space">&hellip;</span><a class="page-number" href="/page/61/">61</a><a class="extend next" rel="next" href="/page/57/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2024/11/12/x1aqcwUG3XDiskN.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2025 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>