<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">658</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">52</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/19/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/roscore%E6%BA%90%E7%A0%81/">roscore源码</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><p>执行<code>which roscore</code>的结果是<code>/opt/ros/kinetic/bin/roscore</code>，本身是个python脚本。</p>
<p>roscore的源代码在<code>https://github.com/ros/ros_comm/blob/melodic-devel/tools/roslaunch/scripts/roscore</code>，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> optparse <span class="keyword">import</span> OptionParser</span><br><span class="line"><span class="keyword">from</span> rosmaster.master_api <span class="keyword">import</span> NUM_WORKERS</span><br><span class="line"></span><br><span class="line">NAME = <span class="string">&#x27;roscore&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_optparse</span>():</span></span><br><span class="line"></span><br><span class="line">    parser = OptionParser(usage=<span class="string">&quot;usage: %prog [options]&quot;</span>,</span><br><span class="line">                          prog=NAME,</span><br><span class="line">                          description=<span class="string">&quot;roscore will start up a ROS Master, a ROS Parameter Server and a rosout logging node&quot;</span>,</span><br><span class="line">                          epilog=<span class="string">&quot;See http://wiki.ros.org/roscore&quot;</span></span><br><span class="line">                          )</span><br><span class="line">    parser.add_option(<span class="string">&quot;-p&quot;</span>, <span class="string">&quot;--port&quot;</span>,</span><br><span class="line">                      dest=<span class="string">&quot;port&quot;</span>, default=<span class="literal">None</span>,</span><br><span class="line">                      <span class="built_in">help</span>=<span class="string">&quot;master port. Only valid if master is launched&quot;</span>, metavar=<span class="string">&quot;PORT&quot;</span>)</span><br><span class="line">    parser.add_option(<span class="string">&quot;-v&quot;</span>, action=<span class="string">&quot;store_true&quot;</span>,</span><br><span class="line">                      dest=<span class="string">&quot;verbose&quot;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                      <span class="built_in">help</span>=<span class="string">&quot;verbose printing&quot;</span>)</span><br><span class="line">    parser.add_option(<span class="string">&quot;-w&quot;</span>, <span class="string">&quot;--numworkers&quot;</span>,</span><br><span class="line">                      dest=<span class="string">&quot;num_workers&quot;</span>, default=NUM_WORKERS, <span class="built_in">type</span>=<span class="built_in">int</span>,</span><br><span class="line">                      <span class="built_in">help</span>=<span class="string">&quot;override number of worker threads&quot;</span>, metavar=<span class="string">&quot;NUM_WORKERS&quot;</span>)</span><br><span class="line">    parser.add_option(<span class="string">&quot;-t&quot;</span>, <span class="string">&quot;--timeout&quot;</span>,</span><br><span class="line">                      dest=<span class="string">&quot;timeout&quot;</span>,</span><br><span class="line">                      <span class="built_in">help</span>=<span class="string">&quot;override the socket connection timeout (in seconds).&quot;</span>, metavar=<span class="string">&quot;TIMEOUT&quot;</span>)</span><br><span class="line">    parser.add_option(<span class="string">&quot;--master-logger-level&quot;</span>,</span><br><span class="line">                      dest=<span class="string">&quot;master_logger_level&quot;</span>, default=<span class="literal">False</span>, <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">                      <span class="built_in">help</span>=<span class="string">&quot;set rosmaster.master logger level (&#x27;debug&#x27;, &#x27;info&#x27;, &#x27;warn&#x27;, &#x27;error&#x27;, &#x27;fatal&#x27;)&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> parser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = _get_optparse()</span><br><span class="line">(options, args) = parser.parse_args(sys.argv[<span class="number">1</span>:])</span><br><span class="line"><span class="comment">#从这里知道roscore 并不支持参数</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">0</span>:</span><br><span class="line">    parser.error(<span class="string">&quot;roscore does not take arguments&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#roscore实际只调用roslanch.main</span></span><br><span class="line"><span class="keyword">import</span> roslaunch</span><br><span class="line">roslaunch.main([<span class="string">&#x27;roscore&#x27;</span>, <span class="string">&#x27;--core&#x27;</span>] + sys.argv[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
<h3 id="roslaunch-main"><a href="#roslaunch-main" class="headerlink" title="roslaunch.main"></a>roslaunch.main</h3><p>roslaunch.main 其实主要做了几件事，</p>
<ul>
<li>创建保存log的文件夹</li>
<li>启动roslaunch server</li>
<li>启动roscores master和rosout</li>
</ul>
<p>roslaunch脚本只有两句话，其实是导入了roslaunch包，执行了roslaunch.main()函数：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> roslaunch</span><br><span class="line">roslaunch.main()</span><br></pre></td></tr></table></figure><br><code>roslaunch.main()</code>的源码在<code>http://docs.ros.org/kinetic/api/roslaunch/html/</code> 的217行。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/18/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E8%A7%A3%E6%9E%90ros%20init%EF%BC%88%E4%B8%89%EF%BC%89/">解析ros init（三）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><h3 id="param-init"><a href="#param-init" class="headerlink" title="param::init"></a>param::init</h3><p>Parameter是ROS系统运行所定义的全局变量，它由master节点的parameter server基于XML-RPC负责维护。它是全局可见的，因此可以运行时修改。ROS的namespace使得参数的命名具备非常清晰的层级结构，避免他们之间的冲突</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//./src/ros_comm/roscpp/src/libros/param.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> M_string&amp; remappings)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  M_string::const_iterator it = remappings.<span class="built_in">begin</span>();<span class="comment">//remappings变量的头元素</span></span><br><span class="line">  M_string::const_iterator end = remappings.<span class="built_in">end</span>();<span class="comment">//remappings变量的末元素</span></span><br><span class="line">  <span class="keyword">for</span> (; it != end; ++it)<span class="comment">//依次遍历remappings变量的所有元素</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> std::string&amp; name = it-&gt;first;<span class="comment">//提取键</span></span><br><span class="line">    <span class="keyword">const</span> std::string&amp; param = it-&gt;second;<span class="comment">//提取值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name.<span class="built_in">size</span>() &lt; <span class="number">2</span>)    <span class="comment">//跳过键的长度小于2的元素</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name[<span class="number">0</span>] == <span class="string">&#x27;_&#x27;</span> &amp;&amp; name[<span class="number">1</span>] != <span class="string">&#x27;_&#x27;</span>)<span class="comment">//如果键以“__”开头</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//为name赋予一个本地名称，用符号&quot;~&quot;代替“__”</span></span><br><span class="line">      std::string local_name = <span class="string">&quot;~&quot;</span> + name.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">bool</span> success = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> i = boost::lexical_cast&lt;<span class="keyword">int32_t</span>&gt;(param);    <span class="comment">//尝试将param转化成整型</span></span><br><span class="line">        <span class="comment">//将local_name规整化</span></span><br><span class="line">        ros::param::<span class="built_in">set</span>(names::<span class="built_in">resolve</span>(local_name), i);</span><br><span class="line">        success = <span class="literal">true</span>;<span class="comment">//将成功标志置上</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in"><span class="keyword">catch</span></span> (boost::bad_lexical_cast&amp;)</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (success)    <span class="comment">//如果成功标志已被置上，则越过后续过程</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">continue</span>;     <span class="comment">//此时，即param成功被转化为整型</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//没能转化为整型，尝试将param转化成浮点型</span></span><br><span class="line">        <span class="keyword">double</span> d = boost::lexical_cast&lt;<span class="keyword">double</span>&gt;(param);</span><br><span class="line">        <span class="comment">//将local_name规整化</span></span><br><span class="line">        ros::param::<span class="built_in">set</span>(names::<span class="built_in">resolve</span>(local_name), d);</span><br><span class="line">        success = <span class="literal">true</span>;   <span class="comment">//将成功标志置上</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in"><span class="keyword">catch</span></span> (boost::bad_lexical_cast&amp;)</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (success)    <span class="comment">//如果成功标志已被置上，则越过后续过程</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">continue</span>;    <span class="comment">//此时，即param成功被转化为浮点型</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 处理param为布尔型或其他的情况</span></span><br><span class="line">      <span class="keyword">if</span> (param == <span class="string">&quot;true&quot;</span> || param == <span class="string">&quot;True&quot;</span> || param == <span class="string">&quot;TRUE&quot;</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        ros::param::<span class="built_in">set</span>(names::<span class="built_in">resolve</span>(local_name), <span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (param == <span class="string">&quot;false&quot;</span> || param == <span class="string">&quot;False&quot;</span> || param == <span class="string">&quot;FALSE&quot;</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        ros::param::<span class="built_in">set</span>(names::<span class="built_in">resolve</span>(local_name), <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        ros::param::<span class="built_in">set</span>(names::<span class="built_in">resolve</span>(local_name), param);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  XMLRPCManager::<span class="built_in">instance</span>()-&gt;<span class="built_in">bind</span>(<span class="string">&quot;paramUpdate&quot;</span>, paramUpdateCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ros::param::set()函数的定义也在文件./src/ros_comm/roscpp/src/libros/param.cpp中，有一系列的重载函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> XmlRpc::XmlRpcValue&amp; v)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> std::string&amp; s)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> <span class="keyword">char</span>* s)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">const</span> std::string&amp; key, <span class="keyword">double</span> d)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">const</span> std::string&amp; key, <span class="keyword">int</span> i)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">const</span> std::string&amp; key, <span class="keyword">bool</span> b)</span> </span></span><br></pre></td></tr></table></figure></p>
<p>以转化为整型的重载函数为例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> std::map&lt;std::string, <span class="keyword">int</span>&gt;&amp; map)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">setImpl</span>(key, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显然这个函数为模板函数比较合适，适用于多种情况</span></span><br><span class="line"><span class="comment">// 将第二个参数转化成相应了XmlRpcValue类型，然后调用第一个重载函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setImpl</span><span class="params">(<span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> std::map&lt;std::string, T&gt;&amp; map)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//  XmlRpcValue starts off as &quot;invalid&quot; and assertStruct turns it  into a struct type</span></span><br><span class="line">  XmlRpc::XmlRpcValue   xml_value;</span><br><span class="line">  xml_value.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy the contents into the XmlRpcValue</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">typename</span> std::map&lt;std::string, T&gt;::const_iterator it = map.<span class="built_in">begin</span>(); </span><br><span class="line">    it != map.<span class="built_in">end</span>(); ++it)</span><br><span class="line">  &#123;</span><br><span class="line">    xml_value[it-&gt;first] = it-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line">  ros::param::<span class="built_in">set</span>(key, xml_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>set第一个重载如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> XmlRpc::XmlRpcValue&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::string mapped_key = ros::names::<span class="built_in">resolve</span>(key);</span><br><span class="line"></span><br><span class="line">  XmlRpc::XmlRpcValue params, result, payload;</span><br><span class="line">  params[<span class="number">0</span>] = this_node::<span class="built_in">getName</span>();</span><br><span class="line">  params[<span class="number">1</span>] = mapped_key;</span><br><span class="line">  params[<span class="number">2</span>] = v;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//Lock around the execute to the master in case we get a parameter update on this value between executing on the master and setting the parameter in the g_params list</span></span><br><span class="line">    boost::<span class="function">mutex::scoped_lock <span class="title">lock</span><span class="params">(g_params_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (master::<span class="built_in">execute</span>(<span class="string">&quot;setParam&quot;</span>, params, result, payload, <span class="literal">true</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Update our cached params list now so that if get() is called immediately after param::set()</span></span><br><span class="line">      <span class="comment">// we already have the cached state and our value will be correct</span></span><br><span class="line">      <span class="keyword">if</span> (g_subscribed_params.<span class="built_in">find</span>(mapped_key) != g_subscribed_params.<span class="built_in">end</span>())</span><br><span class="line">      &#123;</span><br><span class="line">        g_params[mapped_key] = v;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">invalidateParentParams</span>(mapped_key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数master::execute(“setParam”, params, result, payload, true)用于在master(节点管理器)上执行XML-RPC通信机制。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ros::master::<span class="built_in">execute</span>(<span class="keyword">const</span> std::string&amp;  method,</span><br><span class="line">    <span class="keyword">const</span> XmlRpc::XmlRpcValue &amp;     request,</span><br><span class="line">    XmlRpc::XmlRpcValue &amp;   response,</span><br><span class="line">    XmlRpc::XmlRpcValue &amp;   payload,</span><br><span class="line">    <span class="keyword">bool</span>  wait_for_master </span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>method：要调用的 RPC 方法</li>
<li>request：The arguments to the RPC call   //传递给RPC的参数</li>
<li>response：[out] The resonse that was received.   //接收到的回应</li>
<li>payload： [out] The payload that was received</li>
<li>wait_for_master： //是否一直循环等待与master建立连接</li>
</ul>
<p>函数的源码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">execute</span><span class="params">(<span class="keyword">const</span> std::string&amp; method, <span class="keyword">const</span> XmlRpc::XmlRpcValue&amp; request, XmlRpc::XmlRpcValue&amp; response, XmlRpc::XmlRpcValue&amp; payload, <span class="keyword">bool</span> wait_for_master)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::WallTime start_time = ros::WallTime::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  std::string  master_host = <span class="built_in">getHost</span>(); <span class="comment">//获取g_host的值</span></span><br><span class="line">  <span class="keyword">uint32_t</span>  master_port = <span class="built_in">getPort</span>();   <span class="comment">//获取g_port的值</span></span><br><span class="line">  <span class="comment">//根据 master_host, master_port 获取XMLRPC通信的客户端，这两个一般是根据环境变量所得</span></span><br><span class="line">  XmlRpc::XmlRpcClient *c = XMLRPCManager::<span class="built_in">instance</span>()-&gt;<span class="built_in">getXMLRPCClient</span>(master_host, master_port, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">  <span class="keyword">bool</span> printed = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">bool</span> slept = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">bool</span> b = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="meta">#<span class="meta-keyword">if</span> defined(__APPLE__)</span></span><br><span class="line">            boost::<span class="function">mutex::scoped_lock <span class="title">lock</span><span class="params">(g_xmlrpc_call_mutex)</span></span>;</span><br><span class="line">      <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="comment">//c是根据master_host, master_port的值获取XMLRPC通信的客户端指针（XmlRpc::XmlRpcClient *c）</span></span><br><span class="line">      <span class="comment">// 循环不断执行execute，以保持和master的通信</span></span><br><span class="line">      b = c-&gt;<span class="built_in">execute</span>(method.<span class="built_in">c_str</span>(), request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    ok = !ros::<span class="built_in">isShuttingDown</span>() &amp;&amp; !XMLRPCManager::<span class="built_in">instance</span>()-&gt;<span class="built_in">isShuttingDown</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!b &amp;&amp; ok)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (!printed &amp;&amp; wait_for_master)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;[%s] Failed to contact master at [%s:%d].  %s&quot;</span>, method.<span class="built_in">c_str</span>(), master_host.<span class="built_in">c_str</span>(), master_port, wait_for_master ? <span class="string">&quot;Retrying...&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        printed = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!wait_for_master)</span><br><span class="line">      &#123;</span><br><span class="line">        XMLRPCManager::<span class="built_in">instance</span>()-&gt;<span class="built_in">releaseXMLRPCClient</span>(c);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!g_retry_timeout.<span class="built_in">isZero</span>() &amp;&amp; (ros::WallTime::<span class="built_in">now</span>() - start_time) &gt;= g_retry_timeout)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;[%s] Timed out trying to connect to the master after [%f] seconds&quot;</span>, method.<span class="built_in">c_str</span>(), g_retry_timeout.<span class="built_in">toSec</span>());</span><br><span class="line">        XMLRPCManager::<span class="built_in">instance</span>()-&gt;<span class="built_in">releaseXMLRPCClient</span>(c);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ros::<span class="built_in">WallDuration</span>(<span class="number">0.05</span>).<span class="built_in">sleep</span>();</span><br><span class="line">      slept = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (!XMLRPCManager::<span class="built_in">instance</span>()-&gt;<span class="built_in">validateXmlrpcResponse</span>(method, response, payload))</span><br><span class="line">      &#123;</span><br><span class="line">        XMLRPCManager::<span class="built_in">instance</span>()-&gt;<span class="built_in">releaseXMLRPCClient</span>(c);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不断执行循环，除非调用ros::shutdown() 或 XMLRPCManager::shutdown()</span></span><br><span class="line">    ok = !ros::<span class="built_in">isShuttingDown</span>() &amp;&amp; !XMLRPCManager::<span class="built_in">instance</span>()-&gt;<span class="built_in">isShuttingDown</span>();</span><br><span class="line">  &#125; <span class="keyword">while</span>(ok);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ok &amp;&amp; slept)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Connected to master at [%s:%d]&quot;</span>, master_host.<span class="built_in">c_str</span>(), master_port);</span><br><span class="line">  &#125;</span><br><span class="line">  XMLRPCManager::<span class="built_in">instance</span>()-&gt;<span class="built_in">releaseXMLRPCClient</span>(c);</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数主要就是基于XML-RPC进行<code>setParam</code>的远程调用，需要不断判断连接状态</p>
<p>每个节点其实就是个XML-RPC服务端，在运行<code>ros::start()</code>时执行了<code>XMLRPCManager::instance()-&gt;start();——XmlRpcServer::bindAndListen</code>，在这个函数中又开启了一个线程依次调用：<code>XMLRPCManager::serverThreadFunc</code>——<code>server_.work(0.1);</code>，服务端的两个关键函数完成了。</p>
<p><br></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>init()其实做很少工作，主要就是解析一下环境和命令行参数，init()不允许参与实际的连接，因而，用户可以手动检测像是master启动没有，有没有按自定义的行为启动这样的事</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/18/C++/Boost/Boost%E6%95%99%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%E8%AF%BB%E5%86%99JSON/">Boost教程（四）读写JSON</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/Boost/">Boost</a></span><div class="content"><p>Boost读写JSON用的是<code>property_tree</code>模块，这个模块不用加到<code>find_package</code>里，它没有库文件，直接include头文件即可．但用法总体上不如Qt的JSON模块好用。</p>
 <font color = orange size= 3> 今天发现用Boost写JSON有个大问题，就是数值类型和bool最终都被转化为字符串，无法避免。所以最好不要用Boost读写JSON了 </font>

<h3 id="写JSON"><a href="#写JSON" class="headerlink" title="写JSON"></a>写JSON</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/property_tree/ptree.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/property_tree/json_parser.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> std::string file_path=<span class="string">&quot;/home/user/test.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">boost::property_tree::ptree root; </span><br><span class="line">boost::property_tree::ptree items;</span><br><span class="line"></span><br><span class="line">boost::property_tree::ptree item1;</span><br><span class="line">item1.<span class="built_in">put</span>(<span class="string">&quot;ID&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">item1.<span class="built_in">put</span>(<span class="string">&quot;Name&quot;</span>,<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">items.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;1&quot;</span>,item1));</span><br><span class="line"></span><br><span class="line">boost::property_tree::ptree item2;</span><br><span class="line">item2.<span class="built_in">put</span>(<span class="string">&quot;ID&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">item2.<span class="built_in">put</span>(<span class="string">&quot;Name&quot;</span>,<span class="string">&quot;zhang&quot;</span>);</span><br><span class="line">items.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;2&quot;</span>,item2));</span><br><span class="line"></span><br><span class="line">root.<span class="built_in">put_child</span>(<span class="string">&quot;user&quot;</span>,items);</span><br><span class="line">boost::property_tree::<span class="built_in">write_json</span>(file_path,root);</span><br></pre></td></tr></table></figure>
<p>这样写出的JSON如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;user&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;1&quot;</span>: &#123; <span class="attr">&quot;ID&quot;</span>: <span class="string">&quot;1&quot;</span>,<span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;wang&quot;</span>&#125;,</span><br><span class="line">        <span class="attr">&quot;2&quot;</span>: &#123; <span class="attr">&quot;ID&quot;</span>: <span class="string">&quot;2&quot;</span>,<span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;zhang&quot;</span>&#125;,</span><br><span class="line">        <span class="attr">&quot;3&quot;</span>: &#123; <span class="attr">&quot;ID&quot;</span>: <span class="string">&quot;3&quot;</span>, <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;li&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>把最后两句改一下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boost::property_tree::<span class="built_in">write_json</span>(file_path,item1);</span><br></pre></td></tr></table></figure><br>结果如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;ID&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;wang&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>把最后两句再这样改：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root.<span class="built_in">put_child</span>(<span class="string">&quot;user&quot;</span>,item1);</span><br><span class="line">boost::property_tree::<span class="built_in">write_json</span>(file_path,root);</span><br></pre></td></tr></table></figure><br>结果如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;user&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;ID&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;wang&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="修改某个JSON值"><a href="#修改某个JSON值" class="headerlink" title="修改某个JSON值"></a>修改某个JSON值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">json::ptree pt;</span><br><span class="line">pt.<span class="built_in">put</span>(<span class="string">&quot;data&quot;</span>,<span class="number">1</span>);</span><br><span class="line">pt.<span class="built_in">put</span>(<span class="string">&quot;num&quot;</span>,<span class="number">2</span>);</span><br><span class="line">pt.<span class="built_in">get_child</span>(<span class="string">&quot;num&quot;</span>).<span class="built_in">put_value</span>(<span class="number">9</span>);</span><br></pre></td></tr></table></figure>
<h4 id="JSON数组"><a href="#JSON数组" class="headerlink" title="JSON数组"></a>JSON数组</h4><p>实现JSON数组还是只用<code>ptree</code>类型，稍微复杂点，之前因为<code>make_pair</code>而一直以为用别的方法，其实是让paire的key为空即可：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> json = boost::property_tree;</span><br><span class="line"></span><br><span class="line">json::ptree pt;</span><br><span class="line">json::ptree children;</span><br><span class="line">json::ptree child1, child2, child3;</span><br><span class="line"></span><br><span class="line">child1.<span class="built_in">put</span>(<span class="string">&quot;&quot;</span>, <span class="number">1</span>);</span><br><span class="line">child2.<span class="built_in">put</span>(<span class="string">&quot;&quot;</span>, <span class="number">2</span>);</span><br><span class="line">child3.<span class="built_in">put</span>(<span class="string">&quot;&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">children.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;&quot;</span>, child1));</span><br><span class="line">children.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;&quot;</span>, child2));</span><br><span class="line">children.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;&quot;</span>, child3));</span><br><span class="line"></span><br><span class="line">pt.<span class="built_in">add_child</span>(<span class="string">&quot;MyArray&quot;</span>, children);</span><br><span class="line"></span><br><span class="line">std::stringstream stream;</span><br><span class="line">json::<span class="built_in">write_json</span>(stream, pt);</span><br><span class="line">cout&lt;&lt; stream.<span class="built_in">str</span>() &lt;&lt;endl;</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;MyArray&quot;: [</span><br><span class="line">        &quot;1&quot;,</span><br><span class="line">        &quot;2&quot;,</span><br><span class="line">        &quot;3&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样结果，代码还可以优化成这样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">json::ptree child;</span><br><span class="line">for(int i=0;i&lt;3;i++)</span><br><span class="line">&#123;</span><br><span class="line">    child.put(&quot;&quot;, i);</span><br><span class="line">    children.push_back(std::make_pair(&quot;&quot;, child));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>child的内容会依次更新，逐个都插入children</p>
<h3 id="将json写入string"><a href="#将json写入string" class="headerlink" title="将json写入string"></a>将json写入string</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::stringstream stream;</span><br><span class="line">boost::property_tree::<span class="built_in">write_json</span>(stream, item1);</span><br><span class="line">cout&lt;&lt;stream.<span class="built_in">str</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>不能直接用cout&lt;&lt;，没有重载运算符，不过这样也比较简单</p>
<h3 id="从string中解析json串"><a href="#从string中解析json串" class="headerlink" title="从string中解析json串"></a>从string中解析json串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// json是　&#123; &quot;a&quot;: 2&#125;</span></span><br><span class="line">std::string c;		<span class="comment">//c为json串</span></span><br><span class="line">std::istringstream iss;</span><br><span class="line">iss.<span class="built_in">str</span>(c);</span><br><span class="line"></span><br><span class="line">boost::property_tree::ptree item;</span><br><span class="line">boost::property_tree::json_parser::<span class="built_in">read_json</span>(iss, item);</span><br><span class="line"><span class="keyword">int</span> n = item.get&lt;<span class="keyword">int</span>&gt;(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/15/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9win10%E4%B8%BB%E9%A2%98/">使用第三方win10主题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/">常用工具</a></span><div class="content"><p>win10自带的主题就那几个，希望能用一些好看的，但Win10原生是不支持第三方主题的，需要特别之后才可以用</p>
<p>需要先安装一个叫<code>UltraUXThemePatcher</code>的软件，下载在<a target="_blank" rel="noopener" href="https://www.mediafire.com/file/dj52gcod2rt7t00/UxthemePatcher+Win10+1903.zip">这里</a></p>
<p>安装时要注意，软件版本应当和系统版本基本一致，否则会出问题</p>
<ol>
<li><p>右键用管理员身份运行 UltraUXThemePatcher，然后点击 Install，开启安装。<br><img src="https://live.staticflickr.com/65535/48066780947_5137161986_b.jpg" alt=""></p>
</li>
<li><p>重启电脑，打开<code>Cortana</code>，打开<code>创建还原点</code>程序，这个应当是win10的新程序，应当是与VMWare的还原点类似的。打开后选C盘，先到<code>配置</code>里<code>启用系统保护</code>，然后<code>创建</code>。因为主题文件偶尔会出问题，所以最好有还原点。<br><img src="https://live.staticflickr.com/65535/48066728898_9df0c0118b.jpg" alt=""></p>
</li>
<li><p>(可选)安装OldNewExplore，让Windows 10的资源管理器变成Windows 7风格（有些主题需要）</p>
</li>
<li><p>把下载的第三方主题放到<code>C:\Windows\Resources\Themes</code>文件夹</p>
</li>
<li><p>到 桌面-右键-个性化-主题 里面选择主题。</p>
</li>
</ol>
<p>效果：<br><img src="https://live.staticflickr.com/65535/48066728758_b1e65dfe8e_b.jpg" alt=""></p>
<p>参考：<br><a target="_blank" rel="noopener" href="http://www.xia1ge.com/tag/win10%E4%B8%BB%E9%A2%98">第三方主题</a><br><a target="_blank" rel="noopener" href="https://www.cleodesktop.com/2019/05/uxthemepatcher-for-windows10-may-2019.html">视频指导使用第三方主题</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/14/C++/Boost/Boost%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Boost教程（三）多线程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/Boost/">Boost</a></span><div class="content"><p>使用Windows写Boost多线程时，还需要先编译Boost源码产生库文件，我试了几次都没成功，就懒得在Windows上编程了。</p>
<p>在Linux上，Boost使用多线程还得用到filesystem和system模块，否则会报错，可能是thread模块用到了它们，因此cmake这样写<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find_package(Boost COMPONENTS filesystem system thread REQUIRED)</span><br><span class="line"></span><br><span class="line">add_executable(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="string">&quot;main.cpp&quot;</span> )</span><br><span class="line">target_link_libraries(untitled  <span class="variable">$&#123;Boost_FILESYSTEM_LIBRARY&#125;</span> </span><br><span class="line">        <span class="variable">$&#123;Boost_SYSTEM_LIBRARY&#125;</span>  </span><br><span class="line">        <span class="variable">$&#123;Boost_THREAD_LIBRARY&#125;</span>)</span><br></pre></td></tr></table></figure><br>头文件只需要<code>#include &lt;boost/thread.hpp&gt;</code></p>
<p>对于ROS环境，库文件已经包含在<code>$&#123;catkin_LIBRARIES&#125;</code>当中</p>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;slot1: &quot;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;slot2: &quot;</span>&lt;&lt; <span class="number">2</span>*n&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">13</span>;</span><br><span class="line">    boost::thread th_1 = boost::<span class="built_in">thread</span>(boost::<span class="built_in">bind</span>(&amp;thread_1,n));</span><br><span class="line">    th_1.<span class="built_in">join</span>();</span><br><span class="line">    boost::thread th_2 = boost::<span class="built_in">thread</span>(boost::<span class="built_in">bind</span>(&amp;thread_2,n));</span><br><span class="line">    th_2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;<span class="string">&quot;end&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有两个join()会有多种结果：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slot2: 26end</span><br><span class="line"></span><br><span class="line">slot1: 13</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slot1: end</span><br><span class="line">13</span><br><span class="line">slot2: 26</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slot1: slot2: 13</span><br><span class="line">26</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>可见几个线程的执行顺序乱套了，给两个线程都加<code>join()</code>才确定顺序是 <strong>线程１－线程２－主线程</strong>，如果只加一个，剩下两个线程的顺序还是不确定。</p>
<h3 id="boost-condition"><a href="#boost-condition" class="headerlink" title="boost::condition"></a>boost::condition</h3><p>程序如下，main函数里要把上面两个线程的join交换一下，先执行线程2，这样在线程2里的随机数如果大于90，会唤醒线程1。如果先执行线程1，会一直阻塞，程序没法向下执行了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">boost::mutex mut;</span><br><span class="line">boost::condition cond;</span><br><span class="line">boost::mutex::scoped_lock _lock(mut);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cond.<span class="built_in">wait</span>(_lock);</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;thread 1: &quot;</span>&lt;&lt;<span class="built_in">rand</span>()%<span class="number">50</span> &lt;&lt;endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m = <span class="number">50</span> + <span class="built_in">rand</span>()%<span class="number">50</span>;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;thread 2: &quot;</span>&lt;&lt; m &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(m&gt;<span class="number">90</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cond.<span class="built_in">notify_one</span>();</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;thread 2 wake thread 1   &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>某次的测试结果：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thread 2: 65</span><br><span class="line">thread 2: 93</span><br><span class="line">thread 2 wake thread 1   thread 1: 35</span><br><span class="line">thread 2: 86</span><br><span class="line">thread 2: 92</span><br><span class="line">thread 2 wake thread 1   thread 1: 49</span><br><span class="line">thread 2: 71</span><br></pre></td></tr></table></figure></p>
<h3 id="atomic-无锁编程"><a href="#atomic-无锁编程" class="headerlink" title="atomic 无锁编程"></a>atomic 无锁编程</h3><p>多个线程之间共享地址空间，所以多个线程共享进程中的全局变量和堆，都可以对全局变量和堆上的数据进行读写，但是如果两个线程同时修改同一个数据，可能造成某线程的修改丢失；如果一个线程写的同时，另一个线程去读该数据时可能会读到写了一半的数据。这些行为都是线程不安全的行为，会造成程序运行逻辑出现错误。下面的程序很常见：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// boost::atomic&lt;int&gt; i(0);</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">boost::mutex mut;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_1</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">100000</span>;   <span class="comment">//  n不够大时，i不容易出现不同的情况</span></span><br><span class="line">    boost::thread th1 = boost::<span class="built_in">thread</span>(boost::<span class="built_in">bind</span>(&amp;thread_1,n));</span><br><span class="line">    boost::thread th2 = boost::<span class="built_in">thread</span>(boost::<span class="built_in">bind</span>(&amp;thread_1,n));</span><br><span class="line">    th1.<span class="built_in">join</span>();</span><br><span class="line">    th2.<span class="built_in">join</span>();</span><br><span class="line">    cout&lt;&lt; i&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">       mut.<span class="built_in">lock</span>();</span><br><span class="line">        i++;</span><br><span class="line">       mut.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果不加lock，i最终值是不确定的，因为两个线程同时对i进行了写操作。一般地，我们用互斥锁mutex保护临界区，保证同一时间只能有一个线程可以获取锁，持有锁的线程可以对共享变量进行修改，修改完毕后释放锁，而不持有锁的线程阻塞等待直到获取到锁，然后才能对共享变量进行修改，最后i必定为200000</p>
<p>Boost提供了原子类型atomic，通过使用原子类型可摆脱每次对共享变量进行操作都进行的加锁解锁动作，节省了系统开销，同时避免了线程因阻塞而频繁的切换。atomic封装了不同计算机硬件的底层操作原语，提供了跨平台的原子操作功能，解决并发竞争读写变量的困扰，只需要包含文件<code>&lt;boost/atomic.hpp&gt;</code>，在上面的代码中使用<code>boost::atomic&lt;int&gt; i(0);</code>，然后去掉函数中的互斥锁，运行效果是一样的，而且节省了系统开销。</p>
<p>atomic可以把对类型T的操作原子化，T的要求：</p>
<ol>
<li>标量类型（算数，枚举，指针）</li>
<li>POD类型，可以使用memcmp,memset等函数</li>
</ol>
<p>两种方式创建atomic对象：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">atomic&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">assert</span>(a==<span class="number">10</span>);      <span class="comment">//安全函数，若表达式不成立结束程序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">atomic&lt;<span class="keyword">long</span>&gt; L;</span><br><span class="line">cout &lt;&lt; L &lt;&lt;endl;    <span class="comment">//初始值不确定</span></span><br></pre></td></tr></table></figure><br>最重要的两个成员函数： <code>store()</code> (operator=) 和 <code>load()</code> (operator T() )以原子方式存取，不会因为并发访问导致数据不一致。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boost::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">b</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="built_in">assert</span>(b != <span class="number">0</span>);</span><br><span class="line">std::cout &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">b.<span class="built_in">store</span>(<span class="number">0</span>);<span class="comment">//存值</span></span><br><span class="line">std::cout &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function">boost::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">n1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; n1.<span class="built_in">exchange</span>(<span class="number">200</span>) &lt;&lt; std::endl;  <span class="comment">//交换两个值，并且返回原值100</span></span><br><span class="line">std::cout &lt;&lt; n1 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>测试代码中临界区非常短，只有一个语句，所以显得加锁解锁操作对程序性能影响很大，但在实际应用中，我们的临界区一般不会这么短，临界区越长，加锁和解锁操作的性能损耗越微小，无锁编程和有锁编程之间的性能差距也就越微小。</p>
<p>无锁编程最大的优势在于两点：</p>
<ul>
<li>避免了死锁的产生。由于无锁编程避免了使用锁，所以也就不会出现并发编程中最让人头疼的死锁问题，对于提高程序健壮性有很大积极意义</li>
<li>代码更加清晰与简洁</li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/8638.html">C++11多线程编程</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/14/C++/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%20join/">多线程 join</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span><div class="content"><p>使用Windows写Boost多线程时，还需要先编译Boost源码产生库文件，我试了几次都没成功，就懒得在Windows上编程了。</p>
<p>在Linux上，Boost使用多线程还得用到filesystem和system模块，否则会报错，可能是thread模块用到了它们，因此cmake这样写<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find_package(Boost COMPONENTS filesystem system thread REQUIRED)</span><br><span class="line"></span><br><span class="line">add_executable(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="string">&quot;main.cpp&quot;</span> )</span><br><span class="line">target_link_libraries(untitled  <span class="variable">$&#123;Boost_FILESYSTEM_LIBRARY&#125;</span> </span><br><span class="line">        <span class="variable">$&#123;Boost_SYSTEM_LIBRARY&#125;</span>  </span><br><span class="line">        <span class="variable">$&#123;Boost_THREAD_LIBRARY&#125;</span>)</span><br></pre></td></tr></table></figure><br>头文件只需要<code>#include &lt;boost/thread.hpp&gt;</code></p>
<p>对于ROS环境，库文件已经包含在<code>$&#123;catkin_LIBRARIES&#125;</code>当中</p>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>使用join()函数时，主调线程阻塞，等待被调线程终止，然后主调线程回收被调线程资源，并继续运行<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;slot1: &quot;</span>&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;slot2: &quot;</span>&lt;&lt; <span class="number">2</span>*n&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">13</span>;</span><br><span class="line">    boost::thread th_1 = boost::<span class="built_in">thread</span>(boost::<span class="built_in">bind</span>(&amp;thread_1,n));</span><br><span class="line">    th_1.<span class="built_in">join</span>();</span><br><span class="line">    boost::thread th_2 = boost::<span class="built_in">thread</span>(boost::<span class="built_in">bind</span>(&amp;thread_2,n));</span><br><span class="line">    th_2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;<span class="string">&quot;end&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>没有两个join()会有多种结果：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slot2: 26end</span><br><span class="line"></span><br><span class="line">slot1: 13</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slot1: end</span><br><span class="line">13</span><br><span class="line">slot2: 26</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slot1: slot2: 13</span><br><span class="line">26</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>可见几个线程的执行顺序乱套了，执行顺序是 &emsp;&emsp;  线程1 ——线程 1的<code>join()</code>—— 线程2 ——线程 2的<code>join()</code> &emsp;&emsp; 才确定顺序是 <strong>线程１－线程２－主线程</strong>，如果只加一个，或者先定义两个线程，再执行两个join，线程的顺序还是不确定。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/14/C++/Boost/Boost%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">Boost教程（二）文件系统</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/Boost/">Boost</a></span><div class="content"><p>首先在cmake中使用Boost的filesystem模块：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find_package(Boost COMPONENTS system filesystem REQUIRED)</span><br><span class="line"></span><br><span class="line">target_link_libraries(mytarget </span><br><span class="line">  $&#123;Boost_FILESYSTEM_LIBRARY&#125;</span><br><span class="line">  $&#123;Boost_SYSTEM_LIBRARY&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>必须得加上<code>system</code>模块</p>
<p>filesystem库提供了两个头文件，一个是<boost/filesystem.hpp>，这个头文件包含主要的库内容。它提供了对文件系统的重要操作。同时它定义了一个类path，正如大家所想的，这个是一个可移植的路径表示方法，它是filesystem库的基础。</p>
<p>filesystem在任何时候，只要不能完成相应的任务，它都可能抛出 basic_filesystem_error异常，当然并不是总会抛出异常，因为在库编译的时候可以关闭这个功能。</p>
<p>路径的创建很简单，仅仅需要向类boost::filesystem::path()的构造器传递一个string<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    filesystem::path cur_path = filesystem::<span class="built_in">current_path</span>();</span><br><span class="line">    filesystem::path parent_path = cur_path.<span class="built_in">parent_path</span>();</span><br><span class="line">    <span class="comment">//path支持重载/运算符，这个很好用</span></span><br><span class="line">    filesystem::path file_path = cur_path/<span class="string">&quot;test&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;curren path: &quot;</span>&lt;&lt;cur_path&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;parent path: &quot;</span>&lt;&lt;parent_path&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(filesystem::<span class="built_in">exists</span>(file_path))   <span class="comment">// 适合判断文件的存在</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;exists test &quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    filesystem::path  filePath = <span class="string">&quot;/home/user/yaml&quot;</span>;</span><br><span class="line">    cout&lt;&lt;fs::<span class="built_in">is_directory</span>(filePath)&lt;&lt;endl;     </span><br><span class="line">    cout&lt;&lt;fs::<span class="built_in">is_empty</span>(filePath)&lt;&lt;endl;     <span class="comment">// 判断是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// unsigned long int,  byte</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;file test size: &quot;</span>&lt;&lt;filesystem::<span class="built_in">file_size</span>(file_path)&lt;&lt;endl;</span><br><span class="line"><span class="comment">//    filesystem::remove(file_path);</span></span><br><span class="line">    filesystem::<span class="built_in">rename</span>(file_path, cur_path/<span class="string">&quot;newTest&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function">filesystem::path <span class="title">p</span><span class="params">(<span class="string">&quot;/home/user/ost.yaml&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(fs::<span class="built_in">exists</span>(p))   <span class="comment">// Boost缺陷，若文件不存在，两函数也能正常输出</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;p.<span class="built_in">extension</span>()&lt;&lt;endl;      <span class="comment">// &quot;yaml&quot;</span></span><br><span class="line">        cout&lt;&lt;p.<span class="built_in">stem</span>()&lt;&lt;endl;        <span class="comment">// 文件名，不带扩展名</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除文件，失败会强行结束：terminate called after throwing an instance of &#x27;boost::filesystem::filesystem_error&#x27;   所以要用 try catch throw</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        boost::filesystem::<span class="built_in">remove</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>( <span class="keyword">const</span> boost::exception &amp; e )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;remove error&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line"><span class="comment">//        return -1;</span></span><br><span class="line">    &#125;</span><br><span class="line">    filesystem::<span class="built_in">create_directory</span>(cur_path/<span class="string">&quot;dir&quot;</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;is dir: &quot;</span>&lt;&lt;filesystem::<span class="built_in">is_directory</span>(cur_path/<span class="string">&quot;dir&quot;</span>)&lt;&lt;endl;</span><br></pre></td></tr></table></figure></p>
<p>递归获取某文件夹中符合某扩展名的所有文件名：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> fs = boost::filesystem;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;fs::path&gt; <span class="title">getFileNames</span><span class="params">(fs::path p, std::string extension)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;fs::path&gt; names;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!fs::<span class="built_in">is_directory</span>(p) )</span><br><span class="line">        <span class="keyword">return</span> names;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fs::<span class="built_in">is_empty</span>(p))</span><br><span class="line">        <span class="keyword">return</span> names;</span><br><span class="line"></span><br><span class="line">    <span class="function">fs::recursive_directory_iterator <span class="title">iter</span><span class="params">(p)</span></span>;       <span class="comment">//迭代目录下的所有文件</span></span><br><span class="line">    fs::recursive_directory_iterator end_iter;      <span class="comment">// 只接就是end iterator</span></span><br><span class="line">    <span class="keyword">if</span>( !p.<span class="built_in">empty</span>() &amp;&amp; fs::<span class="built_in">exists</span>(p))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(; iter!= end_iter;iter++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (fs::<span class="built_in">is_directory</span>( *iter ) )</span><br><span class="line">                &#123;</span><br><span class="line"><span class="comment">//                    std::cout&lt;&lt;*iter &lt;&lt; &quot;is dir&quot; &lt;&lt; std::endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line"><span class="comment">//                    std::cout&lt;&lt;iter-&gt;path().stem() &lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//                    std::cout&lt;&lt;iter-&gt;path().extension() &lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//                    std::cout &lt;&lt; &quot;full name: &quot;&lt;&lt;*iter &lt;&lt; endl;              </span></span><br><span class="line">                    <span class="keyword">if</span>(iter-&gt;<span class="built_in">path</span>().<span class="built_in">extension</span>() == extension)</span><br><span class="line">                    &#123;</span><br><span class="line">                        names.<span class="built_in">push_back</span>(iter-&gt;<span class="built_in">path</span>().<span class="built_in">stem</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in"><span class="keyword">catch</span></span> ( <span class="keyword">const</span> std::exception &amp; ex )&#123;</span><br><span class="line">                std::cerr &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> names;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">std::vector&lt;fs::path&gt; names = <span class="built_in">getFileNames</span>(<span class="string">&quot;/home/zzp/yaml&quot;</span>, <span class="string">&quot;.yaml&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(names.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;It&#x27;s empty or not a dir&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;names.<span class="built_in">size</span>();i++)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;name: &quot;</span>&lt;&lt;names.<span class="built_in">at</span>(i)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/13/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Git常用命令</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/">常用工具</a></span><div class="content"><p>使用Git的大忌:</p>
<ul>
<li>没什么有价值的修改就提交，也就是没有意义的提交</li>
<li>提交到别人的分支</li>
<li>提交的代码又引入了新的更严重更明显的bug，也就是不如不提交。比第一条更严重，让别人也无法合并</li>
</ul>
<h2 id="在本地建立仓库到push的过程："><a href="#在本地建立仓库到push的过程：" class="headerlink" title="在本地建立仓库到push的过程："></a>在本地建立仓库到push的过程：</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span></span><br><span class="line">git remote add origin https://github.com/rjosodtssp/Design-Modes.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>提交会附带消息和一个哈希值，哈希值是一串包含数字和字母的随机序列。</p>
<h2 id="生成公钥"><a href="#生成公钥" class="headerlink" title="生成公钥"></a>生成公钥</h2><p><img src="https://s2.loli.net/2022/06/15/NlS4hYr9Cz6W7eH.png" alt=""></p>
<h2 id="删除远程库的某文件"><a href="#删除远程库的某文件" class="headerlink" title="删除远程库的某文件"></a>删除远程库的某文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm file.cpp</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure>
<p>从本地库中删除了，再push就可以从远程库删除</p>
<h2 id="从远程仓库拉取"><a href="#从远程仓库拉取" class="headerlink" title="从远程仓库拉取"></a>从远程仓库拉取</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git <span class="built_in">clone</span></span><br></pre></td></tr></table></figure>
<h2 id="单独push某文件"><a href="#单独push某文件" class="headerlink" title="单独push某文件"></a>单独push某文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit test.cpp</span><br><span class="line">//在vim中输入更新信息</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title=" 添加远程仓库 "></a><center> 添加远程仓库 </center></h2><p><code>git remote add origin git@github.com:rjosodtssp/DailyCode.git</code><br>添加一个远程仓库，地址是 <font color = blue> git@github.com:rjosodtssp/DailyCode.git </font>,而 <strong>origin</strong> 是给这个项目的远程仓库起的名字，只有一个远程仓库时名字就是 origin</p>
<p>查看当前项目有哪些远程仓库可以执行如下命令:<br><code>git remote -v</code></p>
<h2 id="删除Repository"><a href="#删除Repository" class="headerlink" title=" 删除Repository "></a><center> 删除Repository </center></h2><p>在GitHub网站上操作，打开要删除的Repository,点 <code>Settings</code><br><img src="https://live.staticflickr.com/65535/48061319366_a21c469d95_b.jpg" alt=""></p>
<h2 id="Commit-message-用-emoji"><a href="#Commit-message-用-emoji" class="headerlink" title=" Commit message 用 emoji "></a><center> Commit message 用 emoji </center></h2><p>初次提交示例:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;:tada: Initialize Repo&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>🆕 (全新)  :new:   引入新功能<br>(闪电)      :zap:    提升性能<br>🔖 (书签)  :bookmark:  发行/版本标签<br>🐛 (bug)   :bug:   修复 bug<br>(急救车)    :ambulance: 重要补丁</p>
<p>(扳手)      :wrench:    修改配置文件<br>(加号)      :heavy_plus_sign:   增加一个依赖<br>➖ (减号)  :heavy_minus_sign:  减少一个依赖<br>(备忘录)    :memo:       撰写文档<br>(锤子)      :hammer:    重大重构<br>🔥 (火焰)   :fire:  移除代码或文件</p>
<h2 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title=" 撤销对文件的修改 "></a><center> 撤销对文件的修改 </center></h2><p>对 <code>test.cpp</code> 修改后，打算返回上次提交的状态，使用命令:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- qclipper.cpp</span><br></pre></td></tr></table></figure><br>如果要撤销 <strong>所有文件</strong> 的修改，命令为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -f</span><br></pre></td></tr></table></figure><br><code>git diff ReadMe.mdown</code> 表示在commit之前查看文件修改哪些地方， 在commit之后使用此命令无效。</p>
<h2 id="避免每次提交时登录"><a href="#避免每次提交时登录" class="headerlink" title="避免每次提交时登录"></a>避免每次提交时登录</h2><p>如果我们git clone的下载代码的时候是连接的<a target="_blank" rel="noopener" href="https://而不是git@git">https://而不是git@git</a> (ssh)的形式，当我们操作git pull/push到远程的时候，总是提示我们输入账号和密码才能操作成功，频繁的输入账号和密码会很麻烦。</p>
<p>解决办法：git bash进入你的项目目录，输入<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><br>然后你会在你本地生成一个文本，上边记录你的账号和密码。不用关心在哪，使用上述的命令配置好之后，再操作一次git pull，然后它会提示你输入账号密码，这一次之后就不需要再次输入密码了。</p>
<h2 id="在Github找到以前提交的版本"><a href="#在Github找到以前提交的版本" class="headerlink" title=" 在Github找到以前提交的版本 "></a><center> 在Github找到以前提交的版本 </center></h2><p>点击<code>commits</code><br>点击红圈的标志，进入旧版本的<code>repository</code>，然后可以下载</p>
<p><img src="https://live.staticflickr.com/65535/48061368043_9fcb31abba_b.jpg" alt="Alt text"></p>
<h2 id="git-tag"><a href="#git-tag" class="headerlink" title=" git tag "></a><center> git tag </center></h2><p>Git 中的tag指向一次commit的id，通常用来给开发分支做一个标记，如标记一个版本号。</p>
<h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1<span class="number">.01</span> -m <span class="string">&quot;Relase version 1.01&quot;</span></span><br></pre></td></tr></table></figure>
<p>注解：git tag 是打标签的命令，-a 是添加标签，其后要跟新标签号，-m 及后面的字符串是对该标签的注释。</p>
<h2 id="将user分支合并到master分支"><a href="#将user分支合并到master分支" class="headerlink" title="将user分支合并到master分支"></a>将user分支合并到master分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前是user分支</span></span><br><span class="line">git add test.yaml </span><br><span class="line">git commit -m <span class="string">&quot;:wrench:&quot;</span></span><br><span class="line">git push origin user</span><br><span class="line"><span class="comment"># 切换到 master 分支</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge user</span><br><span class="line">git push origin master</span><br><span class="line">git checkout user</span><br></pre></td></tr></table></figure>
<h2 id="提交标签到远程仓库"><a href="#提交标签到远程仓库" class="headerlink" title="提交标签到远程仓库"></a>提交标签到远程仓库</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>
<p>注解：就像git push origin master 把本地修改提交到远程仓库一样，-tags可以把本地的打的标签全部提交到远程仓库。</p>
<h2 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v1<span class="number">.01</span></span><br></pre></td></tr></table></figure>
<p>注解：-d 表示删除，后面跟要删除的tag名字</p>
<h2 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/v1<span class="number">.01</span></span><br></pre></td></tr></table></figure>
<p>注解：就像git push origin :branch_1 可以删除远程仓库的分支branch_1一样， 冒号前为空表示删除远程仓库的tag。</p>
<h2 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h2><p><code>git tag</code> 或者 <code>git tag -l</code></p>
<p><img src="https://live.staticflickr.com/65535/48061319131_fb5423f504_b.jpg" alt="Alt text"></p>
<h2 id="修改commit-message"><a href="#修改commit-message" class="headerlink" title=" 修改commit message "></a><center> 修改commit message </center></h2><p>&emsp;&emsp;上一次的message如果需要修改，使用：<code>git commit --amend</code> 如果上一次的commit已经push了，那么需要强制提交 <code>git push -f origin master</code></p>
<h2 id="从远程仓库更新"><a href="#从远程仓库更新" class="headerlink" title="从远程仓库更新"></a>从远程仓库更新</h2><p>GitHub 的仓库上已经更新了，但本地却没有做相应的更改。如果是这样，可以使用 <code>git pull origin &lt;branch&gt;</code>命令从远程分支中拉取最新的更改。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></p>
<h2 id="修改别人的代码"><a href="#修改别人的代码" class="headerlink" title=" 修改别人的代码 "></a><center> 修改别人的代码 </center></h2><p>先到别人的项目上fork到自己的GitHub下，clone下来以后进行修改，push到自己的项目。</p>
<p>在自己的项目页面<code>pull request</code>，把我的修改发到对方的项目里，GitHub同时给对方发了邮件，由对方决定是否接受修改。</p>
<p>注意：不要在对方的项目页面clone</p>
<h2 id="查看当前用户名和邮箱"><a href="#查看当前用户名和邮箱" class="headerlink" title=" 查看当前用户名和邮箱 "></a><center> 查看当前用户名和邮箱 </center></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure>
<p>修改用户名和地址，不加global只能生效一次<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;your name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;your email&quot;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><ul>
<li>origin 远程服务器</li>
<li>origin/master 远程分支</li>
<li>master 本地分支</li>
</ul>
<p>origin并不特别,就像分支名master在git中没有任何特殊意义一样.当执行git init时,master会作为初始分支的默认名字,因此使得master分支名被广泛使用.而origin是执行git clone时的默认服务器名称,当然可以通过指令git clone -o cat,使得默认服务器名称为cat,而默认远程分支为cat/master.</p>
<p>从远程分支check out一个本地分支,该本地分支被称为追踪分支(tracking branch),被追踪的分支被称为上游分支(upstream branch),追踪分支可以理解为是和远程分支有直接关联的本地分支. 如果我们在追踪分支时执行git pull,git会自动知道需要获取和merge的分支的服务器.</p>
<p>拉取远程指定分支<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https:<span class="comment">//github.com/zjZSTU/zjzstu.github.com.git</span></span><br><span class="line">git fetch origin dev</span><br></pre></td></tr></table></figure></p>
<p>本地创建并切换到分支<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b step1 origin/step</span><br></pre></td></tr></table></figure></p>
<p><code>git branch -a</code>   list both remote-tracking and local branches<br><img src="https://s2.loli.net/2023/09/18/1DLjtqSX4Ua5egG.png" alt=" "></p>
<p><code>git branch -vv</code>  会列出所有的分支信息,包含追踪分支的关联关系<br><img src="https://s2.loli.net/2023/09/18/2vqmLaBd5tzfM8e.png" alt=""></p>
<p>常见的情况是，我自己有一个分支<code>me</code>，还要拉取另一个人的分支，两人共用部分文件，合并到分支master。在自己分支修改文件结束后，提交到自己的分支。然后切换到master分支，<code>git checkout master</code>。由于不知道另一个人是否更新了代码，所以先执行<code>git pull</code>更新一下，然后<code>git merge me</code>，这就合并了我的分支，再<code>git push origin master</code>。</p>
<p><font size=3 color = blue> 有时会出现冲突 </font>，这是由于两人修改了同一个文件，冲突的提示<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><br><code>git status</code> 也可以告诉我们冲突的文件. 在冲突的文件里，Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，只能自己手动修改，然后再提交。解决冲突的过程一直是在<code>master</code>分支。 用带参数的<code>git log</code>也可以看到分支的合并情况</p>
<p>工具<code>gitk</code>也可以查看和管理分支</p>
<h2 id="问题累计"><a href="#问题累计" class="headerlink" title="问题累计"></a>问题累计</h2><p>对git本地仓库，使用<code>rm</code>而不是<code>git rm</code>删除一个文件A后，直接commit 和 push，远程仓库仍然有A。此时已经不能再执行<code>git rm</code>了，所以将删除动作添加到暂存区 <code>git add .</code>，然后再commit 和 push<br><img src="https://s2.loli.net/2024/02/18/nR4oJMcxH2LGOA6.png" alt="操作过程"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/12/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E8%A7%A3%E6%9E%90ros%20init%EF%BC%88%E4%BA%8C%EF%BC%89/">解析ros init（二）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><h3 id="this-node-init"><a href="#this-node-init" class="headerlink" title="this_node::init"></a>this_node::init</h3><p>命名空间<code>names</code>是在这里初始化的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> M_string&amp; remappings, <span class="keyword">uint32_t</span> options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ThisNode::<span class="built_in">instance</span>().<span class="built_in">init</span>(name, remappings, options);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ThisNode是一个类，instance()是单例模式</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ThisNode&amp; <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> ThisNode singleton;</span><br><span class="line">	<span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要实现在这里</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThisNode::init</span><span class="params">(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> M_string&amp; remappings, <span class="keyword">uint32_t</span> options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *ns_env = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">  _dupenv_s(&amp;ns_env, <span class="literal">NULL</span>, <span class="string">&quot;ROS_NAMESPACE&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  ns_env = <span class="built_in">getenv</span>(<span class="string">&quot;ROS_NAMESPACE&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ns_env)	<span class="comment">//如果获得环境变量</span></span><br><span class="line">  &#123;</span><br><span class="line">    namespace_ = ns_env;    <span class="comment">// namespace_是成员变量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">    <span class="built_in">free</span>(ns_env);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (name.<span class="built_in">empty</span>()) &#123;	<span class="comment">// 节点名不能为空</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">InvalidNameException</span>(<span class="string">&quot;The node name must not be empty&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  name_ = name;     <span class="comment">// 节点名赋值，name_也是类成员变量，初始值为&quot;empty&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> disable_anon = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//在输入参数remappings查找键为&quot;__name&quot;的项</span></span><br><span class="line">  M_string::const_iterator it = remappings.<span class="built_in">find</span>(<span class="string">&quot;__name&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (it != remappings.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    name_ = it-&gt;second;</span><br><span class="line">    disable_anon = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//在输入参数remappings查找键为&quot;__ns&quot;的项</span></span><br><span class="line">  it = remappings.<span class="built_in">find</span>(<span class="string">&quot;__ns&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (it != remappings.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    namespace_ = it-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里可以看出ROS_NAMESPACE不是必要的</span></span><br><span class="line">  <span class="keyword">if</span> (namespace_.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    namespace_ = <span class="string">&quot;/&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果在上面赋值为 / ，最终就是 /  ；否则就是 /+namespace</span></span><br><span class="line">  namespace_ = (namespace_ == <span class="string">&quot;/&quot;</span>)</span><br><span class="line">    ? std::<span class="built_in">string</span>(<span class="string">&quot;/&quot;</span>) </span><br><span class="line">    : (<span class="string">&quot;/&quot;</span> + namespace_)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  std::string error;</span><br><span class="line">  <span class="comment">// 对命名空间进行验证，这肯定又是个字符串处理函数</span></span><br><span class="line">  <span class="comment">// 检查首字符，首字符只能是~ / 或 alpha，逐个检查name中的每个字符是否为合法字符</span></span><br><span class="line">  <span class="keyword">if</span> (!names::<span class="built_in">validate</span>(namespace_, error))</span><br><span class="line">  &#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;Namespace [&quot;</span> &lt;&lt; namespace_ &lt;&lt; <span class="string">&quot;] is invalid: &quot;</span> &lt;&lt; error;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">InvalidNameException</span>(ss.<span class="built_in">str</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// names must be initialized here, because it requires the namespace to already be known so that it can properly resolve names.</span></span><br><span class="line">  <span class="comment">// It must be done before we resolve g_name, because otherwise the name will not get remapped.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将remappings映射为g_remappings和g_unresolved_remappings两个变量</span></span><br><span class="line">  names::<span class="built_in">init</span>(remappings);</span><br><span class="line">  <span class="comment">// 节点名不能含有 / 和 ~</span></span><br><span class="line">  <span class="keyword">if</span> (name_.<span class="built_in">find</span>(<span class="string">&quot;/&quot;</span>) != std::string::npos)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">InvalidNodeNameException</span>(name_, <span class="string">&quot;node names cannot contain /&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (name_.<span class="built_in">find</span>(<span class="string">&quot;~&quot;</span>) != std::string::npos)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">InvalidNodeNameException</span>(name_, <span class="string">&quot;node names cannot contain ~&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 简单的格式化操作</span></span><br><span class="line">  name_ = names::<span class="built_in">resolve</span>(namespace_, name_);</span><br><span class="line">  <span class="comment">// 如果初始化时的options选择的时匿名节点，那么在节点名后加UNIX时间戳，单位是纳秒</span></span><br><span class="line">  <span class="keyword">if</span> (options &amp; init_options::AnonymousName &amp;&amp; !disable_anon)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">200</span>];</span><br><span class="line">    <span class="comment">// 其实是ros::WallTime::now()  返回当前时间的纳秒表示</span></span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf), <span class="string">&quot;_%llu&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)WallTime::<span class="built_in">now</span>().<span class="built_in">toNSec</span>());</span><br><span class="line">    name_ += buf;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//把节点和名字联系起来</span></span><br><span class="line">  ros::console::<span class="built_in">setFixedFilterToken</span>(<span class="string">&quot;node&quot;</span>, name_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的函数是:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFixedFilterToken</span><span class="params">(<span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> std::string&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  g_extra_fixed_tokens[key] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>主要是对变量g_extra_fixed_tokens进行赋值</p>
<h3 id="file-log-init"><a href="#file-log-init" class="headerlink" title="file_log::init"></a>file_log::init</h3><p><code>file_log</code>就是个命名空间，函数定义在./src/ros_comm/roscpp/src/libros/file_log.cpp:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> M_string&amp; remappings)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::string log_file_name;</span><br><span class="line">  M_string::const_iterator it = remappings.<span class="built_in">find</span>(<span class="string">&quot;__log&quot;</span>);</span><br><span class="line">  <span class="comment">//在remappings中找到键为&quot;__log&quot;的项</span></span><br><span class="line">  <span class="keyword">if</span> (it != remappings.<span class="built_in">end</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    log_file_name = it-&gt;second;		<span class="comment">//如果找到了，将对应的值赋值给log_file_name</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Log filename can be specified on the command line through __log</span></span><br><span class="line">    <span class="comment">// If it&#x27;s been set, don&#x27;t create our own name</span></span><br><span class="line">    <span class="keyword">if</span> (log_file_name.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Setup the logfile appender</span></span><br><span class="line">      <span class="comment">// Can&#x27;t do this in rosconsole because the node name is not known</span></span><br><span class="line">      <span class="keyword">pid_t</span> pid = <span class="built_in">getpid</span>();		<span class="comment">//获取当前进程号</span></span><br><span class="line">      std::string ros_log_env;</span><br><span class="line">      <span class="comment">//获取&quot;ROS_LOG_DIR&quot;</span></span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">get_environment_variable</span>(ros_log_env, <span class="string">&quot;ROS_LOG_DIR&quot;</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        log_file_name = ros_log_env + std::<span class="built_in">string</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>		<span class="comment">//如果不存在&quot;ROS_LOG_DIR&quot;这个环境变量</span></span><br><span class="line">      &#123;			<span class="comment">//获取&quot;ROS_HOME&quot;的环境变量值</span></span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">get_environment_variable</span>(ros_log_env, <span class="string">&quot;ROS_HOME&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">          log_file_name = ros_log_env + std::<span class="built_in">string</span>(<span class="string">&quot;/log/&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>		<span class="comment">//如果不存在环境变量&quot;ROS_HOME&quot;</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 无法跨平台?</span></span><br><span class="line">          <span class="comment">// 如果没有设置以上环境变量，日志最终放在 ~/.ros/log</span></span><br><span class="line">          <span class="keyword">if</span>( <span class="built_in">get_environment_variable</span>(ros_log_env, <span class="string">&quot;HOME&quot;</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            std::string dotros = ros_log_env + std::<span class="built_in">string</span>(<span class="string">&quot;/.ros/&quot;</span>);</span><br><span class="line">            fs::<span class="built_in">create_directory</span>(dotros);</span><br><span class="line">            log_file_name = dotros + <span class="string">&quot;log/&quot;</span>;</span><br><span class="line">            fs::<span class="built_in">create_directory</span>(log_file_name);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// log_file_name是完整路径，这里是取 文件名=节点名_</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; this_node::<span class="built_in">getName</span>().<span class="built_in">length</span>(); i++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isalnum</span>(this_node::<span class="built_in">getName</span>()[i]))</span><br><span class="line">        &#123;</span><br><span class="line">          log_file_name += <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          log_file_name += this_node::<span class="built_in">getName</span>()[i];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 变成了  节点名_pid_log</span></span><br><span class="line">      <span class="keyword">char</span> pid_str[<span class="number">100</span>];</span><br><span class="line">      <span class="built_in">snprintf</span>(pid_str, <span class="built_in"><span class="keyword">sizeof</span></span>(pid_str), <span class="string">&quot;%d&quot;</span>, pid);  <span class="comment">//将pid以整形变量的形式写入pid_str</span></span><br><span class="line">      log_file_name += std::<span class="built_in">string</span>(<span class="string">&quot;_&quot;</span>) + std::<span class="built_in">string</span>(pid_str) + std::<span class="built_in">string</span>(<span class="string">&quot;.log&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    log_file_name = fs::<span class="built_in">system_complete</span>(log_file_name).<span class="built_in">string</span>();</span><br><span class="line">    g_log_directory = fs::<span class="built_in">path</span>(log_file_name).<span class="built_in">parent_path</span>().<span class="built_in">string</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个函数其实就是确定日志存放目录和日志名称，例如：<br><img src="https://i.loli.net/2019/06/18/5d08f4513674d52984.png" alt=""></p>
<p>问题是为什么有的节点最后还要加上时间戳？</p>
<p>参考：<br><a target="_blank" rel="noopener" href="http://docs.ros.org/indigo/api/rostime/html/time_8h_source.html">ros time.h</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/11/C++/C++%20%20%E5%9F%BA%E7%A1%80/%E8%A7%A3%E6%9E%90cout,cerr,clog/">解析cout,cerr,clog</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E5%9F%BA%E7%A1%80/">C++ 基础</a></span><div class="content"><p>clog和cerr主要用于错误输出。</p>
<ul>
<li>cout    写入标准输出流 stdout，有缓冲</li>
<li>cerr    写入标准错误流 stderr，无缓冲</li>
<li>clog    写入标准错误流 stderr，有缓冲</li>
</ul>
<h3 id="std-endl的含义"><a href="#std-endl的含义" class="headerlink" title="std::endl的含义"></a>std::endl的含义</h3><p>常常有 <code>std::cout&lt;&lt;&quot;test&quot;&lt;&lt;std::endl</code>，这是把<code>test</code>先放到标准输出流，cout会对内容进行缓冲，不会立即输出到显示器．有两种方法立即显示：加flush或endl，后者还要换行，这是在缓冲区不满时刷新．有时不加这两个关键字也能显示，是因为缓冲区满了或者长时间未输入．</p>
<h3 id="precision"><a href="#precision" class="headerlink" title="precision"></a>precision</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout.precision(3);</span><br><span class="line">cout&lt;&lt;123.567890&lt;&lt;endl;　　// 124</span><br><span class="line">cout&lt;&lt;scientific&lt;&lt;123.567890&lt;&lt;endl;         // 1.236e+02</span><br></pre></td></tr></table></figure>
<p><code>precision</code>是控制输出浮点数的精度，3表示四舍五入后得到3个有效数字．精度数字超出数字个数时，还按原来数字．</p>
<p>scientific表示科学计数法表示，此时精度数字是小数点位数</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/55/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/55/">55</a><span class="page-number current">56</span><a class="page-number" href="/page/57/">57</a><span class="space">&hellip;</span><a class="page-number" href="/page/66/">66</a><a class="extend next" rel="next" href="/page/57/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2024 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>