<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">625</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">51</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2022/04/02/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move_base%20%E5%88%86%E6%9E%90/move_base%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF/">move_base的服务端和客户端</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move-base%E5%88%86%E6%9E%90/">move_base分析</a></span><div class="content"><p><code>find_package</code>中添加<code>actionlib</code> 和 <code>actionlib_msgs</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_action_files</span>(</span><br><span class="line">   DIRECTORY action</span><br><span class="line">   FILES</span><br><span class="line">   DoDishes.action</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>
<p><code>package.xml</code>添加<code>actionlib</code>的编译和执行依赖，如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;actionlib&lt;/build_depend&gt;</span><br><span class="line">&lt;build_depend&gt;actionlib_msgs&lt;/build_depend&gt;</span><br><span class="line">&lt;run_depend&gt;actionlib&lt;/run_depend&gt;</span><br><span class="line">&lt;run_depend&gt;actionlib_msgs&lt;/run_depend&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// action定义在 scheduler/action/Scheduler.action</span></span><br><span class="line"><span class="keyword">typedef</span> actionlib::SimpleActionServer&lt;scheduler::SchedulerAction&gt; Server;</span><br><span class="line">actionlib::SimpleActionServer&lt;scheduler::SchedulerAction&gt;  as_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册抢占回调函数</span></span><br><span class="line">as_.<span class="built_in">registerPreemptCallback</span>(boost::<span class="built_in">bind</span>(&amp;Explore::preemptCB, <span class="keyword">this</span>))</span><br><span class="line">as_.<span class="built_in">registerGoalCallback</span>(boost::<span class="built_in">bind</span>(&amp;Explore::goalCB, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Explore::preemptCB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;%s: Preempted&quot;</span>, action_name_.<span class="built_in">c_str</span>());</span><br><span class="line">  explore_ = <span class="literal">false</span>;</span><br><span class="line">  explore_state_ = STOP;</span><br><span class="line">  ac_.<span class="built_in">cancelAllGoals</span>();</span><br><span class="line">  <span class="keyword">if</span>(as_.<span class="built_in">isActive</span>())</span><br><span class="line">	as_.<span class="built_in">setPreempted</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Explore::goalCB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  explore_state_ = FULL_ROTATE;</span><br><span class="line">  as_.<span class="built_in">acceptNewGoal</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SimpleActionServer</code>有构造函数可以注册<code>ExecuteCallback</code>回调函数，但没有其他两个回调，原型：<br><code>SimpleActionServer (ros::NodeHandle n, std::string name, ExecuteCallback execute_callback, bool auto_start)</code></p>
<p><code>move_base</code>的构造函数中是这样使用的：<br><code>as_ = new MoveBaseActionServer(ros::NodeHandle(), &quot;move_base&quot;, boost::bind(&amp;MoveBase::executeCb, this, _1), false);</code></p>
<p>服务端<code>as_</code>最后需要<code>start()</code>来启动，再加<code>ros::spin()</code>阻塞。 <code>MoveBase</code>构造函数的最后只有前者，<code>ros::spin()</code>其实是在<code>move_base_node.cpp</code>里</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>这里只看带回调函数的函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> actionlib::SimpleActionClient&lt; ActionSpec &gt;::<span class="built_in">sendGoal</span>(<span class="keyword">const</span> Goal&amp; goal,</span><br><span class="line">    SimpleDoneCallback       done_cb = <span class="built_in">SimpleDoneCallback</span>(),</span><br><span class="line">    SimpleActiveCallback     active_cb = <span class="built_in">SimpleActiveCallback</span>(),</span><br><span class="line">    SimpleFeedbackCallback   feedback_cb = <span class="built_in">SimpleFeedbackCallback</span>() </span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>向<code>ActionServer</code>发送goal, 并注册回调函数。 如果调用本函数时已经有个goal处于active，状态机就会忽略goal并且开始向新的goal导航，不用发取消的请求。</p>
<ul>
<li>done_cb:        Callback that gets called on transitions to <code>Done</code>，用于监听服务器任务执行完后的相应消息以及客户端的相应处理</li>
<li>active_cb:      Callback that gets called on transitions to <code>Active</code>，服务器任务被激活时的消息提示以及客户端的相应处理</li>
<li>feedback_cb:    Callback that gets called whenever <code>feedback</code> for this goal is received，接收服务器的反馈消息以及客户端的相应处理<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> actionlib::SimpleActionClient&lt;move_base_msgs::MoveBaseAction&gt; MoveBaseClient;</span><br><span class="line">MoveBaseClient   ac_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">ac_.<span class="built_in">sendGoal</span>(goal,</span><br><span class="line">    boost::<span class="built_in">bind</span>(&amp;DoDishesActionClient::DoneCb, <span class="keyword">this</span>, _1, _2),</span><br><span class="line">    boost::<span class="built_in">bind</span>(&amp;DoDishesActionClient::ActiveCb, <span class="keyword">this</span>),</span><br><span class="line">    boost::<span class="built_in">bind</span>(&amp;DoDishesActionClient::FeedbackCb, <span class="keyword">this</span>, _1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoneCb</span><span class="params">(<span class="keyword">const</span> actionlib::SimpleClientGoalState&amp; state,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> first_actionlib_sample::DoDishesResultConstPtr&amp; result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Finished in state [%s]&quot;</span>, state.<span class="built_in">toString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Toal dish cleaned: %i&quot;</span>, result-&gt;toal_dishes_cleaned);</span><br><span class="line">        ros::<span class="built_in">shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当目标激活的时候，会调用一次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ActiveCb</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ROS_INFO</span>(<span class="string">&quot;Goal just went active&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收服务器的反馈信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FeedbackCb</span><span class="params">(<span class="keyword">const</span> first_actionlib_sample::DoDishesFeedbackConstPtr&amp; feedback)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Got Feedback Complete Rate: %f&quot;</span>, feedback-&gt;percent_complete);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Goal的状态"><a href="#Goal的状态" class="headerlink" title="Goal的状态"></a>Goal的状态</h2><p><code>GoalStatus</code><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PENDING = <span class="number">0</span></span><br><span class="line">ACTIVE = <span class="number">1</span></span><br><span class="line">PREEMPTED = <span class="number">2</span></span><br><span class="line">SUCCEEDED = <span class="number">3</span></span><br><span class="line">ABORTED = <span class="number">4</span></span><br><span class="line">REJECTED = <span class="number">5</span></span><br><span class="line">PREEMPTING = <span class="number">6</span></span><br><span class="line">RECALLING = <span class="number">7</span></span><br><span class="line">RECALLED = <span class="number">8</span></span><br><span class="line">LOST = <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt; ac_.<span class="built_in">getState</span>().<span class="built_in">toString</span>() &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取goal的状态信息</span></span><br><span class="line"><span class="comment">// PENDING, ACTIVE, RECALLED, REJECTED, PREEMPTED, ABORTED, SUCCEEDED, LOST(isn&#x27;t tracking a goal)</span></span><br><span class="line"><span class="function">SimpleClientGoalState   <span class="title">getState</span> <span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="comment">// 输出上面的几个状态，大写字母，对调试很有用</span></span></span><br><span class="line"><span class="function">std::string <span class="title">toString</span><span class="params">()</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure>
<p>如果当前已经在某个状态，再次设置为这个状态就会报警：比如<code>ABORTED</code>状态  <font size="3" color="orange"> To transition to an aborted state, the goal must be in a preempting or active state, it is currently in state: 4  </font></p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.guyuehome.com/14050">ROS Action动作通讯编程</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/31/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E8%BF%9E%E7%BB%AD%E5%8F%91%E5%AF%BC%E8%88%AA%E7%9B%AE%E6%A0%87%E6%97%B6%E7%9A%84%E5%AF%BC%E8%88%AA%E4%B8%AD%E6%96%AD/">连续发导航目标时的导航中断</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-31</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%85%B6%E4%BB%96/">其他</a></span><div class="content"><p>车收到导航命令没有动，查日志如下<br><img src="https://s2.loli.net/2022/03/31/3pLtO8HI7GMDTbV.png" alt="move_base接收的目标四元数invalid.png"></p>
<p>在一个客户端程序里，在<code>sendGoal</code>之前调用了两次<code>cancelAllGoals</code>，结果得到下面的日志，某次goal的消息全是0<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">[ INFO] [<span class="number">1648276976.479444090</span>]: move_base client send goal: type: <span class="number">1</span></span><br><span class="line">target_pose: </span><br><span class="line">  header: </span><br><span class="line">    seq: <span class="number">11</span></span><br><span class="line">    stamp: <span class="number">1648276976.479361050</span></span><br><span class="line">    frame_id: map</span><br><span class="line">  pose: </span><br><span class="line">    position: </span><br><span class="line">      x: <span class="number">-3.9901</span></span><br><span class="line">      y: <span class="number">0.427604</span></span><br><span class="line">      z: <span class="number">0</span></span><br><span class="line">    orientation: </span><br><span class="line">      x: <span class="number">0</span></span><br><span class="line">      y: <span class="number">0</span></span><br><span class="line">      z: <span class="number">0</span></span><br><span class="line">      w: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">[ INFO] [<span class="number">1648276976.492017723</span>]: move base task just went active</span><br><span class="line">[ WARN] [<span class="number">1648276979.458537608</span>]: <span class="number">32</span> receive cmd: position: </span><br><span class="line">  x: <span class="number">-4.01633</span></span><br><span class="line">  y: <span class="number">0.440816</span></span><br><span class="line">  z: <span class="number">0</span></span><br><span class="line">orientation: </span><br><span class="line">  x: <span class="number">0</span></span><br><span class="line">  y: <span class="number">0</span></span><br><span class="line">  z: <span class="number">0</span></span><br><span class="line">  w: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">[ INFO] [<span class="number">1648276979.494004129</span>]: actionlib result state: PREEMPTED</span><br><span class="line">[ INFO] [<span class="number">1648276979.494157917</span>]: actionlib result: result: <span class="number">0</span></span><br><span class="line">result_pose: </span><br><span class="line">  header: </span><br><span class="line">    seq: <span class="number">0</span></span><br><span class="line">    stamp: <span class="number">0.000000000</span></span><br><span class="line">    frame_id: </span><br><span class="line">  pose: </span><br><span class="line">    position: </span><br><span class="line">      x: <span class="number">0</span></span><br><span class="line">      y: <span class="number">0</span></span><br><span class="line">      z: <span class="number">0</span></span><br><span class="line">    orientation: </span><br><span class="line">      x: <span class="number">0</span></span><br><span class="line">      y: <span class="number">0</span></span><br><span class="line">      z: <span class="number">0</span></span><br><span class="line">      w: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[ INFO] [<span class="number">1648276979.494228945</span>]: actionDoneCb state PREEMPTED</span><br><span class="line">[ INFO] [<span class="number">1648276979.494308493</span>]: move_base client send goal: type: <span class="number">1</span></span><br><span class="line">target_pose: </span><br><span class="line">  header: </span><br><span class="line">    seq: <span class="number">12</span></span><br><span class="line">    stamp: <span class="number">1648276979.494253319</span></span><br><span class="line">    frame_id: map</span><br><span class="line">  pose: </span><br><span class="line">    position: </span><br><span class="line">      x: <span class="number">0</span></span><br><span class="line">      y: <span class="number">0</span></span><br><span class="line">      z: <span class="number">0</span></span><br><span class="line">    orientation: </span><br><span class="line">      x: <span class="number">0</span></span><br><span class="line">      y: <span class="number">0</span></span><br><span class="line">      z: <span class="number">0</span></span><br><span class="line">      w: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">[ERROR] [<span class="number">1648276979.504876032</span>]: BUG: Got a transition to CommState [PENDING] when our in SimpleGoalState [DONE]</span><br><span class="line">[ERROR] [<span class="number">1648276979.504963821</span>]: BUG: Got a transition to CommState [RECALLING] when our in SimpleGoalState [DONE]</span><br><span class="line">[ERROR] [<span class="number">1648276979.514087412</span>]: BUG: Got a transition to CommState [PREEMPTING] when in SimpleGoalState [DONE]</span><br><span class="line">[ERROR] [<span class="number">1648276979.515084871</span>]: BUG: Got a second transition to DONE</span><br></pre></td></tr></table></figure><br>结果导致move_base漏接了一个目标，最后取消两个<code>cancelAllGoals</code>就好了</p>
<ul>
<li><p><code>cancelAllGoals()</code>[inline]: Cancel all goals currently running on the action server. This preempts all goals running on the action server at the point that this message is serviced by the ActionServer.</p>
</li>
<li><p><code>cancelGoal()</code>[inline]: Cancel the goal that we are currently pursuing</p>
</li>
</ul>
<p><code>cancellAllGoals()</code>和<code>cancellGoal()</code>经常放在<code>SIGINT</code>信号的回调函数里，用于停止所有actions</p>
<p>参考： <a target="_blank" rel="noopener" href="https://github.com/thecodeside/elektron_ballcollector">elektron_ballcollector</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/22/C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88(%E4%B8%89)%20weak_ptr/">智能指针(三) weak_ptr</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">智能指针</a></span><div class="content"><p><code>weak_ptr</code>本身也是一个模板类，但是不能直接用它来定义一个智能指针的对象，只能配合<code>shared_ptr</code>来使用，可以将<code>shared_ptr的对象赋值给weak_ptr</code>，并且这样并不会改变引用计数的值。查看weak_ptr的代码时发现，它主要有<code>lock</code>、<code>swap</code>、<code>reset</code>、<code>expired</code>、<code>operator=</code>、<code>use_count</code>几个函数，与shared_ptr相比多了l<code>ock</code>、<code>expired</code>函数，但是却少了<code>get</code>函数，甚至连<code>operator*</code>  和 <code>operator-&gt;</code>都没有</p>
<h2 id="weak-ptr解决循环引用"><a href="#weak-ptr解决循环引用" class="headerlink" title="weak_ptr解决循环引用"></a>weak_ptr解决循环引用</h2><p><code>weak_ptr</code>必须跟<code>shared_ptr</code>配合使用, 它用于解决<code>shared_ptr</code>的死锁问题，如果两个<code>shared_ptr</code>一直互相引用，那么它们的引用计数永远不是0，资源永远不释放，这样实际造成了内存泄露。<code>weak_ptr</code>并不拥有其指向的对象，让<code>weak_ptr</code>指向<code>shared_ptr</code>所指向对象，对象的引用计数并不会增加</p>
<p>循环引用的情况：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Father</span>() &#123;cout&lt;&lt;<span class="string">&quot; father 析构&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">    shared_ptr&lt;Son&gt; son_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Son</span>() &#123;cout&lt;&lt;<span class="string">&quot; son 析构&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">    shared_ptr&lt;Father&gt; father_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> father = make_shared&lt;Father&gt;();</span><br><span class="line"><span class="keyword">auto</span> son = make_shared&lt;Son&gt;();</span><br><span class="line">father-&gt;son_ = son;</span><br><span class="line">son-&gt;father_ = father;</span><br></pre></td></tr></table></figure><br>结果一个析构函数也没运行，说明对象资源没有释放。使用<code>weak_ptr</code>解决很简单，让Son的成员变量father改为<code>weak_ptr</code>类型，运行后发现两个析构都有了。</p>
<p>main函数退出前，Son对象的引用计数是2，而Father的引用计数是1。<br>son指针销毁，Son对象的引用计数变成1。<br>father指针销毁，Father对象的引用计数变成0，导致Father对象析构，Father对象的析构会导致它包含的son_指针被销毁，这时Son对象的引用计数变成0，所以Son对象也会被析构。</p>
<p>参考:<a target="_blank" rel="noopener" href="https://blog.csdn.net/Jacketinsysu/article/details/53341370">shared_ptr循环引用的例子及解决方法示例</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/22/C++/C++%20%20%E5%9F%BA%E7%A1%80/c++11%20%E6%96%B0%E7%89%B9%E6%80%A7%20%201/">c++11 新特性</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E5%9F%BA%E7%A1%80/">C++ 基础</a></span><div class="content"><h2 id="auto-和-for循环"><a href="#auto-和-for循环" class="headerlink" title="auto 和 for循环"></a>auto 和 for循环</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; vec &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> n :vec)</span><br><span class="line">    std::cout &lt;&lt; n;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> n : arr)</span><br><span class="line">    std::cout &lt;&lt; n;</span><br></pre></td></tr></table></figure>
<p>C++11的for使用方法简单了很多，但是上述对容器的遍历是只读的，也就是说遍历的值是不可修改的。</p>
<p>如果要修改遍历的值，需要将遍历的变量声明为引用类型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; vec &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;修改前&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; n :vec)</span><br><span class="line">    std::cout &lt;&lt; n++;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;修改后&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> j : vec)</span><br><span class="line">    std::cout &lt;&lt; j;</span><br></pre></td></tr></table></figure><br>结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修改前</span><br><span class="line">12345</span><br><span class="line">修改后</span><br><span class="line">23456</span><br></pre></td></tr></table></figure></p>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>C++11提供了对匿名函数的支持，称为Lambda表达式. Lambda表达式具体形式如下:<br><code>[capture](parameters)-&gt;return-type&#123;body&#125;</code></p>
<p>如果没有参数，空的圆括号()可以省略。 返回值也可以省略，如果函数体只由一条return语句组成或返回类型为void的话。形如:<br><code>[capture](parameters)&#123;body&#125;</code></p>
<p>几个Lambda函数的例子:  　　　　<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125; <span class="comment">// 隐式返回类型</span></span><br><span class="line">[](<span class="keyword">int</span>&amp; x) &#123; ++x; &#125;   <span class="comment">// 没有return语句 -&gt; lambda 函数的返回类型是&#x27;void&#x27;</span></span><br><span class="line">[]() &#123; ++global_x; &#125;  <span class="comment">// 没有参数, 仅访问某个全局变量</span></span><br><span class="line">[]&#123; ++global_x; &#125;     <span class="comment">// 与上一个相同,省略了()</span></span><br></pre></td></tr></table></figure><br>先掌握这些简单的情况</p>
<h2 id="判断inf-nan"><a href="#判断inf-nan" class="headerlink" title="判断inf, nan"></a>判断inf, nan</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isinf</span><span class="params">( <span class="keyword">float</span> arg )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isfinite</span><span class="params">( <span class="keyword">float</span> arg )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isnan</span><span class="params">( <span class="keyword">float</span> arg )</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h2><p>C++11新标准规定，允许将变量声明为<code>constexpr</code>类型以便由编译器验证变量的值是否是一个常量表达式。如果不是，编译器报错。同时，声明为constexpr的变量一定是常量，而且必须用常量表达式初始化。  constexpr可以修饰函数参数、函数返回值、变量、类的构造函数、函数模板等，是一种比const更加严格的约束，它修饰的表达式除了具有“运行时常量性”，也具有“编译时常量性”，即constexpr修饰的表达式的值在编译期间可知。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>;              <span class="comment">//正确，20是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> limit = mf + <span class="number">1</span>;       <span class="comment">//正确，mf + 1是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = <span class="built_in">size</span>();         <span class="comment">//未知，若size()函数是一个constexpr函数时即正确，反之错误。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> t = i;                <span class="comment">//错误，i不是常量</span></span><br></pre></td></tr></table></figure></p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ljwgis/p/13095739.html">constexpr</a></p>
<h2 id="匿名命名空间"><a href="#匿名命名空间" class="headerlink" title="匿名命名空间"></a>匿名命名空间</h2><h2 id="std-tie"><a href="#std-tie" class="headerlink" title="std::tie"></a>std::tie</h2><h2 id="限域枚举"><a href="#限域枚举" class="headerlink" title="限域枚举"></a>限域枚举</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">SensorType</span> &#123;</span></span><br><span class="line">      RANGE = <span class="number">0</span>,</span><br><span class="line">      IMU,</span><br><span class="line">      ODOMETRY,</span><br><span class="line">      FIXED_FRAME_POSE,</span><br><span class="line">      LANDMARK,</span><br><span class="line">      LOCAL_SLAM_RESULT</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapBuilderInterface</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> LocalSlamResultCallback =</span><br><span class="line">  TrajectoryBuilderInterface::LocalSlamResultCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> SensorId = TrajectoryBuilderInterface::SensorId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Callback =</span><br><span class="line">      std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> std::string&amp;, std::unique_ptr&lt;Data&gt;)&gt;;</span><br></pre></td></tr></table></figure>
<h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h2><p>std::weak<em>ptr<Task> Schedule(std::unique_ptr<Task> task)<br>      LOCKS_EXCLUDED(mutex</em>) override;</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/21/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/cartographer%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E5%8F%98%E5%8C%96/">cartographer新版本的变化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><h2 id="publish-tracked-pose-和-use-pose-extrapolator"><a href="#publish-tracked-pose-和-use-pose-extrapolator" class="headerlink" title="publish_tracked_pose 和 use_pose_extrapolator"></a>publish_tracked_pose 和 use_pose_extrapolator</h2><p>新版本增加的参数<code>publish_tracked_pose</code>，默认false<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeOptions</span> &#123;</span></span><br><span class="line">  ::cartographer::mapping::proto::MapBuilderOptions map_builder_options;</span><br><span class="line">  std::string map_frame;</span><br><span class="line">  <span class="keyword">double</span> lookup_transform_timeout_sec;</span><br><span class="line">  <span class="keyword">double</span> submap_publish_period_sec;</span><br><span class="line">  <span class="keyword">double</span> pose_publish_period_sec;</span><br><span class="line">  <span class="keyword">double</span> trajectory_publish_period_sec;</span><br><span class="line">  <span class="keyword">bool</span> publish_to_tf = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">bool</span> publish_tracked_pose = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">bool</span> use_pose_extrapolator = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在<code>Node</code>构造函数中的部分<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node_options_.publish_tracked_pose) &#123;</span><br><span class="line">    tracked_pose_publisher_ =</span><br><span class="line">        node_handle_.advertise&lt;::geometry_msgs::PoseStamped&gt;(</span><br><span class="line">            kTrackedPoseTopic, kLatestOnlyPublisherQueueSize);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>发布消息的部分在<code>Node::PublishLocalTrajectoryData</code>的最后。</p>
<p>这里用到了<strong>新版本</strong>的另一个新内容： 参数<code>use_pose_extrapolator</code></p>
<p>Node里的位姿估计器，作用是融合里程计和IMU，推测出一个位姿。 如果<code>use_pose_extrapolator</code>参数为true，发布出的这个位姿不准，因为是先验的位姿，没有经过雷达校准，除非IMU和里程计特别准。因此这个参数一般都是false</p>
<p>如果参数<code>publish_tracked_pose</code>为false，<code>use_pose_extrapolator</code>其实就无效了</p>
<h2 id="Node-MaybeWarnAboutTopicMismatch"><a href="#Node-MaybeWarnAboutTopicMismatch" class="headerlink" title="Node::MaybeWarnAboutTopicMismatch"></a>Node::MaybeWarnAboutTopicMismatch</h2><p>新版本中的<code>Node::AddTrajectory</code>添加<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wall_timers_.<span class="built_in">push_back</span>(node_handle_.<span class="built_in">createWallTimer</span>(</span><br><span class="line">      ::ros::<span class="built_in">WallDuration</span>(kTopicMismatchCheckDelaySec),</span><br><span class="line">      &amp;Node::MaybeWarnAboutTopicMismatch, <span class="keyword">this</span>, <span class="comment">/*oneshot=*/</span><span class="literal">true</span>)  );</span><br></pre></td></tr></table></figure><br>创建一个3s执行一次的定时器，由于<code>oneshot=true</code>，所以只执行一次。检查设置的topic名字在ROS中是否存在，不存在则报错</p>
<h2 id="pose-graph-odometry-motion-filter"><a href="#pose-graph-odometry-motion-filter" class="headerlink" title="pose_graph_odometry_motion_filter"></a>pose_graph_odometry_motion_filter</h2><p><code>CreateGlobalTrajectoryBuilder2D</code>的参数增加 <code>pose_graph_odometry_motion_filter</code>里程计的滤波器，但没有初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">absl::optional&lt;MotionFilter&gt; pose_graph_odometry_motion_filter;</span><br><span class="line"><span class="keyword">if</span> (trajectory_options.<span class="built_in">has_pose_graph_odometry_motion_filter</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Using a motion filter for adding odometry to the pose graph.&quot;</span>;</span><br><span class="line">    pose_graph_odometry_motion_filter.<span class="built_in">emplace</span>(</span><br><span class="line">        <span class="built_in">MotionFilter</span>(trajectory_options.<span class="built_in">pose_graph_odometry_motion_filter</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GetTrajectoryStates-改名为-GetLocalTrajectoryData"><a href="#GetTrajectoryStates-改名为-GetLocalTrajectoryData" class="headerlink" title="GetTrajectoryStates 改名为 GetLocalTrajectoryData"></a><code>GetTrajectoryStates</code> 改名为 <code>GetLocalTrajectoryData</code></h2><p>原因在于后端里也有<code>GetTrajectoryStates</code>，容易混淆</p>
<p><code>Node</code>构造函数 —— <code>Node::PublishLocalTrajectoryData</code> —— <code>map_builder_bridge_.GetLocalTrajectoryData()</code></p>
<p>最后用到的<code>local_slam_data_</code>在<code>MapBuilderBridge::OnLocalSlamResult</code>中赋值</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/16/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/ROS%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">ROS常用数据类型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a></span><div class="content"><h2 id="geometry-msgs-系列"><a href="#geometry-msgs-系列" class="headerlink" title="geometry_msgs 系列"></a>geometry_msgs 系列</h2><ul>
<li><p><code>geometry_msgs/Pose</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs/Point position</span><br><span class="line">geometry_msgs/Quaternion orientation</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>geometry_msgs::PoseStamped</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header  header</span><br><span class="line">geometry_msgs/Pose  pose</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>geometry_msgs::Point</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float64 x</span><br><span class="line">float64 y</span><br><span class="line">float64 z</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>geometry_msgs::Quaternion</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float64 x</span><br><span class="line">float64 y</span><br><span class="line">float64 z</span><br><span class="line">float64 w</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>geometry_msgs/PoseArray</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header</span><br><span class="line">geometry_msgs/Pose[] poses</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>geometry_msgs/Pose2D</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float64 x</span><br><span class="line">float64 y</span><br><span class="line">float64 theta</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>geometry_msgs/Transform</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs/Vector3 translation</span><br><span class="line">geometry_msgs/Quaternion rotation</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>geometry_msgs/PoseWithCovariance</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs/Pose  pose</span><br><span class="line">float64[36]  covariance</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>geometry_msgs::Polygon</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs/Point32[]  points</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="tf-系列"><a href="#tf-系列" class="headerlink" title="tf 系列"></a>tf 系列</h2><p>以下两个类都继承 <code>tf::Transform</code></p>
<h3 id="tf-Pose"><a href="#tf-Pose" class="headerlink" title="tf::Pose"></a><code>tf::Pose</code></h3><p><code>tf::Stamped</code>对数据类型做模板化（除了tf::Transform），并附带元素frame<em>id</em>和stamp、<br><code>setData</code>成员函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tf::Stamped&lt;tf::Pose&gt; pose;</span><br><span class="line"><span class="built_in">getOrigin</span>().<span class="built_in">getX</span>();</span><br><span class="line"><span class="built_in">getOrigin</span>().<span class="built_in">getY</span>();</span><br><span class="line">tf::<span class="built_in">getYaw</span>(pose.<span class="built_in">getRotation</span>())</span><br></pre></td></tr></table></figure></p>
<h3 id="tf-StampedTransform"><a href="#tf-StampedTransform" class="headerlink" title="tf::StampedTransform"></a>tf::StampedTransform</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x= transform.<span class="built_in">getOrigin</span>().<span class="built_in">getX</span>();</span><br><span class="line"><span class="keyword">double</span> y= transform.<span class="built_in">getOrigin</span>().<span class="built_in">getY</span>();</span><br><span class="line"><span class="keyword">double</span> z= transform.<span class="built_in">getOrigin</span>().<span class="built_in">getZ</span>();</span><br><span class="line"><span class="keyword">double</span> angle = transform.<span class="built_in">getRotation</span>().<span class="built_in">getAngle</span>();</span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;x: %f, y: %f, z: %f, angle: %f&quot;</span>,x,y,z,angle);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry_msgs::PoseStamped&amp; pose = ;</span><br><span class="line">tf::StampedTransform  transform;</span><br><span class="line">geometry_msgs::PoseStamped new_pose;</span><br><span class="line"></span><br><span class="line">tf::Stamped&lt;tf::Pose&gt; tf_pose;</span><br><span class="line">tf::<span class="built_in">poseStampedMsgToTF</span>(pose, tf_pose);</span><br><span class="line"></span><br><span class="line">tf_pose.<span class="built_in">setData</span>(transform * tf_pose);</span><br><span class="line">tf_pose.stamp_ = transform.stamp_;</span><br><span class="line">tf_pose.frame_id_ = global_frame;</span><br><span class="line">tf::<span class="built_in">poseStampedTFToMsg</span>(tf_pose, new_pose);  <span class="comment">//转为 geometry_msgs::PoseStamped类型</span></span><br></pre></td></tr></table></figure>
<p><code>tf::poseStampedMsgToTF</code>函数，把<code>geometry_msgs::PoseStamped</code>转化为<code>Stamped&lt;Pose&gt;</code></p>
<p><br></p>
<h2 id="PoseSE2"><a href="#PoseSE2" class="headerlink" title="PoseSE2"></a>PoseSE2</h2><p>源码在<code>pose_se2.h</code>，有两个private成员<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Vector2d  _position; </span><br><span class="line"><span class="keyword">double</span> _theta;</span><br></pre></td></tr></table></figure><br>支持下列函数:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PoseSE2</span>(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> theta)</span><br><span class="line"><span class="built_in">PoseSE2</span>(<span class="keyword">const</span> geometry_msgs::Pose&amp; pose)</span><br><span class="line"><span class="built_in">PoseSE2</span>(<span class="keyword">const</span> tf::Pose&amp; pose)</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream&amp; stream, <span class="keyword">const</span> PoseSE2&amp; pose)</span><br></pre></td></tr></table></figure><br>另外还支持运算符* + - =</p>
<p><code>Eigen::Vector2d  orientationUnitVec() const</code>: 获得当前朝向的单位向量</p>
<p><code>PoseSE2::average(start, goal);</code></p>
<h2 id="costmap-converter-ObstacleArrayMsg"><a href="#costmap-converter-ObstacleArrayMsg" class="headerlink" title="costmap_converter/ObstacleArrayMsg"></a>costmap_converter/ObstacleArrayMsg</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header    <span class="comment"># frame_id 为map</span></span><br><span class="line">costmap_converter/ObstacleMsg[] obstacles</span><br><span class="line"></span><br><span class="line"><span class="comment"># costmap_converter/ObstacleMsg 的成员如下</span></span><br><span class="line">std_msgs/Header header    <span class="comment"># frame_id 为map</span></span><br><span class="line"><span class="comment"># Obstacle footprint (polygon descriptions)</span></span><br><span class="line">geometry_msgs/Polygon polygon</span><br><span class="line"><span class="comment"># radius for circular/point obstacles</span></span><br><span class="line">float64 radius</span><br><span class="line"><span class="comment"># Obstacle ID</span></span><br><span class="line"><span class="comment"># Specify IDs in order to provide (temporal) relationships</span></span><br><span class="line"><span class="comment"># between obstacles among multiple messages.</span></span><br><span class="line">int64 id</span><br><span class="line"><span class="comment"># Individual orientation (centroid)</span></span><br><span class="line">geometry_msgs/Quaternion orientation</span><br><span class="line"><span class="comment"># Individual velocities (centroid)</span></span><br><span class="line">geometry_msgs/TwistWithCovariance velocities</span><br></pre></td></tr></table></figure>
<p>类<code>Obstacle</code>定义在<code>obstacle.h</code>，派生类有<code>PointObstacle</code>, <code>CircularObstacle</code>, <code>LineObstacle</code>,<code>PolygonObstacle</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> boost::shared_ptr&lt;Obstacle&gt; ObstaclePtr;</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;ObstaclePtr&gt;  ObstContainer;</span><br></pre></td></tr></table></figure></p>
<p>PoseSequence pose<em>vec</em>; //!&lt; Internal container storing the sequence of optimzable pose vertices</p>
<p>TimeDiffSequence timediff<em>vec</em>;  //!&lt; Internal container storing the sequence of optimzable timediff vertices</p>
<p><code>VertexPose</code> 继承<code>g2o::BaseVertex&lt;3, PoseSE2 &gt;</code>。<br>This class stores and wraps a SE2 pose (position and orientation) into a vertex that can be optimized via g2o</p>
<p><code>VertexTimeDiff</code>继承<code>g2o::BaseVertex&lt;1, double&gt;</code>。This class stores and wraps a time difference \f$ \Delta T \f$ into a vertex that can be optimized via g2o</p>
<p>判断初始化：<code>bool isInit() const &#123;return !timediff_vec_.empty() &amp;&amp; !pose_vec_.empty(); &#125;</code></p>
<p><code>TimedElasticBand::clearTimedElasticBand()</code>: 清空 timediff<em>vec</em>  pose<em>vec</em></p>
<p><code>addPoseAndTimeDiff</code>: Add one single Pose first. Timediff describes the time difference between last conf and given conf”;</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/16/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/%E6%89%80%E6%9C%89%E7%BA%A6%E6%9D%9F%E7%9A%84%E4%BF%A1%E6%81%AF%E7%9F%A9%E9%98%B5/">所有约束的信息矩阵</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/">TEB算法</a></span><div class="content"><p>所有约束的信息矩阵都是对角矩阵</p>
<ul>
<li>速度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix&lt;<span class="keyword">double</span>,<span class="number">2</span>,<span class="number">2</span>&gt; information;</span><br><span class="line"><span class="built_in">information</span>(<span class="number">0</span>,<span class="number">0</span>) = cfg_-&gt;optim.weight_max_vel_x;</span><br><span class="line"><span class="built_in">information</span>(<span class="number">1</span>,<span class="number">1</span>) = cfg_-&gt;optim.weight_max_vel_theta;</span><br><span class="line"><span class="built_in">information</span>(<span class="number">0</span>,<span class="number">1</span>) = <span class="number">0.0</span>;</span><br><span class="line"><span class="built_in">information</span>(<span class="number">1</span>,<span class="number">0</span>) = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>加速度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix&lt;<span class="keyword">double</span>,<span class="number">2</span>,<span class="number">2</span>&gt; information;</span><br><span class="line">information.<span class="built_in">fill</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">information</span>(<span class="number">0</span>,<span class="number">0</span>) = cfg_-&gt;optim.weight_acc_lim_x;</span><br><span class="line"><span class="built_in">information</span>(<span class="number">1</span>,<span class="number">1</span>) = cfg_-&gt;optim.weight_acc_lim_theta;</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix&lt;<span class="keyword">double</span>,<span class="number">1</span>,<span class="number">1</span>&gt; information;</span><br><span class="line">information.<span class="built_in">fill</span>(cfg_-&gt;optim.weight_optimaltime);</span><br></pre></td></tr></table></figure>
</li>
<li><p>最短距离</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix&lt;<span class="keyword">double</span>,<span class="number">1</span>,<span class="number">1</span>&gt; information;</span><br><span class="line">information.<span class="built_in">fill</span>(cfg_-&gt;optim.weight_shortest_path);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>优先转弯方向，二元边</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create edge for satisfiying kinematic constraints</span></span><br><span class="line">Eigen::Matrix&lt;<span class="keyword">double</span>,<span class="number">1</span>,<span class="number">1</span>&gt; information_rotdir;</span><br><span class="line">information_rotdir.<span class="built_in">fill</span>(cfg_-&gt;optim.weight_prefer_rotdir);</span><br></pre></td></tr></table></figure>
</li>
<li><p>障碍</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix&lt;<span class="keyword">double</span>,<span class="number">1</span>,<span class="number">1</span>&gt; information;</span><br><span class="line">information.<span class="built_in">fill</span>(cfg_-&gt;optim.weight_obstacle * weight_multiplier);</span><br></pre></td></tr></table></figure>
<ul>
<li>动态障碍   AddEdgesDynamicObstacles</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Matrix&lt;<span class="keyword">double</span>,<span class="number">2</span>,<span class="number">2</span>&gt; information;</span><br><span class="line"><span class="built_in">information</span>(<span class="number">0</span>,<span class="number">0</span>) = cfg_-&gt;optim.weight_dynamic_obstacle * weight_multiplier;</span><br><span class="line"><span class="built_in">information</span>(<span class="number">1</span>,<span class="number">1</span>) = cfg_-&gt;optim.weight_dynamic_obstacle_inflation;</span><br><span class="line"><span class="built_in">information</span>(<span class="number">0</span>,<span class="number">1</span>) = <span class="built_in">information</span>(<span class="number">1</span>,<span class="number">0</span>) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/13/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%89%8D%E7%AB%AF%205.%20Ceres%20scan%20matcher%E4%B8%AD%E7%9A%84%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0/">前端 5. Ceres scan matcher中的占用空间代价函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>先看这个匹配的原理</p>
<h2 id="ceres中的类-BiCubicInterpolator"><a href="#ceres中的类-BiCubicInterpolator" class="headerlink" title="ceres中的类 BiCubicInterpolator"></a>ceres中的类 BiCubicInterpolator</h2><p>输入无限的二维grid<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Grid2D</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> DATA_DIMENSION = <span class="number">2</span> &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GetValue</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">double</span>* f)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><code>GetValue</code>函数返回函数<code>f</code>(可能是向量)的值， 枚举<code>DATA_DIMENSION</code>表示所插值函数的维度，比如对一个图片(红绿蓝)进行插值，那么<code>DATA_DIMENSION = 3</code></p>
<p><code>BiCubicInterpolator</code>使用<a target="_blank" rel="noopener" href="https://blog.csdn.net/shiyimin1/article/details/80141333">三次卷积算法</a>生成平滑估计，或者说<strong>双三次插值法</strong>，用来在真实曲线的任一点评价 <script type="math/tex">f(r,c), \frac{\partial f(r,c)}{\partial r}, \frac{\partial f(r,c)}{\partial c}</script> </p>
<p>对二维数组进行插值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> data[] = &#123;<span class="number">1.0</span>, <span class="number">3.0</span>, <span class="number">-1.0</span>, <span class="number">4.0</span>,</span><br><span class="line">                       <span class="number">3.6</span>, <span class="number">2.1</span>,  <span class="number">4.2</span>, <span class="number">2.0</span>,</span><br><span class="line">                       <span class="number">2.0</span>, <span class="number">1.0</span>,  <span class="number">3.1</span>, <span class="number">5.2</span>&#125;;</span><br><span class="line"><span class="comment">// 生成 BiCubicInterpolator 需要的二维数组</span></span><br><span class="line"><span class="function">Grid2D&lt;<span class="keyword">double</span>, 1&gt;  <span class="title">array</span><span class="params">(data, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">BiCubicInterpolator <span class="title">interpolator</span><span class="params">(array)</span></span>;</span><br><span class="line"><span class="keyword">double</span> f, dfdr, dfdc;</span><br><span class="line">interpolator.<span class="built_in">Evaluate</span>(<span class="number">1.2</span>, <span class="number">2.5</span>, &amp;f, &amp;dfdr, &amp;dfdc);</span><br></pre></td></tr></table></figure><br>函数<code>void Evaluate(double r, double c, double* f, double* dfdr, double* dfdc)</code>，残差会对应第3个参数<code>f</code>。 Evaluate the interpolated function value and/or its 导数. Returns false 如果<code>r</code> 或者 <code>c</code>越界</p>
<font size="4" color="orange">  这里的用法没看懂，怎么获得插值后的结果, GetValue获得还是之前的值 </font>

<h2 id="OccupiedSpaceCostFunction2D"><a href="#OccupiedSpaceCostFunction2D" class="headerlink" title="OccupiedSpaceCostFunction2D"></a>OccupiedSpaceCostFunction2D</h2><p>这个<code>Occupied Space Cost Function</code>的模型和 <code>Real time correlative scan matching</code> 的思路基本上一致，只是求解方法变成了最小二乘问题的求解。</p>
<p>将点云中所有点的坐标映射到栅格坐标系，<font size="4" color="blue"> 假如点对应的空闲概率最小，说明对应栅格几乎被占据，点确实是hit点，此时的变换为最优变换。  </font>出于精度考虑使用了ceres提供的双三线性插值。 还有地图大小限制的问题，即一旦点云变换后存在部分脱离地图范围的点，这些点的代价值需要定义。cartographer中的做法是在地图周围增加一个巨大的边框(kPadding)，并且通过一个地图适配器定义点落在边框中的代价值。</p>
<p>先看创建代价函数 <code>CreateOccupiedSpaceCostFunction2D</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建代价函数 for matching the &#x27;point_cloud&#x27; to the &#x27;grid&#x27; with a &#x27;pose&#x27;</span></span><br><span class="line"><span class="comment">//  &#x27;point_cloud&#x27; 是 filtered_gravity_aligned_point_cloud</span></span><br><span class="line"><span class="comment">// &#x27;grid&#x27; 是 matching_submap-&gt;grid()</span></span><br><span class="line"><span class="comment">//  grid 和 point observation  匹配越差，代价越大</span></span><br><span class="line"><span class="comment">//  比如 points falling into less occupied space</span></span><br><span class="line"><span class="function">ceres::CostFunction* <span class="title">CreateOccupiedSpaceCostFunction2D</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">double</span> scaling_factor, <span class="keyword">const</span> sensor::PointCloud&amp; point_cloud,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Grid2D&amp; grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ceres::AutoDiffCostFunction&lt;OccupiedSpaceCostFunction2D,</span><br><span class="line">           ceres::DYNAMIC,   <span class="comment">/* residuals 残差维度未知 */</span></span><br><span class="line">           <span class="number">3</span>  <span class="comment">/* pose variables */</span>&gt;</span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">OccupiedSpaceCostFunction2D</span>(scaling_factor, point_cloud, grid),</span><br><span class="line">    point_cloud.<span class="built_in">size</span>() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>OccupiedSpaceCostFunction2D</code>的构造函数只有参数赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> pose, T* residual)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Eigen::Matrix&lt;T, 2, 1&gt; <span class="title">translation</span><span class="params">(pose[<span class="number">0</span>], pose[<span class="number">1</span>])</span></span>;</span><br><span class="line">    <span class="function">Eigen::Rotation2D&lt;T&gt; <span class="title">rotation</span><span class="params">(pose[<span class="number">2</span>])</span></span>;</span><br><span class="line">    Eigen::Matrix&lt;T, <span class="number">2</span>, <span class="number">2</span>&gt; rotation_matrix = rotation.<span class="built_in">toRotationMatrix</span>();</span><br><span class="line">    Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">3</span>&gt; transform;</span><br><span class="line">    transform &lt;&lt; rotation_matrix, translation, <span class="built_in">T</span>(<span class="number">0.</span>), <span class="built_in">T</span>(<span class="number">0.</span>), <span class="built_in">T</span>(<span class="number">1.</span>);</span><br><span class="line">    <span class="comment">// 构造二阶线性插值类， 成员变量只有 grid_</span></span><br><span class="line">    <span class="comment">// 功能主要是在概率栅格图对应的 index 中取出相应的概率值</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> GridArrayAdapter  <span class="title">adapter</span><span class="params">(grid_)</span></span>;</span><br><span class="line">    <span class="comment">// 使用Ceres提供的双三次插值迭代器</span></span><br><span class="line">    <span class="function">ceres::BiCubicInterpolator&lt;GridArrayAdapter&gt;  <span class="title">interpolator</span><span class="params">(adapter)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> MapLimits&amp;  limits = grid_.<span class="built_in">limits</span>();</span><br><span class="line">    <span class="comment">// 遍历点云（当前 scan）中的所有点，计算该点匹配残差： 1-Smooth(Tp)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; point_cloud_.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这是2D点，第三个元素是 scaling factor</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> Eigen::Matrix&lt;T, 3, 1&gt; <span class="title">point</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        (  T(point_cloud_[i].position.x()) ),</span></span></span><br><span class="line"><span class="params"><span class="function">        (  T(point_cloud_[i].position.y()) ),</span></span></span><br><span class="line"><span class="params"><span class="function">           T(<span class="number">1.</span>)   )</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将点转换到 local map 坐标系下</span></span><br><span class="line">        <span class="keyword">const</span> Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; world = transform * point;</span><br><span class="line">        <span class="comment">/* 计算  1-Smooth(T * point)</span></span><br><span class="line"><span class="comment">        前两个参数用来描述x y轴索引， 第三个参数用于记录插值后的结果</span></span><br><span class="line"><span class="comment">        xy索引的计算是通过 GridArrayAdapter::GetValue 获取栅格数据 </span></span><br><span class="line"><span class="comment">        取出每个点对应的栅格地图空闲概率（双三次插值之后的） p */</span></span><br><span class="line">        interpolator.<span class="built_in">Evaluate</span>(</span><br><span class="line">        <span class="comment">// 传进来的时候x和y都分别加了  kPadding</span></span><br><span class="line">        <span class="comment">// max的x y减掉真实的xy得到  cell_index</span></span><br><span class="line">        <span class="comment">/* kPadding是为了解决有些点可能跑到地图外面去的情况，所以加了一个超大的值</span></span><br><span class="line"><span class="comment">          即将地图上下左右边界分别扩大 kPadding，这是为了照顾ceres的Evaluate函数 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将坐标转换为栅格坐标，与子图坐标方向相反，双三次插值器自动计算中对应坐标的value</span></span><br><span class="line">        (limits.<span class="built_in">max</span>().<span class="built_in">x</span>() - world[<span class="number">0</span>]) / limits.<span class="built_in">resolution</span>() - <span class="number">0.5</span> +</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(kPadding),</span><br><span class="line">        (limits.<span class="built_in">max</span>().<span class="built_in">y</span>() - world[<span class="number">1</span>]) / limits.<span class="built_in">resolution</span>() - <span class="number">0.5</span> +</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(kPadding),</span><br><span class="line">        &amp;residual[i]  );</span><br><span class="line">        <span class="comment">// 因为有多个点，残差不是一维的，所有残差使用同一权重</span></span><br><span class="line">        residual[i] = scaling_factor_ * residual[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>占用栅格中原本存储的就是栅格空闲的概率，而这里<code>GetValue</code>查询出来的概率其实就是 <script type="math/tex">1-M_{smooth}\ \ (T_{\xi} H_k)</script>，令其最小化就对了</p>
<script type="math/tex; mode=display">每个残差权重=\frac{参数 occupied\ space\  weight} {\sqrt{点云数}}</script><p><code>GridArrayAdapter</code>是cartographer定义的，使用适配器模式，<code>interpolator</code>构造函数的参数需要的是模板里的类型。重要函数的是<code>GetValue</code>，调用的地方在<code>interpolator.Evaluate</code>里面。根源还是<code>BiCubicInterpolator</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GridArrayAdapter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> DATA_DIMENSION = <span class="number">1</span> &#125;;  <span class="comment">//被插值的向量维度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GridArrayAdapter</span><span class="params">(<span class="keyword">const</span> Grid2D&amp; grid)</span> : grid_(grid) &#123;</span>&#125;</span><br><span class="line">    <span class="comment">// 返回空闲概率， kPadding 是个很大的数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> row, <span class="keyword">const</span> <span class="keyword">int</span> column, <span class="keyword">double</span>* <span class="keyword">const</span> value)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="comment">// 处于地图外部时，赋予最大的free值</span></span><br><span class="line">      <span class="keyword">if</span>(row &lt; kPadding || column &lt; kPadding || </span><br><span class="line">      	row &gt;= <span class="built_in">NumRows</span>() - kPadding || column &gt;= <span class="built_in">NumCols</span>() - kPadding)</span><br><span class="line">        	*value = kMaxCorrespondenceCost;</span><br><span class="line">     <span class="comment">// 在地图里取空闲概率，这里需要减掉kPadding，因为在传进来的时候，已经加了kPadding</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        	*value = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(grid_.<span class="built_in">GetCorrespondenceCost</span>(</span><br><span class="line">            Eigen::<span class="built_in">Array2i</span>(column - kPadding, row - kPadding) )  );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumRows</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> grid_.<span class="built_in">limits</span>().<span class="built_in">cell_limits</span>().num_y_cells + <span class="number">2</span> * kPadding;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumCols</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> grid_.<span class="built_in">limits</span>().<span class="built_in">cell_limits</span>().num_x_cells + <span class="number">2</span> * kPadding;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> Grid2D&amp;  grid_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考: <a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15754466/5627571">ceres 三次插值</a><br><a target="_blank" rel="noopener" href="https://github.com/ceres-solver/ceres-solver/blob/master/include/ceres/cubic_interpolation.h">cubic_interpolation.h</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/09/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E6%A6%82%E7%8E%87%E7%9F%A5%E8%AF%86/">概率知识</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a></span><div class="content"><p>贝叶斯法则： <script type="math/tex">P(x|z) = \frac{P(z|x)P(x)}{P(z)}</script></p>
<p><script type="math/tex">P(x|z)</script>是后验， <script type="math/tex">P(z|x)</script> 是似然， <script type="math/tex">P(x)</script>是先验</p>
<ul>
<li>先验：指根据以往经验得到事件发生的概率</li>
</ul>
<p>最大后验： 使<script type="math/tex">P(x|z)</script>最大的x估计，比如分布是高斯分布，那么求出的是均值，比估计整个分布简单的多。 </p>
<p>有时求最大后验时，<script type="math/tex">P(x)</script>也不知道，所以只把似然最大化。</p>
<p>最大似然： 在什么状态下，最可能产生当前的观测。对于高斯分布，就是什么情况下最可能取得均值，让概率密度函数最大</p>
<p>在状态估计中，可以这么理解，先验就是没有得到观测值时的概率分布，似然就是观测的概率分布，后验就是在得到观测值后对先验校正后的概率分布。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/15/PCL%E7%82%B9%E4%BA%91/KD%E6%A0%91%E5%92%8C%E6%9C%80%E8%BF%91%E9%82%BB%E6%90%9C%E7%B4%A2/">KD树和最近邻搜索</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/PCL%E7%82%B9%E4%BA%91/">PCL点云</a></span><div class="content"><p>kD树的构建步骤：</p>
<ol>
<li><p>在K维数据集合中选择具有最大方差的维度k，然后在该维度上选择中值为pivot对该数据集合进行划分，得到两个子集合；同时创建一个树结点node，用于存储</p>
</li>
<li><p>对两个子集合重复（1）步骤的过程，直至所有子集合都不能再划分为止；</p>
</li>
</ol>
<ul>
<li><p>选择数据方差大的维度，是因为沿该坐标轴方向上数据点分散的比较开；另外可以减少最近邻搜索时的回溯代价，减少子树的访问</p>
</li>
<li><p>对于n个实例的k维数据来说，建立kd-tree的时间复杂度为 <script type="math/tex">O(k*n*logn)</script> ， 这有时会比较复杂</p>
</li>
</ul>
<h2 id="最近邻搜索"><a href="#最近邻搜索" class="headerlink" title="最近邻搜索"></a>最近邻搜索</h2><p>算法的时间复杂度是 <script type="math/tex">O(log\ n)</script><br>举例如下：<br><img src="https://s2.loli.net/2022/02/26/TR5Udj1KFEmeksC.png" alt="KD树构建"><br><img src="https://s2.loli.net/2022/02/26/gUTYFzSAe32fMZx.png" alt="坐标图"><br><img src="https://s2.loli.net/2022/02/27/dmfrgANo64Lxqj5.png" alt="搜索过程"></p>
<ul>
<li>不会去搜索根节点的另一颗子树</li>
<li>不需要计算每一个节点的欧式距离，而多数情况只需要计算点到超平面的距离就可以了。</li>
<li>KD树在维度较小时（比如20、30），算法的查找效率很高，然而当数据维度增大（例如：K≥100），查找效率会随着维度的增加而迅速下降。假设数据集的维数为 D，一般来说要求数据的规模 N 满足 <script type="math/tex">N>>2^D</script>，才能达到高效的搜索，否则大部分的点都会被查询。</li>
</ul>
<h2 id="PCL中的KD树"><a href="#PCL中的KD树" class="headerlink" title="PCL中的KD树"></a>PCL中的KD树</h2><p><code>nearestKSearch</code>参数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> pcl::search::Search&lt; PointT &gt;::<span class="built_in">nearestKSearch</span>(</span><br><span class="line">								<span class="keyword">const</span> PointCloud &amp; 	cloud,</span><br><span class="line">								<span class="keyword">int</span> 	k,</span><br><span class="line">								std::vector&lt; Indices &gt; &amp; 	k_indices,</span><br><span class="line">								std::vector&lt; std::vector&lt; <span class="keyword">float</span> &gt; &gt; &amp; 	k_sqr_distances </span><br><span class="line">) <span class="keyword">const</span></span><br></pre></td></tr></table></figure><br>对给定的点，搜索 k-nearest neighbors</p>
<p>参数：</p>
<ul>
<li>[in]    cloud    the point cloud data</li>
<li>[in]    k    the number of neighbors to search for</li>
<li>[out]    k_indices    the resultant indices of the neighboring points, k_indices[i] corresponds to the neighbors of the query point i</li>
<li>[out]    查询到的点的距离平方</li>
</ul>
<p>这个函数的返回值是 查询到的个数。</p>
<p>PCL中的KD-Tree一般适用于三维特征点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/kdtree/kdtree_flann.h&gt;</span>  <span class="comment">//kdtree近邻搜索</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/io/pcd_io.h&gt;</span>  <span class="comment">//文件输入输出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/point_types.h&gt;</span>  <span class="comment">//点类型相关定义</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl/visualization/cloud_viewer.h&gt;</span>  <span class="comment">//点类型相关定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 读取点云</span></span><br><span class="line">	pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::<span class="function">Ptr <span class="title">cloud</span><span class="params">(<span class="keyword">new</span> pcl::PointCloud&lt;pcl::PointXYZRGB&gt;)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (pcl::io::loadPCDFile&lt;pcl::PointXYZRGB&gt;(<span class="string">&quot;rabbit.pcd&quot;</span>, *cloud) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">PCL_ERROR</span>(<span class="string">&quot;Cloudn&#x27;t read file!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 原始点云着色</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cloud-&gt;points.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">		cloud-&gt;points[i].r = <span class="number">255</span>;</span><br><span class="line">		cloud-&gt;points[i].g = <span class="number">255</span>;</span><br><span class="line">		cloud-&gt;points[i].b = <span class="number">255</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  建立kd-tree</span></span><br><span class="line">	pcl::KdTreeFLANN&lt;pcl::PointXYZRGB&gt;  kdtree;  <span class="comment">//建立kdtree对象</span></span><br><span class="line">	kdtree.<span class="built_in">setInputCloud</span>(cloud); <span class="comment">//设置需要建立kdtree的点云指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//   K近邻搜索</span></span><br><span class="line">	pcl::PointXYZRGB searchPoint = cloud-&gt;points[<span class="number">1000</span>];   <span class="comment">// 设置查找点</span></span><br><span class="line">	<span class="keyword">int</span> K = <span class="number">900</span>;  <span class="comment">//设置需要查找的近邻点个数</span></span><br><span class="line">	<span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">pointIdxNKNSearch</span><span class="params">(K)</span></span>;  <span class="comment">//  保存每个近邻点的索引</span></span><br><span class="line">	<span class="function">std::vector&lt;<span class="keyword">float</span>&gt; <span class="title">pointNKNSquaredDistance</span><span class="params">(K)</span></span>; <span class="comment">// 保存每个近邻点与查找点之间的欧式距离平方</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kdtree.<span class="built_in">nearestKSearch</span>(searchPoint, K, pointIdxNKNSearch, pointNKNSquaredDistance) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; pointIdxNKNSearch.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">			cloud-&gt;points[pointIdxNKNSearch[i]].r = <span class="number">0</span>;</span><br><span class="line">			cloud-&gt;points[pointIdxNKNSearch[i]].g = <span class="number">255</span>;</span><br><span class="line">			cloud-&gt;points[pointIdxNKNSearch[i]].b = <span class="number">0</span>;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;K = 900近邻点个数：&quot;</span> &lt;&lt; pointIdxNKNSearch.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//   显示点云</span></span><br><span class="line">	pcl::<span class="function">visualization::CloudViewer <span class="title">viewer</span><span class="params">(<span class="string">&quot;cloud viewer&quot;</span>)</span></span>;</span><br><span class="line">	viewer.<span class="built_in">showCloud</span>(cloud);</span><br><span class="line">	<span class="comment">// 或者 pause()</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果运行时出现报警 <font size="4" color="orange"> Failed to find match for field ‘rgb’  </font>，则把<code>pcl::PointXYZRGBA&gt;</code>改为<code>pcl::PointXYZ&gt;</code></p>
<p><img src="https://s2.loli.net/2022/02/15/La14Fe6wiCg52J7.png" alt="KD树和八叉树的比较"></p>
<p>从搜索点数来看，当原点云与目标点云重叠区域较大时，优先选择<code>nearestKSearch</code>接口来寻找最近邻，否则优先使用<code>radiusSearch</code>接口来寻找最近邻。 PCL的ICP用的就是 <code>nearestKSearch</code></p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/HelloJinYe/article/details/106587816">点云数据通过pcl的kdtree搜索关键点某半径邻域内的区域</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/15/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/63/">63</a><a class="extend next" rel="next" href="/page/17/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2023 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>