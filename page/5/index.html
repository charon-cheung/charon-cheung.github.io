<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">624</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">51</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2022/12/24/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/landmark%E7%9A%84%E6%B7%BB%E5%8A%A0%E6%AE%8B%E5%B7%AE%E5%9D%97/">landmark的添加残差块</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-12-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">problem-&gt;<span class="built_in">AddResidualBlock</span>(</span><br><span class="line">    LandmarkCostFunction2D::<span class="built_in">CreateAutoDiffCostFunction</span>(</span><br><span class="line">        observation, prev-&gt;data, next-&gt;data),</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> ceres::<span class="built_in">HuberLoss</span>(huber_scale), </span><br><span class="line">    prev_node_pose-&gt;<span class="built_in">data</span>(),  next_node_pose-&gt;<span class="built_in">data</span>(), </span><br><span class="line">    C_landmarks-&gt;<span class="built_in">at</span>(landmark_id).<span class="built_in">rotation</span>(),</span><br><span class="line">    C_landmarks-&gt;<span class="built_in">at</span>(landmark_id).<span class="built_in">translation</span>() );</span><br></pre></td></tr></table></figure>
<h2 id="CreateAutoDiffCostFunction"><a href="#CreateAutoDiffCostFunction" class="headerlink" title="CreateAutoDiffCostFunction"></a>CreateAutoDiffCostFunction</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">static</span> ceres::CostFunction* <span class="title">CreateAutoDiffCostFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> LandmarkObservation&amp; observation, <span class="keyword">const</span> NodeSpec2D&amp; prev_node,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> NodeSpec2D&amp; next_node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ceres::AutoDiffCostFunction&lt;</span><br><span class="line">        LandmarkCostFunction2D,</span><br><span class="line">        <span class="number">6</span> <span class="comment">/* residuals，operator() return的是6维向量 */</span>,</span><br><span class="line">                    <span class="comment">// 所估计变量的维度</span></span><br><span class="line">        <span class="number">3</span> <span class="comment">/* previous node pose variables (x,y,theta) */</span>, </span><br><span class="line">        <span class="number">3</span> <span class="comment">/* next node pose variables  (x,y,theta)  */</span>,</span><br><span class="line">        <span class="number">4</span> <span class="comment">/* landmark rotation variables  */</span>,</span><br><span class="line">        <span class="number">3</span> <span class="comment">/* landmark translation variables */</span>&gt;(</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">LandmarkCostFunction2D</span>(observation, prev_node, next_node));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T* <span class="keyword">const</span> prev_node_pose, <span class="keyword">const</span> T* <span class="keyword">const</span> next_node_pose,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">const</span> T* <span class="keyword">const</span> landmark_rotation,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">const</span> T* <span class="keyword">const</span> landmark_translation,</span></span></span><br><span class="line"><span class="params"><span class="function">                  T* <span class="keyword">const</span> e)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> std::tuple&lt;std::array&lt;T, 4&gt;, std::array&lt;T, 3&gt;&gt;</span><br><span class="line">        interpolated_rotation_and_translation = <span class="built_in">InterpolateNodes2D</span>(</span><br><span class="line">            prev_node_pose, prev_node_gravity_alignment_, next_node_pose,</span><br><span class="line">            next_node_gravity_alignment_, interpolation_parameter_);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> std::array&lt;T, 6&gt; error = <span class="built_in">ScaleError</span>(</span><br><span class="line">        <span class="built_in">ComputeUnscaledError</span>(</span><br><span class="line">            landmark_to_tracking_transform_,</span><br><span class="line">            std::get&lt;<span class="number">0</span>&gt;(interpolated_rotation_and_translation).<span class="built_in">data</span>(),</span><br><span class="line">            std::get&lt;<span class="number">1</span>&gt;(interpolated_rotation_and_translation).<span class="built_in">data</span>(),</span><br><span class="line">            landmark_rotation, landmark_translation),</span><br><span class="line">        translation_weight_, rotation_weight_);</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(error), std::<span class="built_in">end</span>(error), e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ComputeUnscaledError"><a href="#ComputeUnscaledError" class="headerlink" title="ComputeUnscaledError"></a>ComputeUnscaledError</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> std::array&lt;T, 6&gt; <span class="title">ComputeUnscaledError</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> transform::Rigid3d&amp;  relative_pose, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> T* <span class="keyword">const</span> start_rotation,  <span class="keyword">const</span> T* <span class="keyword">const</span> start_translation, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> T* <span class="keyword">const</span> end_rotation,    <span class="keyword">const</span> T* <span class="keyword">const</span> end_translation )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 四元数共轭，在这里就是逆</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> Eigen::Quaternion&lt;T&gt; <span class="title">R_i_inverse</span><span class="params">( start_rotation[<span class="number">0</span>],</span></span></span><br><span class="line"><span class="params"><span class="function">                                         -start_rotation[<span class="number">1</span>],</span></span></span><br><span class="line"><span class="params"><span class="function">                                         -start_rotation[<span class="number">2</span>],</span></span></span><br><span class="line"><span class="params"><span class="function">                                         -start_rotation[<span class="number">3</span>] )</span></span>;</span><br><span class="line">    <span class="comment">// 平移的差</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> Eigen::Matrix&lt;T, 3, 1&gt; <span class="title">delta</span><span class="params">(end_translation[<span class="number">0</span>] - start_translation[<span class="number">0</span>],</span></span></span><br><span class="line"><span class="params"><span class="function">                                     end_translation[<span class="number">1</span>] - start_translation[<span class="number">1</span>],</span></span></span><br><span class="line"><span class="params"><span class="function">                                     end_translation[<span class="number">2</span>] - start_translation[<span class="number">2</span>])</span></span>;</span><br><span class="line">  <span class="keyword">const</span> Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; h_translation = R_i_inverse * delta;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Eigen::Quaternion&lt;T&gt; h_rotation_inverse =</span><br><span class="line">      Eigen::Quaternion&lt;T&gt;(end_rotation[<span class="number">0</span>], -end_rotation[<span class="number">1</span>], </span><br><span class="line">                          -end_rotation[<span class="number">2</span>], -end_rotation[<span class="number">3</span>]) *</span><br><span class="line">      Eigen::Quaternion&lt;T&gt;(start_rotation[<span class="number">0</span>], start_rotation[<span class="number">1</span>],</span><br><span class="line">                           start_rotation[<span class="number">2</span>], start_rotation[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Eigen::Matrix&lt;T, <span class="number">3</span>, <span class="number">1</span>&gt; angle_axis_difference =</span><br><span class="line">      transform::<span class="built_in">RotationQuaternionToAngleAxisVector</span>(</span><br><span class="line">          h_rotation_inverse * relative_pose.<span class="built_in">rotation</span>().cast&lt;T&gt;());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;  &#123;<span class="built_in">T</span>(relative_pose.<span class="built_in">translation</span>().<span class="built_in">x</span>()) - h_translation[<span class="number">0</span>],</span><br><span class="line">             <span class="built_in">T</span>(relative_pose.<span class="built_in">translation</span>().<span class="built_in">y</span>()) - h_translation[<span class="number">1</span>],</span><br><span class="line">             <span class="built_in">T</span>(relative_pose.<span class="built_in">translation</span>().<span class="built_in">z</span>()) - h_translation[<span class="number">2</span>],</span><br><span class="line">           angle_axis_difference[<span class="number">0</span>], </span><br><span class="line">           angle_axis_difference[<span class="number">1</span>],</span><br><span class="line">           angle_axis_difference[<span class="number">2</span>]&#125;  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>relative_pose</code> 是 <code>landmark_to_tracking_transform</code>，landmark和tracking坐标系的相对位姿，在<code>SensorBridge::HandleLandmarkMessage</code>中获得<br><img src="https://s2.loli.net/2022/12/24/lyuNW3ix6gZOh7R.png" alt=""><br><img src="https://s2.loli.net/2022/12/24/RC7pznglYG26iaL.png" alt=""></p>
<p>landmark作为独立变量进入Pose Graph的稀疏优化，它增加的优化维度是 <code>landmarks个数 * 每个landmark的参数个数</code>，不要使用太多landmark</p>
<p><code>ScaleError</code>一看就是残差乘以权重<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::array&lt;T, 3&gt; <span class="title">ScaleError</span><span class="params">( <span class="keyword">const</span> std::array&lt;T, <span class="number">3</span>&gt;&amp; error,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">double</span> translation_weight,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">double</span> rotation_weight )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#123;</span><br><span class="line">      error[<span class="number">0</span>] * translation_weight,</span><br><span class="line">      error[<span class="number">1</span>] * translation_weight,</span><br><span class="line">      error[<span class="number">2</span>] * rotation_weight</span><br><span class="line">  &#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/12/22/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/landmark%E7%9A%84%E5%90%8E%E7%AB%AF%E5%A4%84%E7%90%86/">landmark的后端处理</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-12-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>加入landmark后，Pose Graph有了不同的node和edge，也就是landmark也作为node，landmark-pose之间的 edge是新的一种edge，即在pose对landmark的观测</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LandmarkNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LandmarkObservation</span> &#123;</span></span><br><span class="line">      <span class="keyword">int</span> trajectory_id;</span><br><span class="line">      common::Time time;</span><br><span class="line">      transform::Rigid3d landmark_to_tracking_transform;</span><br><span class="line">      <span class="keyword">double</span> translation_weight;</span><br><span class="line">      <span class="keyword">double</span> rotation_weight;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 同一时刻，可能观测到多个landmark数据</span></span><br><span class="line">    std::vector&lt;LandmarkObservation&gt; landmark_observations;</span><br><span class="line">    absl::optional&lt;transform::Rigid3d&gt; global_landmark_pose;</span><br><span class="line">    <span class="keyword">bool</span> frozen = <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>landmark是应用于后端，不是实时的，应当调大权重让carto更相信它的结果</p>
<p>添加数据部分<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::AddLandmarkData</span><span class="params">(<span class="keyword">int</span> trajectory_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">const</span> sensor::LandmarkData&amp; landmark_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">AddWorkItem</span>([=]() <span class="built_in">LOCKS_EXCLUDED</span>(mutex_) &#123;</span><br><span class="line">    absl::MutexLock <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CanAddWorkItemModifying</span>(trajectory_id)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; observation : landmark_data.landmark_observations)</span><br><span class="line">      &#123;</span><br><span class="line">      	          			<span class="comment">// initial landmark_nodes</span></span><br><span class="line">          <span class="comment">// const transform::Rigid3d global_pose =</span></span><br><span class="line">          <span class="comment">// observation.landmark_to_map_transform;</span></span><br><span class="line">      <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">      data_.landmark_nodes的类型是 std::map&lt;std::string <span class="comment">/* landmark ID */</span>, PoseGraphInterface::LandmarkNode&gt;</span><br><span class="line">      <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        data_.landmark_nodes[observation.id].landmark_observations.<span class="built_in">emplace_back</span>(</span><br><span class="line">            PoseGraphInterface::LandmarkNode::LandmarkObservation&#123;</span><br><span class="line">                trajectory_id, landmark_data.time,</span><br><span class="line">                observation.landmark_to_tracking_transform,</span><br><span class="line">                observation.translation_weight, observation.rotation_weight&#125; );</span><br><span class="line"></span><br><span class="line">          <span class="comment">// data_.landmark_nodes[observation.id].global_landmark_pose = global_pose;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// optimization_problem_-&gt;new_landmark_add_ = true;</span></span><br><span class="line">    <span class="keyword">return</span> WorkItem::Result::kDoNotRunOptimization;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里就是把观测到的landmark信息都保存到<code>data_.landmark_nodes</code>，最后返回的标识也是不优化</p>
<p>后端优化的流程和其他传感器数据一样:<br><code>PoseGraph2D::HandleWorkQueue</code> —— <code>PoseGraph2D::RunOptimization</code> —— <code>OptimizationProblem2D::Solve(data_.constraints, GetTrajectoryStates(), data_.landmark_nodes)</code> —— <code>AddLandmarkCostFunctions(landmark_nodes, node_data_, &amp;C_nodes, &amp;C_landmarks, &amp;problem, options_.huber_scale() )</code></p>
<p><code>OptimizationProblem2D::Solve</code>部分：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">  std::set&lt;<span class="keyword">int</span>&gt; frozen_trajectories;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; it : trajectories_state)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (it.second == PoseGraphInterface::TrajectoryState::FROZEN)</span><br><span class="line">    &#123;</span><br><span class="line">      frozen_trajectories.<span class="built_in">insert</span>(it.first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ceres::Problem::Options problem_options;</span><br><span class="line">  <span class="function">ceres::Problem <span class="title">problem</span><span class="params">(problem_options)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the starting point.  TODO(hrapp): Move ceres data into SubmapSpec.</span></span><br><span class="line">  <span class="comment">// ceres需要的是double指针，std::array 能转成原始指针的形式</span></span><br><span class="line">  MapById&lt;SubmapId, std::array&lt;<span class="keyword">double</span>, 3&gt;&gt; C_submaps;</span><br><span class="line">  MapById&lt;NodeId, std::array&lt;<span class="keyword">double</span>, 3&gt;&gt; C_nodes;</span><br><span class="line">  std::map&lt;std::string, CeresPose&gt; C_landmarks;</span><br><span class="line">  <span class="keyword">bool</span> first_submap = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将需要优化的  子图位姿  设置为优化参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; submap_id_data : submap_data_) &#123;</span><br><span class="line">    <span class="comment">// submap_id的轨迹是否是冻结的</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> frozen =</span><br><span class="line">        frozen_trajectories.<span class="built_in">count</span>(submap_id_data.id.trajectory_id) != <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将子图的global_pose放入 C_submaps</span></span><br><span class="line">    C_submaps.<span class="built_in">Insert</span>(submap_id_data.id,</span><br><span class="line">                     <span class="built_in">FromPose</span>(submap_id_data.data.global_pose));</span><br><span class="line">    <span class="comment">// c++11中，std::array::data()返回指向数组对象第一个元素的指针</span></span><br><span class="line">    problem.<span class="built_in">AddParameterBlock</span>(C_submaps.<span class="built_in">at</span>(submap_id_data.id).<span class="built_in">data</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个子图或冻结，不优化子图位姿。 也就是不优化初值</span></span><br><span class="line">    <span class="keyword">if</span> (first_submap || frozen) &#123;</span><br><span class="line">      first_submap = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// Fix the pose of the first submap or all submaps of a frozen</span></span><br><span class="line">      <span class="comment">// trajectory.</span></span><br><span class="line">      problem.<span class="built_in">SetParameterBlockConstant</span>(C_submaps.<span class="built_in">at</span>(submap_id_data.id).<span class="built_in">data</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要优化的  节点位姿  设置为优化参数，与上面的子图优化大致相同</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; node_id_data : node_data_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> frozen =</span><br><span class="line">        frozen_trajectories.<span class="built_in">count</span>(node_id_data.id.trajectory_id) != <span class="number">0</span>;</span><br><span class="line">    C_nodes.<span class="built_in">Insert</span>(node_id_data.id, <span class="built_in">FromPose</span>(node_id_data.data.global_pose_2d));</span><br><span class="line">    problem.<span class="built_in">AddParameterBlock</span>(C_nodes.<span class="built_in">at</span>(node_id_data.id).<span class="built_in">data</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (frozen)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 这里的第一个节点也要参与优化，跟子图的不同了</span></span><br><span class="line">      problem.<span class="built_in">SetParameterBlockConstant</span>(C_nodes.<span class="built_in">at</span>(node_id_data.id).<span class="built_in">data</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">				<span class="comment">/* ...... */</span></span><br><span class="line"><span class="comment">// 第2种残差：landmark与landmark数据插值出来的节点相对位姿的差值</span></span><br><span class="line"><span class="built_in">AddLandmarkCostFunctions</span>(landmark_nodes, node_data_, </span><br><span class="line">						&amp;C_nodes, &amp;C_landmarks,</span><br><span class="line">                        &amp;problem, options_.<span class="built_in">huber_scale</span>()  );</span><br></pre></td></tr></table></figure></p>
<p>landmark数据 与 通过2个节点位姿插值出来的相对位姿 的差值作为残差项</p>
<h2 id="AddLandmarkCostFunctions"><a href="#AddLandmarkCostFunctions" class="headerlink" title="AddLandmarkCostFunctions"></a>AddLandmarkCostFunctions</h2><p>最外层两个循环是遍历landmark节点和遍历每个节点的观测，也就是说可能会同时看到多个landmark。直接看循环里面的内容<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> std::string&amp; landmark_id = landmark_node.first;</span><br><span class="line"><span class="comment">// 轨迹中第一个 node_data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; begin_of_trajectory =</span><br><span class="line">    node_data.<span class="built_in">BeginOfTrajectory</span>(observation.trajectory_id);</span><br><span class="line"><span class="comment">// 如果 landmark observation was made before the trajectory was created</span></span><br><span class="line"><span class="keyword">if</span> (observation.time &lt; begin_of_trajectory-&gt;data.time) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 以下语句Find the trajectory nodes before and after the landmark observation */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到在landmark观测时间后的第一个节点</span></span><br><span class="line"><span class="keyword">auto</span> next = </span><br><span class="line">    node_data.<span class="built_in">lower_bound</span>(observation.trajectory_id, observation.time);</span><br><span class="line"><span class="comment">/*  The landmark observation was made, but the next trajectory node has</span></span><br><span class="line"><span class="comment">    not been added yet. 即next已经是轨迹最后一个节点  */</span></span><br><span class="line"><span class="keyword">if</span> (next == node_data.<span class="built_in">EndOfTrajectory</span>(observation.trajectory_id)  ) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果是刚开始的node data</span></span><br><span class="line"><span class="keyword">if</span> (next == begin_of_trajectory) &#123;</span><br><span class="line">  next = std::<span class="built_in">next</span>(next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的pre配合next是为了获取两个位置，找到landmark观测时间的前一个节点</span></span><br><span class="line"><span class="keyword">auto</span> prev = std::<span class="built_in">prev</span>(next);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据两个索引，获取两个节点位姿</span></span><br><span class="line"><span class="comment">// Add parameter blocks for the landmark ID if they were not added before</span></span><br><span class="line">std::array&lt;<span class="keyword">double</span>, 3&gt;* prev_node_pose = &amp;C_nodes-&gt;<span class="built_in">at</span>(prev-&gt;id);</span><br><span class="line">std::array&lt;<span class="keyword">double</span>, 3&gt;* next_node_pose = &amp;C_nodes-&gt;<span class="built_in">at</span>(next-&gt;id);</span><br></pre></td></tr></table></figure><br>根据landmark观测的时间，找到观测前后的节点，获取位姿</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果landmark_id 不存在于 C_landmarks，</span></span><br><span class="line"><span class="keyword">if</span> (!C_landmarks-&gt;<span class="built_in">count</span>(landmark_id))&#123;</span><br><span class="line">  <span class="comment">// landmark如果已经优化，则 global_landmark_pose 有值</span></span><br><span class="line">  <span class="comment">// 否则根据时间插值计算一个位姿</span></span><br><span class="line">  <span class="keyword">const</span> transform::Rigid3d starting_point =</span><br><span class="line">      landmark_node.second.global_landmark_pose.<span class="built_in">has_value</span>()</span><br><span class="line">          ? landmark_node.second.global_landmark_pose.<span class="built_in">value</span>()</span><br><span class="line">          : <span class="built_in">GetInitialLandmarkPose</span>(observation, prev-&gt;data, next-&gt;data,</span><br><span class="line">                                   *prev_node_pose, *next_node_pose);</span><br></pre></td></tr></table></figure>
<p>开始<code>C_landmarks</code>当然为空，只有在优化完成后，这里才存在，即 <code>RunOptimization</code> 的最后会添加: <code>data_.landmark_nodes[landmark.first].global_landmark_pose = landmark.second;</code>，顺着上面的调用路线就能发现</p>
<h3 id="GetInitialLandmarkPose"><a href="#GetInitialLandmarkPose" class="headerlink" title="GetInitialLandmarkPose"></a>GetInitialLandmarkPose</h3><p>这里用了一堆数据类型转换，以及四元数、旋转向量、欧拉角之间的转换。还重新实现了slerp函数<code>SlerpQuaternions</code>，因为Eigen的slerp与Ceres的不兼容。<br><img src="https://s2.loli.net/2022/12/24/Mr3kVGcnqd9EulW.png" alt="过程"></p>
<p><br></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  C_landmarks-&gt;<span class="built_in">emplace</span>(</span><br><span class="line">      landmark_id,</span><br><span class="line">      <span class="comment">// 四元数不支持广义加法，使用QuaternionParameterization </span></span><br><span class="line">      <span class="built_in">CeresPose</span>(starting_point, <span class="literal">nullptr</span> <span class="comment">/* translation_parametrization */</span>,</span><br><span class="line">                absl::make_unique&lt;ceres::QuaternionParameterization&gt;(),</span><br><span class="line">                problem)  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set landmark constant if it is frozen. 不参与优化</span></span><br><span class="line">  <span class="comment">// 这里容易记不清，frozen 定义在  struct LandmarkNode</span></span><br><span class="line">  <span class="keyword">if</span> (landmark_node.second.frozen) &#123;</span><br><span class="line">    problem-&gt;<span class="built_in">SetParameterBlockConstant</span>(</span><br><span class="line">        C_landmarks-&gt;<span class="built_in">at</span>(landmark_id).<span class="built_in">translation</span>());</span><br><span class="line"></span><br><span class="line">    problem-&gt;<span class="built_in">SetParameterBlockConstant</span>(</span><br><span class="line">        C_landmarks-&gt;<span class="built_in">at</span>(landmark_id).<span class="built_in">rotation</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CeresPose</code>的构造函数里就两行<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">problem-&gt;<span class="built_in">AddParameterBlock</span>(data_-&gt;translation.<span class="built_in">data</span>(), <span class="number">3</span>,</span><br><span class="line">                         translation_parametrization.<span class="built_in">release</span>());</span><br><span class="line">problem-&gt;<span class="built_in">AddParameterBlock</span>(data_-&gt;rotation.<span class="built_in">data</span>(), <span class="number">4</span>,</span><br><span class="line">                         rotation_parametrization.<span class="built_in">release</span>());</span><br></pre></td></tr></table></figure><br>对于平移，无需<code>ceres::LocalParameterization</code></p>
<p><br></p>
<h3 id="添加残差块"><a href="#添加残差块" class="headerlink" title="添加残差块"></a>添加残差块</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">problem-&gt;<span class="built_in">AddResidualBlock</span>(</span><br><span class="line">    LandmarkCostFunction2D::<span class="built_in">CreateAutoDiffCostFunction</span>(</span><br><span class="line">        observation, prev-&gt;data, next-&gt;data),</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> ceres::<span class="built_in">HuberLoss</span>(huber_scale), </span><br><span class="line">    prev_node_pose-&gt;<span class="built_in">data</span>(),  next_node_pose-&gt;<span class="built_in">data</span>(), </span><br><span class="line">    C_landmarks-&gt;<span class="built_in">at</span>(landmark_id).<span class="built_in">rotation</span>(),</span><br><span class="line">    C_landmarks-&gt;<span class="built_in">at</span>(landmark_id).<span class="built_in">translation</span>() );</span><br></pre></td></tr></table></figure>
<p><code>if (!C_landmarks-&gt;count(landmark_id))</code>已经结束，添加残差块。</p>
<h2 id="Solve-和-RunOptimization-的最后处理"><a href="#Solve-和-RunOptimization-的最后处理" class="headerlink" title="Solve 和 RunOptimization 的最后处理"></a>Solve 和 RunOptimization 的最后处理</h2><p><code>Solve</code>的最后<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; C_landmark : C_landmarks) &#123;</span><br><span class="line">	<span class="comment">// first 是 landmark_id</span></span><br><span class="line">	landmark_data_[C_landmark.first] = C_landmark.second.<span class="built_in">ToRigid</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个<code>C_landmarks</code>还是上面那个，<code>ToRigid()</code>当然是优化后的landmark全局位姿了</p>
<p>在<code>RunOptimization</code>的最后<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历成员变量 landmark_data_，它在 Solve 函数的最后赋值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; landmark : optimization_problem_-&gt;<span class="built_in">landmark_data</span>() )</span><br><span class="line">&#123;</span><br><span class="line">	 <span class="comment">// first 是 landmark_id</span></span><br><span class="line">  data_.landmark_nodes[landmark.first].global_landmark_pose = landmark.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>optimization_problem_-&gt;landmark_data()</code>返回的就是上面的<code>landmark_data_</code>，说白了，这里就是把优化后的landmark数据从<code>OptimizationProblem2D</code>层传回<code>PoseGraph2D</code>层</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/12/22/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/landmark%E7%9A%84%E5%89%8D%E7%AB%AF%E5%A4%84%E7%90%86/">landmark的前端处理</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-12-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>landmark就是添加了一个观测，让定位更鲁棒。</p>
<p>In order to make Cartographer calculations deterministic we strictly time order sensor data using the collator. But you only know in what order to publish data when you have already seen data from all other sources. Sparse sources pose a problem to that strategy.</p>
<p>如果观测是空的，应当发布空的 landmark messages to unblock the queue. 对于fixed frame poses (GPS)也适用。</p>
<h2 id="前端的处理"><a href="#前端的处理" class="headerlink" title="前端的处理"></a>前端的处理</h2><h3 id="node-cc-层"><a href="#node-cc-层" class="headerlink" title="node.cc 层"></a><code>node.cc</code> 层</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// landmark_poses_list 话题</span></span><br><span class="line">  landmark_poses_list_publisher_ =</span><br><span class="line">      node_handle_.advertise&lt;::visualization_msgs::MarkerArray&gt;(</span><br><span class="line">          kLandmarkPosesListTopic, kLatestOnlyPublisherQueueSize);</span><br></pre></td></tr></table></figure>
<p>发布话题：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Node::PublishLandmarkPosesList</span><span class="params">(<span class="keyword">const</span> ::ros::WallTimerEvent&amp; unused_timer_event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (landmark_poses_list_publisher_.<span class="built_in">getNumSubscribers</span>() &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function">absl::MutexLock <span class="title">lock</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">      landmark_poses_list_publisher_.<span class="built_in">publish</span>(map_builder_bridge_.<span class="built_in">GetLandmarkPosesList</span>() );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>处理传感器数据<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Node::HandleLandmarkMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">int</span> trajectory_id, <span class="keyword">const</span> std::string&amp; sensor_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> cartographer_ros_msgs::LandmarkList::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">absl::MutexLock <span class="title">lock</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!sensor_samplers_.<span class="built_in">at</span>(trajectory_id).landmark_sampler.<span class="built_in">Pulse</span>()) </span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">CHECK</span>(msg-&gt;landmarks.<span class="built_in">size</span>() != <span class="number">0</span>) &lt;&lt; <span class="string">&quot;No Landmarks !&quot;</span>;</span><br><span class="line"></span><br><span class="line">  map_builder_bridge_.<span class="built_in">sensor_bridge</span>(trajectory_id)-&gt;<span class="built_in">HandleLandmarkMessage</span>(sensor_id, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="sensor-bridge-cc-层"><a href="#sensor-bridge-cc-层" class="headerlink" title="sensor_bridge.cc 层"></a><code>sensor_bridge.cc</code> 层</h3><p>用到的类型<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LandmarkData</span> &#123;</span></span><br><span class="line">  common::Time time;</span><br><span class="line">  std::vector&lt;LandmarkObservation&gt; landmark_observations;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LandmarkObservation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  std::string id;</span><br><span class="line">  transform::Rigid3d landmark_to_tracking_transform;</span><br><span class="line">  <span class="keyword">double</span> translation_weight;</span><br><span class="line">  <span class="keyword">double</span> rotation_weight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>landmark的观测是相对于 tracking frame<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SensorBridge::HandleLandmarkMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::string&amp; sensor_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> cartographer_ros_msgs::LandmarkList::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> landmark_data = <span class="built_in">ToLandmarkData</span>(*msg);</span><br><span class="line">  <span class="keyword">auto</span> tracking_from_landmark_sensor = tf_bridge_.<span class="built_in">LookupToTracking</span>(</span><br><span class="line">      landmark_data.time, <span class="built_in">CheckNoLeadingSlash</span>(msg-&gt;header.frame_id));</span><br><span class="line">  <span class="comment">// 把相机对landmark的观测，转换到 tracking 坐标系</span></span><br><span class="line">  <span class="keyword">if</span> (tracking_from_landmark_sensor != <span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; observation : landmark_data.landmark_observations)</span><br><span class="line">      &#123;</span><br><span class="line">        observation.landmark_to_tracking_transform =</span><br><span class="line">            *tracking_from_landmark_sensor *</span><br><span class="line">            observation.landmark_to_tracking_transform;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 进入传感器数据融合阶段</span></span><br><span class="line">  trajectory_builder_-&gt;<span class="built_in">AddSensorData</span>(sensor_id, landmark_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单的类型转换而已<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LandmarkData <span class="title">ToLandmarkData</span><span class="params">(<span class="keyword">const</span> LandmarkList&amp; landmark_list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LandmarkData landmark_data;</span><br><span class="line">    landmark_data.time = <span class="built_in">FromRos</span>(landmark_list.header.stamp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> LandmarkEntry&amp; entry : landmark_list.landmark)</span><br><span class="line">    &#123;</span><br><span class="line">        landmark_data.landmark_observations.<span class="built_in">push_back</span>(</span><br><span class="line">        &#123;entry.id, <span class="built_in">ToRigid3d</span>(entry.tracking_from_landmark_transform),</span><br><span class="line">         entry.translation_weight, <span class="number">10</span>, entry.type&#125;);</span><br><span class="line">         <span class="comment">//LOG(INFO) &lt;&lt; &quot;find landmark x: &quot; &lt;&lt; entry.tracking_from_landmark_transform.position.x;</span></span><br><span class="line">         <span class="comment">//LOG(INFO) &lt;&lt; &quot;find landmark y: &quot; &lt;&lt; entry.tracking_from_landmark_transform.position.y;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> landmark_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数据融合阶段"><a href="#数据融合阶段" class="headerlink" title="数据融合阶段"></a>数据融合阶段</h2><p><code>CollatedTrajectoryBuilder</code>类<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddSensorData</span><span class="params">(<span class="keyword">const</span> std::string&amp; sensor_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> sensor::LandmarkData&amp; landmark_data)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (collate_landmarks_)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">AddData</span>(sensor::<span class="built_in">MakeDispatchable</span>(sensor_id, landmark_data));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wrapped_trajectory_builder_ 赋值在 CollatedTrajectoryBuilder 构造函数</span></span><br><span class="line">    <span class="comment">// 应当为map_builder_-&gt;GetTrajectoryBuilder(trajectory_id)</span></span><br><span class="line">    wrapped_trajectory_builder_-&gt;<span class="built_in">AddSensorData</span>(sensor_id, landmark_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>collate_landmarks</code>的设置问题</li>
</ul>
<p>在<code>CollatedTrajectoryBuilder</code>的构造函数里体现，比较坑的是设置为<code>on</code>或<code>off</code>，不是true, false<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sensor_id.type == SensorId::SensorType::LANDMARK &amp;&amp;</span><br><span class="line">    !collate_landmarks_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果提供landmark的观测不低于10 Hz，那么可以设置<code>TRAJECTORY_BUILDER.collate_landmarks = on</code>. Cartographer将deterministically运行(对于给定的bag, 使用offline node每次获得的结果是一样的). 如果<code>collate_landmarks = off</code>， landmark observations将跳过<code>sensor queue</code> (so they do not block it if they are sparse) and are injected directly into the pose graph, which is not deterministic. </p>
<p>但是看到另一种说法，在 <code>#1224</code>更新版本，作者提出如果有landmark，<code>collate_landmarks</code>就要为 false。这个再观察</p>
<p>接下来进入<code>GlobalTrajectoryBuilder</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddSensorData</span><span class="params">(<span class="keyword">const</span> std::string&amp; sensor_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> sensor::LandmarkData&amp; landmark_data)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   pose_graph_-&gt;<span class="built_in">AddLandmarkData</span>(trajectory_id_, landmark_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里可以看到landmark数据直接进后端，前端没有它的事了</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/12/14/%E6%BF%80%E5%85%89SLAM/%E6%97%B7%E8%A7%86%E7%9A%84CamLaserCalibraTool/">旷视的CamLaserCalibraTool</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-12-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/%E5%85%B6%E4%BB%96/">其他</a></span><div class="content"><p>看到网上有些人说标定结果不错，但我试了很多次，开始还能出运行结果，但是和实际差太多，后来换了个相机，几乎不能运行成功了。kalibr图案、棋盘格、apriltag都试过了，代码调试了很多地方，都不顺利，看github也有很多issue未解决，先搁置了</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><code>laser_filter</code>的配置<code>filter.yaml</code>修改如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scan_filter_chain:</span><br><span class="line">- name: angle</span><br><span class="line">  type: laser_filters/LaserScanAngularBoundsFilter</span><br><span class="line">  params:</span><br><span class="line">    lower_angle: -<span class="number">0.6</span></span><br><span class="line">    upper_angle: <span class="number">0.6</span></span><br><span class="line">- name: range</span><br><span class="line">  type: laser_filters/LaserScanRangeFilter</span><br><span class="line">  params:</span><br><span class="line">    use_message_range_limits: <span class="keyword">false</span></span><br><span class="line">    lower_threshold: <span class="number">0.5</span></span><br><span class="line">    upper_threshold: <span class="number">2.2</span></span><br></pre></td></tr></table></figure></p>
<p>配置文件中的<code>tag_spacing = 0.3</code>并不是<code>tag_spacing</code>的实际距离大小，而是比例：8.8x0.3=2.64，因此这里的tag_spacing是一个固定值为0.3，不用修改！</p>
<p>录制bag要包括雷达scan和图像<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag record scan_filtered /camera_node/image_raw -O pinhole.bag</span><br></pre></td></tr></table></figure><br><code>roslaunch lasercamcal_ros kalibra_apriltag.launch</code>会把检测到每一帧中的april的信息保存到<code>apriltag_pose.txt</code>文件中，作者录制的数据包有1527 msgs，最终也是每一帧都检测到了，我录制的bag有时会有一些帧检测不到，似乎不是什么问题。<br><img src="https://s2.loli.net/2022/12/19/v4d5yGonMcBhSuL" alt=""><br>作者也是没有对录制的包直接做数据时间同步的，相机的帧率大概是2D激光雷达的二倍</p>
<h2 id="移动标定板"><a href="#移动标定板" class="headerlink" title="移动标定板"></a>移动标定板</h2><p>要求是：标定板在激光正前方120°范围内，并且激光前方2m范围内只存在一个连续的直线线段，所以请在空旷的地方采集数据，不然激光数据会提取错误。需要充分旋转 roll 和 pitch。更直白一点，假设在长方形的标定板中心画了个十字线，那请绕着十字线的两个轴充分旋转，比如绕着竖轴旋转，然后还要绕着横轴旋转。在运行offline程序时，程序会将认为正确的直线会显示为红色。</p>
<p>激光线要能落在标定板上。不断调整标定板姿态，每换一个姿态(绕Roll, Pitch, Yaw旋转，移动位置)，请保持静止 2 秒以上，采集 10 个姿态左右的数据（当然越多越好）。用 rosbag 记录所有的图像和激光数据， 标定工具会自动检测你保持静止时刻的数据，并用来标定。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--------- start AutoGetLinePts ---------</span><br><span class="line">id_left: 182, dist left: 1414</span><br><span class="line">id_right: 0, dist right: 1</span><br><span class="line"></span><br><span class="line">currentPt: 0  nextPt: 3</span><br><span class="line">d1: 1.085,  d2: 1414.21</span><br><span class="line">d2: 1000  1000</span><br></pre></td></tr></table></figure>
<p>这里的1000,1414其实就是对应scan的range为nan的情况，在<code>if(d1 &lt; range_max &amp;&amp; d2 &lt; range_max)</code>里过滤掉了，不用管了</p>
<h2 id="失败的情况"><a href="#失败的情况" class="headerlink" title="失败的情况"></a>失败的情况</h2><h3 id="Valid-Calibra-Data-too-little"><a href="#Valid-Calibra-Data-too-little" class="headerlink" title="Valid Calibra Data too little"></a>Valid Calibra Data too little</h3><p>运行<code>roslaunch lasercamcal_ros calibra_offline.launch</code>，结果OpenCV窗口的标定板对应线段不是红色，也没有<code>results.yaml</code><br>终端出现<code>Valid Calibra Data too little</code></p>
<p>查代码发现<code>points = AutoGetLinePts(Points);</code>没有检测到直线。接着查发现问题在<code>selectScanPoints.cpp</code>中的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 至少长于 20 cm, 标定板不能距离激光超过2m, 标定板上的激光点超过 50 个</span></span><br><span class="line"><span class="keyword">if</span>(dist.<span class="built_in">head</span>(<span class="number">2</span>).<span class="built_in">norm</span>() &gt; <span class="number">0.2</span></span><br><span class="line">   &amp;&amp; points.<span class="built_in">at</span>(seg.id_start).<span class="built_in">head</span>(<span class="number">2</span>).<span class="built_in">norm</span>() &lt; <span class="number">2</span></span><br><span class="line">   &amp;&amp; points.<span class="built_in">at</span>(seg.id_end).<span class="built_in">head</span>(<span class="number">2</span>).<span class="built_in">norm</span>() &lt; <span class="number">2</span></span><br><span class="line">   &amp;&amp; seg.id_end-seg.id_start &gt; <span class="number">50</span>   ) </span><br><span class="line">&#123;</span><br><span class="line">    seg.dist = dist.<span class="built_in">head</span>(<span class="number">2</span>).<span class="built_in">norm</span>();</span><br><span class="line">    segs.<span class="built_in">push_back</span>(seg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>有时第一项和最后一项不符合；有时第一项符合，但中间两项又不符合；第四项大部分情况是3. 常见的四个参数如下<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0.100479</span><br><span class="line">1.294</span><br><span class="line">1.218</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">0.201422</span><br><span class="line">2.357</span><br><span class="line">2.513</span><br><span class="line">3</span><br></pre></td></tr></table></figure><br>看来是不符合<strong>只有一个连续直线</strong>这条要求，后来又试了一次，虽然出现了红色直线，但是错的<br><img src="https://s2.loli.net/2022/12/06/RP6bdDLYS2gAZxt.png" alt="错误的结果"></p>
<p>最后终于明白了，源码中的参数都是作者的雷达相关的，需要根据自己雷达调整。<code>int delta = 80/0.3;</code>的两个参数根据雷达角分辨率调整。50降为18，这样就成功了，<code>int skip = 3;</code>也可能要调整。</p>
<font size="4" color="orange">  但是常常不管怎么调参数，仍然可用数据太少 </font>

<h3 id="越界"><a href="#越界" class="headerlink" title="越界"></a>越界</h3><p>运行<code>calibra_offline.launch</code>得到的bug<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Load apriltag pose size: <span class="number">582</span></span><br><span class="line">terminate called after throwing an instance of <span class="string">&#x27;std::out_of_range&#x27;</span></span><br><span class="line">  what():  vector::_M_range_check: __n (which is <span class="number">18446744073709551615</span>) &gt;= <span class="keyword">this</span>-&gt;size() (which is <span class="number">57</span>)</span><br><span class="line">[lasercamcal_ros-<span class="number">1</span>] process has died </span><br></pre></td></tr></table></figure><br>有时连录几次bag，都出现这种情况，估计是某个地方在for循环里<code>push_back</code>导致</p>
<h3 id="结果不可观"><a href="#结果不可观" class="headerlink" title="结果不可观"></a>结果不可观</h3><p>计算初值阶段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"> Notice Notice Notice: system unobservable !!!!!!!</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line">------- Closed-form solution Tlc: -------</span><br><span class="line">   <span class="number">1</span>    <span class="number">0</span>    <span class="number">0</span> -nan</span><br><span class="line">   <span class="number">0</span>    <span class="number">1</span>    <span class="number">0</span> -nan</span><br><span class="line">   <span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span>  nan</span><br><span class="line">   <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/12/13/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/tf(%E4%B8%89)%20lookTransform%E5%92%8C%E9%BD%90%E6%AC%A1%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E7%9A%84%E5%85%B3%E7%B3%BB%E6%8E%A8%E5%AF%BC/">tf(三) lookTransform和齐次变换矩阵的关系推导</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-12-13</time><div class="content"><p>建立tf树 <strong>A—-&gt;B—-&gt;C</strong>，求 C—-&gt;A变换<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosrun tf static_transform_publisher <span class="number">0.169</span>, <span class="number">0.035</span>, -<span class="number">0.125</span>,   -<span class="number">1.57</span>, <span class="number">0</span>, -<span class="number">1.57</span>  A  B <span class="number">100</span></span><br><span class="line">rosrun tf static_transform_publisher   <span class="number">0</span>,   <span class="number">0.015</span>,     <span class="number">0</span>,    -<span class="number">1.57</span>, <span class="number">0</span>, -<span class="number">1.57</span>  B  C <span class="number">100</span></span><br></pre></td></tr></table></figure><br>平时使用的tf是<code>tf::Transformer::lookupTransform(target_frame,  source_frame)</code>，表示的是 <code>source_frame ---&gt; target_frame</code>的变换，获得的位姿关系是子在父坐标系中，所以是<code>lookupTransform(&quot;A&quot;, &quot;B&quot;)</code>，根据《SLAM十四讲》63页的表示方法，写成 <script type="math/tex">T_{AB}</script><br>，也就是父子顺序。 因此 C—-&gt;A变换是 <script type="math/tex">T_{AC} = T_{AB} * T_{BC}</script></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><code>CMake</code>关键部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  eigen_conversions</span><br><span class="line">  roscpp</span><br><span class="line">  tf</span><br><span class="line">  pcl_ros</span><br><span class="line">)</span><br><span class="line">find_package(PCL <span class="number">1.3</span> REQUIRED COMPONENTS common io)</span><br></pre></td></tr></table></figure><br>c++关键部分<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tf/transform_broadcaster.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tf/message_filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tf/transform_listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl_conversions/pcl_conversions.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcl_ros/transforms.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">tf::TransformListener listener;</span><br><span class="line"></span><br><span class="line"><span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (node.<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//创建一个StampedTransform对象存储变换结果数据</span></span><br><span class="line">	tf::StampedTransform ab;</span><br><span class="line">	tf::StampedTransform bc;</span><br><span class="line">	tf::StampedTransform tfAC;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">	    listener.<span class="built_in">lookupTransform</span>(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>,</span><br><span class="line">	                             ros::<span class="built_in">Time</span>(<span class="number">0</span>), ab);</span><br><span class="line">	    listener.<span class="built_in">lookupTransform</span>(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>,</span><br><span class="line">	                             ros::<span class="built_in">Time</span>(<span class="number">0</span>), bc);</span><br><span class="line">	    listener.<span class="built_in">lookupTransform</span>(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>,</span><br><span class="line">	                             ros::<span class="built_in">Time</span>(<span class="number">0</span>), tfAC);</span><br><span class="line">	    <span class="comment">// 输出 lookupTransform 输出的 C---&gt;A 变换</span></span><br><span class="line">	    cout &lt;&lt; <span class="string">&quot;X: &quot;</span>&lt;&lt; tfAC.<span class="built_in">getOrigin</span>().<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot; Y: &quot;</span>&lt;&lt; tfAC.<span class="built_in">getOrigin</span>().<span class="built_in">getY</span>()</span><br><span class="line">	            &lt;&lt;<span class="string">&quot;  Z: &quot;</span>&lt;&lt; tfAC.<span class="built_in">getOrigin</span>().<span class="built_in">getZ</span>()&lt;&lt; endl;</span><br><span class="line">	    cout &lt;&lt; <span class="string">&quot;quaternion: &quot;</span>&lt;&lt; tfAC.<span class="built_in">getRotation</span>().<span class="built_in">x</span>() &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; tfAC.<span class="built_in">getRotation</span>().<span class="built_in">y</span>()&lt;&lt;</span><br><span class="line">	            <span class="string">&quot; &quot;</span> &lt;&lt; tfAC.<span class="built_in">getRotation</span>().<span class="built_in">z</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; tfAC.<span class="built_in">getRotation</span>().<span class="built_in">w</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Eigen::Matrix4f AB, BC, AC;</span><br><span class="line">    <span class="comment">// 使用 pcl_ros 直接得到 4x4的齐次变换矩阵</span></span><br><span class="line">    pcl_ros::<span class="built_in">transformAsMatrix</span>(ab, AB);   </span><br><span class="line">    pcl_ros::<span class="built_in">transformAsMatrix</span>(bc, BC);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;AB:&quot;</span>  &lt;&lt;std::endl;</span><br><span class="line">    std::cout &lt;&lt; AB  &lt;&lt;std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;BC:&quot;</span>  &lt;&lt;std::endl;</span><br><span class="line">    std::cout &lt;&lt; BC  &lt;&lt;std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;AC:&quot;</span>  &lt;&lt;std::endl;</span><br><span class="line">    AC = AB * BC;</span><br><span class="line">    std::cout &lt;&lt; AC  &lt;&lt;std::endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (tf::TransformException &amp;ex) &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;%s&quot;</span>,ex.<span class="built_in">what</span>());</span><br><span class="line">    ros::<span class="built_in">Duration</span>(<span class="number">1.0</span>).<span class="built_in">sleep</span>();</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到AC的右侧平移部分和<code>tfAC.getOrigin()</code>部分相同</p>
<p><code>tf::lookupTransform</code>的源码一直追溯到<code>tf2_ros::Buffer::lookupTransform</code>，源码在<a target="_blank" rel="noopener" href="https://github.com/ros/geometry2/blob/noetic-devel/tf2/src/buffer_core.cpp">f2/src/buffer_core.cpp</a>，注意其中的<code>accum</code>函数和<code>BufferCore::walkToTopParent</code>函数</p>
<h2 id="tf-eigen"><a href="#tf-eigen" class="headerlink" title="tf_eigen"></a>tf_eigen</h2><p><code>tf_eigen.h</code>提供了不少很有用的函数，用于<code>tf</code>和<code>Eigen</code>之间的矩阵和向量互相转换。使用前<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  eigen_conversions</span><br><span class="line">  tf_conversions</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>头文件<code>#include &lt;tf_conversions/tf_eigen.h&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Converts an Eigen Quaternion into a tf Matrix3x3.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">tf::matrixEigenToTF</span> <span class="params">(<span class="keyword">const</span> Eigen::Matrix3d &amp;e, tf::Matrix3x3 &amp;t)</span></span></span><br><span class="line"><span class="function">  <span class="comment">// Converts a tf Matrix3x3 into an Eigen Quaternion.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">tf::matrixTFToEigen</span> <span class="params">(<span class="keyword">const</span> tf::Matrix3x3 &amp;t, Eigen::Matrix3d &amp;e)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="comment">// Converts an Eigen Affine3d into a tf Transform.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">tf::poseEigenToTF</span> <span class="params">(<span class="keyword">const</span> Eigen::Affine3d &amp;e, tf::Pose &amp;t)</span></span></span><br><span class="line"><span class="function">  <span class="comment">// Converts a tf Pose into an Eigen Affine3d.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">tf::poseTFToEigen</span> <span class="params">(<span class="keyword">const</span> tf::Pose &amp;t, Eigen::Affine3d &amp;e)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">// Converts an Eigen Quaternion into a tf Quaternion.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">tf::quaternionEigenToTF</span> <span class="params">(<span class="keyword">const</span> Eigen::Quaterniond &amp;e, tf::Quaternion &amp;t)</span></span></span><br><span class="line"><span class="function">  <span class="comment">// Converts a tf Quaternion into an Eigen Quaternion.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">tf::quaternionTFToEigen</span> <span class="params">(<span class="keyword">const</span> tf::Quaternion &amp;t, Eigen::Quaterniond &amp;e)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  <span class="comment">// Converts an Eigen Affine3d into a tf Transform.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">tf::transformEigenToTF</span> <span class="params">(<span class="keyword">const</span> Eigen::Affine3d &amp;e, tf::Transform &amp;t)</span></span></span><br><span class="line"><span class="function">  <span class="comment">// Converts a tf Transform into an Eigen Affine3d.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">tf::transformTFToEigen</span> <span class="params">(<span class="keyword">const</span> tf::Transform &amp;t, Eigen::Affine3d &amp;e)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="comment">// Converts an Eigen Vector3d into a tf Vector3.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">tf::vectorEigenToTF</span> <span class="params">(<span class="keyword">const</span> Eigen::Vector3d &amp;e, tf::Vector3 &amp;t)</span></span></span><br><span class="line"><span class="function">   <span class="comment">// Converts a tf Vector3 into an Eigen Vector3d.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">tf::vectorTFToEigen</span> <span class="params">(<span class="keyword">const</span> tf::Vector3 &amp;t, Eigen::Vector3d &amp;e)</span></span></span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/12/12/%E6%BF%80%E5%85%89SLAM/%E6%A0%87%E5%AE%9A%E9%9B%B7%E8%BE%BE%E5%92%8C%E7%9B%B8%E6%9C%BA%E7%9A%84%E5%A4%96%E5%8F%82/">标定雷达和相机的外参</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-12-12</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/%E5%85%B6%E4%BB%96/">其他</a></span><div class="content"><h2 id="粗标定"><a href="#粗标定" class="headerlink" title="粗标定"></a>粗标定</h2><p>realsense和雷达外参的粗标定，也就是<code>laser</code>坐标系和<code>camera_color_optical_frame</code>之间的相对位姿，但如果realsense是低着头，竖直和横向的相对位姿的测量误差就大了。</p>
<p>使用realsense检测贴在墙上的二维码，获得距离，同时使用雷达检测到墙的距离，让雷达尽量正对二维码位置。</p>
<p>雷达到前方距离: 1.288，对应realsense的z值: 1.119，二者差 0.169<br>用直尺测量高度的差: 0.125<br>横向: realsense在雷达左侧 0.035</p>
<p>如果<code>laser</code>为父坐标系，二者的变换矩阵为</p>
<script type="math/tex; mode=display">
\begin{gathered}
\begin{bmatrix} 0 & 0 & 1 & 0.169 \\ -1 & 0& 1& 0.035 \\ 0& -1& 0& -0.125 \\ 0&  0& 0& 1  \end{bmatrix}
\end{gathered}</script><p>但realsense的坐标系体系是 <code>camera_link</code> —-&gt; <code>camera_color_frame</code> —-&gt; <code>camera_color_optical_frame</code>，其中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">camera_link camera_color_optical_frame</span><br><span class="line">- Translation: [<span class="number">0.000</span>, <span class="number">0.015</span>, <span class="number">0.000</span>]</span><br><span class="line">- Rotation: in Quaternion [-<span class="number">0.498</span>, <span class="number">0.502</span>, -<span class="number">0.498</span>, <span class="number">0.502</span>]</span><br><span class="line">            <span class="function">in <span class="title">RPY</span> <span class="params">(radian)</span> [-1.571, 0.008, -1.570]</span></span><br><span class="line"><span class="function">            in <span class="title">RPY</span> <span class="params">(degree)</span> [-89.992, 0.476, -89.975]</span></span><br></pre></td></tr></table></figure><br>所以不能直接建立<code>laser</code>坐标系和<code>camera_color_optical_frame</code>的父子关系，要建立<code>laser</code>和<code>camera_link</code>的。</p>
<p>使用变换矩阵的计算，已知 <script type="math/tex">T_{laser-color} = T_A</script>，  <script type="math/tex">T_{camera-color} = T_B</script>。 计算 <script type="math/tex">T_{laser-camera} = T_A * T_{B}^{-1}</script></p>
<p>结果转为tf格式，应当为 <code>&lt;node pkg=&quot;tf&quot; type=&quot;static_transform_publisher&quot; name=&quot;laser_camera_broadcaster&quot; args=&quot;0.169 0.02 -0.125 0 0 0  laser camera_link 100&quot;/&gt;</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/12/03/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E5%90%91%E9%87%8F%EF%BC%8C%E5%B9%B3%E9%9D%A2%E5%92%8C%E5%9D%90%E6%A0%87%E7%B3%BB%E5%8F%98%E6%8D%A2/">向量，平面和坐标系变换</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-12-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a></span><div class="content"><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><ul>
<li><p>标准化后的向量<strong>点乘</strong>得到的值为夹角的余弦。如果得到 -1, 0, -1，便可知道两个向量方向的关系是相反, 垂直, 相同</p>
</li>
<li><p>向量叉乘后得到的向量和原先两个向量垂直，也就是法向量</p>
</li>
<li><p>向量叉乘后得到的向量的模，其值为两个向量构成的三角形的面积的二倍。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/01/06/c92xQvbGwnMAOeV.png" alt=""></p>
<ul>
<li>叉乘的一些性质</li>
</ul>
<p><img src="https://s2.loli.net/2023/02/27/AH7SmXvqgxbwRf2.png" alt=" "><br>用行列式的表示方法观察，不用计算就能看出前三条。</p>
<h2 id="平面的一般式"><a href="#平面的一般式" class="headerlink" title="平面的一般式"></a>平面的一般式</h2><p>高中学过的表示方法为 <script type="math/tex">ax+by+cz=d</script>，法向量为 <script type="math/tex">(a,b,c)^T</script>。这里涉及到了归一化问题，两边可以乘以系数，还是同一个平面，也可以说法向量是不唯一的。但如果给出了一般式 <script type="math/tex">ax+by+cz=D</script>，就说法向量为 <script type="math/tex">(a,b,c)^T</script></p>
<p>空间内一点<script type="math/tex">(x_0, y_0, z_0)</script> 到平面的距离是 <script type="math/tex">\frac{| ax_0 + b y_0 + cz_0|}{ \sqrt{a^2 + b^2 + c^2}}</script>，如果已经归一化，那么分母就是 1</p>
<p>法向量可以看做平面上两个向量的叉乘。</p>
<h2 id="法向量-距离形式"><a href="#法向量-距离形式" class="headerlink" title="法向量 * 距离形式"></a>法向量 * 距离形式</h2><p><code>N</code>为法向量(1x3的向量)，那么<code>[N, d]</code>或者<code>(N | d)</code>为 1x4 的向量，其中d为平面到原点的距离。</p>
<h2 id="旋转问题"><a href="#旋转问题" class="headerlink" title="旋转问题"></a>旋转问题</h2><p>现在平面的表示形式(无论哪种)都是基于坐标系A，另有一个坐标系B，从B到A的变换矩阵是M(4x4)，那么平面在坐标系B下的表示形式是什么？</p>
<p>向量 <script type="math/tex">P=(a,b,c,d)</script>，注意不是法向量，平面上一点为 <script type="math/tex">v=(x,y,z,1)</script>，那么 <script type="math/tex">P^Tv =0</script>，经过变换后，点<code>v</code>变成了 <script type="math/tex">v'</script>，那么有 <script type="math/tex">P'Mv=0</script>，也就有<script type="math/tex">P'Mv= P^Tv</script>，因此可得 <script type="math/tex">P'= (M^{-1})^{T}p</script>，M矩阵的逆根据《SLAM十四讲》的公式<code>3.13</code>可以直接写出，最后根据 <script type="math/tex">P'</script> 写成一般式</p>
<p>感觉这样推导并不严谨，但可以这样理解。</p>
<p>参考：<a target="_blank" rel="noopener" href="http://www.songho.ca/opengl/gl_normaltransform.html">OpenGL Normal Vector Transformation</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/12/03/SLAM%E5%B7%A5%E5%85%B7/ceres%203%20%E8%A7%A3%E6%9E%90%E6%B1%82%E5%AF%BC/">Ceres(三) 解析求导</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-12-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SLAM%E5%B7%A5%E5%85%B7/">SLAM工具</a></span><div class="content"><p>最常见的一个例子是<script type="math/tex">f(x) = e^{mx+c}</script>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/OORRANNGGE/article/details/84110354#fromHistory">链接</a>，不再复制粘贴</p>
<p>还是之前的曲线拟合问题： <script type="math/tex">e^{(ax^2 + bx + c)}</script>，如果改用解析求导，需要构建一个继承<code>CostFunction</code>的类。核心函数是<code>bool CostFunction: :Evaluate(double const *const *parameters, double *residuals, double **jacobians)</code>，<strong>计算残差向量和雅可比矩阵</strong></p>
<ul>
<li><p>parameters: parameters是一个大小为<code>CostFunction::parameter_block_sizes_.size()</code>(输入参数块的数量和大小)的数组，parameters[i]是一个大小为<code>parameter_block_sizes_[i]</code>的数组，其中包含<code>CostFunction</code>所依赖的第i个参数块。parameters不会为nullptr</p>
</li>
<li><p>residuals: 是一个大小为<code>num_residuals_</code>(输出残差的个数)的数组。residuals也不会为nullptr</p>
</li>
<li><p>jacobians: 是一个大小为<code>CostFunction::parameter_block_sizes_.size()</code>的数组。如果<code>jacobians</code>是nullptr，用户只需要计算残差</p>
</li>
<li><p>jacobians[i]: 是一个大小为 <code>num_residuals x parameter_block_sizes_[i]</code> 的行数组，如果<code>jacobians[i]</code>不为nullptr，用户需要计算关于<code>parameters[i]</code>的残差向量的雅可比矩阵，并将其存储在这个数组中，即<br><img src="https://s2.loli.net/2022/12/03/ium6A51sajQkMXy.png" alt=""></p>
</li>
</ul>
<p>如果<code>jacobians</code>为nullptr，通常我们只需要在<code>Evaluate</code>函数中实现<code>residuals</code>的计算，<code>jacobians</code>后面可以通过Ceres提供的自动求导（数值求导）替代，否则，还需要在<code>Evaluate</code>函数中实现<code>jacobians</code>的计算</p>
<p>如果<code>parameters</code>大小和<code>residuals</code>大小在编译时是已知的，就可以使用<code>SizeCostFunction</code>，该函数可以将paramters大小和residuals大小设置为模板参数，用户只需要在使用的时候给模板参数赋值就可以<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板参数依次为： number of residuals,  first parameter的维度</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCostFun</span> :</span> <span class="keyword">public</span> SizedCostFunction&lt;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">MyCostFun</span>(<span class="keyword">double</span> x, <span class="keyword">double</span> y):</span><br><span class="line">			<span class="built_in">m_x</span>(x), <span class="built_in">m_y</span>(y)&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Evaluate</span><span class="params">(<span class="keyword">double</span> <span class="keyword">const</span>* <span class="keyword">const</span>* parameters,</span></span></span><br><span class="line"><span class="params"><span class="function">		      	 <span class="keyword">double</span>* residuals,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="keyword">double</span>** jacobians)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">double</span> a = parameters[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">double</span> b = parameters[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">double</span> c = parameters[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">       residuals[<span class="number">0</span>] = m_y - <span class="built_in">exp</span>(a*m_x*m_x + b*m_x + c);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (jacobians != <span class="literal">NULL</span> &amp;&amp; jacobians[<span class="number">0</span>] != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		    jacobians[<span class="number">0</span>][<span class="number">0</span>] = -<span class="built_in">exp</span>(a*m_x*m_x + b*m_x + c)* m_x * m_x;</span><br><span class="line">		    jacobians[<span class="number">0</span>][<span class="number">1</span>] = -<span class="built_in">exp</span>(a*m_x*m_x + b*m_x + c)* m_x;</span><br><span class="line">		    jacobians[<span class="number">0</span>][<span class="number">2</span>] = -<span class="built_in">exp</span>(a*m_x*m_x + b*m_x + c);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">double</span> m_x;</span><br><span class="line">    <span class="keyword">double</span> m_y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>拟合<script type="math/tex">f(x) = e^{mx+c}</script> 时，使用<code>SizedCostFunction&lt;1, 2&gt;</code>，只计算雅格比<code>jacobians[0][0]</code> 和 <code>jacobians[0][1]</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argv, <span class="keyword">char</span>** argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argv, argc, <span class="string">&quot;test_ceres&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="comment">// 真实值</span></span><br><span class="line">	<span class="keyword">double</span> a = <span class="number">1.0</span>, b = <span class="number">2.0</span>, c = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成带有噪声的模拟数据</span></span><br><span class="line">	vector&lt;<span class="keyword">double</span>&gt; x_data, y_data;</span><br><span class="line">	<span class="keyword">int</span> N = <span class="number">240</span>;  <span class="comment">// 数据数量</span></span><br><span class="line">	<span class="keyword">double</span> w_sigma = <span class="number">1.0</span>;  <span class="comment">// 高斯标准差</span></span><br><span class="line">	cv::RNG  rng;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i =<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">double</span> x = i/<span class="number">100.0</span>;</span><br><span class="line">		x_data.<span class="built_in">push_back</span>(x);</span><br><span class="line">		y_data.<span class="built_in">push_back</span>(<span class="built_in">exp</span>(a*x*x + b*x + c) + rng.<span class="built_in">gaussian</span>(w_sigma)  );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 作为初值</span></span><br><span class="line">	a = <span class="number">0.0</span>;</span><br><span class="line">	b = <span class="number">0.0</span>;</span><br><span class="line">	c = <span class="number">0.0</span>;</span><br><span class="line">	Problem problem;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		CostFunction* cost_func = <span class="keyword">new</span> <span class="built_in">MyCostFun</span>(x_data[i], y_data[i]);</span><br><span class="line">		problem.<span class="built_in">AddResidualBlock</span>(cost_func, <span class="literal">nullptr</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">	&#125;</span><br><span class="line">	Solver::Options option;</span><br><span class="line">	option.minimizer_progress_to_stdout = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	Solver::Summary summary;</span><br><span class="line">	<span class="built_in">Solve</span>(option, &amp;problem, &amp;summary);</span><br><span class="line">	cout &lt;&lt; summary.<span class="built_in">BriefReport</span>() &lt;&lt; endl &lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a: &quot;</span>&lt;&lt; a &lt;&lt;<span class="string">&quot;  b: &quot;</span>&lt;&lt; b &lt;&lt; <span class="string">&quot;  c: &quot;</span>&lt;&lt; c &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始我设置代价函数的模板为<code>SizedCostFunction&lt;1, 3&gt;</code>，结果运行报错： <font size="4" color="orange"> [problem_impl.cc:286]  Check failed: num_parameter_blocks == cost_function-&gt;parameter_block_sizes().size() (3 vs. 1)  </font></p>
<p>问题在于<code>parameter_block_sizes</code>只有1，而我们需要3，也就是对应abc三个参数。读<code>SizedCostFunction</code>源码发现，模板定义为<code>template &lt;int kNumResiduals, int... Ns&gt;</code>，构造函数只有两行<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set_num_residuals</span>(kNumResiduals);</span><br><span class="line">*<span class="built_in">mutable_parameter_block_sizes</span>() = std::vector&lt;<span class="keyword">int32_t</span>&gt;&#123;Ns...&#125;;</span><br></pre></td></tr></table></figure><br>因此从第2个模板参数开始，有几个参数就对应<code>parameter_block_sizes</code>，改为<code>SizedCostFunction&lt;1, 1, 1, 1&gt;</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/12/02/SLAM%E5%B7%A5%E5%85%B7/ceres%204%20LocalParameterization%20/">Ceres(四) LocalParameterization</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-12-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SLAM%E5%B7%A5%E5%85%B7/">SLAM工具</a></span><div class="content"><p>四元数表示的是一个<code>SO3</code>，四元数有四维即四个自由度，但它表示的含义其实只有三个自由度，这显然是不合理的，所以产生了<strong>单位四元数</strong>这么一个东西，单位四元数指四元数的四个量的二范数是1，这其实是一个约束，约束了四元数的一个自由度，这样四元数就只剩下三个自由度了，正好符合一个SO3的维数。</p>
<p><font size="4" color="orange"> 这段话没有完全理解：  </font> 这里其实是一个 Manifold 变量 over parameterized的问题，即 Manifold 上变量的维度大于其自由度。这会导致 Manifold 上变量各个量之间存在约束，如果直接对这些量求导、优化，那么这就是一个有约束的优化，实现困难。为了解决这个问题，在数学上是对 Manifold 在当前变量值处形成的切空间（Tangent Space）求导，在切空间上优化，最后投影回 Manifold。</p>
<p>在ceres里面，如果使用的是自动求导，然后再结合爬山法，那么每步迭代中都会产生一个四维的迭代的增量<code>delta</code>，这样就仅仅需要将原四元数 “加上” 这个迭代产生的<code>delta</code>就能够得到新的四元数了。这里问题就来了，直接加上以后这个四元数就不再是一个单位四元数了，不符合二范数之和为1。如果每次迭代过后，都将这个四元数进行归一化处理，就会显然很麻烦。</p>
<p>同理，旋转矩阵也是如此。二者都是使用<strong>过参数化</strong>表示旋转的方式，它们是不支持广义的加法(一般使用符号 <script type="math/tex">\boxplus</script> 表示)。也就是说使用普通的加法就会打破约束：<strong>旋转矩阵加旋转矩阵得到的就不再是旋转矩阵，四元数加四元数得到的不是单位四元数</strong>。所以我在使用ceres对其进行迭代更新的时候就需要自定义其更新方式了，具体的做法是实现一个参数本地化的子类，需要继承<code>LocalParameterization</code>，它是纯虚类，所以继承的时候要把所有的纯虚函数都实现。</p>
<p>Ceres存储四元数的顺序是<code>(w, x, y, z)</code>，<code>Eigen::Quaternion</code>内部内存分布为<code>(x, y, z, w)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CERES_EXPORT</span> <span class="title">QuaternionParameterization</span> :</span> <span class="keyword">public</span> LocalParameterization</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">QuaternionParameterization</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Plus</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>* x,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">const</span> <span class="keyword">double</span>* delta,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">double</span>* x_plus_delta)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">ComputeJacobian</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>* x,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">double</span>* jacobian)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表示参数的自由度，也就是 Manifold 空间（四元数）是 4 维的</span></span><br><span class="line">  <span class="comment">// 即四元数本身的实际维数，如果是旋转矩阵，则为 9</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GlobalSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">4</span>; &#125;</span><br><span class="line">  <span class="comment">// 表示迭代增量所在的切空间(tangent space)是 3 维的。即旋转矢量的实际维数</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">LocalSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">3</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对两个Size，我的理解是：<strong>四元数本身的维度是 4，但其自由度只有 3，因此迭代量的维度也应该是 3</strong></p>
<ul>
<li>Plus()函数</li>
</ul>
<p>原型： <code>bool Plus(const double* x, const double* delta, double* x_plus_delta)</code></p>
<p>四元数的更新方法，参数分别为优化前的四元数 x，用旋转矢量表示的增量<code>delta</code>（<font size="4" color="blue"> 而且本来就是半轴角，所以不需要除以2  </font>），更新后的四元数 <code>x_plus_delta</code>。函数首先将增量由旋转矢量转换为四元数，<strong>转换过程就是《视觉SLAM十四讲》的公式(3.19)</strong>，然后用优化前的<code>x</code>左乘增量，获得<code>x_plus_delta</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QuaternionParameterization::Plus</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>* x,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">const</span> <span class="keyword">double</span>* delta,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">double</span>* x_plus_delta)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* -------- 将旋转矢量转换为四元数形式-------- */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> norm_delta =</span><br><span class="line">      <span class="built_in">sqrt</span>(delta[<span class="number">0</span>] * delta[<span class="number">0</span>] + delta[<span class="number">1</span>] * delta[<span class="number">1</span>] + delta[<span class="number">2</span>] * delta[<span class="number">2</span>]);</span><br><span class="line">  <span class="keyword">if</span> (norm_delta &gt; <span class="number">0.0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  	<span class="comment">// 这里的 除以norm_delta 相当于归一化</span></span><br><span class="line">  	<span class="keyword">const</span> <span class="keyword">double</span> sin_delta_by_delta = (<span class="built_in">sin</span>(norm_delta) / norm_delta);</span><br><span class="line">  	<span class="keyword">double</span> q_delta[<span class="number">4</span>];</span><br><span class="line">  	q_delta[<span class="number">0</span>] = <span class="built_in">cos</span>(norm_delta);</span><br><span class="line">  	q_delta[<span class="number">1</span>] = sin_delta_by_delta * delta[<span class="number">0</span>];</span><br><span class="line">  	q_delta[<span class="number">2</span>] = sin_delta_by_delta * delta[<span class="number">1</span>];</span><br><span class="line">  	q_delta[<span class="number">3</span>] = sin_delta_by_delta * delta[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  	<span class="comment">/* --------2.采用四元数乘法更新-------- */</span></span><br><span class="line">  	<span class="comment">// 注意这个乘法的顺序关乎求雅克比矩阵，具体说明参照 ComputeJacobian</span></span><br><span class="line">  	x_plus_delta = q_delta * x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        x_plus_delta[i] = x[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ComputeJacobian函数</li>
</ul>
<p>原型：<code>bool ComputeJacobian(const double* x, double* jacobian)</code></p>
<p>四元数相对于旋转矢量的雅克比矩阵，即 <code>x_plus_delta</code>( 也就是 Plus(x, delta) ) 关于 <code>delta</code>(接近0)的雅克比矩阵。计算该参数加上更新量的结果对更新量的雅可比矩阵</p>
<p>四元数维度为 4，迭代量维度为 3，因此雅可比维度应该是 4x3。也就是 <script type="math/tex">GlobalSize \times LocalSize</script></p>
<p>如果直接在求观测误差对四元数求雅可比，得到的结果维度和该变量的维度是一致的，也就是说<font size="4" color="blue"> 雅格比同样具有冗余的自由度 </font>，还是开始就提出的问题，因此还需要对其迭代量进行雅可比求解。数学表示如下<br><img src="https://s2.loli.net/2022/12/02/9eH2bmLwxEavuTC.png" alt=""><br>(2)式为四元数上的例子，<code>q</code>为四元数，维度为 4，<script type="math/tex">\Delta q</script>为作用在四元数上的更新量，维度为 3</p>
<p>上面两个公式的第一部分是对原始过参数化的优化变量（四元数）的导数，这个很容易求得，直接借助ceres的<code>AutoDiffCostFunction()</code> 计算即可，或者自己计算雅可比矩阵，实现一个costfunction。关键是第二部分。</p>
<p>先补充一下四元数知识，来自十四讲<br><img src="https://s2.loli.net/2022/12/02/jibMDyocYQOWZz7.png" alt=""><br><img src="https://s2.loli.net/2022/12/02/Cxqz6QNZ5XsHDnB.png" alt=""></p>
<p>继续推导如下<br><img src="https://s2.loli.net/2022/12/02/x65odci8lXzPy4v.png" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x[0] 对应 w</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QuaternionParameterization::ComputeJacobian</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>* x,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="keyword">double</span>* jacobian)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  jacobian[<span class="number">0</span>] = -x[<span class="number">1</span>]; jacobian[<span class="number">1</span>]  = -x[<span class="number">2</span>]; jacobian[<span class="number">2</span>]  = -x[<span class="number">3</span>];  <span class="comment">// NOLINT</span></span><br><span class="line">  jacobian[<span class="number">3</span>] =  x[<span class="number">0</span>]; jacobian[<span class="number">4</span>]  =  x[<span class="number">3</span>]; jacobian[<span class="number">5</span>]  = -x[<span class="number">2</span>];  <span class="comment">// NOLINT</span></span><br><span class="line">  jacobian[<span class="number">6</span>] = -x[<span class="number">3</span>]; jacobian[<span class="number">7</span>]  =  x[<span class="number">0</span>]; jacobian[<span class="number">8</span>]  =  x[<span class="number">1</span>];  <span class="comment">// NOLINT</span></span><br><span class="line">  jacobian[<span class="number">9</span>] =  x[<span class="number">2</span>]; jacobian[<span class="number">10</span>] = -x[<span class="number">1</span>]; jacobian[<span class="number">11</span>] =  x[<span class="number">0</span>];  <span class="comment">// NOLINT</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用的方法:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ceres::LocalParameterization* local_param = <span class="keyword">new</span> ceres::<span class="built_in">QuaternionParameterization</span>();</span><br><span class="line">problem.<span class="built_in">AddParameterBlock</span>(quaternion, <span class="number">4</span>, local_param) <span class="comment">//重构参数，优化时实际使用的是3维的等效旋转矢量</span></span><br></pre></td></tr></table></figure></p>
<p>注意：从 Ceres version 2.2.0开始，<code>LocalParameterization</code> interface and associated classes are deprecated. Please use <code>Manifold</code> instead.</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/vivian187/p/16502590.html">LocalParameterization子类说明</a><br><a target="_blank" rel="noopener" href="https://www.xiaotaoguo.com/p/ceres-usage-2/"> Ceres 学习记录（二）</a></p>
<p>通过<code>Problem::AddResidualBlock()</code>函数，记录输入parameters和residuals的尺寸</p>
<p><code>AddParameterBlock</code>添加的优化变量并不一定是ceres内部运算时采用的优化变量，例如我们通常会采用四元数+平移也就是SE3作为外部维护的状态，在ceres优化中也被成为global parameter，但通常会对 se3(local parameter)求解jacobian，那么此时我们必须要告诉ceres，求解出se3的优化增量后如何对SE3进行更新，这个就是通过<strong>指定参数化方式</strong>完成的，即传入LocalParameterization的子类对象，</p>
<p>参数化类中需要实现什么？</p>
<ol>
<li><p>定义该参数优化过程中，求解出来的Local parameter对Global parameter进行更新的方法，<code>virtual bool Plus(const double* x, const double* delta, double* x_plus_delta) const</code></p>
</li>
<li><p>定义<code>Global parameter</code>对<code>Local parameter</code>的jacobian, <code>virtual bool ComputeJacobian(const double* x, double* jacobian) const</code>，因为ceres优化时，只能设置残差关于李群的jacobian(通过实现<code>ceres::SizedCostFunction</code>子类完成)，但我们需要的是残差关于李代数的jacobian，因此通过这个函数传入李群与对应李代数的jacobian，从而实现转换。</p>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/11/22/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/(%E9%9B%B6)%20%E5%AE%89%E8%A3%85/">(零) 安装cartographer</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/">原理和配置</a></span><div class="content"><p>cartographer的安装非常复杂，尤其是proto脚本和各种依赖项，如果一次不成功，最好把proto或其他依赖库彻底删除重来，越改可能越乱，再也装不好了。</p>
<p>ros2的carto好像还是非常早期的版本，一些参数都不支持，先不必使用</p>
<h2 id="安装过程的问题"><a href="#安装过程的问题" class="headerlink" title="安装过程的问题"></a>安装过程的问题</h2><p>下载protobuf很可能失败，只好手动下载: git clone <a target="_blank" rel="noopener" href="https://github.com/google/protobuf.git">https://github.com/google/protobuf.git</a></p>
<p>小强编译cartographer更新的lib文件在<code>/home/xiaoqiang/Documents/ros/devel/lib/cartographer_ros</code></p>
<h2 id="gtest问题"><a href="#gtest问题" class="headerlink" title="gtest问题"></a>gtest问题</h2><p>编译cartographer报错gtest<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/src/gtest/src/gtest.cc:1897:10: error: <span class="built_in">type</span> ‘const class testing::internal::scoped_ptr&lt;testing::internal::GTestFlagSaver&gt;’ argument given to ‘delete’, expected pointer</span><br><span class="line">   delete gtest_flag_saver_;</span><br></pre></td></tr></table></figure><br>估计是gtest的版本不兼容导致，从github上下载编译<code>google-test</code>，注意修改CMake支持c++14，否则连从github直接下载的源码编译也报错：</p>
<p>然后编译cartographer时，把几个重要的CMakeLists.txt也加上c++14的支持，否则所有的测试文件(以<code>test.cc</code>结尾的文件)编译都会出错</p>
<h3 id="缺少liborocos-kdl库文件"><a href="#缺少liborocos-kdl库文件" class="headerlink" title="缺少liborocos-kdl库文件"></a>缺少liborocos-kdl库文件</h3><p>默认的版本是1.3.2，这是<a target="_blank" rel="noopener" href="https://ubuntu.pkgs.org/16.04/ubuntu-universe-i386/liborocos-kdl1.3_1.3.0+dfsg-1_i386.deb.html">下载地址</a></p>
<h3 id="缺FindLuaGoogle"><a href="#缺FindLuaGoogle" class="headerlink" title="缺FindLuaGoogle"></a>缺<code>FindLuaGoogle</code></h3><p>报错：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Could NOT find <span class="title">Lua</span> <span class="params">(missing: LUA_LIBRARIES LUA_INCLUDE_DIR)</span> </span></span><br><span class="line"><span class="function">CMake Error at cmake/modules/FindLuaGoogle.cmake:217 <span class="params">(MESSAGE)</span>:</span></span><br><span class="line"><span class="function">  Did not find Lua &gt;</span>= <span class="number">5.2</span></span><br></pre></td></tr></table></figure><br>解决：  <code>sudo apt-get install lua5.2 lua5.2-dev</code></p>
<h3 id="absl库的问题"><a href="#absl库的问题" class="headerlink" title="absl库的问题"></a>absl库的问题</h3><p>cartographer新版本要先安装abseil，否则报错<br><img src="https://s2.loli.net/2022/05/11/CI6bwA5gOhkV9LB.png" alt=""></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/abseil/abseil-cpp.git</span><br><span class="line"><span class="built_in">cd</span> abseil-cpp</span><br><span class="line">cmake -L CMakeLists.txt &amp;&amp; make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>编译时会有个问题，需要加C++11，在absl文件夹里的CMakeList.txt里面添加<code>set(CMAKE_CXX_FLAGS &quot;-std=c++11&quot;)</code> 或者 <code>add_compile_options(-std=c++11)</code></p>
<p>如果还是缺少文件，就按照<code>find_package</code>的要求配置<br><img src="https://i.loli.net/2020/07/05/v2cR5HxEA8WPkoY.png" alt="缺abslTargets.cmake.png"></p>
<p><img src="https://i.loli.net/2021/01/04/4WOglJU26s5iBFm.png" alt="编译cartographer_rviz出错.png"><br>这个问题困扰我好久，最后终于发现在编译absl库时的cmake没有加 <code>-fPIC flag</code>，所以执行 <code>cmake -DCMAKE_POSITION_INDEPENDENT_CODE=ON ..</code>，这样就永久解决这个问题了。</p>
<p>要注意报错信息，找的是<code>AbseilConfig.cmake</code> 或者 <code>abseilConfig.cmake</code>，查看<code>cartographer_ros</code>的<code>CMakeLists</code>。 我的abseil装完是在<code>/usr/local/lib/cmake/absl/abslConfig.cmake</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加查找目录</span></span><br><span class="line"><span class="built_in">set</span>(Abseil_DIR <span class="string">&quot;/usr/local/lib/cmake/absl&quot;</span>)</span><br><span class="line">find_package(Abseil REQUIRED)</span><br></pre></td></tr></table></figure><br><br></p>
<font size="4" color="blue"> 后来我又用另一种方式解决了  </font>

<p>从github下载 <code>abseil-cpp-20190808.1</code>，解压后执行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/abseil/abseil-cpp.git</span><br><span class="line"><span class="built_in">cd</span> abseil-cpp</span><br><span class="line">git checkout 215105818dfde3174fe799600bb0f3cae233d0bf <span class="comment"># 20211102.0</span></span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -G Ninja \</span><br><span class="line">  -DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">  -DCMAKE_POSITION_INDEPENDENT_CODE=ON \</span><br><span class="line">  -DCMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span>/stow/absl \</span><br><span class="line">  ..</span><br><span class="line">ninja</span><br><span class="line">sudo ninja install</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/stow</span><br><span class="line">sudo stow absl</span><br></pre></td></tr></table></figure></p>
<p>修改<code>cartographer_ros/CMakeLists.txt</code>的部分：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(absl_DIR <span class="string">&quot;/usr/local/stow/absl/lib/cmake/absl&quot;</span>)</span><br><span class="line">find_package(absl REQUIRED)</span><br></pre></td></tr></table></figure></p>
<h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><p>安装cartogapher新版本时候，编译后遇到<code>Unrecognized syntax identifier &quot;proto3&quot;. This parser only recognizes &quot;proto2&quot;。</code></p>
<p>检查protobuf版本: <code>protoc --version</code> 显示的是2.6版本。<br>使用<code>locate protoc</code>发现我有两个protc，在<code>/usr/bin</code>和<code>/usr/local/bin</code>，分别检查版本，发现都是2.6。再次使用<code>md5sum</code>检查，发现两个文件完全一样<br><img src="https://s2.loli.net/2022/05/11/jVSTLiKBJDHvARt.png" alt="检查protoc.png"></p>
<p>安装 Protobuf<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 版本不要太新</span></span><br><span class="line">VERSION=<span class="string">&quot;v3.4.1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Build and install proto3.</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/google/protobuf.git</span><br><span class="line"><span class="built_in">cd</span> protobuf</span><br><span class="line">git checkout tags/<span class="variable">$&#123;VERSION&#125;</span></span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -G Ninja \</span><br><span class="line">  -DCMAKE_POSITION_INDEPENDENT_CODE=ON \</span><br><span class="line">  -DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">  -Dprotobuf_BUILD_TESTS=OFF \</span><br><span class="line">  ../cmake</span><br><span class="line">ninja</span><br><span class="line">sudo ninja install</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install autoconf autogen</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/protocolbuffers/protobuf.git</span><br><span class="line"><span class="built_in">cd</span> protobuf</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line"><span class="comment"># 这一步可能会报错，无视就好</span></span><br><span class="line">make check</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig <span class="comment"># refresh shared library cache.</span></span><br></pre></td></tr></table></figure><br>检查一下安装后protobuf的版本，<code>protoc --version</code></p>
<p>编译器优先找了<code>/usr/bin/protoc</code>的版本, 新安装的proto3是放在<code>/usr/local/bin/protoc</code>下的，可以删除<code>/usr/bin/protoc</code>，然后把<code>/usr/local/bin/protoc</code>放入<code>/usr/bin</code>，或者建立软连接：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /usr/bin/protoc /usr/bin/protoc.bk</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/protoc /usr/bin/protoc</span><br></pre></td></tr></table></figure></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>有时编译遇到错误，只删除<code>build_isolated/cartographer_ros/CMakeFiles</code>即可，不用全删编译完成的文件</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/4/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/63/">63</a><a class="extend next" rel="next" href="/page/6/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2023 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>