<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">654</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">52</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/30/%E6%BF%80%E5%85%89SLAM/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88/robot_pose_ekf%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">robot_pose_ekf源码分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88/">多传感器融合</a></span><div class="content"><p>robot_pose_ekf基本流程：</p>
<ol>
<li><p>从每个传感器获取数据</p>
</li>
<li><p>检查它们是否有效，如果它们有效，则将它们相对于参考基准坐标系进行转换</p>
</li>
<li><p>当获得传感器信息时，它将被存储，直到所有传感器的信息可用为止。收到的每个数据都有自己的时间戳</p>
</li>
<li><p>一旦所有数据都可用，则在所有传感器数据均可用时，针对每个可用传感器数据更新扩展卡尔曼滤波器（在Orocos-BFL库中定义）。即：如果来自里程计的数据在时间t_0（&gt; 0）可用，则来自imu的数据在时间t_1（&gt; t_0）处获得，而来自视觉里程计的数据在时间t_2（&gt; t_1）处获得，则在时间t_1对所有三组数据进行滤波。</p>
</li>
<li><p>该融合的传感器数据被转换为里程计消息，并在话题/odom_combined上发布</p>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/30/Matlab/matlab%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83/">Matlab实现高斯分布</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Matlab/">Matlab</a></span><div class="content"><p>一般是两种方法<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=[<span class="number">-20</span>:<span class="number">0.01</span>:<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">%y2 = pdf(&#x27;Normal&#x27;,x,1,5)</span></span><br><span class="line">y = gaussmf(x,[<span class="number">1</span> <span class="number">5</span>]);</span><br><span class="line"><span class="built_in">plot</span>(x,y2)</span><br></pre></td></tr></table></figure><br><img src="https://i.loli.net/2020/03/30/xs4JOZ2QHSg8Rdp.png" alt="运行结果"></p>
<p><img src="https://i.loli.net/2020/03/30/yBuZR26nLh8EFQT.png" alt=""><br>深蓝色区域是距平均值小于一个标准差之内的数值范围。在正态分布中，此范围所占比率为全部数值之68%，根据正态分布，两个标准差之内的比率合起来为95%；三个标准差之内的比率合起来为99%。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/30/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%9B%9B)%E8%BF%90%E5%8A%A8%E6%A8%A1%E5%9E%8B/">源码分析(四)运动模型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/">amcl和粒子滤波</a></span><div class="content"><p>在AMCL中，里程计是作为状态预测器存在的，通过接受当前的控制信号，从<strong>上一帧机器人状态对这一帧机器人状态进行预测，并与当前观测的结果对当前预测进行加权打分</strong>。所以通过输入和输出我们知道，里程计在AMCL中的作用就是根据当前控制信号更新上一帧的能表征机器人状态的粒子集合。</p>
<p>给机器人一个初始位姿，粒子才根据初始位姿进行初始化分布，才会进行更新(<code>UpdateAction函数</code>)，否则不会有<code>amcl_pose</code>话题输出，而更新依赖于读取到传感器数据发生变化，如在amcl中里程计的数据变化等，也就是机器人的运动</p>
<h2 id="工具函数和类"><a href="#工具函数和类" class="headerlink" title="工具函数和类"></a>工具函数和类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 两个处理角度的函数，保证角度都在(-π，π] 的范围内 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如 30°的弧度,代入后基本还是得30°的弧度</span></span><br><span class="line"><span class="comment">// 但是对于210°, 代入得到的是-150°的弧度值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">normalize</span><span class="params">(<span class="keyword">double</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">atan2</span>(<span class="built_in">sin</span>(z),<span class="built_in">cos</span>(z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于240和30的弧度,返回-150的弧度</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">angle_diff</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> d1, d2;</span><br><span class="line">  a = <span class="built_in">normalize</span>(a);</span><br><span class="line">  b = <span class="built_in">normalize</span>(b);</span><br><span class="line">  d1 = a-b;</span><br><span class="line">  d2 = <span class="number">2</span>*M_PI - <span class="built_in">fabs</span>(d1);</span><br><span class="line">  <span class="keyword">if</span>(d1 &gt; <span class="number">0</span>)</span><br><span class="line">    d2 *= <span class="number">-1.0</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">fabs</span>(d1) &lt; <span class="built_in">fabs</span>(d2))</span><br><span class="line">    <span class="keyword">return</span>(d1);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in"><span class="keyword">return</span></span>(d2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向量，成员为[x,y,θ]</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">double</span> v[<span class="number">3</span>];</span><br><span class="line">&#125; <span class="keyword">pf_vector_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Odometric sensor data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AMCLOdomData</span> :</span> <span class="keyword">public</span> AMCLSensorData</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Odometric pose</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">pf_vector_t</span> pose;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Change in odometric pose</span></span><br><span class="line">  <span class="keyword">public</span>: <span class="keyword">pf_vector_t</span> delta;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个粒子的采样信息，只有位姿和权重</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// Pose represented by this sample</span></span><br><span class="line">  <span class="keyword">pf_vector_t</span> pose;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Weight for this pose</span></span><br><span class="line">  <span class="keyword">double</span> weight;</span><br><span class="line">  </span><br><span class="line">&#125; <span class="keyword">pf_sample_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从零均值的高斯分布获得随机值，标准差为sigma</span></span><br><span class="line"><span class="comment">// We use the polar form of the Box-Muller transformation</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pf_ran_gaussian</span><span class="params">(<span class="keyword">double</span> sigma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> x1, x2, w, r;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123; r = <span class="built_in">drand48</span>(); &#125; <span class="keyword">while</span> (r==<span class="number">0.0</span>);</span><br><span class="line">    x1 = <span class="number">2.0</span> * r - <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123; r = <span class="built_in">drand48</span>(); &#125; <span class="keyword">while</span> (r==<span class="number">0.0</span>);</span><br><span class="line">    x2 = <span class="number">2.0</span> * r - <span class="number">1.0</span>;</span><br><span class="line">    w = x1*x1 + x2*x2;</span><br><span class="line">  &#125; <span class="keyword">while</span>(w &gt; <span class="number">1.0</span> || w==<span class="number">0.0</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span>(sigma * x2 * <span class="built_in">sqrt</span>(<span class="number">-2.0</span>*<span class="built_in">log</span>(w)/w));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="laserReceived中的准备工作"><a href="#laserReceived中的准备工作" class="headerlink" title="laserReceived中的准备工作"></a>laserReceived中的准备工作</h2><p>下面来看回调函数<code>laserReceived</code>中的运动模型准备工作，我们需要的是<code>odata</code>，它的类型就是上面的<code>AMCLOdomData</code>，以delta成员为例，它的赋值顺序是： odata.delta &lt;—- delta &lt;—- pose(当前位姿)和pf<em>odom_pose</em>(上一次位姿)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得雷达数据时刻的odom坐标系中的坐标,赋值给pose</span></span><br><span class="line"><span class="keyword">pf_vector_t</span> pose;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">getOdomPose</span>(latest_odom_pose_, pose.v[<span class="number">0</span>], pose.v[<span class="number">1</span>], pose.v[<span class="number">2</span>],</span><br><span class="line">              laser_scan-&gt;header.stamp, base_frame_id_))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Couldn&#x27;t determine robot&#x27;s pose associated with laser scan&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pf_vector_t</span> delta = <span class="built_in">pf_vector_zero</span>();</span><br><span class="line"><span class="comment">// 完成初始化后执行</span></span><br><span class="line"><span class="keyword">if</span>(pf_init_)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 位姿相对上一次的变化， pf_odom_pose_就是上一时刻的位姿</span></span><br><span class="line">delta.v[<span class="number">0</span>] = pose.v[<span class="number">0</span>] - pf_odom_pose_.v[<span class="number">0</span>];</span><br><span class="line">delta.v[<span class="number">1</span>] = pose.v[<span class="number">1</span>] - pf_odom_pose_.v[<span class="number">1</span>];</span><br><span class="line">delta.v[<span class="number">2</span>] = <span class="built_in">angle_diff</span>(pose.v[<span class="number">2</span>], pf_odom_pose_.v[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否更新粒子滤波器，位移需要大于参数update_min_d， 角度需要大于参数update_min_a</span></span><br><span class="line"><span class="keyword">bool</span> update = <span class="built_in">fabs</span>(delta.v[<span class="number">0</span>]) &gt; d_thresh_ ||</span><br><span class="line">              <span class="built_in">fabs</span>(delta.v[<span class="number">1</span>]) &gt; d_thresh_ ||</span><br><span class="line">              <span class="built_in">fabs</span>(delta.v[<span class="number">2</span>]) &gt; a_thresh_;</span><br><span class="line">update = update || m_force_update;</span><br><span class="line">m_force_update=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the laser update flags</span></span><br><span class="line"><span class="keyword">if</span>(update)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; lasers_update_.<span class="built_in">size</span>(); i++)</span><br><span class="line">    lasers_update_[i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> force_publication = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 第一次执行laserReceived时执行, 之前的handleMapMessage里还是false</span></span><br><span class="line"><span class="comment">// 如果里程计的数据显示机器人已经发生了明显的位移或者旋转，标记所有的雷达更新为true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 难道这里只在开始运行一次 ???</span></span><br><span class="line"><span class="keyword">if</span>(!pf_init_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 上一次滤波器更新的位姿 </span></span><br><span class="line">    pf_odom_pose_ = pose;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 滤波器现在初始化了</span></span><br><span class="line">    pf_init_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Should update sensor data</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; lasers_update_.<span class="built_in">size</span>(); i++)</span><br><span class="line">      lasers_update_[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    force_publication = <span class="literal">true</span>;</span><br><span class="line">    resample_count_ = <span class="number">0</span>; 	<span class="comment">// 重采样次数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 刚启动amcl时不执行,机器人移动后执行, 更新滤波器</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pf_init_ &amp;&amp; lasers_update_[laser_index])</span><br><span class="line">&#123;</span><br><span class="line">    AMCLOdomData odata;</span><br><span class="line">    odata.pose = pose;</span><br><span class="line">    odata.delta = delta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一帧位姿粒子状态pf和当前传感器信息，更新滤波器</span></span><br><span class="line">    odom_-&gt;<span class="built_in">UpdateAction</span>(pf_, (AMCLSensorData*)&amp;odata);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> resampled = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>到此就是算法的准备工作了, <code>pf_</code>是粒子滤波器，在<code>handleMapMessage</code>中创建和初始化</p>
<h2 id="UpdateAction"><a href="#UpdateAction" class="headerlink" title="UpdateAction"></a>UpdateAction</h2><p>接下来就是运动模型的算法了，对应《概率机器人》103页：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply the action model</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AMCLOdom::UpdateAction</span><span class="params">(<span class="keyword">pf_t</span> *pf, AMCLSensorData *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  AMCLOdomData *ndata;</span><br><span class="line">  ndata = (AMCLOdomData*) data;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the new sample poses</span></span><br><span class="line">  <span class="keyword">pf_sample_set_t</span> *set;</span><br><span class="line">  <span class="comment">// 确立当前的粒子集合，我们要产生的是一堆有位姿的粒子</span></span><br><span class="line">  set = pf-&gt;sets + pf-&gt;current_set;</span><br><span class="line">  <span class="comment">// 上一时刻的位姿</span></span><br><span class="line">  <span class="keyword">pf_vector_t</span> old_pose = <span class="built_in">pf_vector_sub</span>(ndata-&gt;pose, ndata-&gt;delta);</span><br><span class="line">  <span class="comment">// 与103页的各个delta量对应</span></span><br><span class="line">    <span class="keyword">double</span> delta_rot1, delta_trans, delta_rot2;</span><br><span class="line">    <span class="keyword">double</span> delta_rot1_hat, delta_trans_hat, delta_rot2_hat;</span><br><span class="line">    <span class="keyword">double</span> delta_rot1_noise, delta_rot2_noise;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相较于于书上，在计算delta _rot1时，多了个判定条件以位移是否小于1cm作为判断条件</span></span><br><span class="line">    <span class="comment">// 如果里程计量得机器人位移小于1cm，delta _rot1就置为0</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sqrt</span>(ndata-&gt;delta.v[<span class="number">1</span>]*ndata-&gt;delta.v[<span class="number">1</span>] + </span><br><span class="line">            ndata-&gt;delta.v[<span class="number">0</span>]*ndata-&gt;delta.v[<span class="number">0</span>]) &lt; <span class="number">0.01</span>)</span><br><span class="line">      delta_rot1 = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      delta_rot1 = <span class="built_in">angle_diff</span>(<span class="built_in">atan2</span>(ndata-&gt;delta.v[<span class="number">1</span>], ndata-&gt;delta.v[<span class="number">0</span>]),</span><br><span class="line">                              old_pose.v[<span class="number">2</span>]);</span><br><span class="line">    delta_trans = <span class="built_in">sqrt</span>(ndata-&gt;delta.v[<span class="number">0</span>]*ndata-&gt;delta.v[<span class="number">0</span>] +</span><br><span class="line">                       ndata-&gt;delta.v[<span class="number">1</span>]*ndata-&gt;delta.v[<span class="number">1</span>] );</span><br><span class="line">    delta_rot2 = <span class="built_in">angle_diff</span>(ndata-&gt;delta.v[<span class="number">2</span>], delta_rot1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We want to treat backward and forward motion symmetrically for the</span></span><br><span class="line">    <span class="comment">// noise model to be applied below.  The standard model seems to assume forward motion.</span></span><br><span class="line">    <span class="comment">// 取了两次旋转角的锐角</span></span><br><span class="line">    delta_rot1_noise = std::<span class="built_in">min</span>(<span class="built_in">fabs</span>(<span class="built_in">angle_diff</span>(delta_rot1,<span class="number">0.0</span>)),</span><br><span class="line">                                <span class="built_in">fabs</span>(<span class="built_in">angle_diff</span>(delta_rot1,M_PI)));</span><br><span class="line">    delta_rot2_noise = std::<span class="built_in">min</span>(<span class="built_in">fabs</span>(<span class="built_in">angle_diff</span>(delta_rot2,<span class="number">0.0</span>)),</span><br><span class="line">                                <span class="built_in">fabs</span>(<span class="built_in">angle_diff</span>(delta_rot2,M_PI)));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用一定数量的粒子来表征这个区域，然后对这些粒子进行采样来尽可能多的逼近机器人的真实值</span></span><br><span class="line">	<span class="comment">// 下面还是书上的公式，我们需要的是sample</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; set-&gt;sample_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 指针形式, 会给set的samples都赋值</span></span><br><span class="line">      <span class="keyword">pf_sample_t</span>* sample = set-&gt;samples + i;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Sample pose differences，pf_ran_gaussian函数：从零平均高斯分布中随机抽取，带有标准差sigma</span></span><br><span class="line">      <span class="comment">// 将这两个角度带入pf_ran_gaussian()进行高斯采样，也就是书103页的sample()函数。</span></span><br><span class="line">      <span class="comment">// 对每个粒子，不同的信息就是高斯采样产生的，其他部分不变</span></span><br><span class="line">      delta_rot1_hat = <span class="built_in">angle_diff</span>(delta_rot1,</span><br><span class="line">                      <span class="built_in">pf_ran_gaussian</span>(<span class="keyword">this</span>-&gt;alpha1*delta_rot1_noise*delta_rot1_noise + <span class="keyword">this</span>-&gt;alpha2*delta_trans*delta_trans)  );</span><br><span class="line"></span><br><span class="line">      delta_trans_hat = delta_trans - </span><br><span class="line">              <span class="built_in">pf_ran_gaussian</span>(<span class="keyword">this</span>-&gt;alpha3*delta_trans*delta_trans +</span><br><span class="line">                              <span class="keyword">this</span>-&gt;alpha4*delta_rot1_noise*delta_rot1_noise +</span><br><span class="line">                              <span class="keyword">this</span>-&gt;alpha4*delta_rot2_noise*delta_rot2_noise);</span><br><span class="line"></span><br><span class="line">      delta_rot2_hat = <span class="built_in">angle_diff</span>(delta_rot2,</span><br><span class="line">                          <span class="built_in">pf_ran_gaussian</span>(<span class="keyword">this</span>-&gt;alpha1*delta_rot2_noise*delta_rot2_noise +</span><br><span class="line">                        <span class="keyword">this</span>-&gt;alpha2*delta_trans*delta_trans) );</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Apply sampled update to particle pose, 对初始预测的修正</span></span><br><span class="line">      sample-&gt;pose.v[<span class="number">0</span>] += delta_trans_hat * </span><br><span class="line">              <span class="built_in">cos</span>(sample-&gt;pose.v[<span class="number">2</span>] + delta_rot1_hat);</span><br><span class="line">      sample-&gt;pose.v[<span class="number">1</span>] += delta_trans_hat * </span><br><span class="line">              <span class="built_in">sin</span>(sample-&gt;pose.v[<span class="number">2</span>] + delta_rot1_hat);</span><br><span class="line">      sample-&gt;pose.v[<span class="number">2</span>] += delta_rot1_hat + delta_rot2_hat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/25/%E6%BF%80%E5%85%89SLAM/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88/%E4%BD%BF%E7%94%A8robot_pose_ekf%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88/">修改robot_pose_ekf实现里程计融合IMU</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88/">多传感器融合</a></span><div class="content"><p>Each source gives a pose estimate and a covariance. The sources operate at different rates and with different latencies. A source can appear and disappear over time, and the node will automatically detect and use the available sensors </p>
<p>给滤波器节点提供信息的所有传感器源都有自己的参考坐标系，并且随着时间推移都可能出现漂移现象。因此，每个传感器发出来的绝对位姿不能直接对比。 </p>
<p><code>robot_pose_ekf</code>使用每个传感器的相对位姿差异来更新扩展卡尔曼滤波器，用松耦合方式融合不同传感器信息实现位姿估计。</p>
<p>在位姿本身上发布协方差是没有用的，而是传感器源发布协方差如何随时间变化，即速度的协方差。使用对世界的观测（例如，测量到已知墙壁的距离）将减少机器人位姿的不确定性；但是这是定位而不是里程计。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>编译前先安装<code>orocos-bfl</code></p>
<p>校正好IMU,因为融合后的效果就是要看imu的校准度</p>
<p>注释掉StatusPublisher.cpp中的<code>sendTransform(tf::StampedTransform(transform, current_time.fromSec(base_time_), &quot;odom&quot;, &quot;base_footprint&quot;));</code>  因为ekf包会为我们处理好这部分tf，所以不需要我们发布odom变换了。但是保留<code>odom</code>话题的发布</p>
<h2 id="修改-robot-pose-ekf-launch"><a href="#修改-robot-pose-ekf-launch" class="headerlink" title="修改 robot_pose_ekf.launch"></a>修改 robot_pose_ekf.launch</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_pose_ekf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_pose_ekf&quot;</span> <span class="attr">name</span>=<span class="string">&quot;robot_pose_ekf&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;output_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;odom_ekf&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;base_footprint_frame&quot;</span> <span class="attr">value</span>=<span class="string">&quot;base_footprint&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;freq&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30.0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;sensor_timeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1.0&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_used&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;odom_data&quot;</span> <span class="attr">value</span>=<span class="string">&quot;odom&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;imu_used&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;imu_data&quot;</span> <span class="attr">value</span>=<span class="string">&quot;imu&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;vo_used&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span>=<span class="string">&quot;/robot_pose_ekf/odom_combined&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/odom_ekf&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>freq：滤波器更新和发布频率。注意频率高仅仅意味着一段时间可以获得更多机器人位姿信息，但是并不表示可以提高位姿估计的精度。</p>
</li>
<li><p>sensor_timeout：当传感器停止向滤波器发送信息时，滤波器在没有传感器的情况下等待多长时间才重新开始工作。</p>
</li>
<li><p>odom_used, imu_used, vo_used：确认是否输入。</p>
</li>
</ul>
<p>启动之后,发布一下tf树,看看各坐标系名称是否正确,而且注意<code>odom_ekf</code>是不是<code>robot_pose_ekf</code>发布的，它提供的tf变换是： <code>odom_ekf --&gt; base_footprint</code>。 我们最终要实现的目标TF关系是： <code>odom_ekf --&gt; base_footprint --&gt; base_link</code></p>
<p>启动launch: <code>roslaunch robot_pose_ekf robot_pose_ekf.launch</code><br><img src="https://s2.loli.net/2023/01/13/6o1NYmOhxcvpjlK.png" alt="节点"><br>为了查看ekf包是否正常工作，可以用下面代码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosservice call /robot_pose_efk/get_status</span><br></pre></td></tr></table></figure></p>
<h2 id="协方差问题"><a href="#协方差问题" class="headerlink" title="协方差问题"></a>协方差问题</h2><p><code>robot_pose_ekf</code>不输出协方差信息，但要求输入协方差，协方差是<font size =3 color=blue>on velocity level</font>。接收的odometry数据格式错误的问题，一般是由于底盘发布的odometry数据的协方差矩阵默认为0矩阵。解决的方法由两种：一种是底盘对协方差矩阵进行初始化；另一种方法在<code>robot_pose_ekf</code>中添加判断，如果接收到的odometry信息的协方差矩阵没有进行初始化，则进行初始化。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Arkapravo/turtlebot/blob/master/turtlebot_node/src/turtlebot_node/covariances.py">turtlebot_node</a>对odom的协方差矩阵设置为<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ODOM_POSE_COVARIANCE = [<span class="number">1e-3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">                        <span class="number">0</span>, <span class="number">1e-3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e6</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e6</span>, <span class="number">0</span>,</span><br><span class="line">                        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e3</span>]</span><br><span class="line"></span><br><span class="line">ODOM_TWIST_COVARIANCE = [<span class="number">1e-3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">                         <span class="number">0</span>, <span class="number">1e-3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                         <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                         <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e6</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                         <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e6</span>, <span class="number">0</span>,</span><br><span class="line">                         <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1e3</span>]</span><br></pre></td></tr></table></figure><br><a target="_blank" rel="noopener" href="https://zacdeng.github.io/2020/08/03/racecar%E4%BB%BF%E7%9C%9F%E7%AB%9E%E8%B5%9B%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89-%20AMCL%E4%B8%8E%E5%B0%8F%E8%BD%A6%E5%AE%9A%E4%BD%8D/#rf2o-laser-odometry">这篇文章</a>也提出了几个例子</p>
<p>注意imu信息的协方差矩阵中代表机器人航向角的分量方差为1e-6，而里程计信息的协方差矩阵中机器人姿态分量的协方差为1e3，两个值相差很大。在进行EKF融合时，会更“相信”imu提供的姿态信息，因为其方差更小。比如机器人在转动过程中轮子发生了打滑，用编码器推算出的姿态一直在旋转，而实际姿态（主要由IMU测量得到）却没发生太大变化，这种情况就需要使用信息融合方法来减小误差。<font size="4" color="blue"> 协方差矩阵中的参数设置非常重要，要根据传感器手册或者实际使用测量来确定。</font></p>
<p>这里的协方差矩阵就是&lt;&lt;概率机器人&gt;&gt;154页的<code>Vt*Mt*VtT</code>, 根据之前速度积分的模型,我们已知的是ωt,Δt,θ</p>
<p>只有a1~a4还未知,它们的说明在《概率机器人》103页，<font size="4" color="orange"> 似乎不对： </font>这里就涉及到粒子滤波和AMCL了,其实它们就是AMCL的四个参数,即里程计的四个噪声分量. 我们在使用AMCL定位前就要调节这四个参数, 有了这四个参数,就能算出里程计的协方差矩阵了.</p>
<p>随着机器人的移动，其位姿的不确定性越来越大。随着时间的流逝，协方差将无限增长。<code>robot_pose_ekf</code>会在每个传感器更新数据前重置协方差， 所以发布的协方差是the increase in covariance over the past time interval. 这个时间间隔不是不变的，它取决于传感器的测量速度和什么时候完成．</p>
<p>try adjusting the process noise vs. the measurement covariance for the state variables you’re fusing. Lower covariance in the measurement and higher process noise will mean that the filter trusts your sensors more. Otherwise, the filter will prefer to stick with its predictions</p>
<p><br></p>
<p>里程计消息的协方差平时可以没有,但是如果要用到卡尔曼滤波做融合,就必须有,否则到<code>OdomEstimation::addMeasurement</code>会报错，那里是判断协方差矩阵的对角线元素<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] [1519539033.600801081]: Covariance specified <span class="keyword">for</span> measurement on topic wheelodom is zero</span><br></pre></td></tr></table></figure><br>但是小强中的里程计协方差矩阵赋值大部分是0<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CarOdom.pose.covariance =  boost::assign::<span class="built_in">list_of</span>(var_len)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(var_len)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">999</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">999</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">999</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(<span class="number">0</span>)(var_angle);</span><br></pre></td></tr></table></figure><br>因此修改<code>robot_pose_ekf/src/odom_estimation_node.cpp</code>中的函数<code>OdomEstimationNode::odomCallback</code>如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">6</span>; j++)</span><br><span class="line">    <span class="built_in">odom_covariance_</span>(i+<span class="number">1</span>, j+<span class="number">1</span>) = odom-&gt;pose.covariance[<span class="number">6</span>*i+j];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// manually set covariance untile imu sends covariance</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">imu_covariance_</span>(<span class="number">1</span>,<span class="number">1</span>) == <span class="number">0.0</span>)  <span class="comment">// 或者不用 if</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">SymmetricMatrix <span class="title">measNoiseOdom_Cov</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">  measNoiseOdom_Cov = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">measNoiseOdom_Cov</span>(<span class="number">1</span>,<span class="number">1</span>) = <span class="built_in">pow</span>(<span class="number">0.01221</span>,<span class="number">2</span>);  <span class="comment">// = 0.01221 meters / sec</span></span><br><span class="line">  <span class="built_in">measNoiseOdom_Cov</span>(<span class="number">2</span>,<span class="number">2</span>) = <span class="built_in">pow</span>(<span class="number">0.01221</span>,<span class="number">2</span>);  <span class="comment">// = 0.01221 meters / sec</span></span><br><span class="line">  <span class="built_in">measNoiseOdom_Cov</span>(<span class="number">3</span>,<span class="number">3</span>) = <span class="built_in">pow</span>(<span class="number">0.01221</span>,<span class="number">2</span>);  <span class="comment">// = 0.01221 meters / sec</span></span><br><span class="line">  <span class="built_in">measNoiseOdom_Cov</span>(<span class="number">4</span>,<span class="number">4</span>) = <span class="built_in">pow</span>(<span class="number">0.007175</span>,<span class="number">2</span>);  <span class="comment">// = 0.41 degrees / sec</span></span><br><span class="line">  <span class="built_in">measNoiseOdom_Cov</span>(<span class="number">5</span>,<span class="number">5</span>) = <span class="built_in">pow</span>(<span class="number">0.007175</span>,<span class="number">2</span>);  <span class="comment">// = 0.41 degrees / sec</span></span><br><span class="line">  <span class="built_in">measNoiseOdom_Cov</span>(<span class="number">6</span>,<span class="number">6</span>) = <span class="built_in">pow</span>(<span class="number">0.007175</span>,<span class="number">2</span>);  <span class="comment">// = 0.41 degrees / sec</span></span><br><span class="line">&#125;</span><br><span class="line">my_filter_.<span class="built_in">addMeasurement</span>(<span class="built_in">StampedTransform</span>(odom_meas_.<span class="built_in">inverse</span>(), odom_stamp_, base_footprint_frame_, <span class="string">&quot;wheelodom&quot;</span>), odom_covariance_);</span><br></pre></td></tr></table></figure><br>这是仿照源码中的函数<code>imuCallback</code>做的修改</p>
<p>如果协方差太大，那么说明机器人不太依靠里程计．协方差矩阵具体值可以考虑设置为精度的二次方。工程中确保odom的协方差矩阵对角线元素不均为0，则robot_pose_ekf即可工作。</p>
<h2 id="源码的坐标系错误"><a href="#源码的坐标系错误" class="headerlink" title="源码的坐标系错误"></a>源码的坐标系错误</h2><p>使用rviz观看滤波后的行走轨迹，结果报错：<br><img src="https://i.loli.net/2020/05/23/BAwtu9NfZ3sQW4I.png" alt="rviz里的ekf_dom_path报错.png"><br>它居然要求的是odom坐标系，但是查看tf树，坐标关系是正确的<code>odom_combined --&gt; base_footprint</code>，没有odom了。</p>
<p>使用echo查看/robot_pose_ekf/odom_combined话题，发现header里的frame_id: “odom”，看来是哪个地方发布错了。 从robot_pose_ekf源码里查找，发现<code>OdomEstimation::getEstimate(geometry_msgs::PoseWithCovarianceStamped&amp; estimate)</code>中，有这样一句<code>estimate.header.frame_id = &quot;odom&quot;;</code>，按说新的坐标系是<code>odom_combined</code>，不知为什么这里还是<code>odom</code>，只能认为是源码写错了。</p>
<p>参考:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/EAIBOT/article/details/51405152">turtlebot所用的里程计和IMU协方差是手动设置的</a><br><a target="_blank" rel="noopener" href="https://answers.ros.org/question/11682/robot_pose_ekf-with-an-external-sensor/?answer=17402#post-id-17402">ROS answer的回答</a><br><a target="_blank" rel="noopener" href="http://xxty.fun/2019/08/12/ROS%E5%B0%8F%E8%BD%A6%EF%BC%9Arobot_pose_ekf%E8%9E%8D%E5%90%88%E9%87%8C%E7%A8%8B%E8%AE%A1%E4%BF%A1%E6%81%AF/">XiaoXiaoTao博客</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/25/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8/">抛出异常</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><p>异常是运行期出现的情况，编译不会报错。如果出现异常，它后面的代码不会执行，一般会显示<font color = orange size= 3> </font> The program has unexpectedly finished. &lt;/font&gt;。如果能处理好异常，就可以让后面的代码继续运行</p>
<p>throw就是抛出异常，后面可以接任何语句表示异常。比如<code>throw 123;</code>, <code>throw &quot;exception&quot;;</code></p>
<p>try里面的第一个语句必须包含throw，可以是个函数。之后的语句不再进行，直接进catch了</p>
<p>catch的参数是和throw一致的，比如下面的<code>const char*</code>，如果要catch任何类型，小括号内换成<code>...</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">   <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">division</span>(<span class="number">1</span>,<span class="number">0</span>) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;本句不执行&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span><br><span class="line">&#123;</span><br><span class="line">  cerr &lt;&lt; msg &lt;&lt; endl;	<span class="comment">// 输出错误用cerr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++ 提供了一系列标准的异常，定义在<exception>，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的。可以使用<code>catch(std::exception e)</code></p>
<p>一些第三方库也提供了异常，使用时要注意。比如log4cpp:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    log4cpp::PropertyConfigurator::<span class="built_in">configure</span>(config_base_path+<span class="string">&quot;setting.conf&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (log4cpp::ConfigureFailure&amp; f)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Configure Problem: &quot;</span> &lt;&lt; f.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>假如程序运行前没有配置文件，而且没有使用异常机制，后面的程序就没法运行了。这不一定是我们想要的，我们不一定要求log4cpp的运行，所以使用异常就很合适了。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/25/Linux%E5%9F%BA%E7%A1%80/ELF%E6%96%87%E4%BB%B6/">ELF文件及调试命令</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux%E5%9F%BA%E7%A1%80/">Linux基础</a></span><div class="content"><p>ELF文件有三种：可执行文件，so共享库，o目标文件</p>
<h2 id="打印文件校验和"><a href="#打印文件校验和" class="headerlink" title="打印文件校验和"></a>打印文件校验和</h2><p>二进制文件传输过程中有没有被损坏或者是否是同一个版本，看看校验和以及程序块计数:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># md5sum liblidar.so</span></span><br><span class="line">615f8ede92bb7cca3d559a46397474b6  liblidar.so</span><br></pre></td></tr></table></figure>
<h2 id="打印ELF文件中的可打印字符串-strings"><a href="#打印ELF文件中的可打印字符串-strings" class="headerlink" title="打印ELF文件中的可打印字符串  strings"></a>打印ELF文件中的可打印字符串  strings</h2><p>例如你在代码中存储了一个版本号信息，那么即使编译成elf文件后，仍然可以通过strings搜索其中的字符串甚至可以搜索某个.c文件是否编译在其中：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings elfFile| grep <span class="string">&quot;someString&quot;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="nm命令查看函数或者全局变量是否存在于elf文件"><a href="#nm命令查看函数或者全局变量是否存在于elf文件" class="headerlink" title="nm命令查看函数或者全局变量是否存在于elf文件"></a>nm命令查看函数或者全局变量是否存在于elf文件</h2><p>nm命令用于查看elf文件的符号信息。文件编译出来之后，我们可能不知道新增加的函数或者全局变量是否已经成功编译进去。这时候，我们可以使用nm命令来查看。当然也可以用来查看函数，比<code>strings</code>命令更精确</p>
<h2 id="查看文件段大小-size"><a href="#查看文件段大小-size" class="headerlink" title="查看文件段大小 size"></a>查看文件段大小 size</h2><p>可以通过size命令查看各段大小：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># size cmdTest</span></span><br><span class="line">text       data      bss      dec      hex  filename</span><br><span class="line">1319      560        8     1887      75f   cmdTest</span><br></pre></td></tr></table></figure>
<p>text段：正文段字节数大小<br>data段:包含静态变量和已经初始化的全局变量的数据段字节数大小<br>bss段：存放程序中未初始化的全局变量的字节数大小<br>当我们知道各个段的大小之后，如果有减小程序大小的需求，就可以有针对性的对elf文件进行优化处理。</p>
<h2 id="为elf文件瘦身-strip"><a href="#为elf文件瘦身-strip" class="headerlink" title="为elf文件瘦身  strip"></a>为elf文件瘦身  strip</h2><p>strip用于去掉elf文件中所有的符号信息：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls -al cmdTest</span></span><br><span class="line">-rwxr-xr-x 1 hyb root 9792 Sep 25 20:30 cmdTest <span class="comment">#总大小为9792字节</span></span><br><span class="line">strip cmdTest</span><br><span class="line">ls -al cmdTest</span><br><span class="line">-rwxr-xr-x 1 hyb root 6248 Sep 25 20:35 cmdTest<span class="comment">#strip之后大小为6248字节</span></span><br></pre></td></tr></table></figure><br>可以看到，“瘦身”之后，大小减少将近三分之一。但是要特别注意的是，“瘦身”之后的elf文件由于没有了符号信息，许多调试命令将无法正常使用，出现core dump时，问题也较难定位，因此只建议在正式发布时对其进行“瘦身”。</p>
<h2 id="查看elf文件信息-readelf"><a href="#查看elf文件信息-readelf" class="headerlink" title="查看elf文件信息 readelf"></a>查看elf文件信息 readelf</h2><p>readelf用于查看elf文件信息，它可以查看各段信息，符号信息等，<code>readelf -h cmdTest</code>是查看elf文件头信息：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  <span class="comment">#elf文件魔数字</span></span><br><span class="line">Class:                             ELF64  <span class="comment">#64位 elf文件</span></span><br><span class="line">Data:                              2<span class="string">&#x27;s complement, little endian#字节序为小端序</span></span><br><span class="line"><span class="string">Version:                           1 (current)</span></span><br><span class="line"><span class="string">OS/ABI:                            UNIX - System V #</span></span><br><span class="line"><span class="string">ABI Version:                       0</span></span><br><span class="line"><span class="string">Type:                              EXEC (Executable file)#目标文件类型</span></span><br><span class="line"><span class="string">Machine:                           Advanced Micro Devices X86-64 #目标处理器体系</span></span><br><span class="line"><span class="string">Version:                           0x1</span></span><br><span class="line"><span class="string">Entry point address:               0x400440  #入口地址</span></span><br><span class="line"><span class="string">Start of program headers:          64 (bytes into file)</span></span><br><span class="line"><span class="string">Start of section headers:          4456 (bytes into file)</span></span><br><span class="line"><span class="string">Flags:                             0x0</span></span><br><span class="line"><span class="string">Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">Size of program headers:           56 (bytes)</span></span><br><span class="line"><span class="string">Number of program headers:         9</span></span><br><span class="line"><span class="string">Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">Number of section headers:         28</span></span><br><span class="line"><span class="string">Section header string table index: 27</span></span><br></pre></td></tr></table></figure><br>从elf头信息中，我们可以知道该elf是64位可执行文件，运行在x86-64中，且字节序为小端序。另外，我们还注意到它的入口地址是<code>0x400440(_start)</code>，而不是<code>400540(main)</code>。也就是说，我们的程序运行并非从main开始。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.yanbinghu.com/2019/10/13/54745.html"></a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/25/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/operator()/">operator()</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>   <span class="title">operator</span><span class="params">()</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;Foo operator&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val*<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo f;</span><br><span class="line"><span class="built_in">f</span>();    <span class="comment">// Foo operator</span></span><br><span class="line">cout&lt;&lt; <span class="built_in">f</span>(<span class="number">5</span>) &lt;&lt;endl;  <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<p>Foo是定义了调用操作符()的类,它的对象就相当于函数名,因此<code>operator()</code>取名叫函数对象</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/21/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/MQTT(%E4%BA%8C)%20QtMqtt%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%8E%B0%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/">MQTT(二) QtMqtt客户端实现发布订阅</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/">第三方库</a></span><div class="content"><p>代码在<a target="_blank" rel="noopener" href="https://github.com/charon-cheung/MQTT_Client">这里</a>，网上的示例是<a target="_blank" rel="noopener" href="https://github.com/emqx/qmqtt">这个</a>，但是我发现现在的QtMqtt已经变换很大，之前的API很多已经不能使用了</p>
<p>值得注意的是，客户端不能在构造函数里订阅话题，因为客户端在connected信号对应的槽函数里才连接成功，所以订阅也应该换到槽函数或者自己做的按钮里</p>
<p>MQTT的通信可以在wireshark里读取，可以直接解析MQTT的数据包：<br><img src="https://i.loli.net/2020/03/22/sR7NwdvrjLHnp4m.png" alt="发布话题test到客户端"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/21/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/MQTT(%E4%B8%80)%20%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8CQt%E5%BA%93/">MQTT (一) 配置服务器和Qt库</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/">第三方库</a></span><div class="content"><h2 id="安装服务器"><a href="#安装服务器" class="headerlink" title="安装服务器"></a>安装服务器</h2><p>配置安装看<a target="_blank" rel="noopener" href="https://www.qingtingip.com/h_298196.html">ubuntu安装MQTT服务器 + windows安装MQTT客户端</a>，主要是三个安装命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装服务端</span></span><br><span class="line">sudo apt-get install mosquitto</span><br><span class="line"><span class="comment">#安装客户端 （订阅sub  与 发布pub）</span></span><br><span class="line">sudo apt-get install mosqutitto-client</span><br><span class="line"><span class="comment">#安装调试器</span></span><br><span class="line">sudo apt-get install mosquitto-dbg </span><br></pre></td></tr></table></figure></p>
<ul>
<li>订阅话题test: mosquitto_sub -t test </li>
<li>发布消息到话题test: mosquitto_pub -t test -m “hello world” </li>
</ul>
<h2 id="编译Qt库QtMqtt"><a href="#编译Qt库QtMqtt" class="headerlink" title="编译Qt库QtMqtt"></a>编译Qt库QtMqtt</h2><p>Qt现在支持MQTT了， 但是很坑的是还需要自己编译，我用的是Qt5.14，从网上找了好几个版本都编译出问题，看了不知道多少博客，最后终于编译成功了。</p>
<p>从<a target="_blank" rel="noopener" href="https://github.com/qt/qtmqtt">Github官方仓库</a>下载5.14.0，解压到<code>F:\MyCpp\qtmqtt-5.14.0</code>，打开后编译，结果会报错，这是因为头文件的问题。在<code>qtmqtt-5.14.0\src\mqtt\mqtt.pro</code>中添加一行<font color = blue size =3> INCLUDEPATH += F:\MyCpp\qtmqtt-5.14.0 </font>，然后qmake, 编译。应该就成功了。</p>
<p>新建的测试程序<code>MQTT_Client</code>，然后将<code>qtmqtt-5.14.0\src\mqtt</code>文件夹中的所有头文件放到一个文件夹<code>QtMqtt</code>，然后放到程序的根目录。到编译生成的文件夹，将<code>lib</code>和<code>include</code>文件夹也放到<code>MQTT_Client</code>根目录，其中的文件Qt5Mqtt.dll.debug可以删除。</p>
<p>编辑<code>MQTT_Client.pro</code>，添加下面内容：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INCLUDEPATH += $<span class="variable">$PWD</span></span><br><span class="line">DEPENDPATH += $<span class="variable">$PWD</span>/include</span><br><span class="line"></span><br><span class="line">win32:CONFIG(release, debug|release): LIBS += -L$<span class="variable">$PWD</span>/lib/ -lQt5Mqtt</span><br><span class="line"><span class="keyword">else</span>:win32:CONFIG(debug, debug|release): LIBS += -L$<span class="variable">$PWD</span>/lib/ -lQt5Mqtt</span><br></pre></td></tr></table></figure></p>
<p>现在程序就可以用QtMqtt了，但是最好能让mqtt跟Qt自身库一样使用，也就是在pro文件中添加<code>QT += mqtt</code>即可，这样才叫优雅。参考<a href="">如何让第三方库和Qt自身库一样使用</a></p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29350001/article/details/76680646">搭建MQTT服务器及测试</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yexiaopeng/p/8542894.html">Qt官方MQTT库的配置</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/18/%E6%BF%80%E5%85%89SLAM/%E9%9B%B7%E8%BE%BE/%E9%9B%B7%E8%BE%BE%E7%9A%84%E8%AE%BE%E5%A4%87%E5%8F%82%E6%95%B0/">单线雷达的设备参数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/%E9%9B%B7%E8%BE%BE/">雷达</a></span><div class="content"><p>大多数雷达都是TOF测量法，只有深度信息，没有相机那样的纹理信息，也就没有视觉SLAM的运算负荷。</p>
<p>目前常见的激光雷达都是旋转扫描式的，内部长期处于旋转中的机械结构会给系统带来不稳定性，在颠簸震动时影响尤其明显。固态激光雷达的逐步成熟可能会为激光SLAM扳回这项劣势。</p>
<p>激光雷达的使用寿命问题已经被解决，能够保证长时间使用不会出现故障。比如在连续工作情况下，RPLIDAR-A2的设计使用寿命可长达5年以上。</p>
<p>雷达的光线遇到大雾、烟尘会受到遮挡，影响性能。</p>
<h2 id="测试材质"><a href="#测试材质" class="headerlink" title="测试材质"></a>测试材质</h2><p>选用雷达需要判断雷达是否适用于自己的场合，所以根据需要在以下场景进行测试</p>
<ul>
<li><p>大理石瓷砖。 应用场景参考：酒店大堂、走廊、室外墙壁</p>
</li>
<li><p>玻璃。 应用场景参考：玻璃门窗，办公大厅、玻璃柜台。 激光会穿过透明玻璃，从而造成一定概率的漏检。可以增加一些辅助反射手段，比如粘贴磨砂贴纸，或配合其他非光学的传感器作为补充。 <strong>雷达有时会穿透玻璃，有时不会，所以临时在玻璃上贴磨砂纸。</strong></p>
</li>
<li><p>不锈钢板。 应用场景参考：电梯、生产车间、港口码头</p>
</li>
<li><p>反光条。 应用场景参考：医院、生产车间、酒店大堂</p>
</li>
</ul>
<h2 id="误差源"><a href="#误差源" class="headerlink" title="误差源"></a>误差源</h2><ul>
<li><p>发送和接收激光束的精确耗时误差，也就是计时设备的精度问题</p>
</li>
<li><p>目标材质的反射值特性，比如全黑的材料吸收了光的大部分能量，使得反射量极低；或者像镜子一样的材料会将大部分光反射到其它地方</p>
</li>
<li><p>运动畸变：由于激光雷达在跟随自动驾驶车辆前进的同时，对周围环境进行扫描建模，也就是说车辆相对于周围的环境是运动的，导致对环境测量的实际位置与真实位置存在偏差。但是扫描频率高，速度低时，可以不必考虑。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/05/07/ICpiBQHvzquXkJj.png" alt=""></p>
<h2 id="测距范围"><a href="#测距范围" class="headerlink" title="测距范围"></a>测距范围</h2><p>指雷达能够测量的距离范围。如果实际障碍距离超出最大值，那么雷达数据会标记为无效点（不是距离为0）。市面上2D雷达最近距离也至少几厘米</p>
<p>实际情况下，雷达测距的最大值有可能因为工作环境而产生变化。雷达要想测距，需要接收到反射的激光。所以官方在测距范围这一项上添加了备注：“基于白色70%反射率物体”。</p>
<p>如果是吸收激光比较厉害的物体，例如黑色的表面又几乎不反光的物体，会导致反射光强度很弱，那么距离稍微远点，可能就测距失败了，这时候，该物体即使在标出的12米范围内同样无法测出。针对类似这样的物体，相当于实际测距的最大值变小了。透明的玻璃也是同样原因。</p>
<p>不过因为不同的物体和环境差异太大了，所以厂商也不太可能将全部情况测试一遍，更多的时候需要靠自己来实验，看是否能够适用实际的工作环境。</p>
<h2 id="扫描角度"><a href="#扫描角度" class="headerlink" title="扫描角度"></a>扫描角度</h2><p>思岚雷达是360°扫描的。有些雷达例如SICK的一些雷达，扫描角度只有220°。 实际使用，通常也不需要完全的360°，特别是雷达放在结构的中间层，因为有结构固定装置的存在，必然会有遮挡。</p>
<h2 id="测距分辨率"><a href="#测距分辨率" class="headerlink" title="测距分辨率"></a>测距分辨率</h2><p>分辨率和精度是两个不同的概念，按照上述参数的意思，更准确来说应该指的是测距精度。</p>
<p>RPLIDAR的精度并不是恒定的一个百分比，简单的解释是，距离越远，反射光受到的干扰越大，自然精度下降了。实际上，不同批次的雷达精度之间也有一定的差异。正因为这些不确定性，官方文档给的是较保守的值。</p>
<p>1.5m范围内小于0.5mm的精度还是可以的，1.5米处约为万分之三点三。<br>当在最大距离12米的时候，如果精度下降到最差的1%，则误差为0.12m，也能接受。</p>
<h2 id="扫描频率"><a href="#扫描频率" class="headerlink" title="扫描频率"></a>扫描频率</h2><p><img src="https://i.loli.net/2020/03/18/6tNElCuaoWwJhcG.png" alt="扫描频率.png"><br>衡量雷达一秒钟能转多少圈，直接改叫雷达转速也是可以的。</p>
<p>转速实际上跟雷达数据更新周期是挂钩的，比如说典型的10Hz，那就是说转一圈的时间大概是100ms，那么雷达数据差不多也是100ms一帧。 要跟<code>scan</code>话题的发布频率区分开，后者跟计算机性能有关。</p>
<p><code>LMS1xx</code>系列的扫描频率是25～50Hz，角度分辨率为<code>0.25°～0.50°</code><br><code>LMS5xx</code>系列的扫描频率是25～100Hz，角度分辨率为<code>0.1667°～1°</code></p>
<p>雷达自身的旋转是有方向的，大部分雷达都是逆时针旋转，与ROS中规定的一样，也有少部分雷达是顺时针旋转的，只不过使用起来有点不方便。</p>
<h2 id="角度分辨率"><a href="#角度分辨率" class="headerlink" title="角度分辨率"></a>角度分辨率</h2><p>正常来说，雷达转一圈，这一圈得到的测量点是均匀分布的，每个点之间间隔的角度就是所谓的角度分辨率了。</p>
<p>角度分辨率越小说明雷达转一圈得到的点数越多。例如，角度分辨率是0.45，则一圈是800个点，角度分辨率是0.9，则一圈是400个点。</p>
<p>不过，实际的角度分辨率其实不一定是固定的，即两个点之间的间距不一定是相同的，不过都在给出的分辨率范围内。在ROS中，雷达数据的标准格式认为角度分辨率是固定的，为了符合ROS标准，雷达的ROS驱动实际上做了角度补偿，将输出点修正为均匀分布的。</p>
<h2 id="数据的强度"><a href="#数据的强度" class="headerlink" title="数据的强度"></a>数据的强度</h2><p>激光雷达的激光点是有能量的，不同品牌激光点的能量也不同。当能量太小时，远距离情况下可能存在返回不了数据的情况。</p>
<p>可以等阳光或者使用光束照射到墙面上，激光雷达再去看被光照射到的墙面，对比这时的点云效果。可以用照度仪测量此时的光强度。倍加福雷达的点云效果在高强度情况下非常好，不愧是用于反光板的雷达。<br><img src="https://i.loli.net/2021/05/07/kvqoJwYV3ItgWmd.png" alt=""></p>
<h2 id="数据的精度"><a href="#数据的精度" class="headerlink" title="数据的精度"></a>数据的精度</h2><p>这是最重要的一个指标，表示激光雷达的数据跳动情况。现在一般厂商的雷达的精度都是2%。也就是100m的情况下，点的跳动幅度为2cm。但是，实际感觉能达到这个精度的雷达不是很多。</p>
<h2 id="multi-echo"><a href="#multi-echo" class="headerlink" title="multi-echo"></a>multi-echo</h2><p>multi-echo可以分析每个测量光束的两个回波信号，这样在雨雪天可以提供可靠的测量结果。一般激光打到玻璃上会有部分穿透，导致测量不准，multi-echo使激光从玻璃上返回来，还能从玻璃后面的墙上返回来。</p>
<p>有的雷达具备这种特性，比如<code>SICK-LMS111</code></p>
<p><br></p>
<p><img src="https://i.loli.net/2020/07/17/hifrG8DxmdnAXTJ.png" alt="A2雷达.png"></p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/tiancailx/article/details/110141867">从零开始搭二维激光SLAM —- 激光雷达数据效果对比</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/VOm_h4WYREsvz7rYfOKIiA">LakiBeam1雷达</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/45/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/45/">45</a><span class="page-number current">46</span><a class="page-number" href="/page/47/">47</a><span class="space">&hellip;</span><a class="page-number" href="/page/66/">66</a><a class="extend next" rel="next" href="/page/47/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2024 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>