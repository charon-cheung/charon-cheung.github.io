<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">595</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">54</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/18/%E8%A7%86%E8%A7%89SLAM/%E4%BB%8EROS%E9%85%8D%E7%BD%AErealsense%E7%9A%84%E5%8F%82%E6%95%B0/">从ROS配置realsense的参数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%A7%86%E8%A7%89SLAM/">视觉SLAM</a></span><div class="content"><h2 id="使用json配置realsense的参数-非rosparam"><a href="#使用json配置realsense的参数-非rosparam" class="headerlink" title="使用json配置realsense的参数(非rosparam)"></a>使用json配置realsense的参数(非rosparam)</h2><p>今天使用realsense时，发现有个参数需要修改<br><img src="https://i.loli.net/2020/10/15/lWn3xzM1CiyZtQX.png" alt="Set Point.png"><br>这个参数可以修正因反光而导致的错误，也就是把稍微凸起的地面当做障碍物，适当减小这个参数可以实现。</p>
<p>这个界面在realsense viewer中，但问题是如何在ROS中做到，它在rosparam中没有对应的参数。查来查去，在github的issue里发现了解决方法。realsense已经提供了一种<code>visual preset</code>文件，其实是个json文件，可以对很多参数设置，而且realsense的launch文件中已经定义了json文件的路径，比如<code>rs_camera.launch</code>:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;json_file_path&quot;</span>      <span class="attr">default</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>realsense提供的所有json文件在<a target="_blank" rel="noopener" href="https://github.com/IntelRealSense/librealsense/wiki/D400-Series-Visual-Presets">这里</a>，我们需要的参数在<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/wiki/IntelRealSense/librealsense/d400_presets/DefaultPreset_D435.json">DefaultPreset_D435.json</a>，也就是第一个参数：<code>&quot;aux-param-autoexposure-setpoint&quot;: &quot;400&quot;</code>，修改它的值后，把json文件的路径填到上面launch参数那里，启动launch就可以实现了。不过不能动态调整参数。</p>
<h2 id="配置点云的滤波器"><a href="#配置点云的滤波器" class="headerlink" title="配置点云的滤波器"></a>配置点云的滤波器</h2><p><code>rs_camera.launch</code>的参数是比较全的，<code>demo_pointcloud.launch</code>比较少。</p>
<p>现在介绍<code>filters</code>这个参数，在launch中没有赋值:<code>&lt;arg name=&quot;filters&quot;  default=&quot;&quot;/&gt;</code></p>
<p>pointcloud: 点云话题是<code>/camera/depth/color/points</code>. 点云的texture可以在<code>rqt_reconfigure</code>里修改，或者用参数<code>pointcloud_texture_stream</code>和<code>pointcloud_texture_index</code>修改</p>
<p>The depth FOV and the texture FOV are not similar. By default, pointcloud is limited to the section of depth containing the texture. You can have a full depth to pointcloud, coloring the regions beyond the texture with zeros, by setting allow_no_texture_points to true.</p>
<p>可以配置的滤波器如下:</p>
<ul>
<li>disparity, convert depth to disparity before applying other filters and back.</li>
<li>spatial，filter the depth image spatially.</li>
<li>temporal，filter the depth image temporally.</li>
<li>hole_filling，apply hole-filling filter.</li>
<li>decimation，reduces depth scene complexity.</li>
</ul>
<p>所有滤波器的说明在<a target="_blank" rel="noopener" href="https://github.com/IntelRealSense/librealsense/blob/master/doc/post-processing-filters.md">这里</a></p>
<p>给参数<code>filters</code>赋值，必须有<code>pointcloud</code>，再增加滤波器，用逗号隔开。比如 <code>disparity,spatial,pointcloud</code></p>
<p>滤波器的相关的源码在<code>base_realsense_node.cpp</code></p>
<ul>
<li><p><code>BaseRealSenseNode::setupFilters()</code>, 读取参数<code>filters</code>，把所有滤波器名称都插入容器<code>_filters</code></p>
</li>
<li><p><code>BaseRealSenseNode::publishPointCloud()</code>, 发布滤波后的点云</p>
</li>
</ul>
<p>参考:<br><a target="_blank" rel="noopener" href="https://github.com/IntelRealSense/realsense-ros">realsense-ros 滤波器</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Dontla/article/details/103574458">CSDN Realsense D435 Post-processing filters</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/18/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/ROS%E7%89%88%E6%9C%AC%E4%B8%8D%E5%85%BC%E5%AE%B9%E4%BA%A7%E7%94%9F%E7%9A%84TransformListenerWrapper%E9%97%AE%E9%A2%98/">tf的疑难问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a></span><div class="content"><h2 id="ROS版本不兼容产生的TransformListenerWrapper问题"><a href="#ROS版本不兼容产生的TransformListenerWrapper问题" class="headerlink" title="ROS版本不兼容产生的TransformListenerWrapper问题"></a>ROS版本不兼容产生的TransformListenerWrapper问题</h2><p><code>AmclNode</code>类中有这样一段：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use a child class to get access to tf2::Buffer class inside of tf_</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TransformListenerWrapper</span> :</span> <span class="keyword">public</span> tf::TransformListener</span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> tf2_ros::Buffer &amp;<span class="title">getBuffer</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> tf2_buffer_;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这是Kinetic的版本，但是在Melodic里没有这一段了，这是ROS版本兼容问题，在Kinetic里用不了这个结构体了。搜索发现<code>getBuffer</code>只有在<code>AmclNode::runFromBag</code>里调用，因为平时不用bag仿真时测试AMCL，所以这句话可以注释掉。</p>
<h2 id="“map”-passed-to-lookupTransform-argument-target-frame-does-not-exist"><a href="#“map”-passed-to-lookupTransform-argument-target-frame-does-not-exist" class="headerlink" title="“map” passed to lookupTransform argument target_frame does not exist"></a>“map” passed to lookupTransform argument target_frame does not exist</h2><p>解决方法： 先加上<code>listener.waitForTransform</code>，再<code>lookupTransform</code></p>
<p>The listener’s buffer, which carries all information about recent transformation, is literally empty. Therefore, any transform which looks-up the buffer does not find the frames it needs. It is good practice to wait for some time after the listener has been created so that the buffer can fill up. But instead of just sleeping, tf use <code>waitForTransform</code></p>
<p>参考: <a target="_blank" rel="noopener" href="https://answers.ros.org/question/192570/tftransformlistenertransformpose-exception-target_frame-does-not-exist/"></a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/25/%E6%BF%80%E5%85%89SLAM/ICP/csm%E5%8C%85%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%20(%E4%BA%8C)/">csm包的源码解读 (二)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/ICP/">ICP</a></span><div class="content"><p><img src="https://i.loli.net/2020/09/25/6sJwMcTGiyY9Ztb.png" alt="smart algorithm.png"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/20/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E5%9D%90%E6%A0%87%E7%B3%BB%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/">坐标系空间转换</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a></span><div class="content"><p>机器人SLAM问题中涉及到平移和旋转，平移是在欧氏空间中，连续的平移变换只需要向量相加。 可是旋转是在非欧空间了，连续的旋转变换就是矩阵相乘</p>
<h2 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h2><p>坐标系A变换到B，从坐标系B到坐标系A的旋转矩阵的每一列，都是{B}的坐标轴单位向量在{A}中的表示<br><img src="https://i.loli.net/2020/09/04/RuIYGCytabgMZDo.png" alt=""><br>旋转矩阵R是一个行列式为1的正交矩阵，而且行向量和列向量的长度都为1，所以它的转置就是它的逆，而逆矩阵就可以将坐标系旋转回来。<br>R的每一行就是{A}的坐标轴单位向量在{B}中的表示。<br>SO(n)是特殊正交群，这个集合由n维空间的旋转矩阵组成。  SO(3)指三维空间的旋转。<br><img src="https://i.loli.net/2020/09/04/RKUsCZrv76zDO4P.png" alt=""></p>
<h2 id="变换矩阵"><a href="#变换矩阵" class="headerlink" title="变换矩阵"></a>变换矩阵</h2><script type="math/tex; mode=display">T =\left[ \begin{matrix}   R & t \\   0 & 1 \\ \end{matrix}  \right]</script><p>左上角为旋转矩阵，右侧为平移向量，这种矩阵又称为特殊欧氏群</p>
<script type="math/tex; mode=display">SE(3) = \left \{T =\left[ \begin{matrix}   R & t \\   0 & 1 \\ \end{matrix}  \right] \in \mathbb{R}^{4\times4} \ | R\in SO(3), t\in \mathbb{R}^3  \right \}</script><p>逆矩阵的形式 <script type="math/tex">\left[ \begin{matrix}   R & t \\   0 & 1 \\ \end{matrix}  \right]^{-1} \ = \left[ \begin{matrix}   R^T & -R^Tt \\   0 & 1 \\ \end{matrix}  \right]</script></p>
<h2 id="Censi-公式"><a href="#Censi-公式" class="headerlink" title="Censi 公式"></a>Censi 公式</h2><p>我习惯用Censi论文的公式，还可以用<code>Grisetti</code>派系的<br><img src="https://i.loli.net/2020/09/20/hsubLed7priFZmS.jpg" alt="坐标系示意图.jpg"><br><img src="https://i.loli.net/2020/09/20/YzpFTi8yEwqHhf5.jpg" alt="圆加和圆减.jpg"><br><img src="https://i.loli.net/2020/09/20/WbSvxUlGwCHNzgF.png" alt=""></p>
<script type="math/tex; mode=display">\vec{a} \oplus \vec{b} = \vec{c}</script><p>$\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\Downarrow$</p>
<script type="math/tex; mode=display">\begin{pmatrix} a_x \\ a_y \\ a_{\theta} \end{pmatrix} + \left[ \begin{matrix}   cos_{a_\theta} & -sin_{a_\theta} & 0 \\  sin_{a_\theta} & cos_{a_\theta} & 0 \\ 0 & 0 & 1\end{matrix}  \right] *  \begin{pmatrix} b_x \\ b_y \\ b_{\theta} \end{pmatrix} = \begin{pmatrix} c_x \\ c_y \\ c_{\theta} \end{pmatrix}</script><h2 id="左乘和右乘"><a href="#左乘和右乘" class="headerlink" title="左乘和右乘"></a>左乘和右乘</h2><p>左乘是行变换，右乘是列变换。这是因为习惯上来说，空间中的向量用列向量表示，用矩阵左乘列向量，就是把它在空间当中变换。</p>
<p>若绕静坐标系（世界坐标系）旋转，则左乘，也是<strong>变换矩阵 x 坐标矩阵</strong></p>
<p>若是绕动坐标系旋转（自身建立一个坐标系），则右乘，也就是<strong>坐标矩阵 x 变换矩阵</strong>。 </p>
<p>即左乘是相对于坐标值所在的坐标系（世界坐标系）下的三个坐标轴进行旋转变换，右乘则是以当前点为旋转中心，进行旋转变换。</p>
<p>图优化里的相对位姿是由右乘获得的，即节点 $X_i$ 和 $X_j$ 之间的相对位姿是</p>
<script type="math/tex; mode=display">Z_{ij} = X_i^{-1}*X_j</script><p>参考：<br><a target="_blank" rel="noopener" href="https://www.pianshen.com/article/17351558785/">cartographer中公式的推导</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/19/%E6%BF%80%E5%85%89SLAM/ICP/laser_scan_matcher%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">laser_scan_matcher 源码解读</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/ICP/">ICP</a></span><div class="content"><p>主要是<code>LaserScanMatcher</code>的构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;LaserScanMatcher&quot;</span>);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line"><span class="function">ros::NodeHandle <span class="title">nh_private</span><span class="params">(<span class="string">&quot;~&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">scan_tools::LaserScanMatcher <span class="title">laser_scan_matcher</span><span class="params">(nh, nh_private)</span></span>;</span><br><span class="line">ros::<span class="built_in">spin</span>();</span><br></pre></td></tr></table></figure></p>
<p>构造函数里初始化一系列参数，重点就是回调函数<code>scanCallback</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一帧scan, cache the tf from base to the scanner</span></span><br><span class="line"><span class="keyword">if</span> (!initialized_)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">createCache</span>(scan_msg);    <span class="comment">// caches the sin and cos of all angles</span></span><br><span class="line">  <span class="comment">// cache the static tf from base to laser</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">getBaseToLaserTf</span>(scan_msg-&gt;header.frame_id))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_WARN</span>(<span class="string">&quot;Skipping scan&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 保存scan数据到  LDP  prev_ldp_scan_;</span></span><br><span class="line">  <span class="built_in">laserScanToLDP</span>(scan_msg, prev_ldp_scan_);</span><br><span class="line">  last_icp_time_ = scan_msg-&gt;header.stamp;</span><br><span class="line">  initialized_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二帧及以后的scan</span></span><br><span class="line">index++;		<span class="comment">// static unsigned int index;</span></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;scan index: %d&quot;</span>, index);</span><br><span class="line">LDP  curr_ldp_scan;</span><br><span class="line"><span class="built_in">laserScanToLDP</span>(scan_msg, curr_ldp_scan);</span><br><span class="line"><span class="built_in">processScan</span>(curr_ldp_scan, scan_msg-&gt;header.stamp);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.loli.net/2020/09/20/VTNfbxGYmPqK3Li.png" alt="流程.png"></p>
<h2 id="公式计算"><a href="#公式计算" class="headerlink" title="公式计算"></a>公式计算</h2><h2 id="newKeyframeNeeded"><a href="#newKeyframeNeeded" class="headerlink" title="newKeyframeNeeded"></a>newKeyframeNeeded</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(tf::<span class="built_in">getYaw</span>(d.<span class="built_in">getRotation</span>())) &gt; kf_dist_angular_)</span><br><span class="line">   <span class="keyword">return</span>   <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">double</span> x = d.<span class="built_in">getOrigin</span>().<span class="built_in">getX</span>();</span><br><span class="line"><span class="keyword">double</span> y = d.<span class="built_in">getOrigin</span>().<span class="built_in">getY</span>();</span><br><span class="line"><span class="keyword">if</span> (x*x + y*y &gt; kf_dist_linear_sq_)</span><br><span class="line">   <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>优先判断相对旋转</p>
<p>调用是这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交换新旧frame, key frame 的意思应该是当前配准时的参考帧</span></span><br><span class="line"><span class="comment">// 这个在机器人一直走直线或原地旋转时很难发生</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">newKeyframeNeeded</span>(corr_ch))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// generate  a  keyframe</span></span><br><span class="line">	<span class="built_in">ld_free</span>(prev_ldp_scan_);</span><br><span class="line">	prev_ldp_scan_ = curr_ldp_scan;</span><br><span class="line">	<span class="comment">// 更新下一个时间段的 f2b_kf</span></span><br><span class="line">	f2b_kf_ = f2b_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>prev_ldp_scan_</code>之前是第一帧scan的数据，只有需要 key frame时，才会更新它，但在<code>processScan</code>开头又会把估计位姿和真值初始化为0。  如果没有达到运动阈值，<code>prev_ldp_scan_</code>还是第一帧scan，时间也是第一帧的时间，仍以第一帧为基准进行ICP配准</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/14/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/%E9%85%8D%E7%BD%AEFirefly-RK3399%E5%B9%B3%E5%8F%B0/">配置Firefly-RK3399平台</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/">ROS机器人</a></span><div class="content"><p>整个系统的构建过程如下：</p>
<ol>
<li>操作系统是ARM架构处理器的Ubuntu mate16.04 LTS 系 统；</li>
<li>使用ROS-kinetic版本；</li>
<li>进行网络配置，把处理器平台上的WiFi模块配置成Access Point (AP)模式，让上位机接入AP与Cortex-A53 处理器平台通信，这样就可以在个人计算机上通过远程登录来操控机器人</li>
<li>把上位机配置成时间服务器，让Cortex-A53平台每次上电后能与上位机的时间保持同步</li>
</ol>
<p>移动底座和激光雷达与Cortex-A53平台都是通过串口来通信的。在基于Cortex-A53处理器的平台上处理激光雷达的扫描数据以及底座中采集的里程计数据。</p>
<p>在Cortex-A53平台上使用的局部路径规划算法无法实现局部路径规划，因为计算量太大，在路径规划过程中处理器CPU占用率达到100%。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/08/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6%E8%99%9A%E5%87%BD%E6%95%B0%20(%E4%BA%8C)%20/">深入探究虚函数 (二) 虚函数表vtbl和虚表指针vptr</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><p>虚函数表是通过一块内存来存储虚函数的地址，它实际是一个函数指针数组，每一个元素都是虚函数的指针，虚函数表的最后一个元素是一个空指针。假如虚函数类型为int，函数指针就是<code>int*</code>类型．<font color = orange size=4>虚函数表将被该类的所有对象共享，每个对象内部包含了一个虚表指针，指向虚函数表 </font></p>
<p>有虚函数的类的最开始部分就是虚指针，它指向虚函数表起始地址，类型为<code>int**</code>（如果虚函数类型int），表中存放虚函数的地址。通过这个指针可以获取到该类对象的所有虚函数，包括父类的。 </p>
<font color = blue size=4>在编译期，编译器完成了虚表的创建，而虚指针在构造函数期间被初始化 </font>

<p><strong>因为派生类会继承基类的虚函数表，</strong>所以通过虚函数表，我们就可以知道该类对象的父类，在转换的时候就可以用来判断对象有无继承关系。派生类中增加的虚函数，如果覆盖了基类的虚函数，虚函数表中会替换相应的基类虚函数，地址换成派生类的；如果没有覆盖基类的虚函数，就添加到原虚函数表后面，以空指针结尾． 所以说派生类的虚函数表中的函数地址不是连续的，基类的是连续的。</p>
<p>虚指针地址是否与this指针相同</p>
<p>类Base的虚表如下图：<br><img src="https://i.loli.net/2020/09/08/gjM4aP5xL8YQGDd.png" alt="Base.png"><br>如果派生类Derived没有覆盖基类的虚函数，它的虚函数表如下图：<br><img src="https://i.loli.net/2020/09/08/KUrxlAep59sbkqy.png" alt="2020-09-08_171319.png"></p>
<p>如果覆盖vFunc1，则替换Base的vFunc1；如果还定义了一个虚函数vFunc3，那么继续往虚函数表之后填，最后一个数组成员还是空指针</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.dzwspace.com/article/cpp-vtbl/">C++ 虚函数表</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/LF_2016/article/details/52311227">深入C++对象模型&amp;虚函数表</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/03/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%8F%91%E5%B8%83%E8%80%85%E7%9A%84latch%E6%9C%BA%E5%88%B6/">发布者的latch机制</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><p>这个就是最常用的advertise函数的最后一个参数，原型： <code>advertise (const std::string &amp;topic, uint32_t queue_size, bool latch=false)</code></p>
<p>是否锁存。某些话题并不是会以某个频率发布，比如<code>/map</code>这个topic，只有在初次订阅或者地图更新这两种情况下，才会向<code>/map</code>发布消息，这里就用到了锁存。</p>
<p>锁存的作用就是，将发布者最后一次发布的消息保存下来，然后把它自动发送给后来的订阅者。这种方式非常适合变动较慢、相对固定的数据（例如地图），然后只发布一次，相比于同样的消息不定的发布，锁存的方式既可以减少通信中对带宽的占用，也可以减少消息资源维护的开销。</p>
<p>查看gmapping中的函数<code>SlamGMapping::startLiveSlam()</code>，发现三个话题都是 latched：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">entropy_publisher_ = private_nh_.advertise&lt;std_msgs::Float64&gt;(<span class="string">&quot;entropy&quot;</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">sst_ = node_.advertise&lt;nav_msgs::OccupancyGrid&gt;(<span class="string">&quot;map&quot;</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">sstm_ = node_.advertise&lt;nav_msgs::MapMetaData&gt;(<span class="string">&quot;map_metadata&quot;</span>, <span class="number">1</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p><code>latch=true</code>，发布消息一次或几次，然后设法阻塞程序(常常用spin()，这里只是阻塞，跟订阅无关)，订阅者仍然能收到阻塞之前发布的消息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ros::<span class="built_in">init</span>(argc,argv, <span class="string">&quot;Pub&quot;</span>);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">ros::Publisher pub_latch_true = nh.advertise&lt;std_msgs::Int8&gt;(<span class="string">&quot;topic_latch_true&quot;</span>, <span class="number">50</span>, <span class="literal">true</span>);</span><br><span class="line">ros::Publisher pub_latch_false = nh.advertise&lt;std_msgs::Int8&gt;(<span class="string">&quot;topic_latch_false&quot;</span>, <span class="number">50</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">std_msgs::Int8 msg;</span><br><span class="line">msg.data = <span class="number">2</span>;</span><br><span class="line">pub_latch_true.<span class="built_in">publish</span>(msg);</span><br><span class="line">pub_latch_false.<span class="built_in">publish</span>(msg);</span><br><span class="line"><span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line">  ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">  rate.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>运行程序后等一会，运行<code>rostopic echo topic_latch_false</code>，什么也没有。运行<code>rostopic echo topic_latch_true</code>，会收到<code>data=2</code>的消息。  即使先运行两个echo，再运行发布者，结果也是如此</p>
<p><code>bool Publisher::isLatched () const</code> 用于判断是否latch</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/03/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5/">协方差矩阵</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a></span><div class="content"><p>协方差可以表示两个变量的协同关系， 变化趋势是否一致。 <strong>相关性</strong>就是用X、Y的协方差除以X的标准差和Y的标准差。</p>
<p>我们机器人用到的向量是<code>(x,y,z, roll,pitch,yaw)</code>，协方差就是一个6x6的矩阵，对角线的元素为各个随机变量的方差，非对角线的元素就是两两随机变量之间的协方差。AMCL中所用的协方差矩阵，由于z,pitch,roll都是0，矩阵的第1,8和最后的元素，分别是x,y,yaw的方差。另外还有x和y的协方差</p>
<p>如果协方差矩阵是单位矩阵，那么就是标准的多元高斯分布。由于协方差矩阵是对称矩阵，所以可以做特征分解</p>
<script type="math/tex; mode=display">\Sigma = P\Lambda P^T</script><p>其实可以变成</p>
<script type="math/tex; mode=display">\Sigma = \left(U\Lambda^\frac{1}{2} \right)  \left(U\Lambda^\frac{1}{2}\right)^T = AA^T</script><p>因此任意一个协方差矩阵可以看做三维变换的结果，<font color = blue size=4>概率密度函数是由协方差矩阵的特征向量控制旋转，特征值控制尺度。 协方差矩阵就是根据这两项对标准高斯分布进行变换。 </font></p>
<p>AMCL中的<code>pf_ran_gaussian</code>函数是以对角线元素为标准差，生成一个高斯分布。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/09/03/octomap%E5%92%8C%E5%85%AB%E5%8F%89%E6%A0%91/%E5%85%AB%E5%8F%89%E6%A0%91%E5%9C%B0%E5%9B%BE/">点云地图和八叉树地图</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/octomap%E5%92%8C%E5%85%AB%E5%8F%89%E6%A0%91/">octomap和八叉树</a></span><div class="content"><p>如果点云分布非常规整，是某个特定物体的点云模型，则应该使用Octree，因为很容易求解凸包并且点与点之间相对距离无需再次比对父节点和子节点，更加明晰，典型的例子是斯坦福的兔子。</p>
<p><code>lego_loam</code>建立的点云太稀疏，只能用于定位而不能导航。</p>
<p>用RGBD建立3D稠密点云图，并使用octomap进行压缩滤除地面信息。然后通过2D投影生成占据栅格地图最后利用costmap进行全局和局部路径规划导航实时避障，这又变成2D导航了</p>
<p>点云地图也有一些基于ICP或直接用八叉树地图的三维导航的方法，可以用于无人机在三维空间的导航。至于稀疏特征点地图，容易受光照和场景影响</p>
<p>点云地图: 无序,因为它的点都是无序的,无法坐标索引查询</p>
<p>八叉树地图特点</p>
<ul>
<li>稀疏: 不需要对空间进行稠密切分</li>
<li>结构化: 方块排列固定,切分为八份</li>
<li>非直接索引查询</li>
</ul>
<p>八叉树地图基于OctoTree，可以是多分辨率的地图<br><img src="https://i.loli.net/2020/09/03/1fKaz4ZpHdjEeRS.png" alt="八叉树"></p>
<p>Voxel Grid就像3D的占用地图，分辨率是固定的<br><img src="https://i.loli.net/2020/09/03/jHnJtO7UfkPmIRx.jpg" alt="VoxelGrid"></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/32/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><span class="page-number current">33</span><a class="page-number" href="/page/34/">34</a><span class="space">&hellip;</span><a class="page-number" href="/page/60/">60</a><a class="extend next" rel="next" href="/page/34/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>