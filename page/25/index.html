<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">652</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">53</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/21/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8E%E7%AB%AF%205%20%E8%AE%A1%E7%AE%97%E7%BA%A6%E6%9D%9F/">后端 5 计算约束</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>我的理解是，求inter约束也是一个 scan to map 的过程，找到和点云最相似的不同时间的子图，也就是找回环。其实是和<code>lidar_localization</code>的后端用NDT找关键帧的匹配是类似的，但是cartographer是点云和栅格地图匹配，不像点云匹配那样直观，分支定界的score就像NDT匹配的score，不过前者越大越好，后者越小越好。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstraintBuilder2D::ComputeConstraint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> SubmapId&amp; submap_id,  <span class="keyword">const</span> Submap2D* <span class="keyword">const</span> submap,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> NodeId&amp; node_id,  <span class="keyword">bool</span> match_full_submap,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> TrajectoryNode::Data* <span class="keyword">const</span>  constant_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> transform::Rigid2d&amp;  initial_relative_pose,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> SubmapScanMatcher&amp;   submap_scan_matcher,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;ConstraintBuilder2D::Constraint&gt;* constraint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(submap_scan_matcher.fast_correlative_scan_matcher);</span><br><span class="line">  <span class="comment">/*  node在local坐标系的位姿 = 子图在local坐标系中的位姿 * node在子图的位姿*/</span></span><br><span class="line">  <span class="keyword">const</span> transform::Rigid2d  initial_pose =</span><br><span class="line">      <span class="built_in">ComputeSubmapPose</span>(*submap) * initial_relative_pose;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">float</span> score = <span class="number">0.</span>;</span><br><span class="line">  transform::Rigid2d pose_estimate = transform::Rigid2d::<span class="built_in">Identity</span>();</span><br></pre></td></tr></table></figure>
<p>整个函数是为了计算<code>constraint_transform</code>(节点 j 和子图 i的关系) ，需要的参数有：</p>
<ul>
<li>节点 j 的<code>filtered_gravity_aligned_point_cloud</code></li>
<li>分支定界的初值 <code>initial_pose</code> (节点 j 在local map坐标系的坐标)</li>
<li><code>Match()</code> 的结果 <code>pose_estimate</code> (节点 j 在local map坐标系的坐标).</li>
<li><code>ComputeSubmapPose()</code>函数 (local map坐标系转到子图 i 坐标系)</li>
</ul>
<p>计算<code>pose_estimate</code>的三步:</p>
<ol>
<li>使用 fast correlative scan matcher 做 Fast estimate</li>
<li>Prune if the score is too low.</li>
<li>ceres Refine</li>
</ol>
<h2 id="匹配所有子图-或-局部子图"><a href="#匹配所有子图-或-局部子图" class="headerlink" title="匹配所有子图 或 局部子图"></a>匹配所有子图 或 局部子图</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配所有子图，对应 MaybeAddGlobalConstraint</span></span><br><span class="line"><span class="keyword">if</span> (match_full_submap)</span><br><span class="line">&#123;</span><br><span class="line">  kGlobalConstraintsSearchedMetric-&gt;<span class="built_in">Increment</span>();</span><br><span class="line">  <span class="keyword">if</span>( submap_scan_matcher.fast_correlative_scan_matcher-&gt;<span class="built_in">MatchFullSubmap</span>(</span><br><span class="line">          constant_data-&gt;filtered_gravity_aligned_point_cloud,</span><br><span class="line">          <span class="comment">// 参数为 global_localization_min_score</span></span><br><span class="line">          options_.<span class="built_in">global_localization_min_score</span>(), </span><br><span class="line">          &amp;score,  &amp;pose_estimate)  )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">CHECK_GT</span>(score, options_.<span class="built_in">global_localization_min_score</span>());</span><br><span class="line">    <span class="built_in">CHECK_GE</span>(node_id.trajectory_id, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">CHECK_GE</span>(submap_id.trajectory_id, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 最后记录下全局约束的次数和统计置信度</span></span><br><span class="line">    kGlobalConstraintsFoundMetric-&gt;<span class="built_in">Increment</span>();</span><br><span class="line">    kGlobalConstraintScoresMetric-&gt;<span class="built_in">Observe</span>(score);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匹配局部子图</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  kConstraintsSearchedMetric-&gt;<span class="built_in">Increment</span>();</span><br><span class="line">  <span class="keyword">if</span> (submap_scan_matcher.fast_correlative_scan_matcher-&gt;<span class="built_in">Match</span>(</span><br><span class="line">          initial_pose, constant_data-&gt;filtered_gravity_aligned_point_cloud,</span><br><span class="line">          <span class="comment">// 参数为 min_score</span></span><br><span class="line">          options_.<span class="built_in">min_score</span>(), </span><br><span class="line">          &amp;score, &amp;pose_estimate)  )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">CHECK_GT</span>(score, options_.<span class="built_in">min_score</span>());</span><br><span class="line">    kConstraintsFoundMetric-&gt;<span class="built_in">Increment</span>();</span><br><span class="line">    kConstraintScoresMetric-&gt;<span class="built_in">Observe</span>(score);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  score_histogram_.<span class="built_in">Add</span>(score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分枝定界求出的位姿被称为 <strong>初始位姿 3</strong>，这个初始位姿3及其携带的点云作为输入，用于ceres与此子图进行优化匹配</p>
<p>在建立全局约束的时候，直接在一个超大的范围内进行分枝定界搜索，并不需要计算一个特殊的初始位姿2，而直接把初始位姿设置为地图limits的中心点，可以理解为map的中心点。 而且打分的参数也不同了。</p>
<p>全局约束的搜索窗口范围： <code>[1e6 * limits_.resolution(), M_PI]</code>，角度其实是±180°</p>
<h2 id="ceres-refine"><a href="#ceres-refine" class="headerlink" title="ceres refine"></a>ceres refine</h2><p>ceres优化匹配，得到更加准确的优化位置<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use the CSM estimate as both the initial and previous pose. </span></span><br><span class="line"><span class="comment">// This has the effect that, in the absence of better information, </span></span><br><span class="line"><span class="comment">// we prefer the original  CSM estimate.</span></span><br><span class="line">ceres::Solver::Summary  unused_summary;</span><br><span class="line"><span class="comment">// ceres更新pose_estimate，获得节点在local map中的最优位姿</span></span><br><span class="line">ceres_scan_matcher_.<span class="built_in">Match</span>(pose_estimate.<span class="built_in">translation</span>(), pose_estimate,</span><br><span class="line">                 constant_data-&gt;filtered_gravity_aligned_point_cloud,</span><br><span class="line">                *submap_scan_matcher.grid,  &amp;pose_estimate,</span><br><span class="line">                &amp;unused_summary);</span><br><span class="line"><span class="comment">// 计算得到node相对子图的位姿</span></span><br><span class="line"><span class="keyword">const</span> transform::Rigid2d constraint_transform = </span><br><span class="line">    <span class="built_in">ComputeSubmapPose</span>(*submap).<span class="built_in">inverse</span>() * pose_estimate;</span><br><span class="line">constraint-&gt;<span class="built_in">reset</span>(<span class="keyword">new</span> Constraint&#123;submap_id,</span><br><span class="line">       node_id,</span><br><span class="line">       &#123; transform::<span class="built_in">Embed3D</span>(constraint_transform),</span><br><span class="line">        options_.<span class="built_in">loop_closure_translation_weight</span>(),</span><br><span class="line">        options_.<span class="built_in">loop_closure_rotation_weight</span>() &#125;,</span><br><span class="line">       Constraint::INTER_SUBMAP&#125; );</span><br></pre></td></tr></table></figure><br>对于局部约束，<code>constraint_transform</code>并不是回环边，其实就是子图和节点的普通约束。 全局约束才构造回环边</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options_.<span class="built_in">log_matches</span>() )</span><br><span class="line">&#123;</span><br><span class="line">    std::ostringstream info;</span><br><span class="line">    info &lt;&lt; <span class="string">&quot;Node &quot;</span> &lt;&lt; node_id &lt;&lt; <span class="string">&quot; with &quot;</span></span><br><span class="line">         &lt;&lt; constant_data-&gt;filtered_gravity_aligned_point_cloud.<span class="built_in">size</span>()</span><br><span class="line">         &lt;&lt; <span class="string">&quot; points on submap &quot;</span> &lt;&lt; submap_id &lt;&lt; std::fixed;</span><br><span class="line">    <span class="keyword">if</span> (match_full_submap)</span><br><span class="line">         info &lt;&lt; <span class="string">&quot; matches&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">const</span> transform::Rigid2d difference =</span><br><span class="line">          initial_pose.<span class="built_in">inverse</span>() * pose_estimate;</span><br><span class="line">      info &lt;&lt; <span class="string">&quot; differs by translation &quot;</span> &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">2</span>)</span><br><span class="line">           &lt;&lt; difference.<span class="built_in">translation</span>().<span class="built_in">norm</span>() &lt;&lt; <span class="string">&quot; rotation &quot;</span></span><br><span class="line">           &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; std::<span class="built_in">abs</span>(difference.<span class="built_in">normalized_angle</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    info &lt;&lt; <span class="string">&quot; with score &quot;</span> &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; <span class="number">100.</span> * score &lt;&lt; <span class="string">&quot;%.&quot;</span>;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; info.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/20/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/%E6%80%9D%E8%80%83%E7%9A%84%E9%97%AE%E9%A2%98/">思考的问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/">原理和配置</a></span><div class="content"><ul>
<li><p>为何子图插入scan结束时CPU升高</p>
</li>
<li><p>为什么要用线程池</p>
</li>
<li><p>To be sure there is a recent loop closure constraint, you can query <code>PoseGraphInterface::constraints()</code>, loop over all constraints and check if there is a recent one of type INTER that spans some time.</p>
</li>
<li><p>A simpler solution is to subscribe to the global slam callback <code>GlobalSlamOptimizationCallback</code> by setting <code>PoseGraphInterface::SetGlobalSlamOptimizationCallback</code>. This will call you back after Cartographer has searched for loop closures. It does not tell you if loop closures were found, it mostly tells you if the background loop closure search is keeping up or falls behind.</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/05/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/gmapping%E5%92%8CAMCL%E7%9A%84%E5%8C%BA%E5%88%AB/">gmapping和AMCL的区别</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/">amcl和粒子滤波</a></span><div class="content"><h2 id="粒子"><a href="#粒子" class="headerlink" title="粒子"></a>粒子</h2><p>AMCL的粒子只包括位姿和权重，需要大量的粒子才能较好描述机器人位姿。gmapping的粒子包括轨迹、地图、权重，粒子过多会占用很大的内存。</p>
<p>AMCL的粒子在初始化时，各粒子的位姿是不同的，是均值参数加高斯噪声； gmapping粒子初始化时，粒子的位姿都是相同的。 所以说AMCL更符合撒粒子的逻辑。</p>
<p>AMCL的粒子数不是固定的，有最小和最大粒子数。在定位过程中，KLD采样会动态减少粒子数；gmapping的粒子数一直是固定的。</p>
<p>AMCL的提议分布是运动模型，分布的特点是又扁又宽； gmapping的提议分布是运动模型又加入了最近的观测，分布特点是小的尖峰。</p>
<p>AMCL的粒子权重是似然域模型改变，gmapping是通过scan match</p>
<p>AMCL输出的位姿是所有粒子加权平均后的结果； gmapping是输出得分最高的粒子</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/02/C++/C++%20%20%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/emplace%E5%92%8Cemplace_back/">emplace 和 emplace_back</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/">C++ 模板与STL</a></span><div class="content"><p>常见用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    v.<span class="built_in">emplace_back</span>();</span><br><span class="line">    <span class="keyword">auto</span>&amp; num = v.<span class="built_in">back</span>();</span><br><span class="line">    num = i;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt; <span class="string">&quot;size: &quot;</span>&lt;&lt;v.<span class="built_in">size</span>() &lt;&lt;<span class="string">&quot;  v.back: &quot;</span>&lt;&lt;v.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size:  1   v.back:  0</span><br><span class="line">size:  2   v.back:  1</span><br><span class="line">size:  3   v.back:  2</span><br><span class="line">size:  4   v.back:  3</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> string&amp; s) &#123;cout &lt;&lt; <span class="string">&quot;A construct &quot;</span> &lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A&amp; a) &#123;cout &lt;&lt;<span class="string">&quot;A copy&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::map&lt;<span class="keyword">int</span>, string&gt; m;</span><br><span class="line">    vector&lt;A&gt; v;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>;  <span class="comment">// a1 构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">push_back</span>(a1);   <span class="comment">// a1 拷贝构造函数</span></span><br><span class="line">    v.<span class="built_in">emplace_back</span>(a1);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//先运行构造函数，后拷贝构造函数</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">A</span>(<span class="string">&quot;test&quot;</span>) );</span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="built_in">A</span>(<span class="string">&quot;test&quot;</span>) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v.push_back(&quot;test&quot;);  报错</span></span><br><span class="line">    <span class="comment">// 这个才是真正的用途</span></span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="string">&quot;test&quot;</span>);   <span class="comment">// 隐式转换，只有拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;******************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于C++ 11里vector的<code>emplace_back</code>函数比较失望，都说提高了效率，其实它仅对于元素做隐式转换的情况有效，此时没有产生临时对象。对其他情况，和<code>push_back</code>没区别。  </p>
<p>这里用到的c++11特性<strong>完美转发</strong>：将接收下来的参数原样完美地传递给对象的构造函数，这带来另一个方便性就是即使是构造函数声明为 <code>explicit</code> 它还是可以正常工作，因为它不存在临时变量和隐式转换。</p>
<h2 id="map-emplace"><a href="#map-emplace" class="headerlink" title="map::emplace"></a>map::emplace</h2><p>map就只有<code>emplace</code>，机制也是一样的。元素是直接构建的，既不复制也不移动，仅当键不存在时才插入。<br>但是map有个问题：emplace 方法把它接收到的所有的参数都一起转发给 <code>pair</code> 的构造函数。但是对于一个 <code>pair</code> 来说，它既需要构造它的 key 又需要构造它的 value。如果我们按照之前普通的语法使用变参模板的话，则它是无法区分哪些参数用来构造 key, 哪些用来构造 value的。 比如下面的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法区分哪个参数用来构造 key 哪些用来构造 value</span></span><br><span class="line"><span class="comment">// 有可能是 std::string s(&quot;hello&quot;, 1), std::complex&lt;double&gt; cpx(2) </span></span><br><span class="line"><span class="comment">// 也有可能是 std::string s(&quot;hello&quot;), std::complex&lt;double&gt; cpx(1, 2)</span></span><br><span class="line">std::map&lt;std::string, std::complex&lt;<span class="keyword">double</span>&gt;&gt; scp;</span><br><span class="line">scp.<span class="built_in">emplace</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">1</span>, <span class="number">2</span>); </span><br></pre></td></tr></table></figure><br>考虑使用可以接受异构、变长参数的 tuple 来对参数进行分组。再使用 C++11 提供的一个特殊类型 <code>piecewise_construct_t</code> 来帮助它们找到各自正确的构造函数了。<code>std::piecewise_construct_t</code> 是一个空类，全局变量 <code>std::piecewise_construct</code> 就是该类型的一个变量。</p>
<p><code>std::piecewise_construct</code>作为构造 pair 对象的第一个参数传递，以选择构造函数形式，通过将两个元组对象的元素转发给它们各自的构造函数来构造其成员。即第一个 tuple 作为 key，第二个 tuple 作为 value。 使用 <code>forward_as_tuple</code>，该函数会构造一个 tuple 并转发给 pair。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 想对于 map 避免临时变量的构造的话，就需要构建两个 tuple</span></span><br><span class="line">std::map&lt;std::string, std::complex&lt;<span class="keyword">double</span>&gt;&gt; scp;</span><br><span class="line">scp.<span class="built_in">emplace</span>(std::piecewise_construct, <span class="comment">// 此常量值作为构造 pair 对象的第一个参数传递，以选择构造函数形式，通过将两个元组对象的元素转发给它们各自的构造函数来构造其成员。</span></span><br><span class="line">    std::forward_as_tuple(<span class="string">&quot;hello&quot;</span>), <span class="comment">// 该函数会构造一个 tuple 并转发给 pair 构造，并存储在 first 字段</span></span><br><span class="line">    std::forward_as_tuple(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">//该函数会构造一个 tuple 并转发给 pair 构造，存储在 second 字段</span></span><br></pre></td></tr></table></figure>
<p>cartographer中的代码就是这样<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::map&lt;int, ::cartographer::mapping::PoseExtrapolator&gt;  extrapolators_;</span></span><br><span class="line">  <span class="comment">// PoseExtrapolator的构造函数有2个参数：common::Duration   pose_queue_duration,</span></span><br><span class="line">                                  <span class="comment">//      double   imu_gravity_time_constant</span></span><br><span class="line">  extrapolators_.<span class="built_in">emplace</span>(</span><br><span class="line">      std::piecewise_construct, </span><br><span class="line">      std::forward_as_tuple(trajectory_id),</span><br><span class="line">      std::forward_as_tuple(</span><br><span class="line">          ::cartographer::common::<span class="built_in">FromSeconds</span>(kExtrapolationEstimationTimeSec),</span><br><span class="line">          gravity_time_constant)  );</span><br></pre></td></tr></table></figure></p>
<h2 id="无参的emplace-back"><a href="#无参的emplace-back" class="headerlink" title="无参的emplace_back"></a>无参的emplace_back</h2><p>还有一种使用无参的<code>vector::emplace_back()</code> 或者 <code>deque::emplace_back()</code>，下面是从cartographer中学来的代码，确实有一定技巧<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    vector&lt;std::unique_ptr&lt;A&gt; &gt; dd;</span><br><span class="line">    dd.<span class="built_in">emplace_back</span>();</span><br><span class="line">    <span class="comment">// 注意这里的 size 也是1</span></span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;capacity: &quot;</span>&lt;&lt; dd.<span class="built_in">capacity</span>() &lt;&lt;<span class="string">&quot; size: &quot;</span>&lt;&lt; dd.<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; dd.at(0)-&gt;getValue() &lt;&lt;endl;  这里运行会崩溃</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span>*  a1 = &amp;dd.<span class="built_in">back</span>();  <span class="comment">// 这个是 unique_ptr</span></span><br><span class="line">    a1-&gt;<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">5</span>) );  <span class="comment">// 不能再用=，unique_ptr不能复制</span></span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;capacity: &quot;</span>&lt;&lt; dd.<span class="built_in">capacity</span>() &lt;&lt;<span class="string">&quot; size: &quot;</span>&lt;&lt; dd.<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; dd.<span class="built_in">at</span>(<span class="number">0</span>)-&gt;<span class="built_in">getValue</span>() &lt;&lt;endl;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">capacity: 1 size: 1</span><br><span class="line">A construct </span><br><span class="line">capacity: 1 size: 1</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://haoqchen.site/2020/01/17/emplace_back-vs-push_back/">emplace_back VS push_back</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/07/31/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8E%E7%AB%AF%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%201%20thread_pool%20%E5%92%8C%20task/">后端的线程池 1 thread_pool 和 task</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-31</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分不重要的成员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolInterface</span>;</span></span><br><span class="line">  <span class="function">State <span class="title">GetState</span><span class="params">()</span> <span class="title">LOCKS_EXCLUDED</span><span class="params">(mutex_)</span></span>;     <span class="comment">//返回本Task当前状态</span></span><br><span class="line">  <span class="comment">// 设置Task 执行的任务 （函数）</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetWorkItem</span><span class="params">(<span class="keyword">const</span> WorkItem&amp; work_item)</span></span>; </span><br><span class="line">  <span class="comment">// 给当前任务添加 依赖任务， 如当前任务为b，AddDependency(a)表示任务a依赖b </span></span><br><span class="line">  <span class="comment">// 把当前任务b，加入到依赖任务 a 的 dependent_tasks_ 列表</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddDependency</span><span class="params">(std::weak_ptr&lt;Task&gt; dependency)</span> <span class="title">LOCKS_EXCLUDED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 执行当前任务，比如当前任务为a，并更新依赖a的任务dependent_tasks_中所有任务状态</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Execute</span><span class="params">()</span> <span class="title">LOCKS_EXCLUDED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前任务进入线程待执行队列</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetThreadPool</span><span class="params">(ThreadPoolInterface* thread_pool)</span> <span class="title">LOCKS_EXCLUDED</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前任务的依赖任务完成时候，当前任务状态随之改变</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">OnDependenyCompleted</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">using</span>  WorkItem = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span>  <span class="title">State</span> &#123;</span> NEW, DISPATCHED, DEPENDENCIES_COMPLETED, RUNNING, COMPLETED &#125;;</span><br><span class="line">  <span class="comment">// 任务具体执行过程</span></span><br><span class="line">  WorkItem   work_item_ ;</span><br><span class="line">  <span class="comment">// 执行当前任务的线程池</span></span><br><span class="line">  ThreadPoolInterface*  thread_pool_to_notify_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="function">State   state_  <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span> </span>= NEW; <span class="comment">// 初始化状态为 NEW</span></span><br><span class="line">  <span class="comment">// 依赖当前任务的任务列表</span></span><br><span class="line">  <span class="function">std::set&lt;Task*&gt;  dependent_tasks_  <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Task类不是线程，可以理解为<strong>有状态和依赖的函数</strong>，核心的成员变量<code>work_item_</code>是仿函数，其返回类型void。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分不重要的成员</span></span><br><span class="line"><span class="comment">// 不明白为什么要先构造个抽象类，只有这一个派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> :</span> <span class="keyword">public</span> ThreadPoolInterface</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> 	<span class="comment">//初始化一个线程数量固定的线程池。</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> num_threads)</span></span>;</span><br><span class="line">  <span class="comment">// 添加想要ThreadPool执行的task，插入 tasks_not_ready_</span></span><br><span class="line">  <span class="comment">// 如果任务满足执行要求，直接插入task_queue_准备执行</span></span><br><span class="line">  <span class="function">std::weak_ptr&lt;Task&gt;  <span class="title">Schedule</span><span class="params">(std::unique_ptr&lt;Task&gt; task)</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> 	<span class="comment">//每个线程初始化时, 执行DoWork()函数. 与线程绑定</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">DoWork</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">NotifyDependenciesCompleted</span><span class="params">(Task* task)</span></span>;</span><br><span class="line">  <span class="comment">//running_只是一个监视哨, 只有线程池在running_状态时, 才能往work_queue_加入函数</span></span><br><span class="line">  <span class="keyword">bool</span> running_  = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// pool_就是一系列线程</span></span><br><span class="line">  std::vector&lt;std::thread&gt;  pool_ ;</span><br><span class="line">  <span class="comment">// 十分重要的任务队列</span></span><br><span class="line">  std::deque&lt;std::shared_ptr&lt;Task&gt;&gt;  task_queue_ ; </span><br><span class="line">  <span class="comment">//未准备好的 task，task可能有依赖还未完成</span></span><br><span class="line">  absl::flat_hash_map&lt;Task*, std::shared_ptr&lt;Task&gt;&gt;  tasks_not_ready_;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看构造函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="keyword">int</span> num_threads)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">absl::MutexLock  <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// 原来还是用了std::thread，还以为google连线程也是自己实现的</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != num_threads; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// std::vector&lt;std::thread&gt;   pool_;</span></span><br><span class="line">    pool_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]() &#123; ThreadPool::<span class="built_in">DoWork</span>(); &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>大致看<code>ThreadPool::DoWork()</code>，最后执行了<code>ThreadPoolInterface::Execute</code>，其实就是<code>Task::Execute</code>。 每个线程与DoWork()函数绑定,也就是线程在后台不断执行DoWork()函数</p>
<p>新的Task如果有依赖项，通过<code>Thread_pool::Schedule</code>添加到 <code>Thread_pool</code>的 <code>tasks_not_ready_</code>队列中。队列中的Task状态是变化的，等依赖项执行完成，Task状态变为<code>DEPENDENCIES_COMPLETED</code>，然后再插入<code>task_queue_</code>队列。最终所有Task都会插入<code>task_queue_</code>中，在<code>DoWork</code>中得到执行。 </p>
<p>如果该Task没有依赖，直接插入<code>task_queue_</code>，准备执行。</p>
<p>对任一个任务的状态转换顺序为：NEW—-&gt;DISPATCHED—-&gt;DEPENDENCIES_COMPLETED—-&gt;RUNNING—-&gt;COMPLETED</p>
<p><code>Thread_pool</code>通过固定数量的thread与<code>task_queue_</code>（待执行的task队列）执行函数绑定。Thread_pool 按照队列首尾顺序不断执行Task。</p>
<p><img src="https://i.loli.net/2021/07/31/biVycPTkQoaDOeB.png" alt="示意图"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/07/30/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8E%E7%AB%AF%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%202%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8Cwork_queue/">后端的线程池 2 线程池和work_queue</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p><code>cartographer_ros</code>节点main函数所在的称为main线程，其它的称后台线程。<code>PoseGrapher::AddNode</code>在main线程，但计算两种约束、优化全局位姿都在后台线程。</p>
<p>PoseGraph有一个线程池，配置一定数量的线程来执行优化任务。线程池在<code>MapBuilder</code>构造函数中创建，作为参数给<code>PoseGraph</code>对象，PoseGraph将其作为 <code>constraints::ConstraintBuilder2D</code>的初始化使用。每个线程执行 <code>ThreadPool::DoWork()</code>函数。 <code>DoWork()</code>函数会一直循环遍历一个<code>deque</code>队列中的Task任务，每次执行完一个Task，就会从队列弹出。  即<code>std::deque&lt;std::shared_ptr&lt;Task&gt; &gt;  task_queue_</code></p>
<p>这个<code>task_queue_</code>的添加任务追溯到线程池的<code>Schedule</code>函数，<code>Schedule</code>函数在<code>PoseGraph2D::AddWorkItem</code>和添加约束的函数里</p>
<p>每次收到SLAM需要的信息都会生成一个work，这个work都会保存到PoseGraph的<code>work_queue_</code>队列中，上面说的task通过<code>SetWorkItem</code>进一步执行<code>DrainWorkQueue</code>， 进而从 <code>work_queue_</code>中取出 WorkItem 执行。这些 WorkItem 是由pose_graph添加各种传感器数据和 Node的时候加入到该队列的，比如<code>AddImuData</code></p>
<h2 id="lambda-和-仿函数"><a href="#lambda-和-仿函数" class="headerlink" title="lambda 和 仿函数"></a>lambda 和 仿函数</h2><p>看<code>work_queue_</code>队列之前，先要搞清lambda 和 仿函数是怎么回事。</p>
<p>先看一个简单的仿函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// int是返回值类型，括号里是参数的类型</span></span><br><span class="line">std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">float</span>, <span class="keyword">float</span>)&gt; func = add;</span><br><span class="line">cout&lt;&lt; <span class="built_in">func</span>(<span class="number">2.4</span>, <span class="number">6.9</span>) &lt;&lt;endl;</span><br></pre></td></tr></table></figure></p>
<p>lambda表达式通常仅仅是仿函数的语法糖，可以直接转换为仿函数。[]中的任何内容都会转换为构造函数参数和仿函数对象的成员，而()中的参数将转换为仿函数operator()的参数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddWorkItem</span><span class="params">(std::function&lt;<span class="keyword">int</span>()&gt;&amp;  work_item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">work_item</span>() &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddImuData</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// []：默认不捕获任何变量</span></span><br><span class="line">	<span class="comment">// [=]：默认以值捕获所有变量</span></span><br><span class="line">	<span class="comment">// 其实可以用 auto</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>()&gt; func = [=]()&#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;input: &quot;</span>&lt;&lt; a &lt;&lt; <span class="string">&quot;  &quot;</span>&lt;&lt; b&lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//    std::function&lt;int(float,float)&gt; func2 = add;</span></span><br><span class="line">    <span class="built_in">AddWorkItem</span>( func );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 函数中调用</span></span><br><span class="line"><span class="built_in">AddImuData</span>(<span class="number">29</span>, <span class="number">7</span>);</span><br></pre></td></tr></table></figure><br>把cartographer中的函数做了修改，这样容易理解。 main 函数中调用<code>AddImuData</code>，我们要的是运行lambda表达式，假如<code>AddWorkItem</code>是空函数，那么不会有运行结果。<code>work_item()</code>才是实际的运行lambda表达式。 </p>
<h2 id="workqueue-机制"><a href="#workqueue-机制" class="headerlink" title="workqueue 机制"></a>work<em>queue</em> 机制</h2><p><code>PoseGraph2D</code>有16个成员函数调用了<code>AddWorkItem</code>，也就是加入了<code>work_queue_</code>队列。操作<code>work_queue_</code>的函数主要是<code>AddWorkItem</code> 和 <code>DrainWorkQueue</code></p>
<p>以<code>PoseGraph2D::AddImuData</code>为例:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::AddImuData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> trajectory_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> sensor::ImuData&amp; imu_data)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">AddWorkItem</span>( [=]() <span class="built_in">LOCKS_EXCLUDED</span>(mutex_)</span><br><span class="line">  &#123;</span><br><span class="line">    absl::MutexLock <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CanAddWorkItemModifying</span>(trajectory_id)) &#123;</span><br><span class="line">      optimization_problem_-&gt;<span class="built_in">AddImuData</span>(trajectory_id, imu_data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> WorkItem::Result::kDoNotRunOptimization;</span><br><span class="line">  &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>后面会看到<code>AddWorkItem</code>的参数是一个仿函数<code>std::function</code>。 <code>AddImuData</code>实际上就一句，也就是调用了<code>AddWorkItem</code>， 这里面的<code>AddWorkItem</code>的参数其实是把一个lambda表达式作为仿函数，这个仿函数的返回值是<code>WorkItem::Result</code>，实际是枚举值<code>kDoNotRunOptimization</code> 或者 <code>kRunOptimization</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个函数地址加入到一个工作队列中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::AddWorkItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::function&lt;WorkItem::Result()&gt;&amp; work_item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">absl::MutexLock  <span class="title">locker</span><span class="params">(&amp;work_queue_mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// 如果工作队列未被初始化，则先初始化，再打开启线程池，后台打开任务队列执行循环</span></span><br><span class="line">  <span class="comment">// 这也是唯一初始化 work_queue_ 的地方</span></span><br><span class="line">  <span class="comment">// std::unique_ptr&lt;WorkQueue&gt;  work_queue_</span></span><br><span class="line">  <span class="keyword">if</span> (work_queue_ == <span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    work_queue_ = absl::make_unique&lt;WorkQueue&gt;();</span><br><span class="line">    <span class="comment">// DrainWorkQueue函数加入到线程池</span></span><br><span class="line">    <span class="keyword">auto</span> task = absl::make_unique&lt;common::Task&gt;();</span><br><span class="line">    task-&gt;<span class="built_in">SetWorkItem</span>([<span class="keyword">this</span>]() &#123; <span class="built_in">DrainWorkQueue</span>(); &#125;);</span><br><span class="line">    thread_pool_-&gt;<span class="built_in">Schedule</span>(std::<span class="built_in">move</span>(task)  );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> now = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  work_queue_-&gt;<span class="built_in">push_back</span>(&#123;now, work_item&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>work_queue_</code>的类型是<code>std::unique_ptr&lt;WorkQueue&gt;</code>， <code>WorkQueue</code>是<code>WorkItem</code>的deque。根据上面的分析，<font color = blue size=4> 我们要想运行lambda表达式，要的是 work_item()</font>，但是这个函数里没看到，因为这里只有添加，是添加到<code>work_queue_</code>里了。实际的运行在<code>DrainWorkQueue</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::DrainWorkQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> process_work_queue = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">size_t</span> work_queue_size;</span><br><span class="line">  <span class="keyword">while</span> (process_work_queue)</span><br><span class="line">  &#123;</span><br><span class="line">    std::function&lt;WorkItem::<span class="built_in">Result</span>()&gt; work_item;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;work_queue_mutex_)</span></span>;</span><br><span class="line">      <span class="comment">// work_queue_ 队列中取出压栈的任务一个一个执行，直到为空</span></span><br><span class="line">      <span class="comment">// work_queue_ 为空, 说明thread_pool中DrainWorkQueue执行完,</span></span><br><span class="line">      <span class="comment">// 等待下一次addNode时候,再次执行thread_pool_-&gt;Schedule(task),再次执行.</span></span><br><span class="line">      <span class="keyword">if</span> (work_queue_-&gt;<span class="built_in">empty</span>())</span><br><span class="line">      &#123;</span><br><span class="line">        work_queue_.<span class="built_in">reset</span>();  <span class="comment">// 智能指针 reset</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取队列中最前的任务，这就是上面说的 work_item</span></span><br><span class="line">      work_item = work_queue_-&gt;<span class="built_in">front</span>().task;</span><br><span class="line">      work_queue_-&gt;<span class="built_in">pop_front</span>();</span><br><span class="line">      work_queue_size = work_queue_-&gt;<span class="built_in">size</span>();</span><br><span class="line">      kWorkQueueSizeMetric-&gt;<span class="built_in">Set</span>(work_queue_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里的 work_item()就是我们需要的 AddImuData里的lambda表达式</span></span><br><span class="line">    <span class="comment">//回头看lambda，可以发现返回值是 kDoNotRunOptimization</span></span><br><span class="line">    <span class="comment">// 执行工作任务后，返回的状态，赋值false或true给 process_work_queue</span></span><br><span class="line">    process_work_queue = <span class="built_in">work_item</span>() == WorkItem::Result::kDoNotRunOptimization;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 运行到这里，说明队列里运行的lambda表达式的返回值是 kRunOptimization</span></span><br><span class="line">  <span class="comment">// 实际上pop了好几个任务</span></span><br><span class="line">  <span class="comment">//  如果work_item()都不需要全局优化, 则直到work_queue_为空, 都不会执行优化</span></span><br><span class="line">  <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Remaining work items in queue: &quot;</span> &lt;&lt; work_queue_size;</span><br><span class="line">  <span class="comment">// We have to optimize again</span></span><br><span class="line">  constraint_builder_.<span class="built_in">WhenDone</span>(</span><br><span class="line">      [<span class="keyword">this</span>](<span class="keyword">const</span> constraints::ConstraintBuilder2D::Result&amp; result)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">HandleWorkQueue</span>(result);</span><br><span class="line">      &#125;  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面说了<code>PoseGraph2D</code>有16个成员函数调用了<code>AddWorkItem</code>，但是发现只有3个函数会返回<code>kRunOptimization</code>：<br><code>FinishTrajectory</code>, <code>RunFinalOptimization</code>和 <code>ComputeConstraintsForNode</code>。</p>
<p>16个里面最重要的当然是后端入口函数<code>PoseGraph2D::AddNode</code>，在它的<code>work_item</code>是<code>ComputeConstraintsForNode</code>， 在<code>ComputeConstraintsForNode</code>的最后部分：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options_.<span class="built_in">optimize_every_n_nodes</span>() &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">  num_nodes_since_last_loop_closure_ &gt; options_.<span class="built_in">optimize_every_n_nodes</span>() )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span>  WorkItem::Result::kRunOptimization;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  WorkItem::Result::kDoNotRunOptimization;</span><br></pre></td></tr></table></figure><br>整个SLAM中实时进入任务队列的主要为<strong>计算约束</strong>，当加入节点数超过参数时，才进行一次优化。</p>
<h2 id="ConstraintBuilder2D-WhenDone"><a href="#ConstraintBuilder2D-WhenDone" class="headerlink" title="ConstraintBuilder2D::WhenDone"></a>ConstraintBuilder2D::WhenDone</h2><p>最后的<code>ConstraintBuilder2D::WhenDone</code>又用到了lambda表达式，又涉及到线程池，实际的后台优化是在<code>HandleWorkQueue</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Result 就是 vector&lt;Constraint&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstraintBuilder2D::WhenDone</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> std::function&lt;<span class="keyword">void</span>(<span class="keyword">const</span> ConstraintBuilder2D::Result&amp;)&gt;&amp; callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="built_in">CHECK</span>(when_done_ == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 成员 unique_ptr&lt;std::function&lt;void(const Result&amp;)&gt;&gt;   when_done_;</span></span><br><span class="line">  when_done_ = absl::make_unique&lt;std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> Result&amp;)&gt; &gt; (callback);</span><br><span class="line">  <span class="built_in">CHECK</span>(when_done_task_ != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 约束的计算结果通过回调进行回传</span></span><br><span class="line">  when_done_task_-&gt;<span class="built_in">SetWorkItem</span>([<span class="keyword">this</span>] &#123; <span class="built_in">RunWhenDoneCallback</span>(); &#125;);</span><br><span class="line">  thread_pool_-&gt;<span class="built_in">Schedule</span>(std::<span class="built_in">move</span>(when_done_task_));</span><br><span class="line">  when_done_task_ = absl::make_unique&lt;common::Task&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里实际就是处理<code>when_done_task_</code>，它是在<code>finish_node_task</code>执行完之后才执行的，内容就是<code>HandleWorkQueue</code></p>
<p>优化执行完毕时的回调函数<code>RunWhenDoneCallback</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstraintBuilder2D::RunWhenDoneCallback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Result result;</span><br><span class="line">  std::unique_ptr&lt;std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> Result&amp;)&gt;&gt; callback;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    <span class="built_in">CHECK</span>(when_done_ != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 将约束结果放入 result</span></span><br><span class="line">    <span class="comment">// MaybeAddConstraint 里添加 constraints_</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> std::unique_ptr&lt;Constraint&gt;&amp; constraint : constraints_)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (constraint == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">      result.<span class="built_in">push_back</span>(*constraint);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (options_.<span class="built_in">log_matches</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(INFO) &lt;&lt; constraints_.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; computations resulted in &quot;</span></span><br><span class="line">                &lt;&lt; result.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; additional constraints.&quot;</span>;</span><br><span class="line">      <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Score histogram:\n&quot;</span> &lt;&lt; score_histogram_.<span class="built_in">ToString</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    constraints_.<span class="built_in">clear</span>();</span><br><span class="line">    callback = std::<span class="built_in">move</span>(when_done_);</span><br><span class="line">    when_done_.<span class="built_in">reset</span>();</span><br><span class="line">    kQueueLengthMetric-&gt;<span class="built_in">Set</span>(constraints_.<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 我理解的 HandleWorkQueue 是在这里</span></span><br><span class="line">  (*callback)(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>scan match</code>的过程如下<br><img src="https://i.loli.net/2021/07/31/8qGxjrQ2ngBylNT.png" alt=""><br><code>AddImuData</code>等函数不是直接放到线程里运行的，进线程池的是<code>DrainWorkQueue</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/07/26/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/cartographer%E7%9A%84%E6%97%A5%E5%BF%97/">cartographer的gflag和glog日志</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/">原理和配置</a></span><div class="content"><h2 id="gflag"><a href="#gflag" class="headerlink" title="gflag"></a>gflag</h2><p><img src="https://s2.loli.net/2022/03/19/ZjlsqPvr4Xkug5z.png" alt="CHECK宏.png"><br><code>先看DEFINE</code>宏，有三个宏：flag的名称，flag的默认值，help字符串。如何查看help信息呢，在执行可执行文件时加上–help选项即可，但是如果要显示help信息，代码里需要调用接口<code>gflags::ParseCommandLineFlags(&amp;argc, &amp;argv, true)</code></p>
<p>gflags支持的变量类型如下：</p>
<ul>
<li>DEFINE_bool: 布尔类型</li>
<li>DEFINE_int32: 32-bit 整型</li>
<li>DEFINE_int64: 64-bit 整型</li>
<li>DEFINE_uint64: 无符号 64-bit 整型</li>
<li>DEFINE_double: double</li>
<li>DEFINE_string: C++ string</li>
</ul>
<p>在程序中使用flag，对于DEFINE过的flag我们可以像使用普通变量那样读写它，只需加一个<code>FLAGS_</code>前缀即可，如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FLAGS_is_handsome)</span><br><span class="line">    FLAGS_is_handsome = <span class="literal">false</span>; </span><br><span class="line">std::cout &lt;&lt; FLAGS_hobby &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">DEFINE_string</span>(configuration_directory, <span class="string">&quot;&quot;</span>,</span><br><span class="line">              <span class="string">&quot;First directory in which configuration files are searched, &quot;</span></span><br><span class="line">              <span class="string">&quot;second is always the Cartographer installation to allow &quot;</span></span><br><span class="line">              <span class="string">&quot;including files from there.&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CHECK_EQ(x,y)    ==</span><br><span class="line">CHECK_NE(x,y)    =</span><br><span class="line">CHECK_LE(x,y)    &lt;=</span><br><span class="line">CHECK_LT(x,y)    &lt;</span><br><span class="line">CHECK_GE(x,y)    &gt;=</span><br><span class="line">CHECK_GT(x,y)    &gt;</span><br></pre></td></tr></table></figure>
<h2 id="glog"><a href="#glog" class="headerlink" title="glog"></a>glog</h2><p>Google glog是一个基于程序级记录日志信息的c++库，编程使用方式与c++的stream操作类似。 每个级别的日志除了输出到对应日志文件中，还输出到每个低级别日志文件中。默认ERROR和FATAL消息除了输出到日志文件中之外，还会输出到标准错误中<br><img src="https://s2.loli.net/2022/03/19/9qURfx4E81uTaSb.png" alt="在CMakeLists中的配置.png"><br>每个级别都对应有相应的日志文件，文件默认存放在临时文件中，Linux是 <code>/tmp</code>。运行cartographer之后，可以在<code>/tmp</code>里看到<br><img src="https://i.loli.net/2021/07/26/1xO5wh6FdBP4Mbc.png" alt=""></p>
<p>glog的库文件都在<code>/usr/lib/x86_64-linux-gnu</code></p>
<h2 id="自定义cartographer的日志格式"><a href="#自定义cartographer的日志格式" class="headerlink" title="自定义cartographer的日志格式"></a>自定义cartographer的日志格式</h2><p><code>glog</code>的明显缺点就是配置输出格式不方便，还要修改源码的<code>logging.cc</code>，重新编译。我下载<code>glog 0.5.0</code>后，修改logging.cc文件再编译安装，结果导致cartographer报错，<code>ScopedRosLogSink::send</code>没有链接，应当是和现有的glog造成了冲突，然后一直解决不了。</p>
<p>然后尝试在<code>ros_log_sink.cc</code>中添加函数，就是把<code>::google::LogSink::ToString</code>重新定义到<code>ros_log_sink.cc</code>，这样避开glog的链接问题。头文件当然也要添加这个成员函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">ScopedRosLogSink::ToString</span><span class="params">(<span class="keyword">const</span> ::google::LogSeverity severity, <span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">int</span> line,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">const</span> struct ::tm* tm_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">const</span> <span class="keyword">char</span>* message, <span class="keyword">size_t</span> message_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">ostringstream <span class="title">stream</span><span class="params">(string(message, message_len))</span></span>;</span><br><span class="line">  stream.<span class="built_in">fill</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  stream &lt;&lt; <span class="string">&#x27;[&#x27;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="number">1</span>+tm_time-&gt;tm_mon</span><br><span class="line">         &lt;&lt; <span class="string">&#x27;_&#x27;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tm_time-&gt;tm_mday</span><br><span class="line">         &lt;&lt; <span class="string">&quot;  &quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tm_time-&gt;tm_hour &lt;&lt; <span class="string">&#x27;:&#x27;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tm_time-&gt;tm_min &lt;&lt; <span class="string">&#x27;:&#x27;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; tm_time-&gt;tm_sec &lt;&lt; <span class="string">&quot;  &quot;</span></span><br><span class="line">         &lt;&lt; file &lt;&lt; <span class="string">&quot;: &quot;</span>  &lt;&lt; line &lt;&lt; <span class="string">&quot;] &quot;</span>;</span><br><span class="line"></span><br><span class="line">  stream &lt;&lt; <span class="built_in">string</span>(message, message_len);</span><br><span class="line">  <span class="keyword">return</span> stream.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>tm_time</code>只精确到秒，这样日志就不能精确到毫秒了，不过目前还不需要。<code>ScopedRosLogSink::send</code>的开头改为<code>ToString</code>函数。这样改完后，日志格式可能还不是想要的<br><img src="https://s2.loli.net/2022/04/21/6HSV8jluRnNh1tk.png" alt="默认日志格式.png"><br>后来才发现原来cartographer的日志格式是把glog的格式和ROS的格式融合一起了，所以修改环境变量如下<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ROSCONSOLE_FORMAT=<span class="string">&#x27;[$&#123;message&#125;&#x27;</span></span><br></pre></td></tr></table></figure><br><img src="https://s2.loli.net/2022/04/21/b9D67wG32xFNEWR.png" alt="修改后的日志.png"></p>
<h2 id="几个常用参数"><a href="#几个常用参数" class="headerlink" title="几个常用参数"></a>几个常用参数</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FLAGS_logtostderr = <span class="literal">true</span>; // 设置日志消息是否转到标准输出而不是日志文件</span><br><span class="line"></span><br><span class="line">FLAGS_alsologtostderr = <span class="literal">true</span>; // 设置日志消息除了日志文件之外是否去标准输出</span><br><span class="line"></span><br><span class="line">FLAGS_colorlogtostderr = <span class="literal">true</span>; // 设置记录到标准输出的颜色消息（如果终端支持）</span><br><span class="line"></span><br><span class="line">FLAGS_logbufsecs = ; // 设置可以缓冲日志的最大秒数，0指实时输出</span><br><span class="line"></span><br><span class="line">FLAGS_max_log_size = ; // 设置最大日志文件大小（以MB为单位）</span><br><span class="line"></span><br><span class="line">FLAGS_stop_logging_if_full_disk = <span class="literal">true</span>; // 设置是否在磁盘已满时避免日志记录到磁盘</span><br></pre></td></tr></table></figure>
<p>cartographer的大部分文件都可以直接使用<code>LOG(INFO)&lt;&lt;&quot;log&quot;;</code>这样的语句，因为都提前配置好了，但是最好重新指定日志路径。</p>
<ul>
<li><code>google::SetLogDestination(google::INFO, &quot;log/INFO_&quot;);</code>  // 设置特定级别的日志的输出目录和前缀。第一个参数为日志级别，第二个参数表示输出目录及日志文件名前缀</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glog/logging.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    google::<span class="built_in">InitGoogleLogging</span>(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// INFO</span></span><br><span class="line">    std::string str_info;</span><br><span class="line">    <span class="comment">// 文件名最后只能是   等级+下划线</span></span><br><span class="line">    str_info.<span class="built_in">append</span>(<span class="string">&quot;/home/user/log/INFO_&quot;</span>);</span><br><span class="line">    google::<span class="built_in">SetLogDestination</span>(google::INFO, str_info.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG</span>(INFO)&lt;&lt; <span class="string">&quot;The is a info!&quot;</span>;</span><br><span class="line">    <span class="comment">// WARNING</span></span><br><span class="line">    std::string str_warn;</span><br><span class="line">    str_warn.<span class="built_in">append</span>(<span class="string">&quot;/home/user/log/WARNING_&quot;</span>);</span><br><span class="line">    google::<span class="built_in">SetLogDestination</span>(google::WARNING, str_warn.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING) &lt;&lt; <span class="string">&quot;The is a warning!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stop glog  可以没有</span></span><br><span class="line">    google::<span class="built_in">ShutdownGoogleLogging</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次运行cartographer后发现在自定义的路径里，INFO开头的日志文件每次都会新建，而INFO结尾的日志是最新运行得到的日志<br><img src="https://i.loli.net/2021/07/26/FBD5a21MecbpOI6.png" alt=""><br><img src="https://i.loli.net/2021/07/26/pm8qsza4KxV7BrQ.png" alt=""></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/07/26/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8E%E7%AB%AF%204%20%E8%AE%A1%E7%AE%97%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/">后端 4 计算约束的准备工作</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>接上一篇，看两次计算约束的函数 <code>ComputeConstraint</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据指定的 nodeid 和 submapid 计算其约束</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::ComputeConstraint</span><span class="params">(<span class="keyword">const</span> NodeId&amp; node_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">const</span> SubmapId&amp; submap_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span>  maybe_add_local_constraint = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">bool</span>  maybe_add_global_constraint = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span>  TrajectoryNode::Data*  constant_data;</span><br><span class="line">  <span class="keyword">const</span>  Submap2D* submap;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    <span class="built_in">CHECK</span>(data_.submap_data.<span class="built_in">at</span>(submap_id).state == SubmapState::kFinished);</span><br><span class="line">    <span class="keyword">if</span> (!data_.submap_data.<span class="built_in">at</span>(submap_id).submap-&gt;<span class="built_in">insertion_finished</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Uplink server only receives grids when they are finished,</span></span><br><span class="line">      <span class="comment">// so skip constraint search before that.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取两个id最新的那个时刻</span></span><br><span class="line">    <span class="keyword">const</span> common::Time  node_time = <span class="built_in">GetLatestNodeTime</span>(node_id, submap_id);</span><br><span class="line">    <span class="keyword">const</span> common::Time  last_connection_time =</span><br><span class="line">        data_.trajectory_connectivity_state.<span class="built_in">LastConnectionTime</span>(</span><br><span class="line">            node_id.trajectory_id,  submap_id.trajectory_id );</span><br><span class="line">    <span class="comment">// 如果节点与submap在同一轨迹内或者距离上次全局约束时间较短，则计算局部约束</span></span><br><span class="line">    <span class="keyword">if</span> (node_id.trajectory_id == submap_id.trajectory_id ||</span><br><span class="line">        node_time &lt;</span><br><span class="line">            last_connection_time +</span><br><span class="line">                common::<span class="built_in">FromSeconds</span>(</span><br><span class="line">                    options_.<span class="built_in">global_constraint_search_after_n_seconds</span>()) )</span><br><span class="line">    &#123;</span><br><span class="line">        maybe_add_local_constraint = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不在同一轨迹内，一定间隔计算全局约束</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (global_localization_samplers_[node_id.trajectory_id]-&gt;<span class="built_in">Pulse</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        maybe_add_global_constraint = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    constant_data = data_.trajectory_nodes.<span class="built_in">at</span>(node_id).constant_data.<span class="built_in">get</span>();</span><br><span class="line">    submap = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> Submap2D*&gt;(</span><br><span class="line">        data_.submap_data.<span class="built_in">at</span>(submap_id).submap.<span class="built_in">get</span>()  );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>建图模式，节点与submap在同一轨迹内 或者 存在一个最近的全局约束把节点的轨迹和子图的轨迹连接起来时，使用<code>local search window</code>计算<strong>局部约束</strong>；</p>
</li>
<li><p>纯定位模式，节点与submap不在同一轨迹，使用<strong>全局搜索窗口</strong>计算约束(对整体子图进行回环检测) 。纯定位进行慢，主要就是 <code>global_constraint_search_after_n_seconds</code> 较大导致，迟迟不能确认<code>maybe_add_global_constraint</code>为true</p>
</li>
</ul>
<p>local约束在求解时，搜索窗口小，有初值;   &emsp;&emsp;  global约束在求解时，搜索窗口大，没有初值。 <font color = blue size=4> 记住二者都是计算 Constraint::INTER_SUBMAP </font> </p>
<p><img src="https://i.loli.net/2021/08/21/UaK7k6HD1pSANBy.png" alt=""></p>
<h2 id="准备计算局部和全局约束"><a href="#准备计算局部和全局约束" class="headerlink" title="准备计算局部和全局约束"></a>准备计算局部和全局约束</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (maybe_add_local_constraint)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> transform::Rigid2d  initial_relative_pose =</span><br><span class="line">      optimization_problem_-&gt;<span class="built_in">submap_data</span>()</span><br><span class="line">          .<span class="built_in">at</span>(submap_id)</span><br><span class="line">          .global_pose.<span class="built_in">inverse</span>() *</span><br><span class="line">      optimization_problem_-&gt;<span class="built_in">node_data</span>().<span class="built_in">at</span>(node_id).global_pose_2d;</span><br><span class="line">  <span class="comment">// 添加局部约束，进行闭环匹配，更新相对位置</span></span><br><span class="line">  constraint_builder_.<span class="built_in">MaybeAddConstraint</span>(</span><br><span class="line">      submap_id, submap, node_id, constant_data, initial_relative_pose);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 添加全局约束</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (maybe_add_global_constraint)</span><br><span class="line">  constraint_builder_.<span class="built_in">MaybeAddGlobalConstraint</span>(</span><br><span class="line">      submap_id, submap, node_id, constant_data);</span><br></pre></td></tr></table></figure>
<p>前端得到节点相对于世界的位姿，也可以得到某个子图的世界位姿，因此得到这个节点相对于这个子图的相对位姿，把这个位姿称为 <strong>初始位姿 1</strong>。  之所以要用世界坐标系作为桥梁，是因为子图和这个节点并不一定在在同一条轨迹坐标系中(local map坐标系)</p>
<p>这里主要是<code>ConstraintBuilder2D</code>类的两个函数:  <code>MaybeAddConstraint</code> 和 <code>MaybeAddGlobalConstraint</code>，它们只有细微不同，前者的开头有这样两句：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (initial_relative_pose.<span class="built_in">translation</span>().<span class="built_in">norm</span>() &gt;</span><br><span class="line">      options_.<span class="built_in">max_constraint_distance</span>()  )</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><br>然后就是其中调用的<code>ConstraintBuilder2D::ComputeConstraint</code>不同，局部约束的是  <code>ComputeConstraint(submap_id, submap, node_id, false, constant_data, initial_relative_pose, *scan_matcher, constraint);</code></p>
<p>全局约束的是 <code>ComputeConstraint( submap_id, submap, node_id, true, constant_data, transform::Rigid2d::Identity(),  *scan_matcher, constraint);</code>，也就是 <code>match full submap</code></p>
<h2 id="局部约束"><a href="#局部约束" class="headerlink" title="局部约束"></a>局部约束</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstraintBuilder2D::MaybeAddConstraint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> SubmapId&amp; submap_id,  <span class="keyword">const</span> Submap2D* <span class="keyword">const</span> submap,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> NodeId&amp; node_id, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> TrajectoryNode::Data* <span class="keyword">const</span> constant_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> transform::Rigid2d&amp; initial_relative_pose)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 参数  max_constraint_distance</span></span><br><span class="line">  <span class="comment">// 初始位姿 1 的模不能太大</span></span><br><span class="line">  <span class="comment">// 约束并非无限制距离，若子图和节点的距离太远，则无需考虑约束</span></span><br><span class="line">  <span class="keyword">if</span> (initial_relative_pose.<span class="built_in">translation</span>().<span class="built_in">norm</span>() &gt;</span><br><span class="line">      options_.<span class="built_in">max_constraint_distance</span>() )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">/* 这是 ConstraintBuilder2D类 唯一使用采样器的地方</span></span><br><span class="line"><span class="comment">  ratio 默认 0.3， 参数 sampling_ratio</span></span><br><span class="line"><span class="comment">  sampling_ratio越小， Pulse()返回的false越多，更容易return*/</span></span><br><span class="line">  <span class="keyword">if</span> (!sampler_.<span class="built_in">Pulse</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// std::unique_ptr&lt;std::function&lt;void(const Result&amp;)&gt;&gt;  when_done_;</span></span><br><span class="line">  <span class="keyword">if</span> (when_done_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">LOG</span>(WARNING)</span><br><span class="line">        &lt;&lt; <span class="string">&quot;MaybeAddConstraint was called while WhenDone was scheduled.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  constraints_.<span class="built_in">emplace_back</span>();  <span class="comment">// 添加空元素</span></span><br><span class="line">  kQueueLengthMetric-&gt;<span class="built_in">Set</span>(constraints_.<span class="built_in">size</span>()  );</span><br><span class="line">  <span class="comment">// 指针指向，对最后一个元素赋值</span></span><br><span class="line">  <span class="keyword">auto</span>* <span class="keyword">const</span> constraint = &amp;constraints_.<span class="built_in">back</span>();</span><br><span class="line">  <span class="comment">// fast time scan matcher 在这里</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>* scan_matcher = </span><br><span class="line">      <span class="built_in">DispatchScanMatcherConstruction</span>(submap_id, submap-&gt;<span class="built_in">grid</span>()  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数<code>max_constraint_distance</code>很重要，如果建图回到同一位置，但没有出现回环，可能是因为过程中的累计误差过大了，大于这个参数，导致没有求 inter 约束。</p>
<h3 id="DispatchScanMatcherConstruction"><a href="#DispatchScanMatcherConstruction" class="headerlink" title="DispatchScanMatcherConstruction"></a>DispatchScanMatcherConstruction</h3><p>针对某一个<code>submap_id</code>的submap构建一个扫描匹配器,先看返回类型<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubmapScanMatcher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">const</span> Grid2D* grid = <span class="literal">nullptr</span>;</span><br><span class="line">  std::unique_ptr&lt;scan_matching::FastCorrelativeScanMatcher2D&gt;</span><br><span class="line">      fast_correlative_scan_matcher;</span><br><span class="line">  <span class="comment">// 线程池用的 Task</span></span><br><span class="line">  std::weak_ptr&lt;common::Task&gt;  creation_task_handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> ConstraintBuilder2D::SubmapScanMatcher*</span></span><br><span class="line"><span class="function"><span class="title">ConstraintBuilder2D::DispatchScanMatcherConstruction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> SubmapId&amp; submap_id,  <span class="keyword">const</span> Grid2D* <span class="keyword">const</span> grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(grid);</span><br><span class="line">  <span class="keyword">if</span> (submap_scan_matchers_.<span class="built_in">count</span>(submap_id) != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> &amp;submap_scan_matchers_.<span class="built_in">at</span>(submap_id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Map of dispatched or constructed scan matchers by &#x27;submap_id&#x27;</span></span><br><span class="line">  <span class="comment">// std::map&lt;SubmapId, SubmapScanMatcher&gt;  submap_scan_matchers_</span></span><br><span class="line">  <span class="keyword">auto</span>&amp; submap_scan_matcher = submap_scan_matchers_[submap_id];</span><br><span class="line">  <span class="comment">// 下面都是成员赋值</span></span><br><span class="line">  submap_scan_matcher.grid = grid;</span><br><span class="line">  <span class="keyword">auto</span>&amp; scan_matcher_options = options_.<span class="built_in">fast_correlative_scan_matcher_options</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> scan_matcher_task = absl::make_unique&lt;common::Task&gt;();</span><br><span class="line">  <span class="comment">// 这里也是 work_item 机制</span></span><br><span class="line">  scan_matcher_task-&gt;<span class="built_in">SetWorkItem</span>(</span><br><span class="line">      [&amp;submap_scan_matcher, &amp;scan_matcher_options]() &#123;</span><br><span class="line">        submap_scan_matcher.fast_correlative_scan_matcher =</span><br><span class="line">            absl::make_unique&lt;scan_matching::FastCorrelativeScanMatcher2D&gt;(</span><br><span class="line">                *submap_scan_matcher.grid, scan_matcher_options);</span><br><span class="line">      &#125; );</span><br><span class="line"></span><br><span class="line">  submap_scan_matcher.creation_task_handle = </span><br><span class="line">      thread_pool_-&gt;<span class="built_in">Schedule</span>(std::<span class="built_in">move</span>(scan_matcher_task));</span><br><span class="line">  <span class="keyword">return</span> &amp;submap_scan_matchers_.<span class="built_in">at</span>(submap_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是构造了<code>scan_matcher_task</code>的 <code>work_item</code>，返回 <code>scan_matcher</code>。 </p>
<p>继续看<code>MaybeAddConstraint</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 线程池</span></span><br><span class="line"><span class="keyword">auto</span> constraint_task = absl::make_unique&lt;common::Task&gt;();</span><br><span class="line">constraint_task-&gt;<span class="built_in">SetWorkItem</span>([=]() <span class="built_in">LOCKS_EXCLUDED</span>(mutex_)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">ComputeConstraint</span>(submap_id, submap, node_id, <span class="literal">false</span>, <span class="comment">/* match */</span></span><br><span class="line">                    constant_data, initial_relative_pose, *scan_matcher,</span><br><span class="line">                    constraint);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// constraint_task 依赖 scan_matcher_task</span></span><br><span class="line">constraint_task-&gt;<span class="built_in">AddDependency</span>(scan_matcher-&gt;creation_task_handle);</span><br><span class="line"><span class="keyword">auto</span> constraint_task_handle =</span><br><span class="line">    thread_pool_-&gt;<span class="built_in">Schedule</span>(std::<span class="built_in">move</span>(constraint_task));</span><br><span class="line"><span class="comment">// finish_node_task_ 依赖 constraint_task</span></span><br><span class="line">finish_node_task_-&gt;<span class="built_in">AddDependency</span>(constraint_task_handle);</span><br></pre></td></tr></table></figure><br>其实<code>MaybeAddConstraint</code>做的就是下面的工作，接下来的重点就是 <code>ConstraintBuilder2D::ComputeConstraint</code><br><img src="https://i.loli.net/2021/08/22/DRiJrzEsXdaYKx6.png" alt=""></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/07/25/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a></span><div class="content"><p><img src="https://i.loli.net/2021/07/25/ev2jF16gaTf3GLy.png" alt=""></p>
<p>四叉树和八叉树就是2D和3D的“二分法”，搜索过程与二叉树搜索也类似，二叉树中是将数组sort后存入二叉树中，从而在查找中实现时间复杂度为log2N；四叉树/八叉树是按平面/空间范围划分有序node，将所有points（坐标已知，但是每个点的point在vector中的index可以认为是随机的，没有规律的，所以不能直接根据index取出point(x,y)）放入所属node中，实现所有points的sorted，进而在搜索时，实现时间复杂度为<code>logN</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/07/23/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8E%E7%AB%AF%203%20ComputeConstraintsForNode/">后端 3 ComputeConstraintsForNode</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Constraint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Pose</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      transform::Rigid3d   zbar_ij;</span><br><span class="line">      <span class="keyword">double</span> translation_weight;</span><br><span class="line">      <span class="keyword">double</span> rotation_weight;</span><br><span class="line">    &#125;;</span><br><span class="line">    SubmapId submap_id;  <span class="comment">// &#x27;i&#x27; in the paper.</span></span><br><span class="line">    NodeId node_id;      <span class="comment">// &#x27;j&#x27; in the paper.</span></span><br><span class="line">    <span class="comment">// Pose of the node &#x27;j&#x27; relative to submap &#x27;i&#x27;.</span></span><br><span class="line">    Pose pose;</span><br><span class="line">    <span class="comment">// Differentiates between intra-submap (where node &#x27;j&#x27; was inserted into</span></span><br><span class="line">    <span class="comment">// submap &#x27;i&#x27;) and inter-submap constraints (where node &#x27;j&#x27; was not </span></span><br><span class="line">    <span class="comment">// inserted  into submap &#x27;i&#x27;).</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Tag</span> &#123;</span> INTRA_SUBMAP, INTER_SUBMAP &#125; tag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在看<code>PoseGraph2D::AddNode</code>最后的计算约束<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WorkItem::Result <span class="title">PoseGraph2D::ComputeConstraintsForNode</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> NodeId&amp; node_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;std::shared_ptr&lt;<span class="keyword">const</span> Submap2D&gt;&gt; insertion_submaps,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">bool</span> newly_finished_submap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::vector&lt;SubmapId&gt; submap_ids;</span><br><span class="line">  std::vector&lt;SubmapId&gt; finished_submap_ids;</span><br><span class="line">  std::set&lt;NodeId&gt; newly_finished_submap_node_ids;</span><br></pre></td></tr></table></figure></p>
<p>下面的内容都放到一个大括号内了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; constant_data =</span><br><span class="line">      data_.trajectory_nodes.<span class="built_in">at</span>(node_id).constant_data;</span><br><span class="line">  <span class="comment">//如果只有1个子图，则返回index为0，否则返回最新的两个连续的submap id</span></span><br><span class="line">  submap_ids = <span class="built_in">InitializeGlobalSubmapPoses</span>(</span><br><span class="line">      node_id.trajectory_id, constant_data-&gt;time, insertion_submaps);</span><br></pre></td></tr></table></figure><br>这里有重要函数<code>InitializeGlobalSubmapPoses</code></p>
<h2 id="InitializeGlobalSubmapPoses"><a href="#InitializeGlobalSubmapPoses" class="headerlink" title="InitializeGlobalSubmapPoses"></a>InitializeGlobalSubmapPoses</h2><p>这个主要是为了计算论文里的 <script type="math/tex">\xi_i^m</script>，最终返回的是子图Id<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;SubmapId&gt; <span class="title">PoseGraph2D::InitializeGlobalSubmapPoses</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">int</span> trajectory_id, <span class="keyword">const</span> common::Time time,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::vector&lt;std::shared_ptr&lt;<span class="keyword">const</span> Submap2D&gt;&gt;&amp; insertion_submaps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(!insertion_submaps.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="comment">// std::unique_ptr&lt;optimization::OptimizationProblem2D&gt;  optimization_problem_;</span></span><br><span class="line">  <span class="comment">// MapById&lt;SubmapId, SubmapSpec2D&gt;   submap_data</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; submap_data = optimization_problem_-&gt;<span class="built_in">submap_data</span>();</span><br><span class="line">  <span class="comment">// insertion_submaps 只有一个子图的情况</span></span><br><span class="line">  <span class="comment">// 说明这是该trajectory的第一张 submap</span></span><br><span class="line">  <span class="keyword">if</span> (insertion_submaps.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// If we don&#x27;t already have an entry for the first submap, add one.</span></span><br><span class="line">    <span class="keyword">if</span> (submap_data.<span class="built_in">SizeOfTrajectoryOrZero</span>(trajectory_id) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (data_.initial_trajectory_poses.<span class="built_in">count</span>(trajectory_id) &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        data_.trajectory_connectivity_state.<span class="built_in">Connect</span>(</span><br><span class="line">            trajectory_id,</span><br><span class="line">            data_.initial_trajectory_poses.<span class="built_in">at</span>(trajectory_id).to_trajectory_id,</span><br><span class="line">            time);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 计算该submap的global_pose(查找轨迹的初始位姿来计算), 后加入优化问题</span></span><br><span class="line">      <span class="comment">// ComputeLocalToGlobalTransform 是 local to global map frame transform</span></span><br><span class="line">      optimization_problem_-&gt;<span class="built_in">AddSubmap</span>(</span><br><span class="line">          trajectory_id, transform::<span class="built_in">Project2D</span>(</span><br><span class="line">          <span class="built_in">ComputeLocalToGlobalTransform</span>(</span><br><span class="line">          data_.global_submap_poses_2d, trajectory_id) *</span><br><span class="line">            insertion_submaps[<span class="number">0</span>]-&gt;<span class="built_in">local_pose</span>()</span><br><span class="line">               )</span><br><span class="line">          );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CHECK_EQ</span>(<span class="number">1</span>, submap_data.<span class="built_in">SizeOfTrajectoryOrZero</span>(trajectory_id));</span><br><span class="line">    <span class="comment">// 该trajectory的第一张 submap， 索引 0</span></span><br><span class="line">    <span class="keyword">const</span> SubmapId submap_id&#123;trajectory_id, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">CHECK</span>(data_.submap_data.<span class="built_in">at</span>(submap_id).submap == insertion_submaps.<span class="built_in">front</span>());</span><br><span class="line">    <span class="keyword">return</span> &#123;submap_id&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 前端维护两个子图了</span></span><br><span class="line">  <span class="built_in">CHECK_EQ</span>(<span class="number">2</span>, insertion_submaps.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> end_it = submap_data.<span class="built_in">EndOfTrajectory</span>(trajectory_id);</span><br><span class="line">  <span class="built_in">CHECK</span>(submap_data.<span class="built_in">BeginOfTrajectory</span>(trajectory_id) != end_it);</span><br><span class="line">  <span class="keyword">const</span> SubmapId  last_submap_id  =  std::<span class="built_in">prev</span>(end_it)-&gt;id;</span><br><span class="line">   <span class="comment">// submap 是 InternalSubmapData类型的成员</span></span><br><span class="line">  <span class="keyword">if</span> (data_.submap_data.<span class="built_in">at</span>(last_submap_id).submap ==</span><br><span class="line">      insertion_submaps.<span class="built_in">front</span>()  )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 此时，&#x27;last_submap_id&#x27; is the ID of &#x27;insertions_submaps.front()&#x27;</span></span><br><span class="line">    <span class="comment">// &#x27;insertions_submaps.back()&#x27; is new，也就是没插入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有2个子图，把第1个子图的 global_pose 加入优化问题</span></span><br><span class="line">    <span class="comment">// 计算第一张子图的 global_pose，last_submap_id已经在后端里</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; first_submap_pose = submap_data.<span class="built_in">at</span>(last_submap_id).global_pose;</span><br><span class="line">    <span class="comment">// ComputeSubmapPose函数  其实就是 submap.local_pose()</span></span><br><span class="line">    optimization_problem_-&gt;<span class="built_in">AddSubmap</span>(</span><br><span class="line">        trajectory_id,</span><br><span class="line">        first_submap_pose *</span><br><span class="line">            constraints::<span class="built_in">ComputeSubmapPose</span>(*insertion_submaps[<span class="number">0</span>]).<span class="built_in">inverse</span>() *</span><br><span class="line">            constraints::<span class="built_in">ComputeSubmapPose</span>(*insertion_submaps[<span class="number">1</span>])  );</span><br><span class="line">    <span class="keyword">return</span> &#123; last_submap_id,  </span><br><span class="line">            SubmapId&#123;trajectory_id, last_submap_id.submap_index + <span class="number">1</span>&#125;  &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不是上面两种情况，也就是已经加入了 back()</span></span><br><span class="line">  <span class="built_in">CHECK</span>(data_.submap_data.<span class="built_in">at</span>(last_submap_id).submap ==</span><br><span class="line">        insertion_submaps.<span class="built_in">back</span>() );</span><br><span class="line">  <span class="keyword">const</span> SubmapId front_submap_id&#123;trajectory_id,</span><br><span class="line">                                 last_submap_id.submap_index - <span class="number">1</span>&#125;;</span><br><span class="line">  <span class="built_in">CHECK</span>(data_.submap_data.<span class="built_in">at</span>(front_submap_id).submap ==</span><br><span class="line">        insertion_submaps.<span class="built_in">front</span>());</span><br><span class="line">  <span class="comment">// 如果不是上面两种情况，那就返回目前最后的两个子图，front_submap_id是更旧的子图</span></span><br><span class="line">  <span class="keyword">return</span> &#123;front_submap_id, last_submap_id&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里之所以出现三种情况，是之前的<code>AppendNode</code>中的<code>data_.submap_data.Append</code>插入子图。</p>
<p>第1种情况用到的<code>ComputeLocalToGlobalTransform</code>在前面讲过。</p>
<p>第2种情况的公式实际是 <script type="math/tex">子图1_g = 子图0_g * 子图0_l^{-1} * 子图1_l</script>， 也就是 <script type="math/tex">子图1_g * 子图1_l^{-1}= 子图0_g * 子图0_l^{-1} = T_{l\_to\_g}</script>，把现有的local to global map的变换用作新子图的位姿计算。</p>
<p>第3种很简单，相当于没处理全局位姿。</p>
<h2 id="计算-INTRA-SUBMAP"><a href="#计算-INTRA-SUBMAP" class="headerlink" title="计算 INTRA_SUBMAP"></a>计算 INTRA_SUBMAP</h2><p>返回继续看 <code>ComputeConstraintsForNode</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CHECK_EQ</span>(submap_ids.<span class="built_in">size</span>(), insertion_submaps.<span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">const</span> SubmapId matching_id = submap_ids.<span class="built_in">front</span>();</span><br><span class="line"><span class="comment">// node(scan) 在 local map坐标系的位姿</span></span><br><span class="line"><span class="keyword">const</span> transform::Rigid2d   local_pose_2d =</span><br><span class="line">    transform::<span class="built_in">Project2D</span>(constant_data-&gt;local_pose *</span><br><span class="line">                         transform::Rigid3d::<span class="built_in">Rotation</span>(</span><br><span class="line">                             constant_data-&gt;gravity_alignment.<span class="built_in">inverse</span>() ) );</span><br><span class="line"><span class="comment">// 全局位姿，通过优化后的 submap全局位姿和 local位姿求出矩阵</span></span><br><span class="line"><span class="comment">// ComputeSubmapPose返回 参数子图的 local_pose</span></span><br><span class="line"><span class="keyword">const</span> transform::Rigid2d global_pose_2d =</span><br><span class="line">    optimization_problem_-&gt;<span class="built_in">submap_data</span>().<span class="built_in">at</span>(matching_id).global_pose *</span><br><span class="line">    constraints::<span class="built_in">ComputeSubmapPose</span>(*insertion_submaps.<span class="built_in">front</span>()).<span class="built_in">inverse</span>() *</span><br><span class="line">    local_pose_2d;</span><br><span class="line"> <span class="comment">// 优化器中增加轨迹节点信息</span></span><br><span class="line">optimization_problem_-&gt;<span class="built_in">AddTrajectoryNode</span>(</span><br><span class="line">    matching_id.trajectory_id,</span><br><span class="line">    optimization::NodeSpec2D&#123;constant_data-&gt;time, local_pose_2d,</span><br><span class="line">                             global_pose_2d,</span><br><span class="line">                             constant_data-&gt;gravity_alignment&#125;  );</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; insertion_submaps.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> SubmapId  submap_id = submap_ids[i];</span><br><span class="line">  <span class="comment">// Even if this was the last node added to &#x27;submap_id&#x27;, the submap will</span></span><br><span class="line">  <span class="comment">// only be marked as finished in &#x27;data_.submap_data&#x27; further below.</span></span><br><span class="line">  <span class="built_in">CHECK</span>( data_.submap_data.<span class="built_in">at</span>(submap_id).state ==</span><br><span class="line">        SubmapState::kNoConstraintSearch );</span><br><span class="line">  data_.submap_data.<span class="built_in">at</span>(submap_id).node_ids.<span class="built_in">emplace</span>(node_id);</span><br><span class="line">  <span class="comment">// node_id的 scan pose 在子图中的 相对位置，就是后面的 intra constrait</span></span><br><span class="line">  <span class="keyword">const</span> transform::Rigid2d   constraint_transform =</span><br><span class="line">    constraints::<span class="built_in">ComputeSubmapPose</span>(*insertion_submaps[i]).<span class="built_in">inverse</span>() *</span><br><span class="line">      local_pose_2d;</span><br><span class="line">  <span class="comment">/*  遍历matching结果的所有submap，其新增加的轨迹节点必定组成了其submap，</span></span><br><span class="line"><span class="comment">  故其约束为 INTRA_SUBMAP 类型约束，可直接将相对位置加入约束队列中  */</span></span><br><span class="line">  data_.constraints.<span class="built_in">push_back</span>(</span><br><span class="line">      Constraint&#123; submap_id, node_id,</span><br><span class="line">                &#123; transform::<span class="built_in">Embed3D</span>(constraint_transform),</span><br><span class="line">                  options_.<span class="built_in">matcher_translation_weight</span>(),</span><br><span class="line">                  options_.<span class="built_in">matcher_rotation_weight</span>()&#125;,</span><br><span class="line">                 Constraint::INTRA_SUBMAP&#125;   );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里是计算 intra 约束的地方。 </p>
<p>匹配的过程就是建立约束的过程，也就是回环检测的过程，因为Cartographer 采用的是图优化，有节点和约束的概念，，节点可以理解为激光点的位姿，约束就是激光数据与子图之间相对位姿。</p>
<p>一共建立3种约束：</p>
<ul>
<li>匹配结果的所有子图，必定包含了新增加的轨迹节点，它们的约束是 INTRA_SUBMAP</li>
<li>新增的节点和已经完成约束计算的子图都要计算约束</li>
<li>对于新的子图不再添加新的轨迹节点时，建立其他节点和该子图之间的约束</li>
</ul>
<p>后两个就是下面的两次<code>ComputeConstraint</code>函数，是<code>INTER</code>约束</p>
<p>子图在后台线程有两种状态 <code>kNoConstraintSearch</code> 和 <code>kFinished</code>。对于前者的子图，只有内部node去匹配；对后者的子图，所有node(包括新node)都匹配这个子图</p>
<h2 id="两次-ComputeConstraint"><a href="#两次-ComputeConstraint" class="headerlink" title="两次 ComputeConstraint"></a>两次 ComputeConstraint</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; submap_id_data : data_.submap_data)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 完成过约束计算的子图</span></span><br><span class="line">  <span class="keyword">if</span> (submap_id_data.data.state == SubmapState::kFinished)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 不包含当前的节点  node_id</span></span><br><span class="line">    <span class="built_in">CHECK_EQ</span>(submap_id_data.data.node_ids.<span class="built_in">count</span>(node_id), <span class="number">0</span>);</span><br><span class="line">    finished_submap_ids.<span class="built_in">emplace_back</span>(submap_id_data.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 前端匹配输出的submap是刚完成的一个，即维护的两个submap中front不再更新</span></span><br><span class="line"><span class="keyword">if</span> (newly_finished_submap)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> SubmapId  newly_finished_submap_id = submap_ids.<span class="built_in">front</span>();</span><br><span class="line">  InternalSubmapData&amp;   finished_submap_data =</span><br><span class="line">      data_.submap_data.<span class="built_in">at</span>(newly_finished_submap_id);</span><br><span class="line">  <span class="built_in">CHECK</span>(finished_submap_data.state == SubmapState::kNoConstraintSearch);</span><br><span class="line">  <span class="comment">// 将新的submap设置为finished，表明已经增加约束条件了</span></span><br><span class="line">  finished_submap_data.state = SubmapState::kFinished;</span><br><span class="line">  newly_finished_submap_node_ids = finished_submap_data.node_ids;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要遍历的<code>submap_data</code> 是 <code>MapById&lt;SubmapId, InternalSubmapData&gt;</code>，该容器记录了所有的子图数据及其内部节点，<code>InternalSubmapData</code>除了描述了子图的数据之外还记录了所有内部的节点，成员是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enum class SubmapState &#123; kActive, kFinished &#125;;    </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InternalSubmapData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">const</span> Submap2D&gt; submap;</span><br><span class="line">    <span class="comment">// 所有直接插入submap的节点</span></span><br><span class="line">    std::set&lt;NodeId&gt; node_ids;</span><br><span class="line">    SubmapState state = SubmapState::kActive;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 新加入的节点与之前所有完成约束计算的子图，均计算一次约束</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; submap_id : finished_submap_ids)</span><br><span class="line">    <span class="built_in">ComputeConstraint</span>(node_id, submap_id);</span><br><span class="line">  <span class="comment">/* 每次新的子图完成，不再更新即不再添加新的轨迹节点时，</span></span><br><span class="line"><span class="comment">  则需要计算此子图与所有优化位姿图node之间的约束 */</span></span><br><span class="line"><span class="keyword">if</span> (newly_finished_submap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> SubmapId newly_finished_submap_id = submap_ids.<span class="built_in">front</span>();</span><br><span class="line">    <span class="comment">// We have a new completed submap, so we look into </span></span><br><span class="line">    <span class="comment">// adding constraints for  old nodes</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; node_id_data : optimization_problem_-&gt;<span class="built_in">node_data</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">const</span> NodeId&amp;  node_id = node_id_data.id;</span><br><span class="line">      <span class="keyword">if</span> (newly_finished_submap_node_ids.<span class="built_in">count</span>(node_id) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">ComputeConstraint</span>(node_id, newly_finished_submap_id);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子图的状态主要是给后台的线程提供的。一开始子图的状态都是<code>kActive</code>的，当它完成之后(<code>kFinished</code>的状态)就会与所有旧的节点 计算约束</p>
<p>此外新增的节点也会与所有完成的子图 计算约束。这一次可以理解为是进行闭环检测，根据节点和循环中的各个子图之间的情况不同，可能构建的是全局约束，也可能是局部约束。 回环检测是一种全局约束。</p>
<p><code>PoseGraph2D::ComputeConstraint</code>只有这里的两次调用。</p>
<h2 id="最后部分"><a href="#最后部分" class="headerlink" title="最后部分"></a>最后部分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 每次新添加一个节点时，均需执行，通知约束构建器。</span></span><br><span class="line">  constraint_builder_.<span class="built_in">NotifyEndOfNode</span>();</span><br><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// 记录距离上次闭环处理增加的节点个数</span></span><br><span class="line">  ++num_nodes_since_last_loop_closure_;</span><br><span class="line">  <span class="comment">// 当新增加节点个数大于阈值时，则调用优化处理结果</span></span><br><span class="line">  <span class="keyword">if</span> (options_.<span class="built_in">optimize_every_n_nodes</span>() &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      num_nodes_since_last_loop_closure_ &gt; options_.<span class="built_in">optimize_every_n_nodes</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> WorkItem::Result::kRunOptimization;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> WorkItem::Result::kDoNotRunOptimization;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color = blue size=4>添加节点和约束是实时的，但是优化不是，</font>更不需要每个节点都进行。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstraintBuilder2D::NotifyEndOfNode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="built_in">CHECK</span>(finish_node_task_ != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 完成一个后端节点</span></span><br><span class="line">  finish_node_task_-&gt;<span class="built_in">SetWorkItem</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">    absl::MutexLock <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">    ++num_finished_nodes_;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">auto</span> finish_node_task_handle =</span><br><span class="line">      thread_pool_-&gt;<span class="built_in">Schedule</span>(std::<span class="built_in">move</span>(finish_node_task_));</span><br><span class="line">  <span class="comment">// 重新开始添加节点任务</span></span><br><span class="line">  finish_node_task_ = absl::make_unique&lt;common::Task&gt;();</span><br><span class="line">  when_done_task_-&gt;<span class="built_in">AddDependency</span>(finish_node_task_handle);</span><br><span class="line">  ++num_started_nodes_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是处理<code>finish_node_task_</code>，每次完成一个node约束计算时均会进行调用。目的是完成<code>finish_node_task_</code>，同时开启一个新的task用于下一次约束任务。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/24/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span><a class="page-number" href="/page/26/">26</a><span class="space">&hellip;</span><a class="page-number" href="/page/66/">66</a><a class="extend next" rel="next" href="/page/26/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2023 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>