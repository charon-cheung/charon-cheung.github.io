<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">561</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">49</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2024/11/12/x1aqcwUG3XDiskN.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2023/07/20/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E7%BA%AF%E8%B7%9F%E8%B8%AA%E7%AE%97%E6%B3%95/prune_plan%E6%9C%BA%E5%88%B6%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/">prune_plan机制及相关问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-07-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E7%BA%AF%E8%B7%9F%E8%B8%AA%E7%AE%97%E6%B3%95/">纯跟踪算法</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2023/07/20/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E7%BA%AF%E8%B7%9F%E8%B8%AA%E7%AE%97%E6%B3%95/prune_plan%E6%9C%BA%E5%88%B6%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/07/20/%E9%82%A3%E4%BA%9B%E5%8D%A1%E6%88%91%E5%BE%88%E4%B9%85%E7%9A%84bug/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92%E5%85%A8%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E5%AF%BC%E8%87%B4move_base%E9%80%80%E5%87%BA/">第二次规划全局路径导致move_base退出</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-07-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E9%82%A3%E4%BA%9B%E5%8D%A1%E6%88%91%E5%BE%88%E4%B9%85%E7%9A%84bug/">那些卡我很久的bug</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2023/07/20/%E9%82%A3%E4%BA%9B%E5%8D%A1%E6%88%91%E5%BE%88%E4%B9%85%E7%9A%84bug/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92%E5%85%A8%E8%A6%86%E7%9B%96%E8%B7%AF%E5%BE%84%E5%AF%BC%E8%87%B4move_base%E9%80%80%E5%87%BA/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/07/06/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/%E6%97%A0%E4%BC%A0%E6%84%9F%E5%99%A8%E6%97%B6%E7%9A%84%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE%E5%92%8Cmove_base%E6%8A%A5%E8%AD%A6/">不使用传感器时的代价地图和move_base报警</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-07-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content"><p>有一次机器人没有装雷达和相机，打算随便跑跑。于是在通用代价地图的障碍层，不设置传感器数据来源，运行<code>move_base</code>出现频繁报警<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The /scan observation buffer has not been updated <span class="keyword">for</span> <span class="number">22.06</span> seconds, and it should be updated every <span class="number">5.00</span> seconds.</span><br></pre></td></tr></table></figure><br>来源在<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ObservationBuffer::isCurrent</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (expected_update_rate_ == ros::<span class="built_in">Duration</span>(<span class="number">0.0</span>))</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// last_updated_ 没有赋值</span></span><br><span class="line">  <span class="keyword">bool</span> current = (ros::Time::<span class="built_in">now</span>() - last_updated_).<span class="built_in">toSec</span>() &lt;= expected_update_rate_.<span class="built_in">toSec</span>();</span><br><span class="line">  <span class="keyword">if</span> (!current)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_WARN</span>(</span><br><span class="line">        <span class="string">&quot;The %s observation buffer has not been updated for %.2f seconds, and it should be updated every %.2f seconds.&quot;</span>,</span><br><span class="line">        topic_name_.<span class="built_in">c_str</span>(), (ros::Time::<span class="built_in">now</span>() - last_updated_).<span class="built_in">toSec</span>(), expected_update_rate_.<span class="built_in">toSec</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时发导航命令，又有报警<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[/move_base]:Sensor data is out of date, we<span class="string">&#x27;re not going to allow commanding of the base for safety</span></span><br></pre></td></tr></table></figure><br>因为没有可靠的传感器数据，<code>move_base</code>不允许车跑起来。来源在<code>MoveBase::executeCycle</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!controller_costmap_ros_-&gt;<span class="built_in">isCurrent</span>())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">ROS_WARN</span>(<span class="string">&quot;[%s]:Sensor data is out of date, we&#x27;re not going to allow commanding of the base for safety&quot;</span>,ros::this_node::<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">  <span class="built_in">publishZeroVelocity</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>也就是函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LayeredCostmap::isCurrent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  current_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (vector&lt;boost::shared_ptr&lt;Layer&gt; &gt;::iterator plugin = plugins_.<span class="built_in">begin</span>(); plugin != plugins_.<span class="built_in">end</span>();</span><br><span class="line">      ++plugin)</span><br><span class="line">  &#123;</span><br><span class="line">    current_ = current_ &amp;&amp; (*plugin)-&gt;<span class="built_in">isCurrent</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>显然是因为障碍层不符合<code>isCurrent</code>，导致代价地图也不符合<code>isCurrent</code>。如果希望车照样跑，就把<code>MoveBase::executeCycle</code>那段注释掉，把<code>ObservationBuffer::isCurrent()</code>的报警也注释掉，否则没完没了。</p>
<p>从网上下载一个包含雷达数据的bag，又设置了通用代价地图和tf树后，发现报警依然，应该还是时间戳问题，懒得再对齐了。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/29/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ROS%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/">ROS编程规范</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><ul>
<li><p><code>Packages</code>,  <code>Topics / Services</code>, 文件、库的命名都采用 <strong>under_scored</strong></p>
</li>
<li><p><code>Classes / Types</code>的命名采用 <strong>CamelCased</strong>，比如<code>class ExampleClass</code>, <code>class HokuyoURGLaser</code>。  函数命名采用 <strong>camelCased</strong>，比如<code>int exampleMethod(int example_arg)</code></p>
</li>
<li><p>普通变量和成员变量命名、命名空间都使用 <strong>under_scored</strong>，循环中的临时变量使用<code>i,j,k</code>，i on the outer loop, j on the next inner loop</p>
</li>
<li><p>常量命名采用 <strong>ALL_CAPITALS</strong></p>
</li>
<li><p>全局变量采用 <code>g_</code> 开头的 <strong>under_scored</strong></p>
</li>
<li><p>每行最多120个字符</p>
</li>
<li><p>所有头文件要包含<code>#ifndef</code>，比如:</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PACKAGE_PATH_FILE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACKAGE_PATH_FILE_H</span></span><br><span class="line">	......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这部分应该在license之后，<code>#endif</code>在头文件的最后</p>
<ul>
<li>不使用宏</li>
</ul>
<p>预处理所用的宏，比如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">        <span class="built_in">temporary_debugger_break</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>函数的输出参数使用指针，而不是引用:  <code>int exampleMethod(FooThing input, BarThing* output);</code></p>
</li>
<li><p>头文件里不要用<code>using namespace</code>关键字，在源文件里可使用<code>using</code>，但不要<code>using namespace std;</code>，而是使用<code>using std::list;</code>, <code>using std::vector;</code>，否则引入了<code>std</code>所有内容。</p>
</li>
<li><p>建议使用Exceptions，而不是returning integer error codes。 析构函数不要抛出异常。 不直接触发的回调函数，不要抛出异常。 </p>
</li>
<li><p>保证代码是 <code>exception-safe</code>: When your code can be interrupted by exceptions, you must ensure that resources you hold will be deallocated when stack variables go out of scope. In particular, mutexes must be released, and heap-allocated memory must be freed. Accomplish this safety by using the following mutex guards and smart pointers</p>
</li>
</ul>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Choices</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Choice</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">     Choice1,</span><br><span class="line">     Choice2,</span><br><span class="line">     Choice3</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> Choices::Choice Choice;</span><br></pre></td></tr></table></figure>
<p>This prevents enums from polluting the namespace they’re inside. Individual items within the enum are referenced by: Choices::Choice1, but the typedef still allows declaration of the Choice enum without the namespace.</p>
<ul>
<li>If you are using C++11 and above, you can use scoped enumeration</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Choice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Choice1,</span><br><span class="line">    Choice2,</span><br><span class="line">    Choice3</span><br><span class="line">&#125;;</span><br><span class="line">Choice c = Choice::Choice1;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>不建议使用全局变量和函数，尤其前者。更不能在多线程中使用。大多数变量和函数都该在类的体内，其他应当在命名空间里。</p>
</li>
<li><p>类不要使用静态变量。</p>
</li>
<li><p>只在 well-defined exit point 调用<code>exit()</code>函数</p>
</li>
<li><p>使用assertions之类的比条件判断语句好，比如<code>ROS_ASSERT</code>, <code>ROS_ASSERT_MSG</code>, <code>ROS_ASSERT_CMD</code>, <code>ROS_BREADK</code></p>
</li>
</ul>
<p>Depending on compilation settings, the assertion may not be executed.</p>
<p>It is typical to develop software with assertion-checking enabled, in order to catch violations. When nearing software completion and when assertions are found to always be true in the face of extensive testing, you build with a flag that removes assertions from compilation, so they take up no space or time. </p>
<p>The following option to catkin_make will define the NDEBUG macro for all your ROS packages, and thereby remove assertion checks.<br><code>catkin_make -DCMAKE_CXX_FLAGS:STRING=&quot;-DNDEBUG&quot;</code></p>
<p>Note: cmake will rebuild all your software when you run it with this command, and will remember the setting through subsequent catkin_make runs until you delete your build and devel directories and rebuild.</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/27/C++/C++%20%20%E5%9F%BA%E7%A1%80/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADCPU%20%E6%9E%B6%E6%9E%84%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B/">判断CPU 架构和操作系统类型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E5%9F%BA%E7%A1%80/">C++ 基础</a></span><div class="content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> defined __linux__</span></span><br><span class="line">      std::cout&lt;&lt;<span class="string">&quot;linux system&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">elif</span> defined _WIN32</span></span><br><span class="line">      std::cout&lt;&lt;<span class="string">&quot;windows system&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   </span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> defined  __aarch64__</span></span><br><span class="line">      std::cout&lt;&lt;<span class="string">&quot;this is arm cpu&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">elif</span> defined __x86_64__</span></span><br><span class="line">      std::cout&lt;&lt;<span class="string">&quot;this id x86 cpu&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cmake 中判断CPU 架构，操作系统类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.10</span><span class="number">.0</span>)</span><br><span class="line"> </span><br><span class="line">message($&#123;CMAKE_HOST_SYSTEM_NAME&#125;)</span><br><span class="line">message($&#123;CMAKE_HOST_SYSTEM_PROCESSOR&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(CMAKE_HOST_SYSTEM_NAME MATCHES <span class="string">&quot;Linux&quot;</span>)</span><br><span class="line">    message(<span class="string">&quot;this is Linux&quot;</span>)</span><br><span class="line">elseif(CMAKE_HOST_SYSTEM_NAME MATCHES <span class="string">&quot;Windows&quot;</span>)</span><br><span class="line">  message(<span class="string">&quot;this is Windows&quot;</span>)</span><br><span class="line">endif()</span><br><span class="line"><span class="keyword">if</span>(CMAKE_HOST_SYSTEM_PROCESSOR MATCHES <span class="string">&quot;aarch64&quot;</span>)</span><br><span class="line">    message(<span class="string">&quot;this is aarch64 cpu&quot;</span>)</span><br><span class="line">elseif(CMAKE_HOST_SYSTEM_PROCESSOR MATCHES <span class="string">&quot;x86_64&quot;</span>)</span><br><span class="line">  message(<span class="string">&quot;this is x86_64 cpu&quot;</span>)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure></p>
<p>根据编译器的情况，有下面的宏用于调试程序:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是不是C++环境，需要注意的是ROS环境中这里为否</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _cplusplus</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;C++\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//判断是不是C环境</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STDC__</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;C\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//输出语句所在函数，行，文件等参数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;function %s: Line 25\n&quot;</span>,__func__);   <span class="comment">//或者用__FUNCTION__</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pretty function %s: Line 25\n&quot;</span>,__PRETTY_FUNCTION__);   <span class="comment">//函数声明，包括了参数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;line: %d\n&quot;</span>,__LINE__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;current file: %s\n&quot;</span>,__FILE__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;date: %s\n&quot;</span>,__DATE__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;time: %s\n&quot;</span>,__TIME__);</span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/25/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/Costmap2DROS%E7%9A%84%E5%87%BD%E6%95%B0getRobotPose/">Costmap2DROS的函数getRobotPose</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content"><p>源码其实并不复杂<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Costmap2DROS::getRobotPose</span><span class="params">(tf::Stamped&lt;tf::Pose&gt;&amp; global_pose)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  global_pose.<span class="built_in">setIdentity</span>();</span><br><span class="line">  tf::Stamped &lt; tf::Pose &gt; robot_pose;</span><br><span class="line">  robot_pose.<span class="built_in">setIdentity</span>();</span><br><span class="line">  robot_pose.frame_id_ = robot_base_frame_;</span><br><span class="line">  robot_pose.stamp_ = ros::<span class="built_in">Time</span>();</span><br><span class="line">  ros::Time current_time = ros::Time::<span class="built_in">now</span>();  <span class="comment">// save time for checking tf delay later</span></span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    tf_.<span class="built_in">transformPose</span>(global_frame_, robot_pose, global_pose);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (tf::LookupException&amp; ex)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR_THROTTLE</span>(<span class="number">1.0</span>, <span class="string">&quot;No Transform available Error looking up robot pose: %s\n&quot;</span>, ex.<span class="built_in">what</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (tf::ConnectivityException&amp; ex)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR_THROTTLE</span>(<span class="number">1.0</span>, <span class="string">&quot;Connectivity Error looking up robot pose: %s\n&quot;</span>, ex.<span class="built_in">what</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span> (tf::ExtrapolationException&amp; ex)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR_THROTTLE</span>(<span class="number">1.0</span>, <span class="string">&quot;Extrapolation Error looking up robot pose: %s\n&quot;</span>, ex.<span class="built_in">what</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// check global_pose timeout</span></span><br><span class="line">  <span class="keyword">if</span> (current_time.<span class="built_in">toSec</span>() - global_pose.stamp_.<span class="built_in">toSec</span>() &gt; transform_tolerance_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_WARN_THROTTLE</span>(<span class="number">1.0</span>,</span><br><span class="line">                      <span class="string">&quot;Costmap2DROS transform timeout. Current time: %.4f, global_pose stamp: %.4f, tolerance: %.4f&quot;</span>,</span><br><span class="line">                      current_time.<span class="built_in">toSec</span>(), global_pose.stamp_.<span class="built_in">toSec</span>(), transform_tolerance_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>核心是函数 <code>transformPose</code>，<code>tf_</code>在这里是<code>tf::TransformListener</code>，但函数实际是继承自基类<code>tf::Transformer</code>，有两个重载，常用的是第一个<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transformer::transformPose</span><span class="params">(<span class="keyword">const</span> std::string&amp;   target_frame,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">const</span> Stamped&lt; tf::Pose &gt;&amp;   stamped_in,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Stamped&lt; tf::Pose &gt;&amp;   stamped_out </span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transformer::transformPose</span><span class="params">(<span class="keyword">const</span> std::string&amp;   target_frame,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">const</span> ros::Time&amp;   target_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">const</span> Stamped&lt; tf::Pose &gt;&amp;   stamped_in,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">const</span> std::string&amp;   fixed_frame,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Stamped&lt; tf::Pose &gt;&amp;   stamped_out </span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure><br>第二个重载会调用函数<code>lookupTransform</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the transform between two frames by frame ID assuming fixed frame.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transformer::lookupTransform</span> <span class="params">( <span class="keyword">const</span> std::string &amp;   target_frame,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> ros::Time &amp;   target_time,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> std::string &amp;   source_frame,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> ros::Time &amp;   source_time,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> std::string &amp;   fixed_frame,</span></span></span><br><span class="line"><span class="params"><span class="function">	StampedTransform &amp;  transform </span></span></span><br><span class="line"><span class="params"><span class="function">)</span>   <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>target_frame  The frame to which data should be transformed</li>
<li>target_time The time to which the data should be transformed. (0 will get the latest)</li>
<li>source_frame  The frame where the data originated</li>
<li>source_time The time at which the source_frame should be evaluated. (0 will get the latest)</li>
<li>fixed_frame The frame in which to assume the transform is constant in time.</li>
<li>transform The transform reference to fill.</li>
</ul>
<p>可能抛出的异常<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> tf&#123;</span><br><span class="line">  <span class="comment">// Pass through exceptions from tf2</span></span><br><span class="line">  <span class="keyword">typedef</span> tf2::TransformException TransformException;</span><br><span class="line">  <span class="keyword">typedef</span> tf2::LookupException LookupException;</span><br><span class="line">  <span class="keyword">typedef</span> tf2::ConnectivityException ConnectivityException;</span><br><span class="line">  <span class="keyword">typedef</span> tf2::ExtrapolationException ExtrapolationException;</span><br><span class="line">  <span class="keyword">typedef</span> tf2::InvalidArgumentException InvalidArgument; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="报警-Costmap2DROS-transform-timeout"><a href="#报警-Costmap2DROS-transform-timeout" class="headerlink" title="报警 Costmap2DROS transform timeout"></a>报警 Costmap2DROS transform timeout</h2><p>报警对应的<code>transform_tolerance_</code>是在构造函数里写死的<code>0.3</code>，一开始我以为这个数太小了，于是改为2，结果没有改善。</p>
<p>以下报警的根源都是<code>Costmap2DROS::getRobotPose</code><br><img src="https://s2.loli.net/2023/06/27/zstZTuh8cO63VvG.png" alt=""><br><img src="https://s2.loli.net/2023/06/27/jnCAr6sdbgxJwBK.png" alt="获取不到开始位姿，无法生成全局路径"></p>
<p>尝试的改善措施(全都无效):</p>
<ul>
<li><code>Costmap2DROS</code>构造函数中设置: <code>transform_tolerance_(2)</code></li>
<li><code>timer_ = private_nh.createTimer(ros::Duration(.1), &amp;Costmap2DROS::movementCB, this);</code> 0.1秒间隔太短了。增大到1.5，稍有改善，但未解决根本问题，反而降低了代价地图的性能。</li>
<li>降低两个代价地图的<code>update_frequency</code></li>
</ul>
<p>所有报警基本来自<code>Costmap2DROS::getRobotPose</code>，或者说<code>map</code>—-&gt;<code>base_link</code>的tf变换不及时。</p>
<ol>
<li>如果不启动VSLAM，启动诠视相机的<code>xv_sdk.launch</code>，使用<code>static_transform_republisher</code>建立假的TF树，启动导航框架，一个报警也没有。因此问题还在VSLAM，怀疑是CPU而不是网络问题。</li>
<li>启动诠视相机的<code>xv_sdk.launch</code>和VSLAM，但不发布tf，使用假的tf树，启动导航框架，仍然没有报警。</li>
<li>继续缩小问题范围，发布假的tf: <code>world</code>—-&gt;<code>map</code>—-&gt;<code>odom</code>—-&gt; <code>base_link</code>，导航框架不报警。但是如果由VSLAM发布<code>map</code>—-&gt;<code>odom</code>，就有报警了。</li>
</ol>
<p>所以问题的原因：</p>
<ol>
<li>VSLAM的<code>map</code>—-&gt;<code>odom</code>—-&gt; <code>base_link</code>变换。</li>
<li>Nano的CPU没有使用到极致，还有多余算力</li>
</ol>
<p>在此情况下规划路径时，全局路径可生成，因为全局规划频率是0，虽然有很多报警，总能成功规划一次。但局部路径就不同了，需要频繁规划。<br>只看TF的频率和<code>tf echo</code>有没有数据还不够，<strong>应该看Rviz里，<code>base_link</code>坐标系在<code>map</code>中的坐标是否能随着机器人的移动实时更新。</strong>先满足这一点，再运行导航框架。</p>
<font size="3" color="blue"> 另一种原因是网络带宽不足  </font></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/05/24/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/rosbag%E7%9A%84%E8%AF%BB%E5%86%99/">rosbag的读写</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-05-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><p>头文件<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rosbag/bag.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rosbag/view.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rosbag/message_instance.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/foreach.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> foreach BOOST_FOREACH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;nav_msgs/Path.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="读写bag文件"><a href="#读写bag文件" class="headerlink" title="读写bag文件"></a>读写bag文件</h3><p><code>open</code>函数默认是读模式。</p>
<p>写bag文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rosbag::Bag bag;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    bag.<span class="built_in">open</span>(<span class="string">&quot;/home/user/plan.bag&quot;</span>, rosbag::bagmode::Write);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> rosbag::BagException&amp; ex) &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;open rosbag error: %s&quot;</span>, ex.<span class="built_in">what</span>() );</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">bag.<span class="built_in">write</span>(<span class="string">&quot;record_plan&quot;</span>,ros::Time::<span class="built_in">now</span>(), coverage_plan);</span><br><span class="line">bag.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><br>打开文件的模式有：<code>enum rosbag::bagmode::BagMode</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Write   </span><br><span class="line">Read    </span><br><span class="line">Append  </span><br></pre></td></tr></table></figure></p>
<p>读bag文件一定要用<code>try</code>和<code>catch</code></p>
<p>下面的例子，bag文件只有一个话题<code>/move_base/transformed_plan</code>，一堆<code>nav_msgs/Path</code>消息<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">rosbag::Bag bag;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    bag.<span class="built_in">open</span>(<span class="string">&quot;/home/user/plan.bag&quot;</span>, rosbag::bagmode::Read);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> rosbag::BagException&amp; ex) &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;open rosbag error: %s&quot;</span>, ex.<span class="built_in">what</span>() );</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;        </span><br><span class="line">std::vector&lt;std::string&gt; topics;</span><br><span class="line"><span class="keyword">bool</span> bag_read_once = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">topics.<span class="built_in">push_back</span>(std::<span class="built_in">string</span>(<span class="string">&quot;record_plan&quot;</span>) );</span><br><span class="line"><span class="function">rosbag::View <span class="title">view</span><span class="params">(bag, rosbag::TopicQuery(topics) )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOST_FOREACH</span>(rosbag::MessageInstance <span class="keyword">const</span> m, view)</span><br><span class="line">&#123;</span><br><span class="line">    nav_msgs::Path::ConstPtr i = m.instantiate&lt;nav_msgs::Path&gt;();</span><br><span class="line">    plan_from_bag.header.frame_id = i-&gt;header.frame_id;</span><br><span class="line">    plan_from_bag.header.stamp = i-&gt;header.stamp;</span><br><span class="line">    plan_from_bag.header.seq = i-&gt;header.seq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> path_size = i-&gt;poses.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;plan from bag size: %zu&quot;</span>,i-&gt;poses.<span class="built_in">size</span>() );</span><br><span class="line">    plan_from_bag.poses.<span class="built_in">reserve</span>(path_size);</span><br><span class="line">    <span class="keyword">if</span>(bag_read_once)    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    plan_from_bag.poses = i-&gt;poses;</span><br><span class="line">    bag_read_once = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">bag.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><br>注意读的时候，topics容器的元素必须还是<code>number</code>，与写文件时一致。如果不一致，读文件会不执行foreach</p>
<p>用到的类如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a view and add a query</span></span><br><span class="line"><span class="comment"> * param bag             The bag file on which to run this query</span></span><br><span class="line"><span class="comment"> * param query           The actual query to evaluate which connections to include</span></span><br><span class="line"><span class="comment"> * param start_time      The beginning of the time range for the query</span></span><br><span class="line"><span class="comment"> * param end_time        The end of the time range for the query</span></span><br><span class="line"><span class="comment"> * param reduce_overlap  If multiple views return the same messages, reduce them to a single message</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">View</span>(Bag <span class="keyword">const</span>&amp; bag, boost::function&lt;<span class="built_in"><span class="keyword">bool</span></span>(ConnectionInfo <span class="keyword">const</span>*)&gt; query,</span><br><span class="line">     ros::Time <span class="keyword">const</span>&amp; start_time = ros::TIME_MIN, ros::Time <span class="keyword">const</span>&amp; end_time = ros::TIME_MAX, <span class="keyword">bool</span> <span class="keyword">const</span>&amp; reduce_overlap = <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ROSBAG_DECL</span> <span class="title">TopicQuery</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TopicQuery</span>(std::string <span class="keyword">const</span>&amp; topic);</span><br><span class="line">    <span class="built_in">TopicQuery</span>(std::vector&lt;std::string&gt; <span class="keyword">const</span>&amp; topics);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ConnectionInfo <span class="keyword">const</span>*)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::string&gt; topics_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>rosbag::View</code>的常用函数</p>
<ul>
<li><code>iterator   begin()</code>  Simply copy the merge_queue state into the iterator.</li>
<li><code>iterator   end()</code>    Default constructed iterator signifies end.</li>
<li><code>ros::Time  getBeginTime()</code></li>
<li><code>ros::Time  getEndTime()</code></li>
<li><code>uint32_t    size ()</code>    获得bag文件中所含消息的个数，不是文件大小</li>
</ul>
<p><br></p>
<p>其他常用函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the filename of the bag</span></span><br><span class="line"><span class="function">std::string  <span class="title">getFileName</span> <span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Get the current size of the bag file (a lower bound) More...</span></span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span>  <span class="title">getSize</span> <span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span>    <span class="title">isOpen</span> <span class="params">()</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="bag文件-unindexed"><a href="#bag文件-unindexed" class="headerlink" title="bag文件 unindexed"></a>bag文件 unindexed</h3><p><img src="https://s2.loli.net/2024/03/21/gdxyEB2KUOtu18s.png" alt=""><br>这种情况下如果没有用<code>try</code>和<code>catch</code>就会出错<br><img src="https://s2.loli.net/2024/03/21/FEfZkL2jmYbtBeg.png" alt=""><br>我查来查去，没发现C++ API里有类似<code>rosbag reindex</code>命令的函数，只能不处理。似乎python里有，没有深入研究，</p>
<p>参考：<br><a target="_blank" rel="noopener" href="http://wiki.ros.org/rosbag/Code%20API">rosbag  API </a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/05/23/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/Costmap2DROS%20%E7%B1%BB/">Costmap2DROS 类</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-05-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content"><p><code>Costmap2DROS</code>类是<code>2D Costmap</code>的ROS封装类，处理订阅的话题，这些话题提供了对障碍物的观测，方式为点云或激光扫描消息。  <code>costmap_2d::Costmap2DROS</code>给用户提供了纯2D的接口，这意味着查询障碍只能在列上进行。例如，在XY平面上位于同一位置的桌子和鞋，虽然在Z方向上有差异但是它们在<code>costmap_2d::Costmap2DROS</code>对象代价地图中对应的cell上拥有相同的代价值。</p>
<p>A ROS wrapper for a 2D Costmap. Handles subscribing to topics that provide observations about obstacles in either the form of PointCloud or LaserScan messages.</p>
<ul>
<li>Costmap2D * getCostmap ()</li>
</ul>
<p>实际是<code>return layered_costmap_-&gt;getCostmap();</code>，跟<code>getLayeredCostmap()-&gt;getCostmap()</code>一样.   Return a pointer to the “master” costmap which receives updates from all the layers.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">costmap_2d::Costmap2D* global_costmap = planner_costmap_ros_-&gt;<span class="built_in">getCostmap</span>();</span><br></pre></td></tr></table></figure></p>
<ul>
<li>bool getRobotPose(tf::Stamped<tf::Pose>&amp; global_pose) const;</li>
</ul>
<p>获取机器人在代价地图的<code>global frame</code>中的位姿，成功获取则返回true<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个返回类型很不方便</span></span><br><span class="line">tf::Stamped&lt;tf::Pose&gt; pose;</span><br><span class="line"><span class="keyword">if</span>(!costmap-&gt;<span class="built_in">getRobotPose</span>(pose))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Cannot clear map because pose cannot be retrieved&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> x = pose.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>();</span><br><span class="line"><span class="keyword">double</span> y = pose.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>();</span><br><span class="line"><span class="keyword">double</span> yaw = tf::<span class="built_in">getYaw</span>(pose.<span class="built_in">getRotation</span>());</span><br><span class="line"><span class="keyword">double</span> yaw_norm = angles::<span class="built_in">normalize_angle</span>(tf::<span class="built_in">getYaw</span>(pose.<span class="built_in">getRotation</span>() ) );</span><br></pre></td></tr></table></figure><br>对于全局代价地图，一般是返回在<code>map</code>坐标系下的位姿，对于局部代价地图，一般是在<code>odom</code>或者<code>map</code>下的位姿。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011608180/article/details/106549423">Costmap2DROS::getRobotPose函数调用分析</a></p>
<ul>
<li>std::string getGlobalFrameID()   和   std::string getBaseFrameID()</li>
</ul>
<p>这两个返回的就是代价地图yaml里配置的全局和局部坐标系</p>
<ul>
<li><p>LayeredCostmap* getLayeredCostmap()</p>
</li>
<li><p><code>std::vector&lt;geometry_msgs::Point&gt; getRobotFootprint()</code>   获取机器人边界（在机器人坐标系下，包含padding），返回的是<code>vector&lt;geometry_msgs::Point&gt;</code>，索引顺序就是yaml中设置的顺序</p>
</li>
<li><p><code>std::vector&lt;geometry_msgs::Point&gt;getUnpaddedRobotFootprint()</code>   获取机器人边界（在机器人坐标系下，不包含padding）</p>
</li>
<li><p><code>geometry_msgs::Polygon  getRobotFootprintPolygon()</code>  获取机器人边界（在机器人坐标系下，包含padding）</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/05/23/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/LayeredCostmap%E7%B1%BB/">LayeredCostmap类</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-05-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content"><p><code>LayeredCostmap</code>类是<code>Costmap2DROS</code>的类成员，它是<strong>主地图</strong>，也能够管理各层地图，因为它含有指向各层子地图的指针，能够调用子地图的类方法，开启子地图的更新。 每一层在Costmap2DROS中以插件方式被实例化，并被添加到<code>LayeredCostmap</code>。每一层可以独立编译，且可使用C++接口对代价地图随意修改，即<code>LayerdCostmap</code>为<code>Costmap2DROS</code>（用户接口）提供了加载地图层的插件机制，每个插件（即地图层）都是<code>Layer</code>类型的</p>
<p><code>LayeredCostmap</code>的所有函数其实都是通过<code>Costmap2D</code>和各个<code>Layer</code>的函数执行的。</p>
<p><code>Layer</code>调用的函数: <code>isCurrent</code>, <code>onFootprintChanged</code>, <code>updateBounds</code>, <code>matchSize</code></p>
<p><code>Costmap2D</code>调用的函数: <code>updateOrigin</code>, <code>resizeMap</code>, <code>setDefaultValue</code><br><br></p>
<ul>
<li><p><code>getCostmap()</code>也可以获得<code>costmap_2d::Costmap2D *costmap</code>指针</p>
</li>
<li><p><code>getInscribedRadius()</code>     获得内切圆半径</p>
</li>
<li><p><code>getCircumscribedRadius()</code>    获得外接圆半径</p>
</li>
<li><p>地图有效性 current</p>
</li>
</ul>
<p>对于各层，都有<code>current_</code>参数，该参数继承自Layer类，且通过<code>Layer::isCurrent</code>查询。总的地图的current是通过各层current的与操作计算出来的, 可看<code>LayeredCostmap::isCurrent()</code>,主要的操作是对操作的实时性提供保证，提供是否发生超时的信息。</p>
<p>对于静态层，只要初始化（onInitialize）完成后current_就一直为true</p>
<p>对于障碍物层，其<code>current_</code>参数是各个观察缓冲区<code>ObservationBuffer</code>是否current的与操作，而<code>ObservationBuffer</code>的current取决于缓冲区更新时间（新的观测数据到来的时间）与<code>expected_update_rate</code>参数的对比。</p>
<p>对于膨胀层，也是只要初始化完成后<code>current_</code>就一直为<code>true</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/05/22/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/Costmap2D%E7%B1%BB%E7%9A%84convexFillCells%E5%87%BD%E6%95%B0/">Costmap2D类的 setConvexPolygonCost 函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-05-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Costmap2D::setConvexPolygonCost</span><span class="params">(<span class="keyword">const</span> std::vector&lt;geometry_msgs::Point&gt;&amp; polygon, <span class="keyword">unsigned</span> <span class="keyword">char</span> cost_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// we assume the polygon is given in the global_frame... we need to transform it to map coordinates</span></span><br><span class="line">  std::vector&lt;MapLocation&gt; map_polygon;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; polygon.<span class="built_in">size</span>(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    MapLocation loc;</span><br><span class="line">    <span class="comment">// 先将世界系下的多边形顶点转换到地图坐标系，并存放进map_polygon数组</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">worldToMap</span>(polygon[i].x, polygon[i].y, loc.x, loc.y))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// (&quot;Polygon lies outside map bounds, so we can&#x27;t fill it&quot;);</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    map_polygon.<span class="built_in">push_back</span>(loc);</span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;MapLocation&gt; polygon_cells;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过机器人顶点坐标数组map_polygon得到多边形边缘及内部的全部cell，存放在 polygon_cells</span></span><br><span class="line">  <span class="comment">// get the cells that fill the polygon</span></span><br><span class="line">  <span class="built_in">convexFillCells</span>(map_polygon, polygon_cells);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the cost of those cells</span></span><br><span class="line">  <span class="comment">// 通过循环对多边形边缘及内部各cell的cost赋值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; polygon_cells.<span class="built_in">size</span>(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index = <span class="built_in">getIndex</span>(polygon_cells[i].x, polygon_cells[i].y);</span><br><span class="line">    costmap_[index] = cost_value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="convexFillCells"><a href="#convexFillCells" class="headerlink" title="convexFillCells"></a>convexFillCells</h2><p>这个函数用于获取多边形边缘及内部cell<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Costmap2D::convexFillCells</span><span class="params">(<span class="keyword">const</span> std::vector&lt;MapLocation&gt;&amp; polygon, std::vector&lt;MapLocation&gt;&amp; polygon_cells)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// we need a minimum polygon of a triangle</span></span><br><span class="line">  <span class="keyword">if</span> (polygon.<span class="built_in">size</span>() &lt; <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// first get the cells that make up the outline of the polygon</span></span><br><span class="line">   <span class="comment">//首先获得轮廓点之间连线的列表，存放在polygon_cells中</span></span><br><span class="line">  <span class="built_in">polygonOutlineCells</span>(polygon, polygon_cells);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// quick bubble sort to sort points by x</span></span><br><span class="line">  MapLocation swap;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 对边上的cell点的x做排序，使其按x坐标升序排列</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; polygon_cells.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (polygon_cells[i].x &gt; polygon_cells[i + <span class="number">1</span>].x)</span><br><span class="line">    &#123;</span><br><span class="line">      swap = polygon_cells[i];</span><br><span class="line">      polygon_cells[i] = polygon_cells[i + <span class="number">1</span>];</span><br><span class="line">      polygon_cells[i + <span class="number">1</span>] = swap;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">        --i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ++i;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">/*  遍历所有x，对每个相同的x，检查y，获得y最大和最小的polygon cell，</span></span><br><span class="line"><span class="comment">   将范围内的所有cell填充进polygon_cells，获得多边形边缘及内部的所有cell   */</span></span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  MapLocation min_pt;</span><br><span class="line">  MapLocation max_pt;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> min_x = polygon_cells[<span class="number">0</span>].x;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> max_x = polygon_cells[polygon_cells.<span class="built_in">size</span>() - <span class="number">1</span>].x;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// walk through each column and mark cells inside the polygon</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> x = min_x; x &lt;= max_x; ++x)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= polygon_cells.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (polygon_cells[i].y &lt; polygon_cells[i + <span class="number">1</span>].y)</span><br><span class="line">    &#123;</span><br><span class="line">      min_pt = polygon_cells[i];</span><br><span class="line">      max_pt = polygon_cells[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      min_pt = polygon_cells[i + <span class="number">1</span>];</span><br><span class="line">      max_pt = polygon_cells[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; polygon_cells.<span class="built_in">size</span>() &amp;&amp; polygon_cells[i].x == x)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (polygon_cells[i].y &lt; min_pt.y)</span><br><span class="line">        min_pt = polygon_cells[i];</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (polygon_cells[i].y &gt; max_pt.y)</span><br><span class="line">        max_pt = polygon_cells[i];</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MapLocation pt;</span><br><span class="line">    <span class="comment">// loop though cells in the column</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> y = min_pt.y; y &lt; max_pt.y; ++y)</span><br><span class="line">    &#123;</span><br><span class="line">      pt.x = x;</span><br><span class="line">      pt.y = y;</span><br><span class="line">      polygon_cells.<span class="built_in">push_back</span>(pt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="polygonOutlineCells"><a href="#polygonOutlineCells" class="headerlink" title="polygonOutlineCells"></a>polygonOutlineCells</h3><p>循环调用raytraceLine函数，不断获取相邻之间的连线，最终组成多边形边上的cell，需要注意的是需要将最后一点和第一点连接起来，形成闭合。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Costmap2D::polygonOutlineCells</span><span class="params">(<span class="keyword">const</span> std::vector&lt;MapLocation&gt;&amp; polygon, std::vector&lt;MapLocation&gt;&amp; polygon_cells)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">PolygonOutlineCells <span class="title">cell_gatherer</span><span class="params">(*<span class="keyword">this</span>, costmap_, polygon_cells)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; polygon.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">raytraceLine</span>(cell_gatherer, polygon[i].x, polygon[i].y, polygon[i + <span class="number">1</span>].x, polygon[i + <span class="number">1</span>].y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!polygon.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> last_index = polygon.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// we also need to close the polygon by going from the last point to the first</span></span><br><span class="line">    <span class="built_in">raytraceLine</span>(cell_gatherer, polygon[last_index].x, polygon[last_index].y, polygon[<span class="number">0</span>].x, polygon[<span class="number">0</span>].y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="raytraceLine"><a href="#raytraceLine" class="headerlink" title="raytraceLine"></a>raytraceLine</h3><p>找到两点连线上的cell。对于离散的平面点，指定两个点，这个函数可以找到两个点之间的其他点，使得这些中间组成一个尽可能趋近直线的点集<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class ActionType&gt;  <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">raytraceLine</span><span class="params">(ActionType at, </span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">unsigned</span> <span class="keyword">int</span> x0, <span class="keyword">unsigned</span> <span class="keyword">int</span> y0, </span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">unsigned</span> <span class="keyword">int</span> x1, <span class="keyword">unsigned</span> <span class="keyword">int</span> y1,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">unsigned</span> <span class="keyword">int</span> max_length = UINT_MAX )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> dx = x1 - x0;</span><br><span class="line">  <span class="keyword">int</span> dy = y1 - y0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> abs_dx = <span class="built_in">abs</span>(dx);</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> abs_dy = <span class="built_in">abs</span>(dy);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> offset_dx = <span class="built_in">sign</span>(dx);</span><br><span class="line">  <span class="keyword">int</span> offset_dy = <span class="built_in">sign</span>(dy) * size_x_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> offset = y0 * size_x_ + x0;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we need to chose how much to scale our dominant dimension, based on the maximum length of the line</span></span><br><span class="line">  <span class="keyword">double</span> dist = <span class="built_in">hypot</span>(dx, dy);</span><br><span class="line">  <span class="keyword">double</span> scale = (dist == <span class="number">0.0</span>) ? <span class="number">1.0</span> : std::<span class="built_in">min</span>(<span class="number">1.0</span>, max_length / dist);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if x is dominant</span></span><br><span class="line">  <span class="keyword">if</span> (abs_dx &gt;= abs_dy)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> error_y = abs_dx / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">bresenham2D</span>(at, abs_dx, abs_dy, error_y, offset_dx, offset_dy, offset, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(scale * abs_dx));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// otherwise y is dominant</span></span><br><span class="line">  <span class="keyword">int</span> error_x = abs_dy / <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">bresenham2D</span>(at, abs_dy, abs_dx, error_x, offset_dy, offset_dx, offset, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(scale * abs_dy));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/11/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/57/">57</a><a class="extend next" rel="next" href="/page/13/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2024/11/12/x1aqcwUG3XDiskN.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2025 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>