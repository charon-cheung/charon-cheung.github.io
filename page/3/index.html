<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">488</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">45</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/02/17/ODak2Fc4E1Q7Ymq.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/22/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%BC%A0%E6%A5%AB%E7%9A%84autonomous_exploration/1.%20%E6%A6%82%E8%BF%B0/">(一) 概述</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/CMU%E7%9A%84autonomous-exploration/">CMU的autonomous_exploration</a></span><div class="content"><p>张楫的CMU团队提出了几个上层规划算法，包括在未知环境中的探索算法和全局路径规划算法，以及全套算法的系统集成和扩展应用。目前开源的是<code>autonomous_exploration</code>, <code>dsv_planner</code>, <code>tare_planner</code>, <code>far_planner</code>。 <code>Autonomous Exploration Development Environment</code>里自带的<code>local planner</code>只是用来做<strong>局部路径规划</strong>和<strong>小范围避障</strong>的，目标点太远时容易卡在死胡同里。如果需要长距离的路径规划建议使用<code>far planner</code>。  </p>
<p><code>TARE</code>算法的论文获得了Best Paper Award and Best System Paper Award of RSS 2021。 CMU-OSU参加<strong>DARPA SubT 2021挑战赛</strong>用的是<code>M-TARE</code>的初级版本(没有开源)。地面机器人同样用的LOAM。 参赛队伍里有曹超，他是张继团队里唯一去参赛的。这也是我研究这个算法的原因，它经过了DARPA的考验。<br><img src="https://s2.loli.net/2022/02/13/A7IfTWMSjqV5x8i.png" alt="过窄门"><br><img src="https://s2.loli.net/2022/02/13/cN2oez5fsl8VbvM.png" alt="下楼梯"></p>
<p>我目前只详细研究了<code>autonomous_exploration</code>的代码。</p>
<p>CMU提供的避障算法优势在于能实时高效地应对复杂环境,同时最大化到达目标点的概率。算法的主要思想在于尽可能地让计算在线下完成。具体来说，一个避障算法最耗时的计算一般在于检测机器人在未来时间点与环境发生碰撞的可能。我们的算法先通过离线生成一个庞大的轨迹库（trajectory library）来模拟机器人在未来一段时间内可能走过的轨迹。接下来对于所有轨迹覆盖的空间，我们计算其内部所有点（在一定解析度下）与所有轨迹发生碰撞的可能性。经过这样的离线计算，我们可以得到一个空间内3D点到轨迹的对应关系。在实时运行的过程中，一旦空间内的某个点上有障碍物，我们可以马上知道哪些轨迹将会受到影响。我们的算法会降低选择这些轨迹作为最终路径的可能性。因为大量的计算都在线下进行，线上运行的时候只需要实时选择无碰撞的轨迹，我们的算法可以在几毫秒之内规划出一条无碰撞而最接近目标点的路径。</p>
<p>ROS里经常出现一种情况：规划出的全局路径没有考虑车是否能过窄通道，结果车到了窄通道附近要么又重新规划到其他方向，要么强行过窄通道。本算法会优先规划路径到开阔的地方。  另外也就避免了<strong>全局路径的无限规划问题</strong></p>
<h2 id="测试平台"><a href="#测试平台" class="headerlink" title="测试平台"></a>测试平台</h2><p>测试平台是室外机器人，车上用了velodyne-16激光雷达，IMU是<code>xsens mti-200</code>。速度只能达到<code>2m/s</code>，所以高速机器人尚需验证。工控机CPU为4.1GHz i7。 定位使用vLOAM的商业版，参考<a target="_blank" rel="noopener" href="https://frc.ri.cmu.edu/~zhangji/publications/JFR_2018.pdf">论文</a>。 运行系统要求是18.04或者20.04，其实是因为仿真环境使用Gazebo7，如果不用Gazebo，在16.04上也可以使用。</p>
<p><img src="https://s2.loli.net/2022/02/09/c95bhLtIRwp8o7y.png" alt="算法应用框架"><br>使用<code>registered scans</code>的好处：</p>
<ul>
<li>使scan数据和state estimation之间的processing对时间同步不太敏感</li>
<li>多个registered scans可以 stacked 到一起，从中提取丰富的几何环境信息</li>
</ul>
<font size="4" color="blue">  这套框架不能用于汽车型机器人 </font>


<h2 id="目前我实现的效果"><a href="#目前我实现的效果" class="headerlink" title="目前我实现的效果"></a>目前我实现的效果</h2><p>由于LOAM的问题，z坐标不可靠，所以我在代码里都把里程计返回的z按0处理，so far只在没有上下坡的情况下测试过。目前基本可以正常导航，环境中可以有动态障碍，可以调整线速度和角速度，可以倒退，不会有路径混乱、花费时间长的情况。</p>
<p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1vOpQ-o2gmoUbw6b_YG_IUg?pwd=2k50">成功的导航，提取码 2k50</a></p>
<p><img src="https://s2.loli.net/2022/01/22/6kilZRebg2HIDTB.gif" alt="点云障碍的生成和清除"></p>
<p>目前在线速度<code>0.5m/s</code>的情况下，还是有一定误差的，亟待优化<br><img src="https://s2.loli.net/2022/02/16/8SjNProzlUGfK7J.png" alt="导航目标和实际位置对比"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/18/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%85%A8%E5%B1%80%E8%B7%AF%E5%BE%84/%E5%85%A8%E5%B1%80%E8%B7%AF%E5%BE%84%E6%97%A0%E6%B3%95%E8%B5%B0%E5%87%BA%E9%9A%9C%E7%A2%8D/">全局路径无法走出障碍</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%85%A8%E5%B1%80%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/">全局路径算法</a></span><div class="content"><p><a target="_blank" rel="noopener" href="https://youtu.be/bjMK5P5YhrU">视频</a><br>这个问题的本质是ROS的全局路径算法不考虑车体的轮廓，跟轮廓有关的避障交给了局部路径，DWA和TEB算法里都有<code>footprintCost</code>之类的函数，可以判断是否撞了障碍，但全局路径算法没有。 全局路径是把车当成了点，从所在栅格到目标栅格进行规划。这里开始规划出的路线就是这样，在走了一段时间被TEB认为不可行后，全局路径换成另一条，但是马上被认为不如之前的全局路径更优，又换回去了。如此循环，所以走不出去了。</p>
<p>但是要让全局路径考虑轮廓，会改动很大(即使不考虑动态障碍)，成本太高了。所以有必要考虑其他导航框架了。</p>
<p>暂时的解决方法只有设置中间点或者加虚拟墙</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/18/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ROS%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%20MultiThreadedSpinner%E5%92%8CAsyncSpinner/">ROS中的多线程 MultiThreadedSpinner和AsyncSpinner</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><p>在ROS当中，原作者是不推荐用多线程的，他建议用多进程，变成一个个节点的形式进行通信。多线程分为两种模式：同步和异步。 </p>
<ul>
<li><p>同步：<code>MultiThreadSpinner s(4)</code>，一共5个线程。包括了主线程。</p>
</li>
<li><p>异步：<code>AsyncSpinner s(4)</code>， 一共5个线程。包括了主线程。</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">回调方法</th>
<th style="text-align:center">阻塞</th>
<th style="text-align:center">线程</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ros::spin()</td>
<td style="text-align:center">阻塞</td>
<td style="text-align:center">单线程</td>
</tr>
<tr>
<td style="text-align:center">ros::spinOnce</td>
<td style="text-align:center">非阻塞</td>
<td style="text-align:center">单线程</td>
</tr>
<tr>
<td style="text-align:center">ros::MultiThreadedSpinner</td>
<td style="text-align:center">阻塞</td>
<td style="text-align:center">多线程</td>
</tr>
<tr>
<td style="text-align:center">ros::AsyncSpinner</td>
<td style="text-align:center">非阻塞</td>
<td style="text-align:center">多线程</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://i.loli.net/2021/11/17/nDG1izHFmLsTPrZ.png" alt=""></p>
<font color = blue size = 4> 这里讨论的是多线程形式的回调函数，而不是多线程之间如何同步的问题  </font>

<p><br></p>
<p>对于多话题的订阅，我们先看传统的方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cb1</span><span class="params">(<span class="keyword">const</span> geometry_msgs::PoseStamped::ConstPtr&amp; msg)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;uwb_pose x: %f&quot;</span>, msg-&gt;pose.position.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cb2</span><span class="params">(<span class="keyword">const</span> geometry_msgs::PoseStamped::ConstPtr&amp; msg)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;yolo_pose x: %f&quot;</span>, msg-&gt;pose.position.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;node&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ros::Subscriber uwbSub = nh.subscribe&lt;geometry_msgs::PoseStamped&gt;(<span class="string">&quot;uwb_pose&quot;</span>, <span class="number">1</span>, cb1);</span><br><span class="line">    ros::Subscriber yoloSub = nh.subscribe&lt;geometry_msgs::PoseStamped&gt;(<span class="string">&quot;yolo_pose&quot;</span>, <span class="number">1</span>, cb2);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在回调函数<code>cb2</code>里，可能先执行一大堆耗时的命令，这里用sleep(2)代替，这样<code>cb1</code>的 <code>ROS_INFO</code>获得的消息就会缺失，这明显就是多线程的问题了。</p>
<p>把代码加上<code>ros::MultiThreadedSpinner s(2);</code> (<font color = blue size = 4> 无需加入头文件  </font>), <code>ros::spin();</code>改为<code>ros::spin(s);</code>, 再运行会发现<code>cb1</code>里没有缺少一个消息。</p>
<p>这里多线程的目的是<strong>保证线程<code>cb1</code>不丢失消息，而不是<code>cb2</code></strong>，它丢失消息是必然的。</p>
<p>对于<code>ros::AsyncSpinner</code>，代码在<code>ros::Subscriber</code>定义之后这样写:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ros::AsyncSpinner <span class="title">spinner</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">spinner.<span class="built_in">start</span>();</span><br><span class="line">ros::<span class="built_in">waitForShutdown</span>();</span><br></pre></td></tr></table></figure></p>
<p>当程序当中有数据处理线程的时候，建议开辟<strong>异步多线程</strong>订阅，算法写在订阅函数里面。 当然，目前的处理当中，我更倾向于重新开辟一个线程，然后通过循环数组来进行数据交互。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://wenglihong.github.io/2016/02/01/ROS%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89ROS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF/">ROS多线程订阅消息</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/%E6%89%AB%E5%88%B0%E5%A4%AA%E4%BD%8E%E7%9A%84%E9%9A%9C%E7%A2%8D%E5%92%8C%E6%89%AB%E4%B8%8D%E5%88%B0%E9%9A%9C%E7%A2%8D/">扫到太低的障碍和扫不到障碍</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2021/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/%E6%89%AB%E5%88%B0%E5%A4%AA%E4%BD%8E%E7%9A%84%E9%9A%9C%E7%A2%8D%E5%92%8C%E6%89%AB%E4%B8%8D%E5%88%B0%E9%9A%9C%E7%A2%8D/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/15/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/%E9%9A%9C%E7%A2%8D%E5%B1%827%20%20%E6%B7%BB%E5%8A%A0%E9%9A%9C%E7%A2%8D/">障碍层7  添加障碍</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content"><p>后面的<code>observations</code>是下面这样获得的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Observation&gt;  observations;</span><br><span class="line"><span class="comment">// get the marking observations</span></span><br><span class="line"><span class="built_in">getMarkingObservations</span>(observations);</span><br></pre></td></tr></table></figure><br><code>Observation</code>保存的是 observation in terms of a point cloud and the origin of the source，有4个成员变量：</p>
<ul>
<li><code>geometry_msgs::Point origin_;</code>   The origin point of the observation</li>
<li><code>pcl::PointCloud&lt;pcl::PointXYZ&gt;* cloud_;</code>   point cloud of the observation</li>
<li><code>double obstacle_range_;</code>  The range out to which an observation should be able to insert obstacles</li>
<li><code>double raytrace_range_;</code>  The range out to which an observation should be able to clear via raytracing</li>
</ul>
<p>获得的<code>observations</code>实际上是从<code>bufferCloud</code>里的<code>observation_list_</code>而来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// place the new obstacles into a priority queue</span></span><br><span class="line"><span class="comment">// each with a priority of zero to begin with</span></span><br><span class="line"><span class="keyword">for</span> (std::vector&lt;Observation&gt;::const_iterator it = observations.<span class="built_in">begin</span>(); </span><br><span class="line">      it != observations.<span class="built_in">end</span>();     ++it)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> Observation&amp; obs = *it;</span><br><span class="line">    <span class="keyword">const</span> pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp;  cloud = *(obs.cloud_);</span><br><span class="line">    <span class="comment">// obstacle_range_ 其实就是参数 obstacle_range</span></span><br><span class="line">    <span class="keyword">double</span> sq_obstacle_range = obs.obstacle_range_ * obs.obstacle_range_;</span><br><span class="line">    <span class="comment">// 遍历点云中的每一个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cloud.points.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">double</span> px = cloud.points[i].x, py = cloud.points[i].y, pz = cloud.points[i].z;</span><br><span class="line">      <span class="comment">// if the obstacle is too high or too far away from the robot we won&#x27;t add it</span></span><br><span class="line">      <span class="keyword">if</span> (pz &gt; max_obstacle_height_)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">ROS_DEBUG</span>(<span class="string">&quot;The point is too high&quot;</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// compute the squared distance from the hitpoint to the pointcloud&#x27;s origin</span></span><br><span class="line">      <span class="keyword">double</span> sq_dist = (px - obs.origin_.x) * (px - obs.origin_.x) + (py - obs.origin_.y) * (py - obs.origin_.y)</span><br><span class="line">          + (pz - obs.origin_.z) * (pz - obs.origin_.z);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if the point is far enough away... we won&#x27;t consider it</span></span><br><span class="line">      <span class="keyword">if</span> (sq_dist &gt;= sq_obstacle_range)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">ROS_DEBUG</span>(<span class="string">&quot;The point is too far away&quot;</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// now we need to compute the map coordinates for the observation</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> mx, my;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">worldToMap</span>(px, py, mx, my))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">ROS_DEBUG</span>(<span class="string">&quot;Computing map coords failed&quot;</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> index = <span class="built_in">getIndex</span>(mx, my);</span><br><span class="line">      costmap_[index] = LETHAL_OBSTACLE;</span><br><span class="line">      <span class="built_in">touch</span>(px, py, min_x, min_y, max_x, max_y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">updateFootprint</span>(robot_x, robot_y, robot_yaw, min_x, min_y, max_x, max_y);</span><br></pre></td></tr></table></figure>
<p>对于多线雷达，<code>(pz - obs.origin_.z) * (pz - obs.origin_.z)</code>是0，可以考虑把这段去掉。 另外点云数据量比单线大了很多，在检测近处障碍的时候，计算<code>sq_dist</code>会得到很多点(虽然delta_z不是0)。单线雷达扫描的是一条线，多线其实是很多条线，但是代价地图是2D的，投影会有很多重复的，需要针对xy去重，显著降低了效率，这又是<code>costmap_2d</code>不适合多线雷达的一个例子。 另外这里就是参数<code>obstacle_range</code>出现的地方。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/14/%E5%9F%BA%E4%BA%8EUWB%E7%9A%84%E8%B7%9F%E9%9A%8F%E5%AF%BC%E8%88%AA/4.%20%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88/">(四) 数据融合</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E4%BA%8EUWB%E7%9A%84%E8%B7%9F%E9%9A%8F%E5%AF%BC%E8%88%AA/">基于UWB的跟随导航</a></span><div class="content"><p>UWB就可以获知目标的位姿，另外使用相机识别也可以获知一个位姿<code>yolo_pose</code>。经过反复对比，UWB位姿的范围更大，yolo的位姿在近距离准确和稳定。但是在不远不近的距离，大致x在<code>(6, 16)</code>范围内，二者的差别没有明显规律，都有不稳定的时候，准确性也不确定谁的更好。 这样就涉及到了数据融合问题。</p>
<p><code>yolo_pose</code>的频率大，约3Hz。但是<code>uwb_pose</code>的频率只有2Hz。</p>
<p>机器人在避障过程中可能会旋转导致目标出现在UWB基站后方，UWB无法区分前后信息，会导致跟随失败， 机器人朝反方向运动。 因此加入yolo_pose融合。</p>
<h2 id="两个位姿的朝向"><a href="#两个位姿的朝向" class="headerlink" title="两个位姿的朝向"></a>两个位姿的朝向</h2><p><img src="https://s2.loli.net/2021/12/04/BmSwDy3PaLigdEO.png" alt="uwb和yolo的位姿朝向 1.png"><br><img src="https://s2.loli.net/2021/12/04/erdgDFRBbHToVW2.png" alt="uwb和yolo的位姿朝向 2.png"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/13/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/%E9%9A%9C%E7%A2%8D%E5%B1%824%20%20%E9%9A%9C%E7%A2%8D%E5%B1%82%E7%9A%84UpdateBounds/">障碍层4  障碍层的updateBounds</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content"><p>代码流程比较复杂: <code>Costmap2DROS::mapUpdateLoop</code> —— <code>Costmap2DROS::updateMap()</code> —— <code>LayeredCostmap::updateMap</code>—— 每一层的 <code>updateBounds</code></p>
<h2 id="mapUpdateLoop"><a href="#mapUpdateLoop" class="headerlink" title="mapUpdateLoop"></a>mapUpdateLoop</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Costmap2DROS::mapUpdateLoop</span><span class="params">(<span class="keyword">double</span> frequency)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (frequency == <span class="number">0.0</span>)		<span class="keyword">return</span>;</span><br><span class="line">  ros::NodeHandle  nh;</span><br><span class="line">  <span class="function">ros::Rate  <span class="title">r</span><span class="params">(frequency)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (nh.<span class="built_in">ok</span>() &amp;&amp; !map_update_thread_shutdown_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">start_t</span>, <span class="keyword">end_t</span>, t_diff;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">updateMap</span>();</span><br><span class="line">    <span class="comment">// 目前的时间用tv 结构体返回</span></span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">start_t</span> = start.tv_sec + <span class="built_in"><span class="keyword">double</span></span>(start.tv_usec) / <span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">end_t</span> = end.tv_sec + <span class="built_in"><span class="keyword">double</span></span>(end.tv_usec) / <span class="number">1e6</span>;</span><br><span class="line">    t_diff = <span class="keyword">end_t</span> - <span class="keyword">start_t</span>;</span><br><span class="line">    <span class="built_in">ROS_DEBUG</span>(<span class="string">&quot;Map update time: %.9f&quot;</span>, t_diff);</span><br><span class="line">    <span class="keyword">if</span> (publish_cycle.<span class="built_in">toSec</span>() &gt; <span class="number">0</span> &amp;&amp; layered_costmap_-&gt;<span class="built_in">isInitialized</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> x0, y0, xn, yn;</span><br><span class="line">      layered_costmap_-&gt;<span class="built_in">getBounds</span>(&amp;x0, &amp;xn, &amp;y0, &amp;yn);</span><br><span class="line">       <span class="comment">// publisher_ 是 Costmap2DPublisher</span></span><br><span class="line">      publisher_-&gt;<span class="built_in">updateBounds</span>(x0, xn, y0, yn);</span><br><span class="line"></span><br><span class="line">      ros::Time now = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">      <span class="keyword">if</span> (last_publish_ + publish_cycle &lt; now)</span><br><span class="line">      &#123;</span><br><span class="line">        publisher_-&gt;<span class="built_in">publishCostmap</span>();</span><br><span class="line">        last_publish_ = now;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r.<span class="built_in">sleep</span>();</span><br><span class="line">    <span class="comment">// make sure to sleep for the remainder of our cycle time</span></span><br><span class="line">    <span class="keyword">if</span> (r.<span class="built_in">cycleTime</span>() &gt; ros::<span class="built_in">Duration</span>(<span class="number">1</span> / frequency))</span><br><span class="line">      <span class="built_in">ROS_WARN</span>(<span class="string">&quot;Map update loop missed its desired rate of %.4fHz... the loop actually took %.4f seconds&quot;</span>, frequency,  r.<span class="built_in">cycleTime</span>().<span class="built_in">toSec</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="updateMap"><a href="#updateMap" class="headerlink" title="updateMap"></a>updateMap</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Costmap2DROS::updateMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!stop_updates_)</span><br><span class="line">  &#123;</span><br><span class="line">	tf::Stamped &lt; tf::Pose &gt; pose;</span><br><span class="line">	<span class="comment">//得到global_frame_ 与 robot_base_frame_ tf</span></span><br><span class="line">	<span class="comment">// 转换信息中的 translation 坐标信息</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getRobotPose</span> (pose))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//获取当前机器人位置，必须要弄清楚这个x，y 代表什么意思</span></span><br><span class="line">      <span class="keyword">double</span> x = pose.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>(),</span><br><span class="line">      y = pose.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(),</span><br><span class="line">      yaw = tf::<span class="built_in">getYaw</span>(pose.<span class="built_in">getRotation</span>());</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/*调用LayeredCostmap 类中的updateMap 更新边界和cost值</span></span><br><span class="line"><span class="comment">		* 先依据各层的更新情况，判断地图更新过的范围的边界。</span></span><br><span class="line"><span class="comment">		* 然后用初始值重置全局地图更新边界范围内的地图信息，</span></span><br><span class="line"><span class="comment">		* 并用各层的信息在更新边界内部更新地图信息</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">      layered_costmap_-&gt;<span class="built_in">updateMap</span>(x, y, yaw);</span><br><span class="line"> </span><br><span class="line">      geometry_msgs::PolygonStamped footprint;</span><br><span class="line">      footprint.header.frame_id = global_frame_;</span><br><span class="line">      footprint.header.stamp = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">      <span class="built_in">transformFootprint</span>(x, y, yaw, padded_footprint_, footprint);</span><br><span class="line">      footprint_pub_.<span class="built_in">publish</span>(footprint);</span><br><span class="line">      initialized_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Costmap2DROS::getRobotPose</span><span class="params">(tf::Stamped&lt;tf::Pose&gt;&amp; global_pose)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//local_costmap和global_costmap的robot_base_frame_都是/base_footprint</span></span><br><span class="line">  robot_pose.frame_id_ = robot_base_frame_;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *如果是local_costmap,global_frame_是/map</span></span><br><span class="line"><span class="comment">    * 如果是global_costmap 是/odom_combined</span></span><br><span class="line"><span class="comment">    * 然后根据tf信息，转换的到global_pose，即机器人当前位置 </span></span><br><span class="line"><span class="comment">    *得到global_frame_ 与robot_base_frame_ tf转换信息中的 translation 坐标信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    tf_.<span class="built_in">transformPose</span>(global_frame_, robot_pose, global_pose);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就只看障碍层的<code>updateBounds</code>函数。这个函数主要完成 clearing, marking以及确定bound。和静态地图类似，同样也是先判断是否是rolling地图，若是则更新地图原点。</p>
<p><img src="https://i.loli.net/2021/11/28/vurPkGCXg6LanSE.png" alt=""><br>点云数据最终传到<code>const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cloud = *(obs.cloud_);</code>  点云z坐标在计算<code>sq_dist</code>之后就不处理了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObstacleLayer::updateBounds</span><span class="params">(<span class="keyword">double</span> robot_x, <span class="keyword">double</span> robot_y, </span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">double</span> robot_yaw, <span class="keyword">double</span>* min_x, <span class="keyword">double</span>* min_y, </span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">double</span>* max_x,  <span class="keyword">double</span>* max_y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (rolling_window_)</span><br><span class="line">    <span class="built_in">updateOrigin</span>(robot_x - <span class="built_in">getSizeInMetersX</span>() / <span class="number">2</span>, </span><br><span class="line">    			 robot_y - <span class="built_in">getSizeInMetersY</span>() / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (!enabled_)   <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">useExtraBounds</span>(min_x, min_y, max_x, max_y);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> current = <span class="literal">true</span>;</span><br><span class="line">  std::vector&lt;Observation&gt; observations, clearing_observations;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get the marking observations</span></span><br><span class="line">  current = current &amp;&amp; <span class="built_in">getMarkingObservations</span>(observations);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get the clearing observations</span></span><br><span class="line">  current = current &amp;&amp; <span class="built_in">getClearingObservations</span>(clearing_observations);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// update the global current status</span></span><br><span class="line">  current_ = current;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// raytrace freespace</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clearing_observations.<span class="built_in">size</span>(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="built_in">raytraceFreespace</span>(clearing_observations[i], min_x, min_y, max_x, max_y);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>清除和添加障碍在后面的文章继续</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/13/%E5%9F%BA%E4%BA%8EUWB%E7%9A%84%E8%B7%9F%E9%9A%8F%E5%AF%BC%E8%88%AA/3.%20%E8%B7%9F%E9%9A%8F%E5%AF%BC%E8%88%AA%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/">(三) 跟随导航中的问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%9F%BA%E4%BA%8EUWB%E7%9A%84%E8%B7%9F%E9%9A%8F%E5%AF%BC%E8%88%AA/">基于UWB的跟随导航</a></span><div class="content"><h2 id="发目标后，车不动，直接Goal-Reached"><a href="#发目标后，车不动，直接Goal-Reached" class="headerlink" title="发目标后，车不动，直接Goal Reached"></a>发目标后，车不动，直接Goal Reached</h2><p><img src="https://i.loli.net/2021/11/09/RTDzpAdLElqbj1h.png" alt="发目标后，直接Goal Reached"><br>看目标位姿没有什么异常，查到源码，其实就是<code>xy_goal_tolerance</code>设置成4太大了，比起点和目标的间距还大</p>
<h2 id="不加载地图，出现传感器原点出范围"><a href="#不加载地图，出现传感器原点出范围" class="headerlink" title="不加载地图，出现传感器原点出范围"></a>不加载地图，出现传感器原点出范围</h2><p><img src="https://i.loli.net/2021/11/09/cavh4oVms1LwQz7.png" alt="传感器原点出了地图范围.png"><br>其实还能继续导航，暂时不处理</p>
<h2 id="关里程计后，车仍然导航，但路径不正常"><a href="#关里程计后，车仍然导航，但路径不正常" class="headerlink" title="关里程计后，车仍然导航，但路径不正常"></a>关里程计后，车仍然导航，但路径不正常</h2><p>在正常情况下，手动关闭里程计，但车继续导航，路径很奇怪，可能会撞障碍。没有了里程计，在代价地图里无法正常获取<code>robot_pose</code>，当然路径不对了。<br><img src="https://i.loli.net/2021/11/11/p7u9atPowI8KAv5.png" alt=""><br>报错在<code>MoveBase::makePlan</code>里，继续追溯到<code>MoveBase::planThread()</code>的部分<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> gotPlan = n.<span class="built_in">ok</span>() &amp;&amp; <span class="built_in">makePlan</span>(temp_goal, *planner_plan_);</span><br><span class="line"><span class="keyword">if</span>(gotPlan)</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(state_==PLANNING)</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(state_ == CONTROLLING)</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><br>加日志发现报错的内容不在上面三个情况里，这倒很意外，由于此时获取不到在代价地图里的全局坐标系的位姿，再加一个情况，处理方式是<code>resetState</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">getRobotPose</span>(odom_global_pose, planner_costmap_ros_))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;couldn&#x27;t get robot pose in global costmap, stop car !&quot;</span>);</span><br><span class="line">  <span class="built_in">resetState</span>();</span><br><span class="line">  runPlanner_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="车在跑了一定范围后找不到全局路径"><a href="#车在跑了一定范围后找不到全局路径" class="headerlink" title="车在跑了一定范围后找不到全局路径"></a>车在跑了一定范围后找不到全局路径</h2><p><img src="https://i.loli.net/2021/11/11/LjF59tsqfoWJ3U2.png" alt="报错"><br>找到报错的地方是 <code>MoveBase::planThread</code> —— <code>GlobalPlanner::makePlan</code> —— <code>found_legal</code>为false<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> gotPlan = n.<span class="built_in">ok</span>() &amp;&amp; <span class="built_in">makePlan</span>(temp_goal, *planner_plan_);</span><br><span class="line"><span class="keyword">if</span>(gotPlan)</span><br><span class="line">    ......</span><br><span class="line"><span class="comment">//if we didn&#x27;t get a plan and we are in the planning state (the robot isn&#x27;t moving)</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(state_==PLANNING)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">ROS_DEBUG_NAMED</span>(<span class="string">&quot;move_base_plan_thread&quot;</span>,<span class="string">&quot;No Plan...&quot;</span>);</span><br></pre></td></tr></table></figure><br>原来是全局代价地图的大量的代价值没有被及时清除，导致目标在障碍物里<br><img src="https://i.loli.net/2021/11/11/79oanXtm6kZH215.png" alt="清除了大部分的代价值.png"><br><img src="https://i.loli.net/2021/11/11/4KMkY2oDh5Z6wWH.png" alt="代价值一直没有清除.png"></p>
<p>导航一段时间，rviz显示如下，开始以为是渲染问题，后来发现是真的代价值<br><img src="https://i.loli.net/2021/11/09/HIlrnJPqxOpEhWT.png" alt=""><br><img src="https://i.loli.net/2021/11/09/mApMTcQXYE1gwBF.png" alt=""><br>原来是之前修改<code>MoveBase::makePlan</code>时，根据失败次数清除代价地图时的问题，因此不再限制超出最大次数后不清理，只对<code>min_clear_</code>做判断；也不在清除后sleep</p>
<h2 id="跟随时，反向旋转"><a href="#跟随时，反向旋转" class="headerlink" title="跟随时，反向旋转"></a>跟随时，反向旋转</h2><p>基本上是目标的朝向突变， 所以对发布的目标朝向限制在<code>[-65°, 65°]</code>。<br><img src="https://i.loli.net/2021/11/13/LOSRPTniAWyrCkJ.png" alt="正确的.png"><br><img src="https://i.loli.net/2021/11/13/FrbZDtaQCBYyc34.png" alt="突变后的.png"></p>
<p>偶尔也会发x<0的目标，应避免，另外目标点的处理可能缩减过多：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ym = (dis - <span class="number">4</span>)/ dis * Ym</span><br><span class="line">Xm = (dis - <span class="number">4</span>)/ dis * Xm</span><br></pre></td></tr></table></figure></p>
<h2 id="UWB在近距离，车不能跟随旋转"><a href="#UWB在近距离，车不能跟随旋转" class="headerlink" title="UWB在近距离，车不能跟随旋转"></a>UWB在近距离，车不能跟随旋转</h2><p>之前的代码对<code>move_base_simple/goal</code>为0的情况都pass了，再恢复又好了。但是位姿朝向不稳定的问题有时仍造成异常。 在低速模式下，加大角速度和角加速度，跟随旋转效果明显提升</p>
<p><br></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/13/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/%E9%9A%9C%E7%A2%8D%E5%B1%826%20%20%E5%8A%A0%E9%80%9F%E6%B8%85%E9%99%A4%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E9%9A%9C%E7%A2%8D/">障碍层6 加速清除代价地图中的障碍</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content"><h2 id="雷达无法及时清除代价地图中的障碍"><a href="#雷达无法及时清除代价地图中的障碍" class="headerlink" title="雷达无法及时清除代价地图中的障碍"></a>雷达无法及时清除代价地图中的障碍</h2><p>使用代价地图时，会出现由于激光雷达测距的局限性，代价地图中的障碍会不能及时清除。 比如有行人走过会拖出一个条状障碍或者雷达扫描到障碍仍不能清除。问题根源在于某些激光雷达测的距离超过极限，会没有相对应的数据。 </p>
<p>不同的激光雷达的情况不一样。所以<code>costmap</code>的源码不可能处理所有的情况。 在测不到数据时， sick雷达，返回的是inf。国内一些雷达，在未测到数据时，返回的是0.0 或者默认的最大值。</p>
<p>代码在障碍层的<code>ObstacleLayer::laserScanValidInfCallback</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; message.ranges.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">float</span> range = message.ranges[ i ];</span><br><span class="line">  <span class="keyword">if</span> ( (!std::<span class="built_in">isfinite</span>(range) &amp;&amp; range &gt; <span class="number">0</span>)  )</span><br><span class="line">  &#123;</span><br><span class="line">    message.ranges[ i ] = message.range_max - epsilon;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码处理了每一个激光的数据，如果是激光的点是最大的距离(不是 finite)，那么将这个点设置为比最大距离小十分之一毫米。看来程序作者也考虑到了这个问题，当激光的距离等于最大的距离的时候会出现障碍物无法清除的现象，但是作者不可能对所有雷达出现数据invalid的情况都做判断，这就需要自己加了。</p>
<p>有两种已知的雷达数据invalid的情况:</p>
<ul>
<li><p>雷达在超出量程或没数据时返回0，上面的if判断加入  <code>|| range ==0.0</code>，</p>
</li>
<li><p>雷达的数据超出量程后设为大于range_max的值，而不是inf，比如量程位30m的HOKUYO激光雷达，超量程后会返回65.33m。这样也不在上面的if判断里，加入<code>range &gt;= range_max</code></p>
</li>
</ul>
<p><strong>最后还要在通用代价地图中设置<code>inf_is_valid</code>参数为true</strong></p>
<font color = blue size = 4>  但是这只适用于单线雷达，如果是多线雷达或相机的深度点云，回调函数就是`pointCloud2Callback`，不能用这个方法了。</font>


<h2 id="地图分辨率高于激光雷达分辨率"><a href="#地图分辨率高于激光雷达分辨率" class="headerlink" title="地图分辨率高于激光雷达分辨率"></a>地图分辨率高于激光雷达分辨率</h2><p>在<code>costmap_common_params.yaml</code>中有两个配置参数<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obstacle_range: 2.5  //只有障碍物在这个范围内才会被标记</span><br><span class="line">raytrace_range: 3    //这个范围内不存在的障碍物都会被清除</span><br></pre></td></tr></table></figure><br>当<code>raytrace_range = 3</code>时，假设激光雷达的角分辨率是1，即360度每一度一个激光点时，每个激光点之间的距离大约是0.052(1x3.14/180 x3), 如果此时地图的分辨率是0.01，在靠近激光点附近有一个障碍物，但是始终在激光雷达两条射线之间的话，也就是始终没有扫描到的话，那这个障碍始终无法被清除掉。所以参数<code>raytrace_range</code>不是越大越好</p>
<p>我们知道代价地图实际上是一定分辨率的方格图，两条射线如下图所示，根据<strong>bresenham2D</strong>算法找到经过的蓝色方格，这些方格的代价值会置为<code>FREE_SPACE</code>。但实际上黄色方格也应该置为<code>FREE_SPACE</code>，但是因为角分辨率不足而没有扫射到，这就是问题的由来。<br><img src="https://i.loli.net/2021/11/09/U5KIhSez2VkngPm.png" alt="示意图"></p>
<p>解决方法首先是买好雷达，角分辨率一定要好。</p>
<p>清除障碍物是<code>ObstacleLayer::raytraceFreespace</code>，<br><code>raytraceLine(marker, x0, y0, x1, y1, cell_raytrace_range);</code> 会将所有在(x0,y0)&gt;&gt;(x1,y1)之间的所有cell标记为<code>FREE_SPACE</code></p>
<p><code>updateRaytraceBounds</code>会根据测量的距离，更新扩张<code>(min_x, min_y, max_x, max_y)</code></p>
<p><code>updateBounds</code> 在根据测量数据完成 clear 操作之后，就开始了mark 操作，对每个测量到的点，标记为obstacle</p>
<p>修改清除代价值的规则，即<code>ObstacleLayer::raytraceFreespace</code>，把一个激光点做十字形扩展：<br><img src="https://i.loli.net/2021/11/09/UM2fgSe1FRKyckv.png" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cloud.points.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> wx = cloud.points[i].x;</span><br><span class="line">    <span class="keyword">double</span> wy = cloud.points[i].y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ROS_INFO(&quot;laser scan wx = %.2f, wy = %.2f&quot;, wx, wy);</span></span><br><span class="line">    <span class="comment">//在检测到的点周围生成6x6的点，</span></span><br><span class="line">    <span class="keyword">double</span> inflate_dx = <span class="number">0.01</span>, inflate_dy = <span class="number">0.01</span>; <span class="comment">//在原来点的位置膨胀的尺度</span></span><br><span class="line">    std::vector&lt; std::pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; &gt; inflate_pts;</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx +    <span class="number">0</span>      , wy +     <span class="number">0</span>     ));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx -    <span class="number">0</span>      , wy - inflate_dy));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx - inflate_dx, wy -     <span class="number">0</span>     ));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx + <span class="number">0</span>         , wy + inflate_dy));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx + inflate_dx, wy +     <span class="number">0</span>      ));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx -    <span class="number">0</span>        , wy - <span class="number">2</span>*inflate_dy));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx - <span class="number">2</span>*inflate_dx, wy -     <span class="number">0</span>     ));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx +    <span class="number">0</span>        , wy + <span class="number">2</span>*inflate_dy));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx + <span class="number">2</span>*inflate_dx, wy +     <span class="number">0</span>      ));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx -    <span class="number">0</span>        , wy - <span class="number">3</span>*inflate_dy));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx - <span class="number">3</span>*inflate_dx, wy -     <span class="number">0</span>     ));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx +    <span class="number">0</span>        , wy + <span class="number">3</span>*inflate_dy));</span><br><span class="line">    inflate_pts.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(wx + <span class="number">3</span>*inflate_dx, wy +     <span class="number">0</span>      ));  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实质上增加一个循环</span></span><br><span class="line">    std::vector&lt; std::pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; &gt;::iterator inflate_iter;</span><br><span class="line">    <span class="keyword">for</span>(inflate_iter = inflate_pts.<span class="built_in">begin</span>(); inflate_iter != inflate_pts.<span class="built_in">end</span>(); inflate_iter++)</span><br><span class="line">    &#123;</span><br><span class="line">      wx = (*inflate_iter).first;</span><br><span class="line">      wy = (*inflate_iter).second;</span><br><span class="line">            ......</span><br><span class="line">      <span class="function">MarkCell <span class="title">marker</span><span class="params">(costmap_, FREE_SPACE)</span></span>;</span><br><span class="line">      <span class="comment">// and finally... we can execute our trace to clear obstacles along that line</span></span><br><span class="line">      <span class="comment">//最终raytraceLine(marker, x0, y0, x1, y1, cell_raytrace_range); </span></span><br><span class="line">      <span class="comment">//会将所有在(x0,y0)&gt;&gt;(x1,y1)之间的所有cell标记为FREE_SPACE。</span></span><br><span class="line">      <span class="built_in">raytraceLine</span>(marker, x0, y0, x1, y1, cell_raytrace_range);</span><br><span class="line">      <span class="comment">//而updateRaytraceBounds 会根据测量的距离，更新扩张（min_x, min_y, max_x, max_y）。</span></span><br><span class="line">      <span class="built_in">updateRaytraceBounds</span>(ox, oy, wx, wy, clearing_observation.raytrace_range_, min_x, min_y, max_x, max_y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="move-base中自动清除代价地图"><a href="#move-base中自动清除代价地图" class="headerlink" title="move_base中自动清除代价地图"></a>move_base中自动清除代价地图</h2><p><code>move_base.cpp</code>修改<code>MoveBase::makePlan</code>，在多次找不到全局路径时，清除代价地图，其实跟<code>clear_costmaps</code>服务端的代码是一样的。一开始我还在<code>move_base</code>里定义了客户端函数，在规划失败太多时发起service请求<code>move_base/clear_costmaps</code>，后来发现服务端的代码就在<code>move_base</code>里，就两行：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!planner_-&gt;<span class="built_in">makePlan</span>(start, goal, plan) || plan.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">ROS_DEBUG_NAMED</span>(<span class="string">&quot;move_base&quot;</span>,<span class="string">&quot;Failed to find a  plan to point (%.2f, %.2f)&quot;</span>, </span><br><span class="line">    goal.pose.position.x, goal.pose.position.y);</span><br><span class="line"></span><br><span class="line">  failed_num++;</span><br><span class="line">  <span class="keyword">if</span>(failed_num &gt; min_clear_ )</span><br><span class="line">  &#123;</span><br><span class="line">    controller_costmap_ros_-&gt;<span class="built_in">resetLayers</span>();</span><br><span class="line">    planner_costmap_ros_-&gt;<span class="built_in">resetLayers</span>();</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;\033[44;37m clear costmaps done ! \033[0m&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>min_clear_</code>是我自定义的参数<code>min_clear</code>的赋值，默认是4。</p>
<p><code>failed_num</code>在构造函数中初始化为0，这是当然的。 另外注意<code>failed_num</code>在 <code>MoveBase::executeCb</code>开头置为0，因为这里是收到新目标的地方。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43259286/article/details/107205695?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link">激光点做圆形扩展</a></p>
<h2 id="客户端发起清除代价地图的请求"><a href="#客户端发起清除代价地图的请求" class="headerlink" title="客户端发起清除代价地图的请求"></a>客户端发起清除代价地图的请求</h2><p>有时全局代价地图还是不能及时清除，但是又不能使用上面自动清除的方法。考虑在客户端(python 程序)发目标点时，先发起<code>move_base/clear_costmaps</code>服务，让<code>move_base</code>清除一次，这样效果好多了。我开始是修改<code>planThread</code>和<code>executeCb</code>函数，但是这两个函数在路径规划时并不是只运行一次，多次运行会清除过多，会撞障碍；如果清除后执行sleep，又使机器人表现卡顿。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/11/04/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/%E9%9A%9C%E7%A2%8D%E5%B1%825%20%20%E4%BB%8E%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE%E6%B8%85%E9%99%A4%E9%9A%9C%E7%A2%8D/">障碍层5  raytraceFreespace从代价地图清除障碍</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></span><div class="content"><p>在上一篇的<code>UpdateBounds</code>函数最后到了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clearing_observations.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">raytraceFreespace</span>(clearing_observations[i], min_x, min_y, max_x, max_y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://i.loli.net/2021/11/15/i79yefxSj3lzVgY.png" alt="流程"></p>
<p>清理传感器到障碍物间的cell，会首先处理测量值越界的问题，然后调用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MarkCell <span class="title">marker</span><span class="params">(costmap_, FREE_SPACE)</span></span>;</span><br><span class="line"><span class="comment">// and finally... we can execute our trace to clear obstacles along that line</span></span><br><span class="line"><span class="built_in">raytraceLine</span>(marker, x0, y0, x1, y1, cell_raytrace_range);</span><br><span class="line"><span class="built_in">updateRaytraceBounds</span>(ox, oy, wx, wy, clearing_observation.raytrace_range_, min_x, min_y, max_x, max_y);</span><br></pre></td></tr></table></figure><br>最终<code>raytraceLine(marker, x0, y0, x1, y1, cell_raytrace_range);</code> 会将所有在<code>(x0,y0)&gt;&gt;(x1,y1)</code>之间的所有cell标记为<code>FREE_SPACE</code>。而<code>updateRaytraceBounds</code> 会根据测量的距离，更新扩张<code>（min_x, min_y, max_x, max_y）</code><br><code>updateBounds</code>在根据测量数据完成 clear 操作之后，就开始了mark 操作，对每个测量到的点，标记为obstacle ：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> px = cloud.points[i].x, py = cloud.points[i].y, pz = cloud.points[i].z;</span><br><span class="line"></span><br><span class="line">......省略</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> index = <span class="built_in">getIndex</span>(mx, my);</span><br><span class="line">costmap_[index] = LETHAL_OBSTACLE;</span><br><span class="line"><span class="built_in">touch</span>(px, py, min_x, min_y, max_x, max_y);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.loli.net/2021/07/14/s2UD3i8wOE4zPCo.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @brief  Given distance in the world, convert it to cells</span></span><br><span class="line"><span class="comment"> * @param  world_dist: The world distance</span></span><br><span class="line"><span class="comment"> * @return The equivalent cell distance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Costmap2D::cellDistance</span><span class="params">(<span class="keyword">double</span> world_dist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> cells_dist = <span class="built_in">max</span>(<span class="number">0.0</span>, <span class="built_in">ceil</span>(world_dist / resolution_));</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)cells_dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarkCell</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MarkCell</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>* costmap, <span class="keyword">unsigned</span> <span class="keyword">char</span> value) :</span><br><span class="line">      <span class="built_in">costmap_</span>(costmap), <span class="built_in">value_</span>(value)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> offset)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    costmap_[offset] = value_;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>* costmap_;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> value_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="updateCosts"><a href="#updateCosts" class="headerlink" title="updateCosts"></a>updateCosts</h2><p>代价地图中每个cell可用255个不同值中任何一个值，可是下层数据结构仅需要3个值。具体来说，每个cell仅需要3个值来表示cell的3种状态：free，occupied，unknown。 当投影到代价地图时候，每种状态被赋一个特定的代价值，也就是说每个cell的cost值是由这个cell对应的各层中对应的cell的状态进行加权得到的。 如果列有一定量的占用就被赋代价值。 如果存储的障碍物信息是3D的，需要将每一列的障碍物信息投影成2D后才能放入到代价地图。</p>
<p>更新障碍地图代价，将机器人足迹范围内设置为<code>FREE_SPACE</code>，并且在bound范围内将本层障碍地图的内容合并到主地图上。</p>
<p>障碍物层是将传感器检测到的点云投影到地图中，不同的传感器来源会分别存到Observation类中。只要遍历存储Obsrvation的容器，将检测到的点云的每个点分别投影到地图中，将对应的网格的代价值设为LETHAL_OBSTACLE，其实现函数在void ObstacleLayer::updateBounds(…)中：</p>
<p>清除代价地图的方式也很好理解，以单线激光雷达的激光线为例子，当激光线发射出去之后，在某处检测到一个障碍物，那说明：从发射的地方至某处之间是free的，那么这之间的旧的障碍物应当被删除，这之间网格的代价值应当被修改为free</p>
<p>可能是Bresenham2D的round off error(舍入误差)造成的. It marks a particular cell as obstacle but the next time when the sensor reading changes instantaneously, it no longer traces it through the same path and hence, the blob seem remains in the costmap.</p>
<p>added 2 lines of code to the Bresenham2D algorithm. This basically clears the cell to the left and right of the grid through which the Line segment constructed by the algorithm passes. This results in loosing some resolution of the map, but the solution works pretty well in real life application</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A 2D implementation of Bresenham&#x27;s raytracing algorithm, applies an action </span></span><br><span class="line"><span class="comment">// at each step template&lt;class ActionType&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bresenham2D</span><span class="params">( ActionType at, <span class="keyword">unsigned</span> <span class="keyword">int</span> abs_da, <span class="keyword">unsigned</span> <span class="keyword">int</span> abs_db, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">int</span> error_b, <span class="keyword">int</span> offset_a, <span class="keyword">int</span> offset_b, <span class="keyword">unsigned</span> <span class="keyword">int</span> offset, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">unsigned</span> <span class="keyword">int</span> max_length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> end = std::<span class="built_in">min</span>(max_length, abs_da);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; end; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">at</span>(offset);</span><br><span class="line">    <span class="built_in">at</span>(offset+<span class="number">1</span>); <span class="comment">// **ADDED THIS LINE**</span></span><br><span class="line">    <span class="built_in">at</span>(offset<span class="number">-1</span>); <span class="comment">// **ADDED THIS LINE**</span></span><br><span class="line">    offset += offset_a;</span><br><span class="line">    error_b += abs_db;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)error_b &gt;= abs_da)</span><br><span class="line">    &#123;</span><br><span class="line">      offset += offset_b;</span><br><span class="line">      error_b -= abs_da;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">at</span>(offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/49/">49</a><a class="extend next" rel="next" href="/page/4/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/02/17/ODak2Fc4E1Q7Ymq.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>