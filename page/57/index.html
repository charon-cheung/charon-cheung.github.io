<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">617</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">52</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2024/11/12/x1aqcwUG3XDiskN.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/14/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/VMWare%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">VMWare常见问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/">常用工具</a></span><div class="content"><h3 id="无法进入图形界面"><a href="#无法进入图形界面" class="headerlink" title="无法进入图形界面"></a>无法进入图形界面</h3><p>![<a target="_blank" rel="noopener" href="https://live.staticflickr.com/7870/46689319155_bc1d198671_z.jpg">https://live.staticflickr.com/7870/46689319155_bc1d198671_z.jpg</a>]<br>![<a target="_blank" rel="noopener" href="https://live.staticflickr.com/7892/33727819068_7e69d575f5.jpg">https://live.staticflickr.com/7892/33727819068_7e69d575f5.jpg</a>]</p>
<p>1.Ctrl+ALt+F1（<code>F1~F5</code>都可以）进入控制台</p>
<p>2.输入用户名和密码进入系统；</p>
<p>3.依次输入以下命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/X11</span><br><span class="line"></span><br><span class="line">sudo cp xorg.conf.failsafe xorg.conf</span><br><span class="line"></span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure></p>
<h3 id="开机启动VMWare并启动指定系统"><a href="#开机启动VMWare并启动指定系统" class="headerlink" title="开机启动VMWare并启动指定系统"></a>开机启动VMWare并启动指定系统</h3><p>将VMWare的快捷方式放到<code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</code>，然后打开快捷方式，修改<code>目标</code>：<br><img src="https://live.staticflickr.com/7880/33727818958_a96131d6f7.jpg" alt=""></p>
<p>改成<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;....exe&quot;  -x  &quot;/path_to_system/Ubuntu 64.vmx&quot;</span><br></pre></td></tr></table></figure><br>其中x是小写，后面加vmx文件的路径，而且加双引号</p>
<h3 id="如何让虚拟机网段与主机相同"><a href="#如何让虚拟机网段与主机相同" class="headerlink" title="如何让虚拟机网段与主机相同"></a>如何让虚拟机网段与主机相同</h3><p>先用管理员身份打开VMWare，再打开<code>编辑-虚拟网络编辑器</code>，将网络做如图设置：桥接模式，并选择网卡为主机真实网卡。这样进入虚拟机后，IP就同主机了，设置成DHCP即可。<br><img src="https://live.staticflickr.com/7866/46889495164_d09d2df43e_b.jpg" alt=""></p>
<h3 id="无法打开虚拟机，提示要获得所有权，但还是失败"><a href="#无法打开虚拟机，提示要获得所有权，但还是失败" class="headerlink" title="无法打开虚拟机，提示要获得所有权，但还是失败"></a>无法打开虚拟机，提示要获得所有权，但还是失败</h3><p>很简单，删除虚拟机文件夹下的lck文件夹即可，映像被lck锁定了。应当是上次没有正常关闭虚拟机导致的</p>
<h3 id="硬盘空间太少"><a href="#硬盘空间太少" class="headerlink" title="硬盘空间太少"></a>硬盘空间太少</h3><p>向虚拟机复制文件就是先在cache文件夹里面生成一个同样的文件，并使用拷贝的方式将其拷贝到拖拽放置的目录中。因此，如果不进行清理的话，cache文件夹中产生的文件，并不会自动删除或者释放。</p>
<p>该文件夹位于用户目录下<code>/home/xxxx/.cache/vmware/drag_and_drop</code>进入文件夹，可以见到每一次拖拽产生的文件，都在子文件夹中有一份。直接删除便可以腾出海量的空间。</p>
<h2 id="vmware-tool安装后仍然不能复制的问题"><a href="#vmware-tool安装后仍然不能复制的问题" class="headerlink" title="vmware tool安装后仍然不能复制的问题"></a>vmware tool安装后仍然不能复制的问题</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo  mkdir /mnt/cdrom </span><br><span class="line">sudo apt-get install open-vm-tools-desktop -y</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<h2 id="VM虚拟机增加磁盘空间"><a href="#VM虚拟机增加磁盘空间" class="headerlink" title="VM虚拟机增加磁盘空间"></a>VM虚拟机增加磁盘空间</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liwenchaoCode/p/10421381.html">VM虚拟机增加磁盘空间</a></p>
<h2 id="VMWare-分辨率设置"><a href="#VMWare-分辨率设置" class="headerlink" title="VMWare 分辨率设置"></a>VMWare 分辨率设置</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuchangyin/article/details/104181864">参考链接</a></p>
<p><img src="https://s2.loli.net/2024/05/11/9fx3yWiCPdMu17n.png" alt="VMware连接USB设备，即使连接到了主机，也可切换到虚拟机"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/23/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/">ROS机器人的开发心得体会</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/">ROS机器人</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2019/03/23/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/20/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E4%BD%BF%E7%94%A8ROS%20Service(%E4%B8%80)%20%E6%9C%8D%E5%8A%A1%E5%92%8C%E8%AF%9D%E9%A2%98%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/">使用ROS Service(一) 服务和话题的区别，基本命令</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><h3 id="服务和话题"><a href="#服务和话题" class="headerlink" title="服务和话题"></a>服务和话题</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">特点</th>
<th style="text-align:center">Topic</th>
<th style="text-align:center">Service</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">通信方式</td>
<td style="text-align:center">异步通信</td>
<td style="text-align:center">同步通信</td>
</tr>
<tr>
<td style="text-align:center">通信模型</td>
<td style="text-align:center">Publish-Subscribe</td>
<td style="text-align:center">Request-Reply</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">多对多</td>
<td style="text-align:center">多对一</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">接收者接到数据会回调</td>
<td style="text-align:center">远程过程调用(RPC)服务器端的服务</td>
</tr>
<tr>
<td style="text-align:center">应用场景</td>
<td style="text-align:center">连续，高频的数据发布</td>
<td style="text-align:center">偶尔调用的功能</td>
</tr>
<tr>
<td style="text-align:center">举例</td>
<td style="text-align:center">激光雷达</td>
<td style="text-align:center">开关传感器，拍照，逆解计算</td>
</tr>
</tbody>
</table>
</div>
<font size="4" color="blue"> 由于是同步通信，service 的回调不能写复杂的、耗时长的业务  </font>

<h3 id="rosservice-call"><a href="#rosservice-call" class="headerlink" title="rosservice  call"></a>rosservice  call</h3><p><code>rosservice call addTwoNum 3 4</code>: 调用服务，<code>addTwoNum</code>是服务名称，<font color = blue size= 3> 名称不加引号</font>，3和4是服务中的req变量的值，注意必须按服务文件中的顺序赋值。</p>
<p>但上面是简单情况，srv文件稍微有点复杂时，就会怎么填也不对，个人认为这是ROS Service很失败的一个地方。<br>例如srv文件的请求部分是这样的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string request_string</span><br><span class="line">string album</span><br></pre></td></tr></table></figure><br>我试了很多种组合，都不正确。其实这种情况也好办，在<code>call srvname</code>之后直接Tab，会给出一个模板：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosservice call service_name &quot;request_string: &#x27;&#x27;</span><br><span class="line">album: &#x27;&#x27;&quot;</span><br></pre></td></tr></table></figure><br>我们要做的就是把内容填到单引号里面，不要再自己修改模板，否则容易出错。</p>
<p><code>call</code>执行成功时，终端不会有任何结果。但是经常出现这样的错误：<font color = orange size= 3> ERROR: service [/control_cam] responded with an error:  </font>，但程序执行没有问题。原因是 <font color = blue size=4>程序中对srv文件中的应答没有处理 </font></p>
<p>其他常用命令：</p>
<ul>
<li>rosservice list: 显示当前所有活动的服务</li>
<li>rosservice info addTwoNum: 显示服务的信息</li>
<li>rosservice type addTwoNum: 显示服务的变量类型</li>
</ul>
<p>其实服务的相关命令和话题的很类似</p>
<h3 id="ROS的服务类型"><a href="#ROS的服务类型" class="headerlink" title="ROS的服务类型"></a>ROS的服务类型</h3><p>启动乌龟节点时，有一个服务叫<code>clear</code>，类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rosservice type clear</span><br><span class="line"></span><br><span class="line">std_srvs/Empty</span><br></pre></td></tr></table></figure><br>看源码可知，服务的类型为空,这表明调用这个服务不需要参数（比如，请求不需要发送数据，响应也没有数据）．调用后，服务清除了turtlesim_node的背景上的轨迹，没有响应．</p>
<p><code>std_srvs</code>包还有两个服务：<code>std_srvs/Trigger</code>和<code>std_srvs/SetBool</code>，但是很不常用</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/11/%E8%84%9A%E6%9C%AC/locate%E5%92%8Cfind/">locate和find</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%84%9A%E6%9C%AC/">脚本</a></span><div class="content"><ul>
<li><p><code>locate</code>的速度比<code>find</code>快，因为它并不是真的查找文件，而是查数据库。</p>
</li>
<li><p>新建的文件，我们立即用<code>locate</code>命令去查找，一般是找不到的，因为数据库的更新不是实时的，而是每天</p>
</li>
<li><code>locate</code>命令所搜索的后台数据库在<code>/var/lib/mlocate</code>这个目录下，可能有些Linux系统位置不同，具体我们可以用<code>locate locate</code>查询</li>
<li><p>并不是所有的目录下的文件都会用<code>locate</code>命令搜索到，<code>/etc/updatedb.conf</code>这个配置文件中，配置了一些<code>locate</code>命令的一些规则。</p>
</li>
<li><p><code>updatedb</code>会大致每天运行，这是靠系统的crontab命令实现的</p>
</li>
<li><code>updatedb -U</code>：更新指定目录相关的数据库信息。默认是整个系统，耗时比较长，因此可以使用该参数，比如<code>sudo updatedb -U /home/user/</code></li>
</ul>
<p><code>updatedb</code>的配置文件 <code>/etc/updatedb.conf</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/updatedb.conf </span><br><span class="line">PRUNE_BIND_MOUNTS = <span class="string">&quot;yes&quot;</span></span><br><span class="line">PRUNEFS = <span class="string">&quot;9p afs anon_inodefs auto autofs bdev binfmt_misc cgroup cifs coda configfs cpuset debugfs devpts ecryptfs exofs fuse fuse.sshfs fusectl gfs gfs2 gpfs hugetlbfs inotifyfs iso9660 jffs2 lustre mqueue ncpfs nfs nfs4 nfsd pipefs proc ramfs rootfs rpc_pipefs securityfs selinuxfs sfs sockfs sysfs tmpfs ubifs udf usbfs fuse.glusterfs ceph fuse.ceph&quot;</span></span><br><span class="line">PRUNENAMES = <span class="string">&quot;.git .hg .svn&quot;</span></span><br><span class="line">PRUNEPATHS = <span class="string">&quot;/afs /media /mnt /net /sfs /tmp /udev /var/cache/ccache /var/lib/yum/yumdb /var/spool/cups /var/spool/squid /var/tmp /var/lib/ceph&quot;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>PRUNENAMES</code>   搜索时不搜索的文件类型</li>
<li><code>PRUNEPATHS</code>   搜索时不搜索的路径</li>
<li><code>PRUNE_BIND_MOUNTS = &quot;yes&quot;</code>    开启搜索限制</li>
<li><code>PRUNEFS</code>    搜索时不搜索的文件系统</li>
</ul>
<h2 id="locate-常用命令"><a href="#locate-常用命令" class="headerlink" title="locate 常用命令"></a>locate 常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">locate -c   <span class="comment"># 查询指定文件的数目。(c为count的意思)</span></span><br><span class="line">locate -e   <span class="comment"># 只显示当前存在的文件条目。(e为existing的意思)</span></span><br><span class="line">locate -i   <span class="comment"># 查找时忽略大小写区别</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正则表达式查找文件</span></span><br><span class="line">locate -r makefile$		<span class="comment"># 以makefile结尾的文件</span></span><br><span class="line">locate -r ^/home/user/		<span class="comment"># 以/home/user/开头的文件		</span></span><br></pre></td></tr></table></figure>
<p>从结果中取出词尾是<code>config2</code>的<br><img src="https://i.loli.net/2020/04/21/9EkIqjKB1Y86yXP.png" alt=""></p>
<p>注意：locate的结果可能是不存在的文件，这时最好用<code>locate -e</code></p>
<p>locate 查找文件<code>tree.xml</code>，也就是知道完整的文件名时，那么最好用 <code>locate  /tree.xml</code>，如果不加<code>/</code>，会显示<code>test_tree.xml</code>的结果</p>
<h2 id="find-常用命令"><a href="#find-常用命令" class="headerlink" title="find 常用命令"></a>find 常用命令</h2><p>查找当前目录中(包括子目录)所有扩展名为cfg的文件:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 或者 &#x27;*.cfg&#x27;</span></span><br><span class="line">find -name *.cfg</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><code>find . -name &#39;*.cpp&#39; -mmin -30</code>       当前目录下，最近30分钟修改的cpp文件</p>
</li>
<li><p><code>find . -name &#39;*.cpp&#39; -mtime 0</code>        当前目录下，最近24小时修改的cpp文件 </p>
</li>
<li><p><code>find . -type f -mtime 0</code>              当前目录下，最近24小时修改的常规文件</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/02/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E4%B9%8C%E9%BE%9F%E8%BF%BD%E4%B9%8C%E9%BE%9F%E7%A8%8B%E5%BA%8F/">深入解析乌龟追乌龟程序</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><p>ROS启动乌龟追乌龟程序用的是<code>roslaunch turtle_tf turtle_tf_demo.launch</code>，其内容如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtlesim_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sim&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;turtlesim&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtle_teleop_key&quot;</span> <span class="attr">name</span>=<span class="string">&quot;teleop&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Axes --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;scale_linear&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;double&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;scale_angular&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;double&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 针对两个乌龟的tf广播 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;turtle1_tf_broadcaster&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;turtle_tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtle_tf_broadcaster.py&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;false&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;turtle&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">value</span>=<span class="string">&quot;turtle1&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;turtle2_tf_broadcaster&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;turtle_tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtle_tf_broadcaster.py&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;false&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;turtle&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">value</span>=<span class="string">&quot;turtle2&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;turtle_pointer&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;turtle_tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;turtle_tf_listener.py&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;false&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>乌龟的程序,按下方向键,乌龟只走一段距离,是在cmd_vel的回调函数里更新乌龟的位置,取决于发布的twist消息和更新间隔dt,由Qt实现</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/02/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BD%BF%E7%94%A8AprilTag%E8%BF%9B%E8%A1%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA%EF%BC%88%E4%BA%8C%EF%BC%89/">使用AprilTag进行机器人导航（二）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%85%B6%E4%BB%96/">其他</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2019/03/02/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BD%BF%E7%94%A8AprilTag%E8%BF%9B%E8%A1%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA%EF%BC%88%E4%BA%8C%EF%BC%89/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/02/26/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/tf(%E4%B8%80)/">tf(一) 概念和基本使用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-02-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><p>tf包处理的是任一个点在所有坐标系之间的坐标变换问题，它把各种转换关系建立在一个树结构上，树的每个节点是坐标系，每个坐标系可以有多个child，但只能有一个parent，转换只能是<strong>从parent向child</strong>。比如Tb-a表示坐标系a向b转换，也就是说a是parent，b是child，这个变换描述的就是child坐标系中的点在parent坐标系下的姿态。要实现这个变换，就是用child坐标系在parent坐标系下的描述（一个矩阵）去描述（乘以）这个点在child坐标系下的描述（坐标）。world参考系是tf树最顶端的父参考系</p>
<p>如果打算用tf解决你的坐标变换问题，请一定要先清晰的画出这棵树的结构，再开始写程序。比较重要的类是<code>tf::TransformBroadcaster</code>, <code>tf::TransformListener</code>, <code>tf::Transform</code>, <code>tf::StampedTransform</code></p>
<p>在tf的运行机制中，由于tf会把监听到的内容放到一个缓存中。我们通过<code>transformPose</code>获取变换关系，是通过查询这个缓存来实现的。获取的数据不能保证实时性，会有一定的延迟。也有可能无法获得，因此这个函数在运行过程中会抛出异常，所以这里使用try-catch语句捕获这个异常并返回。</p>
<h2 id="tf-TransformBroadcaster类"><a href="#tf-TransformBroadcaster类" class="headerlink" title="tf::TransformBroadcaster类"></a>tf::TransformBroadcaster类</h2><p><code>sendtransform</code>接口可以建立tf树，发布一个从已有的父坐标系到新的子坐标系的变换时，这棵树就会添加一个树枝，之后就是维护。TransformBroadcaster类就是一个publisher, 如果两个frame之间发生了相对运动，TransformBroadcaster类就会发布<code>TransformStamped</code>消息到tf话题，当多个节点向tf话题发消息时，就形成了tf树。</p>
<h2 id="tf-Transform"><a href="#tf-Transform" class="headerlink" title="tf::Transform"></a>tf::Transform</h2><p>建立坐标系之间的位移和旋转的关系，最后用于sendTransform函数。</p>
<p>它是一个坐标转换。成员有：<code>Matrix3x3  m_basis</code>，用<code>3*3</code>的矩阵表示旋转； <code>Vector3 m_origin</code>，用<code>3*1</code>的向量表示平移。</p>
<p>tf::Transform支持乘法运算符，实际的计算是先把旋转矩阵和平移量组合为<strong>变换矩阵</strong>，变换矩阵相乘后，再转换为<code>tf::Transform</code>类型</p>
<p><code>tf::Transform</code>类的重要函数如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matrix3x3 &amp;   <span class="title">getBasis</span> <span class="params">()</span>    <span class="comment">//Return the basis matrix for the rotation</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Vector3 &amp; <span class="title">getOrigin</span> <span class="params">()</span>  <span class="comment">//Return the origin vector translation</span></span></span><br><span class="line"><span class="function">Quaternion  <span class="title">getRotation</span> <span class="params">()</span>  <span class="comment">//Return a quaternion representing the rotation</span></span></span><br><span class="line"><span class="function">Transform   <span class="keyword">operator</span>* <span class="params">(<span class="keyword">const</span> Transform &amp;t)</span> <span class="keyword">const</span>  <span class="comment">//Return the product of this transform and the other.</span></span></span><br><span class="line"><span class="function">Transform   <span class="title">inverse</span> <span class="params">()</span>    <span class="comment">//Return the inverse of this transform</span></span></span><br></pre></td></tr></table></figure><br><code>inverse()</code>函数很有用，我们可以把上面程序中的<code>transform.getOrigin().x()</code>改成<code>transform.inverse().getOrigin().x()</code>就可以求出乌龟1在乌龟2坐标系中的坐标了。</p>
<p><code>tf::StampedTransform</code>类继承自<code>tf::Transform</code>，它多了两个重要变量就是<code>child_frame_id_</code>和<code>frame_id_</code>。</p>
<h2 id="tf-TransformListener"><a href="#tf-TransformListener" class="headerlink" title="tf::TransformListener"></a>tf::TransformListener</h2><p>监听一个父坐标系到子坐标系的变换，<code>waitForTransform</code>是监听转换关系，可以指定监听的时间或一直阻塞；<code>lookupTransform</code>紧随其后，获取 <code>tf::Transform</code></p>
<p>使用前需要<code>#include &lt;tf/transform_listener.h&gt;</code></p>
<p><code>TransformListener</code>构造函数有两个，常用的是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TransformListener::<span class="built_in">TransformListener</span>(</span><br><span class="line">    ros::Duration max_cache_time = ros::<span class="built_in">Duration</span>(DEFAULT_CACHE_TIME),  </span><br><span class="line">    <span class="keyword">bool</span> spin_thread = <span class="literal">true</span> </span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>平时用的是无参构造函数，其实是默认构造函数，如果指定缓存时间，就用<code>tf::TransformListener  tf_(ros::Duration(15) );</code>，<code>Costmap2DROS</code>中使用的tf缓存，根源是<code>move_base_node.cpp</code>中的<code>tf::TransformListener tf(ros::Duration(10) );</code></p>
<p>参考我写的程序<code>test_costmap</code>。开始，如果没有<code>map</code>—-&gt;<code>base_link</code>的TF转换，则报错<code>No Transform available Error</code>。此时发布TF变换，则不再报错。然后再关闭TF变换，<code>test_costmap</code>还能正常运行10s，然后报错 <code>Extrapolation Error</code></p>
<h3 id="transformPose"><a href="#transformPose" class="headerlink" title="transformPose"></a>transformPose</h3><p>原型是<code>void transformPose(const std::string &amp;target_frame, const geometry_msgs::PoseStamped &amp;stamped_in, geometry_msgs::PoseStamped &amp;stamped_out) const</code>，</p>
<p>target_frame就是你要把源pose转换成哪个frame上的pose。假如你的源pose的frame_id是”odom”，你想转到”map”上，那么target_frame写成“map”就可以了。stamped_in就是源pose，而stamped_out就是目标数据了，也就是转换完成的数据。需要注意的是，从参数上来看，转换时是不需要指定源frame_id的，这是因为它已经包含在了stamped_in中，换句话说，就是这个函数一个隐含的使用条件是，<strong>stamped_in中必须指明源pose属于哪个frame</strong></p>
<p>把odom坐标系的数据转换到map坐标系下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs::PoseStamped pose_odom;</span><br><span class="line">pose_odom.header = odom-&gt;header;</span><br><span class="line">pose_odom.pose = odom-&gt;pose.pose;</span><br><span class="line"></span><br><span class="line">geometry_msgs::PoseStamped pose_map;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    listener.<span class="built_in">transformPose</span>(<span class="string">&quot;map&quot;</span>, pose_odom, pose_map);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>( tf::TransformException ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ROS_WARN</span>(<span class="string">&quot;transfrom exception : %s&quot;</span>,ex.<span class="built_in">what</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有时会出现这样的报错： <font color = orange size=4> transfrom exception : “map” passed to lookupTransform argument target_frame does not exist </font>，但是使用<code>tf_echo</code>发现是正常的。需要检查代码是不是在回调函数里运行了， 不需要在回调函数里创建<code>TransformListener</code>对象， 将它作为类成员变量或者全局变量。 </p>
<p>全局变量是在main函数之前完成构造函数的，如果用到的类构造函数用到NodeHandle，就会报错。比如<code>tf::TransformListener</code>，解决方法是用全局指针，比如<code>boost::shared_ptr&lt;T&gt;</code>，然后在main函数的ros::init()之后指向一个对象。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://answers.ros.org/question/192570/tftransformlistenertransformpose-exception-target_frame-does-not-exist/">tf::TransformListener::transformPose [exception] target_frame does not exist</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/02/19/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BD%BF%E7%94%A8AprilTag%E8%BF%9B%E8%A1%8C%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA%EF%BC%88%E4%B8%80%EF%BC%89/">使用AprilTag进行机器人导航（一）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-02-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%85%B6%E4%BB%96/">其他</a></span><div class="content"><p>充电桩的导航，一般方案是先导航到充电桩附近的一个固定点，然后切换到另一种更精确的导航方式进行精确对接充电桩。<font size="4" color="blue">  精确对接的定位技术有红外、蓝牙、激光特征、二维码、反光板 </font></p>
<p>这里只谈Apriltag，如果是<code>aruco</code>二维码，使用<a target="_blank" rel="noopener" href="https://github.com/pal-robotics/aruco_ros/blob/noetic-devel/aruco_ros">aruco_ros</a></p>
<p>ROS官方提供了一个名为<code>apriltags2_ros</code>的包处理AprilTag，可以根据Tag进行定位导航，我使用的是<code>april.launch</code>。使用前需要先启动摄像头的节点，我用的是<code>usb_cam.launch</code>，如果摄像头程序重启，<code>april.launch</code>也要重启，否则无效。</p>
<p>节点会发布话题<code>tag_detections</code>和<code>tag_detections_image</code>，后者是带数字识别的图，前者是坐标关系的输出。默认的话题频率应该能达到10Hz，<font color = blue size=4>但是完全取决于计算机的性能，无法用参数配置。</font></p>
<p><code>settings.yaml</code>中的参数如下，按默认即可:</p>
<ul>
<li><p>Make sure <code>tag_border</code> corresponds to your tags’ black border bit width (typically 1 - each square in the tag is represents 1 bit);</p>
</li>
<li><p>Setting <code>tag_threads</code> allows certain parts of the core AprilTag 2 algorithm to run parallel computations. Typical multithreading advantages and limitations apply;</p>
</li>
<li><p>增大<code>tag_decimate&gt;1</code> allows to decimate (reduce the resolution) of the image by that amount. This makes the core AprilTag 2 algorithm faster (there are less pixels to process) but means that smaller tags are less likely to be detected，甚至无法识别。Pose estimation and decoding still happens with the full-resolution image;</p>
</li>
<li><p>Setting <code>tag_blur&gt;0</code> blurs the image and <code>tag_blur&lt;0</code> sharpens the image;</p>
</li>
<li><p>Setting <code>tag_refine_edges=1</code> improves the detection fit to the tag, thus the corner detection precision, thus the pose estimation accuracy. Not computationally expensive and recommended to be on (1);</p>
</li>
<li><p>Setting <code>tag_refine_decode=1</code> reducecs the false negative detetion rate;</p>
</li>
<li><p>Setting <code>tag_refine_pose=1</code> improves the estimated pose accuracy but is computationally expensive;</p>
</li>
</ul>
<p>这个包有自定义的消息文件，不知道为什么，如果在自己的程序(我的叫<code>tag_nav</code>)中想包含其消息的头文件，就会报错：<br><img src="https://c2.staticflickr.com/8/7849/40212016093_9a42b7e247_b.jpg" alt=""><br>解决方法：先编译好<code>apriltag2_ros</code>包，然后注释掉<code>CMakeLists</code>中的<code>generate_messages</code>部分，再编译<code>tag_nav</code>。之后没事不要再动<code>apriltag2_ros</code>了。如果先注释再编译<code>apriltag2_ros</code>包，会无法在<code>tag_nav</code>中包含前者的头文件。</p>
<p>我们使用<code>36H11</code>规格的ID为9的二维码进行测试。</p>
<p><strong>注意事项</strong>:</p>
<ul>
<li><p>同一个tag ID不能对应不同的尺寸，这会造成检测的不确定。</p>
</li>
<li><p>同一张图案里不要有相同的tag ID</p>
</li>
<li><p>standalone_tags 和 in tag_bundles 可以有相同ID的tag, 但是size也必须相同。</p>
</li>
<li><p>打印出的<strong>tags周围要有一些白色空间</strong>，这是AprilTag 2 算法要求的，所以我们最好使用带黑框的图案</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/09/26/vkO7tN6T9XBbxRY.jpg" alt="Apriltag2.jpg"></p>
<h3 id="两话题不同步的问题"><a href="#两话题不同步的问题" class="headerlink" title="两话题不同步的问题"></a>两话题不同步的问题</h3><p>运行后提示<font color = orange size= 3> image消息和camera_info消息没有同步</font><br><img src="https://c2.staticflickr.com/8/7916/33269888108_3e8be792f5_b.jpg" alt=""></p>
<p>此时打开<code>rqt</code>，切换到主题<code>tag_detections_image</code>，发现没有结果</p>
<p>源码在<code>continuous_detector.cpp</code>，发现没有进入回调函数<code>ContinuousDetector::imageCallback</code>，它的注册在:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">camera_image_subscriber_ =  it_-&gt;<span class="built_in">subscribeCamera</span>(<span class="string">&quot;/usb_cam/image_raw&quot;</span>,   <span class="number">1</span>,  &amp;ContinuousDetector::imageCallback, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><br>函数解释：订阅一对同步化的image和camera info话题，This version assumes the standard topic naming scheme, where the info topic is named “camera_info” in the same namespace as the base image topic.</p>
<p>既然二者目前没有同步，当然没有进入回调函数，也就无法识别Tag了。最终发现原因就是在工控机上运行了<code>roslaunch usb_cam usb_cam.launch</code>，而在远程机运行了<code>apriltag_ros</code>包，而两台电脑通信不畅，解决方法就是将二者都在工控机上运行。</p>
<p>现在执行<code>rqt</code>就可以看到识别的结果了，二维码中心是ID,终端上也出现了二维码ID等信息:<br><img src="https://i.loli.net/2020/08/31/wPqEDiTYvr3S14C.png" alt="识别Tag"></p>
<h3 id="Tag的位姿"><a href="#Tag的位姿" class="headerlink" title="Tag的位姿"></a>Tag的位姿</h3><p>若要查看检测结果，执行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rostopic　<span class="built_in">echo</span>　/tag_detections</span><br></pre></td></tr></table></figure><br>得到这样的结果<br><img src="https://i.loli.net/2020/08/31/8KfgzoBFWEq5Tje.png" alt="tag_detections"><br>很明显，我们需要的是<code>position</code>和<code>orientation</code>。在实际中，Tag应当是不动的，摄像头安装在机器人上，是运动的。所以描述二者关系时，以Tag为原点进行分析，如下图是Tag和摄像头（黄圈）<br><img src="https://i.loli.net/2020/08/31/LUxgC4hMupsHD8Z.png" alt=""><br>经过我实际的测试，这种环境中的坐标轴应当是这样的:<br><img src="https://c2.staticflickr.com/8/7839/33280810218_35a1236470_z.jpg" alt=""><br>y代表了上下方向，由于Tag是固定的，而机器人不能飞起来，所以y可以不用考虑。当机器人在Tag右边时，x为负，在左边时为正。当机器人远离Tag时，z值变大，走近Tag时，z值变小。我所用的摄像头检测到Tag的最大距离接近5米，已经足够了。</p>
<p>总结一下，摄像头坐标系和tag坐标系的关系如下（普遍适用）：<br><img src="https://i.loli.net/2020/08/31/ilswyR1bG43MESN.png" alt=""></p>
<h3 id="坐标系转换关系问题"><a href="#坐标系转换关系问题" class="headerlink" title="坐标系转换关系问题"></a>坐标系转换关系问题</h3><p><code>apriltag2_ros</code>包存在<code>tag_9</code>坐标系向<code>camera</code>坐标系的转换，在<code>TagDetector::detectTags</code>函数的最后。</p>
<p>接下来我们要在<code>camera</code>和<code>base_link</code>之间建立联系，这样就将所有坐标系关联起来了，在launch文件中添加:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">args</span>=<span class="string">&quot;-0.24 0 0.295 1.571 0 -1.571 /base_link /camera 10&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;tf&quot;</span> <span class="attr">name</span>=<span class="string">&quot;base_link_to_camera&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><br>因为tf是树结构，所以一个坐标系只能有一个parent，但可以有多个child。因此这里不能让camera做parent，而是base_link，因为base_link的parent已经是odom了，不能再给它找个parent</p>
<p>启动所有launch文件后，使用<code>rosrun tf view_frame</code>命令生成pdf文件，查看得知，拥有全部坐标系的情况是这样的:<br><img src="https://c2.staticflickr.com/8/7827/40253601803_d6803a012f_b.jpg" alt=""></p>
<h3 id="apriltags2-ros的bug"><a href="#apriltags2-ros的bug" class="headerlink" title="apriltags2_ros的bug"></a>apriltags2_ros的bug</h3><p>在<code>apriltags2_ros</code>启动一段时间后，会偶然的无法正常检测二维码，<code>tag_detections</code>话题没有结果，也没有图形识别的结果，但摄像头的节点正常。</p>
<p>多次观察<code>tag_detections</code>的发布情况，发现最快的一次是<code>header.seq</code>到1400的时候就出错了，有时是到3900的时候，始终不确定，难以找到原因。</p>
<p>因此尝试<code>AprilTag3</code>，同时把<code>setting.yaml</code>中的线程数改为4，再也没有发生这一bug</p>
<p>参考：<br><a target="_blank" rel="noopener" href="http://wiki.ros.org/image_transport">ROS  image_transport</a><br><a target="_blank" rel="noopener" href="https://optitag.io/blogs/news/using-your-apriltag-with-ros">Using Apriltags with ROS</a><br><a target="_blank" rel="noopener" href="http://docs.ros.org/lunar/api/image_transport/html/classimage__transport_1_1CameraSubscriber.html">image_transport::CameraSubscriber Class </a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/02/02/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/ROS%E6%A0%87%E5%AE%9A%E6%91%84%E5%83%8F%E5%A4%B4/">ROS标定摄像头</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-02-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/">ROS机器人</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%91%84%E5%83%8F%E5%A4%B4/">摄像头</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2019/02/02/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/ROS%E6%A0%87%E5%AE%9A%E6%91%84%E5%83%8F%E5%A4%B4/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/22/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ROS%E7%BC%96%E7%A8%8B%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">ROS编程常用函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><h2 id="接受中文注释"><a href="#接受中文注释" class="headerlink" title="接受中文注释"></a>接受中文注释</h2><p><code>setlocale(LC_ALL, &quot;&quot;);</code></p>
<h2 id="ros-Time-和-double-转换"><a href="#ros-Time-和-double-转换" class="headerlink" title="ros::Time 和 double 转换"></a>ros::Time 和 double 转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x=ros::Time::<span class="built_in">now</span>().<span class="built_in">toSec</span>();     <span class="comment">//把时间戳转化成浮点型格式</span></span><br><span class="line">ros::Time stamp = ros::<span class="built_in">Time</span>().<span class="built_in">fromSec</span>(x);    <span class="comment">//把浮点型变成时间戳</span></span><br></pre></td></tr></table></figure>
<h2 id="读取环境变量"><a href="#读取环境变量" class="headerlink" title="读取环境变量"></a>读取环境变量</h2><p>跨平台函数 <code>bool  get_environment_variable (std::string &amp;str, const char *environment_variable)</code></p>
<h2 id="clamp函数"><a href="#clamp函数" class="headerlink" title="clamp函数"></a>clamp函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">clamp</span><span class="params">(T x, T min, T max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; max)</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; min)</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="转换路径点到-base-link-坐标系下"><a href="#转换路径点到-base-link-坐标系下" class="headerlink" title="转换路径点到 base_link 坐标系下"></a>转换路径点到 <code>base_link</code> 坐标系下</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意最后一个路径点，是 end() 的前一个点</span></span><br><span class="line">geometry_msgs::PoseStamped  global_end = *(std::<span class="built_in">prev</span>(global_plan_.<span class="built_in">end</span>()) );</span><br><span class="line">geometry_msgs::PoseStamped  base_end;</span><br><span class="line"><span class="built_in">transformPose</span>(<span class="string">&quot;base_link&quot;</span>, global_end,  base_end);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span>  <span class="title">transformPose</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::string frame,</span></span></span><br><span class="line"><span class="params"><span class="function">    geometry_msgs::PoseStamped &amp;in_pose,</span></span></span><br><span class="line"><span class="params"><span class="function">    geometry_msgs::PoseStamped &amp;out_pose)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in_pose.header.frame_id == frame)</span><br><span class="line">    &#123;</span><br><span class="line">        out_pose = in_pose;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        out_pose.header.frame_id = frame;</span><br><span class="line">        tf_-&gt;<span class="built_in">transformPose</span>(frame, in_pose, out_pose);</span><br><span class="line">        out_pose.header.seq = in_pose.header.seq;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (tf2::TransformException &amp;ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Exception in transformPose : %s&quot;</span>, ex.<span class="built_in">what</span>()  );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四元数转欧拉角yaw"><a href="#四元数转欧拉角yaw" class="headerlink" title="四元数转欧拉角yaw"></a>四元数转欧拉角yaw</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">quaternionToYaw</span><span class="params">(<span class="keyword">const</span> geometry_msgs::Quaternion&amp;  quat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tf::Quaternion tf_quat;</span><br><span class="line">    tf::<span class="built_in">quaternionMsgToTF</span>(quat, tf_quat);</span><br><span class="line">    <span class="keyword">double</span> roll, pitch, yaw;</span><br><span class="line">    tf::<span class="built_in">Matrix3x3</span>(tf_quat).<span class="built_in">getRPY</span>(roll, pitch, yaw);</span><br><span class="line">    <span class="keyword">return</span> yaw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">quaternionToYaw</span><span class="params">(<span class="keyword">const</span> geometry_msgs::Quaternion&amp;  quat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">tf::Quaternion <span class="title">quat</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>, quat.z, quat.w)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> tf::<span class="built_in">getYaw</span>(quat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉角-——-四元数"><a href="#欧拉角-——-四元数" class="headerlink" title="欧拉角 —— 四元数"></a>欧拉角 —— 四元数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只通过yaw计算四元数，用于平面小车</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> geometry_msgs::Quaternion  <span class="title">tf::createQuaternionMsgFromYaw</span><span class="params">(<span class="keyword">double</span> yaw)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> tf::Quaternion  <span class="title">createQuaternionFromYaw</span> <span class="params">(<span class="keyword">double</span> yaw)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> tf::Quaternion  <span class="title">createQuaternionFromRPY</span><span class="params">(<span class="keyword">double</span> roll, <span class="keyword">double</span> pitch, <span class="keyword">double</span> yaw)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> geometry_msgs::Quaternion  <span class="title">createQuaternionMsgFromRollPitchYaw</span><span class="params">( <span class="keyword">double</span> roll, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">double</span> pitch,   <span class="keyword">double</span> yaw)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="获得当前节点名称"><a href="#获得当前节点名称" class="headerlink" title="获得当前节点名称"></a>获得当前节点名称</h2><p><code>ros::this_node::getName()</code></p>
<p><code>bool  ros::master::getNodes (V_string &amp;nodes)</code>  是获得当前所有运行的节点，效果和<code>rosnode list</code>一样。但这里有个缺陷，使用<code>pkill</code>杀死的节点，在<code>rosnode list</code>里仍然能看到，实际已经退出了。</p>
<h2 id="规范角度-π-π"><a href="#规范角度-π-π" class="headerlink" title="规范角度 [-π, π)"></a>规范角度 [-π, π)</h2><p>调用<code>g2o::normalize_theta(double theta)</code>或者<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">normAngle</span> <span class="params">( <span class="keyword">double</span>&amp; angle )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( angle &gt;= M_PI)</span><br><span class="line">        angle -= <span class="number">2</span> * M_PI;</span><br><span class="line">    <span class="keyword">if</span>( angle &lt; -M_PI)</span><br><span class="line">        angle += <span class="number">2</span> * M_PI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="判断机器人是否静止"><a href="#判断机器人是否静止" class="headerlink" title="判断机器人是否静止"></a>判断机器人是否静止</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">robotIsStill</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> velStatus;</span><br><span class="line">    boost::shared_ptr&lt;nav_msgs::Odometry <span class="keyword">const</span>&gt; twistEdge;</span><br><span class="line">    twistEdge = ros::topic::waitForMessage&lt;nav_msgs::Odometry&gt;(<span class="string">&quot;odom&quot;</span>,ros::<span class="built_in">Duration</span>(<span class="number">0.3</span>) );</span><br><span class="line">    <span class="keyword">if</span>(twistEdge != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> velX = twistEdge-&gt;twist.twist.linear.x;</span><br><span class="line">        <span class="keyword">double</span> angularZ = twistEdge-&gt;twist.twist.angular.z;</span><br><span class="line">        <span class="keyword">if</span>(velX == <span class="number">0</span> &amp;&amp; angularZ == <span class="number">0</span>)</span><br><span class="line">            velStatus = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            velStatus = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> velStatus = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> velStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="移动一定时间，也可以表示移动一定距离"><a href="#移动一定时间，也可以表示移动一定距离" class="headerlink" title="移动一定时间，也可以表示移动一定距离"></a>移动一定时间，也可以表示移动一定距离</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs::Twist cmd_vel;</span><br><span class="line">cmd_vel.linear.x = <span class="number">-0.12</span>;</span><br><span class="line">cmd_vel.linear.y = <span class="number">0.0</span>;</span><br><span class="line">cmd_vel.angular.z = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> t1 = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> t2 = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot; -------------- backward begin ! ------------------ &quot;</span>);</span><br><span class="line"><span class="keyword">while</span>( std::chrono::duration&lt;<span class="keyword">double</span>&gt;(t2-t1).<span class="built_in">count</span>() &lt; <span class="number">3</span> )</span><br><span class="line">&#123;</span><br><span class="line">    vel_pub.<span class="built_in">publish</span>(cmd_vel);</span><br><span class="line">    t2 = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">&#125;</span><br><span class="line">cmd_vel.linear.x = <span class="number">0</span>;</span><br><span class="line">vel_pub.<span class="built_in">publish</span>(cmd_vel);</span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot; -------------- backward done, now continue !  ------------------ &quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="获取当前速度"><a href="#获取当前速度" class="headerlink" title="获取当前速度"></a>获取当前速度</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tf::Stamped&lt;tf::Pose&gt; robot_vel_tf;</span><br><span class="line">base_local_planner::OdometryHelperRos odom_helper_;</span><br><span class="line">odom_helper_.<span class="built_in">getRobotVel</span>(robot_vel_tf);</span><br><span class="line"></span><br><span class="line">geometry_msgs::Twist  robot_vel_;</span><br><span class="line">robot_vel_.linear.x = robot_vel_tf.<span class="built_in">getOrigin</span>().<span class="built_in">getX</span>();</span><br><span class="line">robot_vel_.linear.y = robot_vel_tf.<span class="built_in">getOrigin</span>().<span class="built_in">getY</span>();</span><br><span class="line">robot_vel_.angular.z = tf::<span class="built_in">getYaw</span>(robot_vel_tf.<span class="built_in">getRotation</span>());</span><br></pre></td></tr></table></figure>
<h2 id="poseStampedMsgToTF"><a href="#poseStampedMsgToTF" class="headerlink" title="poseStampedMsgToTF"></a>poseStampedMsgToTF</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get the starting pose of the robot</span></span><br><span class="line">tf::Stamped&lt;tf::Pose&gt; global_pose;</span><br><span class="line"><span class="keyword">if</span>(!planner_costmap_ros_-&gt;<span class="built_in">getRobotPose</span>(global_pose)) &#123;</span><br><span class="line">  <span class="built_in">ROS_WARN</span>(<span class="string">&quot;Unable to get starting pose of robot, unable to create global plan&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">geometry_msgs::PoseStamped start_pose;</span><br><span class="line">tf::<span class="built_in">poseStampedTFToMsg</span>(global_pose, start_pose);</span><br></pre></td></tr></table></figure>
<p>还有类似的函数: <code>poseTFToMsg</code> 和 <code>transformMsgToTF</code></p>
<h2 id="angles包"><a href="#angles包" class="headerlink" title="angles包"></a><code>angles</code>包</h2><ul>
<li><p>static double   from_degrees (double degrees):  Convert degrees to radians</p>
</li>
<li><p>static double   normalize_angle (double angle)</p>
</li>
<li><p>static double   shortest_angular_distance (double from, double to)</p>
</li>
<li><p>static double   to_degrees (double radians):   Convert radians to degrees</p>
</li>
<li><p>static double   two_pi_complement (double angle):  returns the angle in <code>[-2*M_PI, 2*M_PI]</code>  going the other way along the unit circl</p>
</li>
</ul>
<h2 id="tf-命名空间"><a href="#tf-命名空间" class="headerlink" title="tf 命名空间"></a>tf 命名空间</h2><p><a target="_blank" rel="noopener" href="https://docs.ros.org/en/noetic/api/tf/html/c++/namespacetf.html#ae9c19270893b14223e2b2a8aeb2c48e7">tf的命名空间</a>有很多有用的函数，先列出一部分:</p>
<ul>
<li>TFSIMD_FORCE_INLINE tfScalar  angle (const Quaternion &amp;q1, const Quaternion &amp;q2) </li>
</ul>
<p>Return the half angle between two quaternions</p>
<ul>
<li>TFSIMD_FORCE_INLINE tfScalar  angleShortestPath (const Quaternion &amp;q1, const Quaternion &amp;q2)</li>
</ul>
<p>Return the shortest angle between two quaternions</p>
<ul>
<li>void  assertQuaternionValid (const geometry_msgs::Quaternion &amp;q)</li>
</ul>
<p>Throw InvalidArgument if quaternion is malformed</p>
<ul>
<li>void  assertQuaternionValid (const tf::Quaternion &amp;q)</li>
</ul>
<p>Throw InvalidArgument if quaternion is malformed</p>
<ul>
<li>TFSIMD_FORCE_INLINE Quaternion  shortestArcQuat (const Vector3 &amp;v0, const Vector3 &amp;v1)</li>
</ul>
<p>TFSIMD_FORCE_INLINE Quaternion  shortestArcQuatNormalize2 (Vector3 &amp;v0, Vector3 &amp;v1)</p>
<ul>
<li>TFSIMD_FORCE_INLINE Quaternion  slerp (const Quaternion &amp;q1, const Quaternion &amp;q2, const tfScalar &amp;t)</li>
</ul>
<p>Return the result of spherical linear interpolation betwen two quaternions</p>
<ul>
<li><p>std::string   strip_leading_slash (const std::string &amp;frame_name)</p>
</li>
<li><p>TFSIMD_FORCE_INLINE tfScalar  tfAngle (const Vector3 &amp;v1, const Vector3 &amp;v2)</p>
</li>
</ul>
<p>Return the angle between two vectors</p>
<ul>
<li>TFSIMD_FORCE_INLINE Vector3   tfCross (const Vector3 &amp;v1, const Vector3 &amp;v2)</li>
</ul>
<p>Return the cross product of two vectors</p>
<ul>
<li>TFSIMD_FORCE_INLINE tfScalar  tfDistance (const Vector3 &amp;v1, const Vector3 &amp;v2)</li>
</ul>
<p>Return the distance between two vectors</p>
<ul>
<li>TFSIMD_FORCE_INLINE tfScalar  tfDistance2 (const Vector3 &amp;v1, const Vector3 &amp;v2)</li>
</ul>
<p>Return the distance squared between two vectors</p>
<ul>
<li>TFSIMD_FORCE_INLINE tfScalar  tfDot (const Vector3 &amp;v1, const Vector3 &amp;v2)</li>
</ul>
<p>Return the dot product between two vectors</p>
<h2 id="goalToGlobalFrame"><a href="#goalToGlobalFrame" class="headerlink" title="goalToGlobalFrame"></a>goalToGlobalFrame</h2><p><code>geometry_msgs::PoseStamped MoveBase::goalToGlobalFrame(const geometry_msgs::PoseStamped&amp; goal_pose_msg)</code><br>这个函数的核心功能是获得机器人坐标系和全局地图坐标系的关系：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf_.<span class="built_in">transformPose</span>(global_frame, goal_pose, global_pose);</span><br></pre></td></tr></table></figure></p>
<h2 id="计算机器人的内接圆和外切圆半径"><a href="#计算机器人的内接圆和外切圆半径" class="headerlink" title="计算机器人的内接圆和外切圆半径"></a>计算机器人的内接圆和外切圆半径</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;geometry_msgs::Point&gt; footprint = planner_costmap_ros_-&gt;<span class="built_in">getRobotFootprint</span>();</span><br><span class="line">costmap_2d::<span class="built_in">calculateMinAndMaxDistances</span>(footprint, robot_inscribed_radius_, robot_circumscribed_radius);</span><br><span class="line"><span class="comment">// 或者这样</span></span><br><span class="line">planner_costmap_ros_-&gt;<span class="built_in">getLayeredCostmap</span>()-&gt;<span class="built_in">getInscribedRadius</span>()</span><br><span class="line">planner_costmap_ros_-&gt;<span class="built_in">getLayeredCostmap</span>()-&gt;<span class="built_in">getCircumscribedRadius</span>()</span><br></pre></td></tr></table></figure>
<h2 id="通过footprint的代价值判断是否撞障碍"><a href="#通过footprint的代价值判断是否撞障碍" class="headerlink" title="通过footprint的代价值判断是否撞障碍"></a>通过footprint的代价值判断是否撞障碍</h2><p>与上一条结合，参考TEB代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="计算-直角三角形的斜边长"><a href="#计算-直角三角形的斜边长" class="headerlink" title="计算 直角三角形的斜边长"></a>计算 直角三角形的斜边长</h2><p><code>#include &lt;math.h&gt;</code></p>
<p><code>double hypot(double x, double y)</code>，输入是两个直角边，用法:  <code>hypot(p1.x - p2.x,  p1.y - p2.y)</code></p>
<h2 id="ros-shutdown"><a href="#ros-shutdown" class="headerlink" title="ros::shutdown()"></a>ros::shutdown()</h2><p>关闭节点并且从主节点登出，会终结所有的订阅、发布、服务，连<code>ROS_INFO</code>也不能再用。一般不用调用此函数，当所有的<strong>NodeHandle</strong>销毁时，就会自动关闭节点。默认的roscpp也会安装<code>SIGINT</code>句柄用来检测<code>Ctrl-C</code>，并自动为你关闭节点。</p>
<h2 id="ros-waitForShutdown"><a href="#ros-waitForShutdown" class="headerlink" title="ros::waitForShutdown ()"></a>ros::waitForShutdown ()</h2><p>等待节点关闭，无论时通过<code>Ctrl-C</code>还是<code>ros::shutdown()</code></p>
<h2 id="ros-isShuttingDown"><a href="#ros-isShuttingDown" class="headerlink" title="ros::isShuttingDown()"></a>ros::isShuttingDown()</h2><p>一旦<code>ros::shutdown()</code>调用（注意是刚开始调用，而不是调用完毕）就返回true。一般建议用ros::ok()，特殊情况可以用ros::isShuttingDown()</p>
<h2 id="ros-NodeHandle"><a href="#ros-NodeHandle" class="headerlink" title="ros::NodeHandle"></a>ros::NodeHandle</h2><p>获取节点的句柄，<code>ros::init</code>是初始化节点，这个是启动节点。<br>如果不想通过对象的生命周期来管理节点的开始和结束，可以通过<code>ros::start()</code>和<code>ros::shutdown()</code>来自己管理节点。</p>
<h2 id="ros-ok"><a href="#ros-ok" class="headerlink" title="ros::ok()"></a>ros::ok()</h2><p>判断是否退出节点，如果返回false，说明可能发生了以下事件</p>
<ul>
<li>调用了<code>ros::shutdown()</code></li>
<li>被另一同名节点踢出ROS网络</li>
<li>节点中的所有<code>ros::NodeHandles</code>都已经被销毁</li>
</ul>
<h3 id="ros-Time-now"><a href="#ros-Time-now" class="headerlink" title="ros::Time::now()"></a>ros::Time::now()</h3><p>获取当前时间: <code>ros::Time time = ros::Time::now()</code><br>使用模拟时间时，当 /clock节点接受到第一条消息时，<code>ros::Time::now()</code>返回时刻 0，此时客户端还不知道时钟时间。</p>
<h3 id="ros-Rate"><a href="#ros-Rate" class="headerlink" title="ros::Rate"></a>ros::Rate</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    rate.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rate类的构造函数参数是频率，不是时间。rate(10)对应时间间隔为<code>1/10</code>秒，也就是100毫秒。<code>Rate::sleep()</code>是进行睡眠，实际调用<code>Duration::sleep()</code>，间隔就是从构造函数开始计算，源码处理比较复杂。</p>
<h3 id="获得当前运行的所有节点名"><a href="#获得当前运行的所有节点名" class="headerlink" title="获得当前运行的所有节点名"></a>获得当前运行的所有节点名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::string&gt; ros::V_string</span><br><span class="line"><span class="comment">// Retreives the currently-known list of nodes from the master. 放入</span></span><br><span class="line"><span class="function">ROSCPP_DECL <span class="keyword">bool</span>   <span class="title">getNodes</span> <span class="params">(V_string &amp;nodes)</span></span></span><br></pre></td></tr></table></figure>
<p>用这个函数很简单：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; nodes;</span><br><span class="line">ros::master::<span class="built_in">getNodes</span>(nodes);	<span class="comment">// bool</span></span><br><span class="line"><span class="keyword">int</span> len = nodes.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;node: &quot;</span>&lt;&lt;nodes.<span class="built_in">at</span>(i)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="获得当前运行的所有话题名"><a href="#获得当前运行的所有话题名" class="headerlink" title="获得当前运行的所有话题名"></a>获得当前运行的所有话题名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ros</span>:</span>:master::TopicInfo</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">TopicInfo</span> ()</span><br><span class="line"> 	<span class="built_in">TopicInfo</span> (<span class="keyword">const</span> std::string &amp;_name, <span class="keyword">const</span> std::string &amp;_datatype)</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::string 	datatype    <span class="comment">// Datatype of the topic. </span></span><br><span class="line">	std::string 	name        <span class="comment">// Name of the topic. </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;TopicInfo&gt; ros::<span class="function">master::V_TopicInfo</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">ROSCPP_DECL <span class="keyword">bool</span>    <span class="title">getTopics</span> <span class="params">(V_TopicInfo &amp;topics)</span></span></span><br></pre></td></tr></table></figure>
<p>使用是类似的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;ros::master::TopicInfo&gt; topics;</span><br><span class="line">ros::master::<span class="built_in">getTopics</span>(topics);</span><br><span class="line"><span class="keyword">int</span> len = topics.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;topic: &quot;</span>&lt;&lt;topics.<span class="built_in">at</span>(i).name&lt;&lt;<span class="string">&quot;   type: &quot;</span></span><br><span class="line">		&lt;&lt;topics.<span class="built_in">at</span>(i).datatype&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="其他可能用到的函数"><a href="#其他可能用到的函数" class="headerlink" title="其他可能用到的函数"></a>其他可能用到的函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ros::<span class="built_in">isInitialized</span> ()    <span class="comment">// 判断ros::init()是否被调用</span></span><br><span class="line"></span><br><span class="line">ros::<span class="built_in">isStarted</span> ()	　<span class="comment">// 判断节点是否已经通过ros::start()启动</span></span><br><span class="line"></span><br><span class="line">ros::<span class="built_in">requestShutdown</span> ()　　<span class="comment">// 在节点的一个线程内要求ROS关闭</span></span><br><span class="line"></span><br><span class="line">ros::this_node::getName       <span class="comment">// 返回当前节点的名称</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">getAdvertisedTopics</span>()　　<span class="comment">//返回节点注册的话题</span></span><br><span class="line"><span class="built_in">getSubscribedTopics</span>()   <span class="comment">//返回节点订阅的主题</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">getNamespace</span>()	<span class="comment">//返回节点的命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_ASSERT</span>(a&lt;b)			<span class="comment">//同assert()，若条件不满足，程序会终止</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_BREAK</span>()				<span class="comment">//直接终止程序，报警FATAL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Get the hostname where the master runs. </span></span><br><span class="line"><span class="function">ROSCPP_DECL <span class="keyword">const</span> std::string &amp;     <span class="title">getHost</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Get the port where the master runs. </span></span></span><br><span class="line"><span class="function">ROSCPP_DECL <span class="keyword">uint32_t</span>    <span class="title">getPort</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Get the full URI to the master (eg. http://host:port/) </span></span></span><br><span class="line"><span class="function">ROSCPP_DECL <span class="keyword">const</span> std::string &amp;     <span class="title">getURI</span> <span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/03/G9F18s6UtHMrCpc.png" alt="ros_Time_now不能在NodeHandle之前.png"></p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wuguangbin1230/article/details/76889753">ros 初始化和关闭</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/56/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/56/">56</a><span class="page-number current">57</span><a class="page-number" href="/page/58/">58</a><span class="space">&hellip;</span><a class="page-number" href="/page/62/">62</a><a class="extend next" rel="next" href="/page/58/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2024/11/12/x1aqcwUG3XDiskN.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2025 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>