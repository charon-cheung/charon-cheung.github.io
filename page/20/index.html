<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">606</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">50</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/09/15/SLAM%E5%B7%A5%E5%85%B7/Eigen(%E4%BA%8C)%20%E6%97%8B%E8%BD%AC%EF%BC%8C%E7%89%B9%E5%BE%81%E5%80%BC%EF%BC%8C%E5%B9%B3%E7%A7%BB/">Eigen(二) 旋转，平移，特征值</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SLAM%E5%B7%A5%E5%85%B7/">SLAM工具</a></span><div class="content"><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>有旋转向量、四元数和旋转矩阵三种表示方法，在Eigen里用前两种进行定义，这样参数少，可以转化为第三种。</p>
<p>牢记下面这张图，根据《视觉SLAM十四讲》总结：<br><img src="https://i.loli.net/2020/03/03/itMb4fy9uzjs6Rl.png" alt="三种方式的转换"></p>
<p>使用的是模板类：<code>class Eigen::AngleAxis&lt; Scalar &gt;</code>，这被称为角轴表示法，顾名思义给定旋转角度和旋转轴即可。其创建方式符合Eigen的原则，传入数据类型作为模板参数。旋转角度以弧度表示，旋转轴为Vector类型的向量，注意向量必须要被归一化(<code>vec.normalized()</code>即可)。Eigen中也预先定义好了<code>AngleAxisd</code>和<code>AngleAxisf</code>两种方便使用。</p>
<p>参考:<a target="_blank" rel="noopener" href="https://blog.csdn.net/weicao1990/article/details/86148828">基于eigen实现欧拉角(RPY), 旋转矩阵, 旋转向量, 四元数之间的变换</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vector3f v1 = Vector3f::<span class="built_in">UnitX</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">AngleAxisf <span class="title">aa</span><span class="params">(<span class="number">45</span>*<span class="number">3.1415</span>/<span class="number">180</span>, v1)</span></span>;</span><br><span class="line"><span class="comment">// 返回弧度制表示的旋转角度 和 旋转轴(列向量)</span></span><br><span class="line">cout &lt;&lt; aa.<span class="built_in">angle</span>() &lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;endl&lt;&lt; aa.<span class="built_in">axis</span>() &lt;&lt;endl; </span><br><span class="line">cout &lt;&lt; aa.<span class="built_in">toRotationMatrix</span>()&lt;&lt;endl;   <span class="comment">// 转换为3 × 3的旋转矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fromRotationMatrix():从一个3×3的旋转矩阵构建AngleAxis对象。也就是提取旋转矩阵所表示的旋转角</span></span><br><span class="line"><span class="comment">//  inverse(): 返回以AngleAxis表示的当前旋转的逆旋转</span></span><br></pre></td></tr></table></figure>
<p>Quaternion是四元数表示法，Quaternion的构造是标准Eigen格式：数据类型作为模板参数+构造参数，而且重载了多个构造函数，因此可以方便地从角轴、旋转矩阵等数据类型进行构造。</p>
<p>Eigen提供了Quaternionf和Quaterniond方便使用。Quaterniond的初始化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Eigen::Quaterniond <span class="title">q1</span><span class="params">(x, y, z, w)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">Eigen::Quaterniond <span class="title">q2</span><span class="params">(Vector4d(x, y, z, w))</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">Eigen::Quaterniond <span class="title">q2</span><span class="params">(Matrix3d(R))</span></span>;</span><br></pre></td></tr></table></figure><br>在Quaternion内部的保存中，<strong>虚部在前，实部在后</strong>。 </p>
<p>如果以第一种方式构造四元数，则实部是x，虚部是<code>[y,z,w]</code>。   对于第二种方式，则实部是w，虚部是[x,y,z]； 对于第三种方式，则是用3x3的旋转矩阵初始化四元数。</p>
<p>所以最常用是 <font size="4" color="blue"> Eigen::Quaterniond q1(w, x, y, z);  </font> ，四个数的传入顺序是w、x、y、z，对应<code>w+xi+yj+zk</code>。</p>
<p><code>Eigen::Quaterniond</code><font size="4" color="blue">  不能使用cout </font></p>
<ul>
<li><p><code>Identity()</code>: 返回一个表示单位旋转的四元数</p>
</li>
<li><p>w(): 返回四元数中的w分量。 同理 x(), y(), z()是返回相应的分量。</p>
</li>
<li><p><strong>coeffs()</strong>: 返回四元数的四个数，可以对其进行索引[]获取值。<font size="4" color="blue"> 需要注意的是返回顺序是x、y、z、w，和构造函数的不同  </font></p>
</li>
<li><p>toRotationMatrix() 将当前Quaternion对象转换为3×3的旋转矩阵。另外，没有fromRotationMatrix()函数，只能用构造函数传入旋转矩阵</p>
</li>
<li><p>slerp():对两个四元数进行球面线性插值(Spherical linear interpolation，通常简称Slerp)，是四元数的一种线性插值运算，主要用于在两个表示旋转的四元数之间平滑差值。</p>
</li>
</ul>
<h3 id="欧拉角-——-旋转矩阵"><a href="#欧拉角-——-旋转矩阵" class="headerlink" title="欧拉角 —— 旋转矩阵"></a>欧拉角 —— 旋转矩阵</h3><p>可以让三个<code>AngleAxis</code>相乘：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数顺序和 static_transform_publisher 的一致</span></span><br><span class="line"><span class="function">Eigen::Vector3f <span class="title">angle</span><span class="params">(roll, pitch, yaw)</span></span>;</span><br><span class="line">Eigen::Matrix3d rotation;</span><br><span class="line">rotation = Eigen::<span class="built_in">AngleAxisd</span>(angle[<span class="number">0</span>], Eigen::Vector3d::<span class="built_in">UnitZ</span>()) *</span><br><span class="line">           Eigen::<span class="built_in">AngleAxisd</span>(angle[<span class="number">1</span>], Eigen::Vector3d::<span class="built_in">UnitY</span>()) *</span><br><span class="line">           Eigen::<span class="built_in">AngleAxisd</span>(angle[<span class="number">2</span>], Eigen::Vector3d::<span class="built_in">UnitX</span>()) ;</span><br></pre></td></tr></table></figure><br>这样计算的结果和每个AngleAxisf转换成旋转矩阵后再相乘得到的结果是相同的</p>
<font size="4" color="blue"> 旋转矩阵转欧拉角的结果可能不是想要的，最好不使用  </font>

<h3 id="四元数-——-旋转矩阵"><a href="#四元数-——-旋转矩阵" class="headerlink" title="四元数 —— 旋转矩阵"></a>四元数 —— 旋转矩阵</h3><p>其实这样更简单，我们可以直接从<code>tf2_ros::Buffer</code>和<code>geometry_msgs::TransformStamped</code>直接获得四元数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Eigen::Quaterniond <span class="title">quaternion</span><span class="params">(transform.transform.rotation.w,</span></span></span><br><span class="line"><span class="params"><span class="function">                              transform.transform.rotation.x,</span></span></span><br><span class="line"><span class="params"><span class="function">                              transform.transform.rotation.y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              transform.transform.rotation.z</span></span></span><br><span class="line"><span class="params"><span class="function">                              )</span></span>;</span><br><span class="line">Eigen::Matrix3d rotation = quaternion.<span class="built_in">matrix</span>();</span><br></pre></td></tr></table></figure></p>
<h2 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h2><p>采用Eigen标准构造原则，构造示例如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Translation&lt;<span class="keyword">float</span>,<span class="number">2</span>&gt;(tx, ty)</span><br><span class="line">Translation&lt;<span class="keyword">float</span>,<span class="number">3</span>&gt;(tx, ty, tz)</span><br><span class="line">Translation&lt;<span class="keyword">float</span>,N&gt;(s)</span><br><span class="line">Translation&lt;<span class="keyword">float</span>,N&gt;(vecN)</span><br></pre></td></tr></table></figure><br>多个平移合并用乘号而不是加号，需要注意。和旋转相比，它的成员函数也相对少一些:</p>
<ul>
<li><p>x():获取平移的x分量(可修改)</p>
</li>
<li><p>y():获取平移的y分量(可修改)</p>
</li>
<li><p>z():获取平移的z分量(可修改)，注意，千万不要对一个二维的Translation获取z分量，否则直接会运行报错</p>
</li>
<li><p>vector()&amp;.translation():返回当前平移的向量表示(可修改)，可以索引[]获取各分量</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Translation2d <span class="title">t1</span><span class="params">(<span class="number">1</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">Translation2d <span class="title">t2</span><span class="params">(<span class="number">2</span>,<span class="number">7</span>)</span></span>;</span><br><span class="line">Translation2d t3;</span><br><span class="line">t3=t1*t2;</span><br><span class="line">cout&lt;&lt;t3.<span class="built_in">translation</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h2 id="计算特征值与特征向量"><a href="#计算特征值与特征向量" class="headerlink" title="计算特征值与特征向量"></a>计算特征值与特征向量</h2><p>构造一个EigenSolver，然后分别调用其成员函数.eigenvalues()、.eigenvectors()即可获得特征值与特征向量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Eigenvalues&gt;</span></span></span><br><span class="line"></span><br><span class="line">A &lt;&lt; <span class="number">2</span>,<span class="number">-2</span>,<span class="number">0</span>, <span class="number">-2</span>,<span class="number">1</span>,<span class="number">-2</span>, <span class="number">0</span>,<span class="number">-2</span>,<span class="number">0</span>;</span><br><span class="line"><span class="function">EigenSolver&lt;Matrix3d&gt; <span class="title">eigensolver</span><span class="params">(A)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (eigensolver.<span class="built_in">info</span>() == Success)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; eigensolver.<span class="built_in">eigenvalues</span>() &lt;&lt; endl&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; eigensolver.<span class="built_in">eigenvectors</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果并不是我们平时熟悉的形式，而是<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(4,0)</span><br><span class="line">(1,0)</span><br><span class="line">(-2,0)</span><br><span class="line"></span><br><span class="line">(-0.666667,0) (-0.666667,0) (-0.333333,0)</span><br><span class="line">(0.666667,0) (-0.333333,0) (-0.666667,0)</span><br><span class="line">(-0.333333,0)  (0.666667,0) (-0.666667,0)</span><br></pre></td></tr></table></figure><br>实际特征值是4,1,-2.   4对应的特征向量分别为<code>(-0.666667, -0.666667,-0.333333)</code></p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wokaowokaowokao12345/article/details/47375427">C++ Eigen库计算矩阵特征值及特征向量</a><br><a target="_blank" rel="noopener" href="http://eigen.tuxfamily.org/dox/AsciiQuickReference.txt">Eigen函数与Matlab对应关系</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/09/14/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/%E5%BD%BB%E5%BA%95%E8%A7%A3%E5%86%B3%20sudo%20rosdep%20init%20%E5%92%8C%20rosdep%20update/">彻底解决 sudo rosdep init 和 rosdep update失败问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a></span><div class="content"><p>如果<code>sudo rosdep init</code> 和 <code>rosdep update</code>没有执行成功，有些ROS功能会无法执行，比如<code>rqt_tf_tree</code>会报错：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">the rosdep view is empty: call <span class="string">&#x27;sudo rosdep init&#x27;</span> and <span class="string">&#x27;rosdep update&#x27;</span></span><br><span class="line">[WARN] wait_for_service(/rqt_gui_py_node_26204/tf2_frames): failed to contact, will keep trying</span><br></pre></td></tr></table></figure></p>
<p>这两个老大难其实都是网络的问题，<code>sudo rosdep init</code>的目的是为了在/etc目录下新建<code>/ros/rosdep/sources.list.d/20-default.list</code>文件。</p>
<p><code>rosdep update</code>根据<code>20-default.list</code>文件中的网址链接去下载相应的文件，最终在<code>/etc/ros/rosdep</code>下放5个文件，分别是base.yaml,gentoo.yaml,osx-homebrew.yaml,python.yaml,ruby.yaml. 但又做了一些配置，所以不是下载文件能解决的。</p>
<p>以下步骤先从网上下载<code>rosdistro</code>文件夹，放到<code>/etc/ros</code><br><img src="https://i.loli.net/2021/09/25/cidWq7ZJo3H62kG.png" alt=""></p>
<h2 id="执行sudo-rosdep-init后报错"><a href="#执行sudo-rosdep-init后报错" class="headerlink" title="执行sudo rosdep init后报错"></a>执行<code>sudo rosdep init</code>后报错</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: cannot download default sources list from:</span><br><span class="line">https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/sources.list.d/20-default.list Website may be down</span><br></pre></td></tr></table></figure>
<p>从网上直接下载这个文件，然后放到<code>/etc/ros/rosdep/sources.list.d</code>，再修改如下:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># os-specific listings first</span></span><br><span class="line"></span><br><span class="line">yaml file:///etc/ros/rosdistro/rosdep/osx-homebrew.yaml osx</span><br><span class="line"></span><br><span class="line"><span class="comment"># generic</span></span><br><span class="line">yaml file:///etc/ros/rosdistro/rosdep/base.yaml</span><br><span class="line">yaml file:///etc/ros/rosdistro/rosdep/python.yaml</span><br><span class="line">yaml file:///etc/ros/rosdistro/rosdep/ruby.yaml</span><br><span class="line">gbpdistro file:///etc/ros/rosdistro/releases/fuerte.yaml fuerte</span><br><span class="line"></span><br><span class="line"><span class="comment"># newer distributions (Groovy, Hydro, ...) must not be listed anymore, they are being fetched from the rosdistro index.yaml instead</span></span><br></pre></td></tr></table></figure></p>
<h2 id="rosdep-update-报错"><a href="#rosdep-update-报错" class="headerlink" title="rosdep update 报错"></a>rosdep update 报错</h2><p><font size="4" color="blue"> kinetic 要修改python2.7的路径, melodic和noetic要修改python3  </font>，当然另一种方法是从其他电脑拷贝已经生成的文件。</p>
<p>kinetic 的修改<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reading <span class="keyword">in</span> sources list data from /etc/ros/rosdep/sources.list.d</span><br><span class="line">ERROR: unable to process <span class="built_in">source</span></span><br></pre></td></tr></table></figure><br>对下面三个文件做修改<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/python2.7/dist-packages/rosdep2/gbpdistro_support.py</span><br><span class="line">修改: FUERTE_GBPDISTRO_URL = <span class="string">&#x27;file:///etc/ros/rosdistro/releases/fuerte.yaml&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/usr/lib/python2.7/dist-packages/rosdep2/rep3.py</span><br><span class="line">修改: REP3_TARGETS_URL = <span class="string">&#x27;file:///etc/ros/rosdistro/releases/targets.yaml&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/usr/lib/python2.7/dist-packages/rosdistro/__init__.py</span><br><span class="line">修改: DEFAULT_INDEX_URL = <span class="string">&#x27;file:///etc/ros/rosdistro/index-v4.yaml&#x27;</span></span><br></pre></td></tr></table></figure><br>启动新终端，再次执行<code>rosdep update</code></p>
<p>melodic和noetic 的修改：clone代码仓<code>https://github.com/ros/rosdistro</code>到本地，并更改其文件<code>rosdep/sources.list.d/20-default.list</code>，将其url改成本地文件路径，内容类似如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># os-specific listings first</span></span><br><span class="line">yaml file:<span class="comment">///home/baby/rosdistro/rosdep/osx-homebrew.yaml osx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># generic</span></span><br><span class="line">yaml file:<span class="comment">///home/baby/rosdistro/rosdep/base.yaml</span></span><br><span class="line">yaml file:<span class="comment">///home/baby/rosdistro/rosdep/python.yaml</span></span><br><span class="line">yaml file:<span class="comment">///home/baby/rosdistro/rosdep/ruby.yaml</span></span><br><span class="line">gbpdistro file:<span class="comment">///home/baby/rosdistro/releases/fuerte.yaml fuerte</span></span><br></pre></td></tr></table></figure><br>由于rosdep使用python3，可直接该动源码。我们需要改动三个文件：</p>
<ul>
<li><p><code>/usr/lib/python3/dist-packages/rosdep2/sources_list.py</code>，修改  <code>DEFAULT_SOURCES_LIST_URL = &#39;file:///home/baby/rosdistro/rosdep/sources.list.d/20-default.list&#39;</code></p>
</li>
<li><p><code>/usr/lib/python3/dist-packages/rosdep2/rep3.py</code>，修改  <code>REP3_TARGETS_URL = &#39;file:///home/baby/rosdistro/releases/targets.yaml&#39;</code></p>
</li>
<li><p><code>/usr/lib/python3/dist-packages/rosdep2/gbpdistro_support.py</code>，修改  <code>FUERTE_GBPDISTRO_URL = &#39;file:///home/baby/rosdistro/releases/fuerte.yaml&#39;</code></p>
</li>
<li><p><code>/usr/lib/python3/dist-packages/rosdistro/__init__.py</code>，修改  <code>DEFAULT_INDEX_URL = &#39;file:///home/baby/rosdistro/index-v4.yaml&#39;</code></p>
</li>
</ul>
<p>完成后先把<code>/etc/ros/rosdep/sources.list.d/20-default.list</code>删除，再执行<code>sudo rosdep init</code>与<code>rosdep update</code>就可以成功了。</p>
<p>参考:<br><a target="_blank" rel="noopener" href="https://www.cxyzjd.com/article/qq_30267617/115028689#fromHistory">解决 rosdep update</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/09/14/SLAM%E5%B7%A5%E5%85%B7/gtsam/">gtsam</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/SLAM%E5%B7%A5%E5%85%B7/">SLAM工具</a></span><div class="content"><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载gtsam源码:  <code>git clone https://bitbucket.org/gtborg/gtsam.git</code></p>
<p>依赖:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Boost &gt;= 1.43 (Ubuntu: sudo apt-get install libboost-all-dev)</span><br><span class="line">CMake &gt;= 3.0 (Ubuntu: sudo apt-get install cmake)</span><br></pre></td></tr></table></figure></p>
<p>安装可选的依赖:</p>
<ul>
<li>Intel Threaded Building Blocks (TBB)</li>
</ul>
<p><code>sudo apt-get install libtbb-dev</code></p>
<ul>
<li>Intel Math Kernel Library (MKL)</li>
</ul>
<p><code>https://software.intel.com/content/www/us/en/develop/articles/installing-intel-free-libs-and-python-apt-repo.html</code></p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/30/%E6%BF%80%E5%85%89SLAM/%E9%9B%B7%E8%BE%BE/%E7%A6%BE%E8%B5%9B16%E7%BA%BF%E9%9B%B7%E8%BE%BE/">禾赛16线雷达</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/%E9%9B%B7%E8%BE%BE/">雷达</a></span><div class="content"><p>多线激光雷达，就是通过多个激光发射器在垂直方向上的分布，通过电机的旋转形成多条线束的扫描。</p>
<p>理论上讲，当然是线束越多、越密，对环境描述就更加充分，这样<strong>还可以降低算法的要求。</strong></p>
<ul>
<li><p>扫描频率：转速。10Hz的含义是一秒雷达转10圈</p>
</li>
<li><p>帧率：一秒内激光雷达电机旋转的圈数，每秒完成一圈扫描的次数。一幅点云图像代表一帧，对应激光雷达内部就是电机旋转一圈完成扫描</p>
</li>
<li><p>输出点云中相邻两个点之间的夹角就是角分辨率。 水平方向上做到高分辨率不难，垂直分辨率和发射器的几何大小相关也与其排布相关。相邻两个发射器间隔越小垂直分辨率越小，禾赛的是2°</p>
</li>
<li><p>输出数据： 距离、角度、反射率、时间戳</p>
</li>
</ul>
<p>禾赛雷达的参数，波长905nm。 最常用的波长是905nm和1550 nm。1550nm波长LiDAR传感器可以以更高的功率运行，以提高探测范围，同时对于雨雾的穿透力更强。<br><img src="https://s2.loli.net/2021/12/21/JdtPwNLEHmgjb9s.png" alt=""><br><img src="https://s2.loli.net/2021/12/21/Alnwcf7QeBO6iTN.png" alt=""><br>注意这是禾赛雷达，其他雷达的线束索引和角度的关系不一定是这样了，比如速腾的线束1对应-15°，线束2对应-13°，以此类推。</p>
<p><img src="https://s2.loli.net/2021/12/21/ohYEdp6tHj4XRcL.png" alt=""></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">header:</span><br><span class="line">  seq: 42200   <span class="comment"># 第几帧数据</span></span><br><span class="line">  stamp:</span><br><span class="line">    secs: 1640071161</span><br><span class="line">    nsecs: 165116000</span><br><span class="line">  frame_id: <span class="string">&quot;base_link&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若为有序点云，height 可以大于 1，即多行点云，每行固定点云的宽度</span></span><br><span class="line"><span class="comment"># 若为无序点云，height 等于1，即一行点云，此时 width 即点云的数量</span></span><br><span class="line">height: 1</span><br><span class="line">width: 60676   <span class="comment"># 一行点云的长度</span></span><br><span class="line">fields:</span><br><span class="line">  -</span><br><span class="line">    name: <span class="string">&quot;x&quot;</span></span><br><span class="line">    offset: 0</span><br><span class="line">    datatype: 7  <span class="comment"># 对应 Float32</span></span><br><span class="line">    count: 1</span><br><span class="line">  -</span><br><span class="line">    name: <span class="string">&quot;y&quot;</span></span><br><span class="line">    offset: 4</span><br><span class="line">    datatype: 7</span><br><span class="line">    count: 1</span><br><span class="line">  -</span><br><span class="line">    name: <span class="string">&quot;z&quot;</span></span><br><span class="line">    offset: 8</span><br><span class="line">    datatype: 7</span><br><span class="line">    count: 1</span><br><span class="line">  -</span><br><span class="line">    name: <span class="string">&quot;intensity&quot;</span></span><br><span class="line">    offset: 16</span><br><span class="line">    datatype: 7</span><br><span class="line">    count: 1</span><br><span class="line">  -</span><br><span class="line">    name: <span class="string">&quot;timestamp&quot;</span></span><br><span class="line">    offset: 24</span><br><span class="line">    datatype: 8</span><br><span class="line">    count: 1</span><br><span class="line">  -</span><br><span class="line">    name: <span class="string">&quot;ring&quot;</span></span><br><span class="line">    offset: 32</span><br><span class="line">    datatype: 4</span><br><span class="line">    count: 1</span><br><span class="line">is_bigendian: False</span><br><span class="line"><span class="comment"># 一个点占的字节数</span></span><br><span class="line">point_step: 48   </span><br><span class="line"><span class="comment"># 一行的长度占用的字节数，也就是 point_step * width</span></span><br><span class="line">row_step: 2912448</span><br><span class="line">data: []  <span class="comment"># 省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若点云中的数据都是有限的(不包含 inf/NaN), 则为 true, 否则为 false</span></span><br><span class="line">is_dense: True</span><br></pre></td></tr></table></figure>
<p>目前把雷达坐标系设置为<code>base_link</code>了。</p>
<p>对有序点云进行操作（降采样、刚体变换）后，有序点云就会变成无序点云。velodyne雷达选择给每个点多加了一个属性<code>ring</code>, 详细定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> velodyne_pointcloud</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">PointXYZIR</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  PCL_ADD_POINT4D;                    <span class="comment">// quad-word XYZ</span></span><br><span class="line">  <span class="keyword">float</span>    intensity;                 </span><br><span class="line">  <span class="keyword">uint16_t</span> ring;                      </span><br><span class="line">  EIGEN_MAKE_ALIGNED_OPERATOR_NEW     <span class="comment">// ensure proper alignment</span></span><br><span class="line">  &#125; EIGEN_ALIGN16;</span><br><span class="line">&#125;; <span class="comment">// namespace velodyne_pointcloud</span></span><br></pre></td></tr></table></figure><br>这个<code>ring</code>表示每个点之前属于哪个线的，16线的话，这个值为0~15。并且高度自低向高排列。</p>
<p><br></p>
<p>通过官方的 PandarView 软件可以用于录制和播放点云数据，点击Record（工具栏上的红色圆点）即可。这样录制的包的格式是pcap。如果是velodyne雷达，可以在ROS中运行以下指令即可播放这个包<br><code>rosrun velodyne_driver  velodyne_node  _model:=VLP16   _pcap:=/home/q/VLP16Data.pcap</code></p>
<h2 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h2><p>型号<code>PandarXT-16</code><br><a target="_blank" rel="noopener" href="https://github.com/HesaiTechnology/HesaiLidar_General_ROS">禾赛雷达的驱动</a></p>
<p>节点<code>/hesai/hesai_lidar</code>无订阅，发布两个话题:</p>
<ul>
<li>/hesai/pandar [sensor_msgs/PointCloud2]   被节点<code>data_pretreat_node</code>订阅</li>
<li>/hesai/pandar_packets [hesai_lidar/PandarScan]，无内容</li>
</ul>
<p><img src="https://s2.loli.net/2021/12/08/ihOLuyUYlV6mNvF.png" alt="禾赛雷达数据占用的带宽.png"></p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weijimin1/article/details/93512218">各品牌雷达的参数</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wujianming-110117/p/13074172.html">Velodyne VLP-16激光雷达数据分析</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34672671/article/details/117411590">Velodyne16 与禾赛Pandar XT16测试</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/25/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/cartographer%E7%9A%84%E7%BC%BA%E7%82%B9/">cartographer的缺点</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2021/08/25/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/cartographer%E7%9A%84%E7%BC%BA%E7%82%B9/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/24/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E6%9C%80%E5%90%8E%E9%98%B6%E6%AE%B5%20RunFinalOptimization/">最后阶段 RunFinalOptimization</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>现在返回到最初的<code>node_main.cc</code>中的<code>Run</code>函数，还有一句<code>node.RunFinalOptimization();</code>，所有轨迹结束时，再执行一次全局优化。  其实就是<code>MapBuilderBridge::RunFinalOptimization</code> —— <code>PoseGraph2D::RunFinalOptimization</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::RunFinalOptimization</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">  	<span class="comment">// 参数 max_num_final_iterations 默认 200</span></span><br><span class="line">    <span class="comment">// 优化标志</span></span><br><span class="line">    <span class="built_in">AddWorkItem</span>([<span class="keyword">this</span>]() <span class="built_in">LOCKS_EXCLUDED</span>(mutex_) &#123;</span><br><span class="line">      absl::MutexLock <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">      optimization_problem_-&gt;<span class="built_in">SetMaxNumIterations</span>(</span><br><span class="line">          options_.<span class="built_in">max_num_final_iterations</span>());</span><br><span class="line">      <span class="keyword">return</span> WorkItem::Result::kRunOptimization;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 参数 max_num_iterations， 默认 50</span></span><br><span class="line">    <span class="comment">// 不优化标志</span></span><br><span class="line">    <span class="built_in">AddWorkItem</span>([<span class="keyword">this</span>]() <span class="built_in">LOCKS_EXCLUDED</span>(mutex_) &#123;</span><br><span class="line">      absl::MutexLock <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">      optimization_problem_-&gt;<span class="built_in">SetMaxNumIterations</span>(</span><br><span class="line">          options_.<span class="built_in">optimization_problem_options</span>()</span><br><span class="line">              .<span class="built_in">ceres_solver_options</span>()</span><br><span class="line">              .<span class="built_in">max_num_iterations</span>());</span><br><span class="line">      <span class="keyword">return</span> WorkItem::Result::kDoNotRunOptimization;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 另一个调用地方在 PoseGraph2D 析构</span></span><br><span class="line">  <span class="built_in">WaitForAllComputations</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在建图结束之后会运行一个新的全局优化，不要求实时性，迭代次数多<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::WaitForAllComputations</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num_trajectory_nodes;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    num_trajectory_nodes = data_.num_trajectory_nodes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> num_finished_nodes_at_start =</span><br><span class="line">      constraint_builder_.<span class="built_in">GetNumFinishedNodes</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> report_progress = [<span class="keyword">this</span>, num_trajectory_nodes,</span><br><span class="line">                          num_finished_nodes_at_start]() &#123;</span><br><span class="line">    <span class="comment">// Log progress on nodes only when we are actually processing nodes.</span></span><br><span class="line">    <span class="keyword">if</span> (num_trajectory_nodes != num_finished_nodes_at_start) &#123;</span><br><span class="line">      std::ostringstream progress_info;</span><br><span class="line">      progress_info &lt;&lt; <span class="string">&quot;Optimizing: &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">1</span>)</span><br><span class="line">                    &lt;&lt; <span class="number">100.</span> *</span><br><span class="line">                           (constraint_builder_.<span class="built_in">GetNumFinishedNodes</span>() -</span><br><span class="line">                            num_finished_nodes_at_start) /</span><br><span class="line">                           (num_trajectory_nodes - num_finished_nodes_at_start)</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;%...&quot;</span>;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;\r\x1b[K&quot;</span> &lt;&lt; progress_info.<span class="built_in">str</span>() &lt;&lt; std::flush;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><code>num_finished_nodes_at_start</code>表示此时已经优化的节点数，假设为 10</p>
</li>
<li><p><code>GetNumFinishedNodes</code>返回当前已经优化的节点数，假设为 11，也就是这个函数开始后，优化了1个节点</p>
</li>
<li><p><code>num_trajectory_nodes</code>，轨迹的总节点数</p>
</li>
</ul>
<p><code>progress_info</code> 输出的是  <script type="math/tex">\frac{11 -10} {100 - 10} \times 100</script></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// First wait for the work queue to drain so that it&#x27;s safe to schedule</span></span><br><span class="line">  <span class="comment">// a WhenDone() callback.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> predicate = [<span class="keyword">this</span>]()</span><br><span class="line">                               <span class="built_in">EXCLUSIVE_LOCKS_REQUIRED</span>(work_queue_mutex_) &#123;</span><br><span class="line">                                 <span class="keyword">return</span> work_queue_ == <span class="literal">nullptr</span>;</span><br><span class="line">                               &#125;;</span><br><span class="line">    <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;work_queue_mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!work_queue_mutex_.<span class="built_in">AwaitWithTimeout</span>(</span><br><span class="line">        absl::<span class="built_in">Condition</span>(&amp;predicate),</span><br><span class="line">        absl::<span class="built_in">FromChrono</span>(common::<span class="built_in">FromSeconds</span>(<span class="number">1.</span>)))) &#123;</span><br><span class="line">      <span class="built_in">report_progress</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now wait for any pending constraint computations to finish.</span></span><br><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">bool</span> notification = <span class="literal">false</span>;</span><br><span class="line">  constraint_builder_.<span class="built_in">WhenDone</span>(</span><br><span class="line">      [<span class="keyword">this</span>,</span><br><span class="line">       &amp;notification](<span class="keyword">const</span> constraints::ConstraintBuilder2D::Result&amp; result)</span><br><span class="line">          <span class="built_in">LOCKS_EXCLUDED</span>(mutex_) &#123;</span><br><span class="line">            absl::MutexLock <span class="built_in">locker</span>(&amp;mutex_);</span><br><span class="line">            data_.constraints.<span class="built_in">insert</span>(data_.constraints.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>(),</span><br><span class="line">                                     result.<span class="built_in">end</span>());</span><br><span class="line">            notification = <span class="literal">true</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> predicate = [&amp;notification]() <span class="built_in">EXCLUSIVE_LOCKS_REQUIRED</span>(mutex_) &#123;</span><br><span class="line">    <span class="keyword">return</span> notification;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">while</span> (!mutex_.<span class="built_in">AwaitWithTimeout</span>(absl::<span class="built_in">Condition</span>(&amp;predicate),</span><br><span class="line">                                  absl::<span class="built_in">FromChrono</span>(common::<span class="built_in">FromSeconds</span>(<span class="number">1.</span>)))) &#123;</span><br><span class="line">    <span class="built_in">report_progress</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CHECK_EQ</span>(constraint_builder_.<span class="built_in">GetNumFinishedNodes</span>(), num_trajectory_nodes);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;\r\x1b[KOptimizing: Done.     &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是把ceres的迭代次数设置为200，其他部分其实不用太深入研究了。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/24/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8E%E7%AB%AF%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%203%20HandleWorkQueue%E5%92%8C%E4%BC%98%E5%8C%96/">后端的线程池 3 HandleWorkQueue和优化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>优化的具体实现在优化器<code>optimization_problem_</code>。将优化的结果采用回调的方式，返回到result中。<br>后端将数据加入到 <code>optimization_problem_</code> 的对应传感器队列中，并按时间排列。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::HandleWorkQueue</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> constraints::ConstraintBuilder2D::Result&amp;  result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  &#123;   <span class="comment">// 将新的约束添加到全局约束队列中</span></span><br><span class="line">    <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    data_.constraints.<span class="built_in">insert</span>(data_.constraints.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>(),</span><br><span class="line">                             result.<span class="built_in">end</span>() );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ceres 在这里</span></span><br><span class="line">  <span class="built_in">RunOptimization</span>();</span><br><span class="line">   			<span class="comment">// 以下是 省略 的内容</span></span><br><span class="line">  <span class="comment">//如果设置了全局优化回调函数，则进行调用</span></span><br><span class="line">  <span class="comment">//根据约束结果，更新轨迹间的链接关系</span></span><br><span class="line">  <span class="comment">// 优化完成后，累计节点清零</span></span><br><span class="line">  <span class="comment">// 计算相同轨迹的 inter_constraints_same_trajectory  </span></span><br><span class="line">  <span class="comment">// 计算不同轨迹的 inter_constraints_different_trajectory</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 优化结束后，重新开启任务队列，即继续执行</span></span><br><span class="line">  <span class="comment">// work_queue_里的 work_item</span></span><br><span class="line">  <span class="built_in">DrainWorkQueue</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="RunOptimization"><a href="#RunOptimization" class="headerlink" title="RunOptimization"></a>RunOptimization</h2><p>优化的实际就是成员变量<code>node_data_</code> 和 <code>submap_data_</code>，也就是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeSpec2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  common::Time time;</span><br><span class="line">  transform::Rigid2d  local_pose_2d;</span><br><span class="line">  transform::Rigid2d  global_pose_2d;</span><br><span class="line">  Eigen::Quaterniond  gravity_alignment;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubmapSpec2D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  transform::Rigid2d  global_pose;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PoseGraph2D::RunOptimization</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (optimization_problem_-&gt;<span class="built_in">submap_data</span>().<span class="built_in">empty</span>() )</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// std::unique_ptr&lt;optimization::OptimizationProblem2D&gt; optimization_problem_;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// No other thread is accessing the optimization_problem_,</span></span><br><span class="line">  <span class="comment">// data_.constraints, data_.frozen_trajectories and data_.landmark_nodes</span></span><br><span class="line">  <span class="comment">// when executing Solve. </span></span><br><span class="line">  <span class="comment">// 调用优化，Ceres在这里面，由于耗时间，故没加锁，防止阻塞其他线程</span></span><br><span class="line">  optimization_problem_-&gt;<span class="built_in">Solve</span>(data_.constraints, </span><br><span class="line">    <span class="built_in">GetTrajectoryStates</span>(),  data_.landmark_nodes);</span><br></pre></td></tr></table></figure>
<p>将所有内部约束和外部约束合并在一起执行<code>Solve</code><br>遍历所有submap，建立参数块；遍历所有node，建立参数块。<br>根据约束，添加残差函数；<br>处理里程计问题，添加可能的残差；<br>求解返回结果;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">   <span class="comment">// 优化后所有的submap和node数据</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; submap_data = optimization_problem_-&gt;<span class="built_in">submap_data</span>();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; node_data = optimization_problem_-&gt;<span class="built_in">node_data</span>();</span><br><span class="line">  <span class="comment">/*  遍历所有优化后的轨迹的所有节点位姿  */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> trajectory_id : node_data.<span class="built_in">trajectory_ids</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; node : node_data.<span class="built_in">trajectory</span>(trajectory_id) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span>&amp; mutable_trajectory_node = data_.trajectory_nodes.<span class="built_in">at</span>(node.id);</span><br><span class="line">      <span class="comment">// 更新所有节点的 全局位姿</span></span><br><span class="line">      mutable_trajectory_node.global_pose =</span><br><span class="line">          transform::<span class="built_in">Embed3D</span>(node.data.global_pose_2d) *</span><br><span class="line">          transform::Rigid3d::<span class="built_in">Rotation</span>(</span><br><span class="line">              mutable_trajectory_node.constant_data-&gt;gravity_alignment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extrapolate all point cloud poses that were not included in the</span></span><br><span class="line">    <span class="comment">// &#x27;optimization_problem_&#x27; yet. 注意是已经加入tarjectory但是还没有进行优化的新Node</span></span><br><span class="line">    <span class="comment">// 由于使用采样器建立约束，有的node没有建立约束，其pose就不会被优化</span></span><br><span class="line">    <span class="comment">// 因此，要通过已经优化的位姿转换关系来修正所有的node</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子图的local到global的新的转移矩阵</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> local_to_new_global =</span><br><span class="line">        <span class="built_in">ComputeLocalToGlobalTransform</span>(submap_data, trajectory_id);</span><br><span class="line">        <span class="comment">// 旧的转移矩阵</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> local_to_old_global = <span class="built_in">ComputeLocalToGlobalTransform</span>(</span><br><span class="line">        data_.global_submap_poses_2d, trajectory_id);</span><br><span class="line">    <span class="keyword">const</span> transform::Rigid3d old_global_to_new_global =</span><br><span class="line">        local_to_new_global * local_to_old_global.<span class="built_in">inverse</span>();</span><br><span class="line">      <span class="comment">// 上次最后一个优化的节点</span></span><br><span class="line">    <span class="keyword">const</span> NodeId last_optimized_node_id =</span><br><span class="line">        std::<span class="built_in">prev</span>(node_data.<span class="built_in">EndOfTrajectory</span>(trajectory_id))-&gt;id;</span><br><span class="line">    <span class="keyword">auto</span> node_it =</span><br><span class="line">        std::<span class="built_in">next</span>(data_.trajectory_nodes.<span class="built_in">find</span>(last_optimized_node_id));</span><br><span class="line">     <span class="comment">// 后续未优化的节点的全局pose进行转移</span></span><br><span class="line">    <span class="keyword">for</span> (; node_it != data_.trajectory_nodes.<span class="built_in">EndOfTrajectory</span>(trajectory_id);</span><br><span class="line">         ++node_it)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// TrajectoryNode类型， 指针</span></span><br><span class="line">      <span class="keyword">auto</span>&amp; mutable_trajectory_node = data_.trajectory_nodes.<span class="built_in">at</span>(node_it-&gt;id);</span><br><span class="line">      修正 global_pose</span><br><span class="line">      mutable_trajectory_node.global_pose =</span><br><span class="line">          old_global_to_new_global * mutable_trajectory_node.global_pose;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新所有路标位姿</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; landmark : optimization_problem_-&gt;<span class="built_in">landmark_data</span>()) &#123;</span><br><span class="line">    data_.landmark_nodes[landmark.first].global_landmark_pose = landmark.second;</span><br><span class="line">  &#125;</span><br><span class="line">  data_.global_submap_poses_2d = submap_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化并非是实时，是在后台进行运行的，并且需要一定的时间。因此当完成优化时，前端输出结果已经对整个位姿图个数进行了增加。后面新加入的节点并未优化，所以返回优化的结果没有最新加入轨迹节点对应的结果。因此采用优化后结果中最后一个轨迹节点的位姿的转移矩阵，作为未参与优化轨迹节点的转移矩阵进行更新。</p>
<p>其中 <script type="math/tex">X</script> 为参与优化的节点，优化前位姿为 <script type="math/tex">X_{old}</script>，优化后的位姿为 <script type="math/tex">X_{new}</script>。而 <script type="math/tex">Y</script> 则为未参与优化的节点。</p>
<script type="math/tex; mode=display">T = X_{old}^{-1} * X_{new}</script><script type="math/tex; mode=display">Y_{new} = T * Y_{old}</script></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/21/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/%E5%90%8E%E7%AB%AF%205%20%E8%AE%A1%E7%AE%97%E7%BA%A6%E6%9D%9F/">后端 5 计算约束</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></span><div class="content"><p>我的理解是，求inter约束也是一个 scan to map 的过程，找到和点云最相似的不同时间的子图，也就是找回环。其实是和<code>lidar_localization</code>的后端用NDT找关键帧的匹配是类似的，但是cartographer是点云和栅格地图匹配，不像点云匹配那样直观，分支定界的score就像NDT匹配的score，不过前者越大越好，后者越小越好。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConstraintBuilder2D::ComputeConstraint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> SubmapId&amp; submap_id,  <span class="keyword">const</span> Submap2D* <span class="keyword">const</span> submap,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> NodeId&amp; node_id,  <span class="keyword">bool</span> match_full_submap,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> TrajectoryNode::Data* <span class="keyword">const</span>  constant_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> transform::Rigid2d&amp;  initial_relative_pose,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> SubmapScanMatcher&amp;   submap_scan_matcher,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unique_ptr&lt;ConstraintBuilder2D::Constraint&gt;* constraint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(submap_scan_matcher.fast_correlative_scan_matcher);</span><br><span class="line">  <span class="comment">/*  node在local坐标系的位姿 = 子图在local坐标系中的位姿 * node在子图的位姿*/</span></span><br><span class="line">  <span class="keyword">const</span> transform::Rigid2d  initial_pose =</span><br><span class="line">      <span class="built_in">ComputeSubmapPose</span>(*submap) * initial_relative_pose;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">float</span> score = <span class="number">0.</span>;</span><br><span class="line">  transform::Rigid2d pose_estimate = transform::Rigid2d::<span class="built_in">Identity</span>();</span><br></pre></td></tr></table></figure>
<p>整个函数是为了计算<code>constraint_transform</code>(节点 j 和子图 i的关系) ，需要的参数有：</p>
<ul>
<li>节点 j 的<code>filtered_gravity_aligned_point_cloud</code></li>
<li>分支定界的初值 <code>initial_pose</code> (节点 j 在local map坐标系的坐标)</li>
<li><code>Match()</code> 的结果 <code>pose_estimate</code> (节点 j 在local map坐标系的坐标).</li>
<li><code>ComputeSubmapPose()</code>函数 (local map坐标系转到子图 i 坐标系)</li>
</ul>
<p>计算<code>pose_estimate</code>的三步:</p>
<ol>
<li>使用 fast correlative scan matcher 做 Fast estimate</li>
<li>Prune if the score is too low.</li>
<li>ceres Refine</li>
</ol>
<h2 id="匹配所有子图-或-局部子图"><a href="#匹配所有子图-或-局部子图" class="headerlink" title="匹配所有子图 或 局部子图"></a>匹配所有子图 或 局部子图</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配所有子图，对应 MaybeAddGlobalConstraint</span></span><br><span class="line"><span class="keyword">if</span> (match_full_submap)</span><br><span class="line">&#123;</span><br><span class="line">  kGlobalConstraintsSearchedMetric-&gt;<span class="built_in">Increment</span>();</span><br><span class="line">  <span class="keyword">if</span>( submap_scan_matcher.fast_correlative_scan_matcher-&gt;<span class="built_in">MatchFullSubmap</span>(</span><br><span class="line">          constant_data-&gt;filtered_gravity_aligned_point_cloud,</span><br><span class="line">          <span class="comment">// 参数为 global_localization_min_score</span></span><br><span class="line">          options_.<span class="built_in">global_localization_min_score</span>(), </span><br><span class="line">          &amp;score,  &amp;pose_estimate)  )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">CHECK_GT</span>(score, options_.<span class="built_in">global_localization_min_score</span>());</span><br><span class="line">    <span class="built_in">CHECK_GE</span>(node_id.trajectory_id, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">CHECK_GE</span>(submap_id.trajectory_id, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 最后记录下全局约束的次数和统计置信度</span></span><br><span class="line">    kGlobalConstraintsFoundMetric-&gt;<span class="built_in">Increment</span>();</span><br><span class="line">    kGlobalConstraintScoresMetric-&gt;<span class="built_in">Observe</span>(score);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匹配局部子图</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  kConstraintsSearchedMetric-&gt;<span class="built_in">Increment</span>();</span><br><span class="line">  <span class="keyword">if</span> (submap_scan_matcher.fast_correlative_scan_matcher-&gt;<span class="built_in">Match</span>(</span><br><span class="line">          initial_pose, constant_data-&gt;filtered_gravity_aligned_point_cloud,</span><br><span class="line">          <span class="comment">// 参数为 min_score</span></span><br><span class="line">          options_.<span class="built_in">min_score</span>(), </span><br><span class="line">          &amp;score, &amp;pose_estimate)  )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">CHECK_GT</span>(score, options_.<span class="built_in">min_score</span>());</span><br><span class="line">    kConstraintsFoundMetric-&gt;<span class="built_in">Increment</span>();</span><br><span class="line">    kConstraintScoresMetric-&gt;<span class="built_in">Observe</span>(score);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">absl::MutexLock <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  score_histogram_.<span class="built_in">Add</span>(score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分枝定界求出的位姿被称为 <strong>初始位姿 3</strong>，这个初始位姿3及其携带的点云作为输入，用于ceres与此子图进行优化匹配</p>
<p>在建立全局约束的时候，直接在一个超大的范围内进行分枝定界搜索，并不需要计算一个特殊的初始位姿2，而直接把初始位姿设置为地图limits的中心点，可以理解为map的中心点。 而且打分的参数也不同了。</p>
<p>全局约束的搜索窗口范围： <code>[1e6 * limits_.resolution(), M_PI]</code>，角度其实是±180°</p>
<h2 id="ceres-refine"><a href="#ceres-refine" class="headerlink" title="ceres refine"></a>ceres refine</h2><p>ceres优化匹配，得到更加准确的优化位置<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use the CSM estimate as both the initial and previous pose. </span></span><br><span class="line"><span class="comment">// This has the effect that, in the absence of better information, </span></span><br><span class="line"><span class="comment">// we prefer the original  CSM estimate.</span></span><br><span class="line">ceres::Solver::Summary  unused_summary;</span><br><span class="line"><span class="comment">// ceres更新pose_estimate，获得节点在local map中的最优位姿</span></span><br><span class="line">ceres_scan_matcher_.<span class="built_in">Match</span>(pose_estimate.<span class="built_in">translation</span>(), pose_estimate,</span><br><span class="line">                 constant_data-&gt;filtered_gravity_aligned_point_cloud,</span><br><span class="line">                *submap_scan_matcher.grid,  &amp;pose_estimate,</span><br><span class="line">                &amp;unused_summary);</span><br><span class="line"><span class="comment">// 计算得到node相对子图的位姿</span></span><br><span class="line"><span class="keyword">const</span> transform::Rigid2d constraint_transform = </span><br><span class="line">    <span class="built_in">ComputeSubmapPose</span>(*submap).<span class="built_in">inverse</span>() * pose_estimate;</span><br><span class="line">constraint-&gt;<span class="built_in">reset</span>(<span class="keyword">new</span> Constraint&#123;submap_id,</span><br><span class="line">       node_id,</span><br><span class="line">       &#123; transform::<span class="built_in">Embed3D</span>(constraint_transform),</span><br><span class="line">        options_.<span class="built_in">loop_closure_translation_weight</span>(),</span><br><span class="line">        options_.<span class="built_in">loop_closure_rotation_weight</span>() &#125;,</span><br><span class="line">       Constraint::INTER_SUBMAP&#125; );</span><br></pre></td></tr></table></figure><br>对于局部约束，<code>constraint_transform</code>并不是回环边，其实就是子图和节点的普通约束。 全局约束才构造回环边</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options_.<span class="built_in">log_matches</span>() )</span><br><span class="line">&#123;</span><br><span class="line">    std::ostringstream info;</span><br><span class="line">    info &lt;&lt; <span class="string">&quot;Node &quot;</span> &lt;&lt; node_id &lt;&lt; <span class="string">&quot; with &quot;</span></span><br><span class="line">         &lt;&lt; constant_data-&gt;filtered_gravity_aligned_point_cloud.<span class="built_in">size</span>()</span><br><span class="line">         &lt;&lt; <span class="string">&quot; points on submap &quot;</span> &lt;&lt; submap_id &lt;&lt; std::fixed;</span><br><span class="line">    <span class="keyword">if</span> (match_full_submap)</span><br><span class="line">         info &lt;&lt; <span class="string">&quot; matches&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">const</span> transform::Rigid2d difference =</span><br><span class="line">          initial_pose.<span class="built_in">inverse</span>() * pose_estimate;</span><br><span class="line">      info &lt;&lt; <span class="string">&quot; differs by translation &quot;</span> &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">2</span>)</span><br><span class="line">           &lt;&lt; difference.<span class="built_in">translation</span>().<span class="built_in">norm</span>() &lt;&lt; <span class="string">&quot; rotation &quot;</span></span><br><span class="line">           &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; std::<span class="built_in">abs</span>(difference.<span class="built_in">normalized_angle</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    info &lt;&lt; <span class="string">&quot; with score &quot;</span> &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; <span class="number">100.</span> * score &lt;&lt; <span class="string">&quot;%.&quot;</span>;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; info.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/20/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/%E6%80%9D%E8%80%83%E7%9A%84%E9%97%AE%E9%A2%98/">思考的问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/">原理和配置</a></span><div class="content"><ul>
<li><p>为何子图插入scan结束时CPU升高</p>
</li>
<li><p>为什么要用线程池</p>
</li>
<li><p>To be sure there is a recent loop closure constraint, you can query <code>PoseGraphInterface::constraints()</code>, loop over all constraints and check if there is a recent one of type INTER that spans some time.</p>
</li>
<li><p>A simpler solution is to subscribe to the global slam callback <code>GlobalSlamOptimizationCallback</code> by setting <code>PoseGraphInterface::SetGlobalSlamOptimizationCallback</code>. This will call you back after Cartographer has searched for loop closures. It does not tell you if loop closures were found, it mostly tells you if the background loop closure search is keeping up or falls behind.</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/08/05/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/gmapping%E5%92%8CAMCL%E7%9A%84%E5%8C%BA%E5%88%AB/">gmapping和AMCL的区别</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/">amcl和粒子滤波</a></span><div class="content"><h2 id="粒子"><a href="#粒子" class="headerlink" title="粒子"></a>粒子</h2><p>AMCL的粒子只包括位姿和权重，需要大量的粒子才能较好描述机器人位姿。gmapping的粒子包括轨迹、地图、权重，粒子过多会占用很大的内存。</p>
<p>AMCL的粒子在初始化时，各粒子的位姿是不同的，是均值参数加高斯噪声； gmapping粒子初始化时，粒子的位姿都是相同的。 所以说AMCL更符合撒粒子的逻辑。</p>
<p>AMCL的粒子数不是固定的，有最小和最大粒子数。在定位过程中，KLD采样会动态减少粒子数；gmapping的粒子数一直是固定的。</p>
<p>AMCL的提议分布是运动模型，分布的特点是又扁又宽； gmapping的提议分布是运动模型又加入了最近的观测，分布特点是小的尖峰。</p>
<p>AMCL的粒子权重是似然域模型改变，gmapping是通过scan match</p>
<p>AMCL输出的位姿是所有粒子加权平均后的结果； gmapping是输出得分最高的粒子</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/19/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/page/21/">21</a><span class="space">&hellip;</span><a class="page-number" href="/page/61/">61</a><a class="extend next" rel="next" href="/page/21/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2023 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>