<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | Silent Assassin</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">453</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">48</span></a></div></div></div><nav id="nav" style="background-image: url(https://i.loli.net/2021/07/13/RCLw5Bx8aFPN74b.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Silent Assassin</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">Silent Assassin</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/16/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/">发布和订阅</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a></span><div class="content"><p>话题通信的媒介是消息，消息的产生和消费是解偶的，二者之间没有强行绑定的关系，ROS节点不在乎是谁在发布Topic，哪个节点在订阅Topic，它只关心topic的名字以及当前的消息类型时候和要求的匹配。所以说话题通信是<strong>多对多</strong>的方式</p>
<p>publisher注册时的消息类型,如果和发布时的消息类型不一致,编译不报错,运行报错</p>
<p>消息是以Boost共享指针的形式传输，我们可以存储它而又不需要复制数据。回调函数最常用的原型是这样的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> std_msgs::StringConstPtr&amp; str)</span></span></span><br></pre></td></tr></table></figure><br>其实它就是<code>void callback(const boost::shared_ptr&lt;std_msgs::String const&gt;&amp;);</code>，还有以下几种：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(boost::shared_ptr&lt;std_msgs::String <span class="keyword">const</span>&gt;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(std_msgs::StringConstPtr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(std_msgs::String::ConstPtr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> std_msgs::String&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(std_msgs::String)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> ros::MessageEvent&lt;std_msgs::String <span class="keyword">const</span>&gt;&amp;)</span></span>;</span><br></pre></td></tr></table></figure><br>MessageEvent类允许你在订阅的回调函数内获取信息的元数据。</p>
<p>其他常用的ros::Subscriber函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> 	<span class="title">getNumPublishers</span> <span class="params">()</span> <span class="keyword">const</span>    <span class="comment">//获得连接订阅者的发布者个数</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> 	<span class="title">getTopic</span> <span class="params">()</span> <span class="keyword">const</span>	<span class="comment">//获得所订阅的话题</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> 	<span class="title">getNumSubscribers</span> <span class="params">()</span> <span class="keyword">const</span>　　<span class="comment">//获得连接发布者的订阅者个数</span></span></span><br></pre></td></tr></table></figure></p>
<p>订阅话题后，回调函数的参数类型必须是对应话题的消息类型，否则能订阅成功但不运行回调。</p>
<h2 id="发布者的回调函数"><a href="#发布者的回调函数" class="headerlink" title="发布者的回调函数"></a>发布者的回调函数</h2><p>用于检测是否有订阅者<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ros::Publisher pub = nh.advertise&lt;std_msgs::Int8&gt;(<span class="string">&quot;topic&quot;</span>, <span class="number">50</span>, connectCb,disconnectCb);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数如下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectCb</span><span class="params">(<span class="keyword">const</span> ros::SingleSubscriberPublisher&amp; pub)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;topic Name: %s&quot;</span>, pub.<span class="built_in">getTopic</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Subscriber Name: %s&quot;</span>, pub.<span class="built_in">getSubscriberName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disconnectCb</span><span class="params">(<span class="keyword">const</span> ros::SingleSubscriberPublisher&amp; pub)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;disconnectCb&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="特殊需求"><a href="#特殊需求" class="headerlink" title="特殊需求"></a>特殊需求</h2><p>有时需要在订阅者的回调函数中发布消息,而且只发布一次,这时没必要用service混合topic,用static变量就可以做到:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ros::Publisher *pubPtr;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> published = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">const</span> std_msgs::Int8ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = msg-&gt;data;</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;msg: %d&quot;</span>, num);</span><br><span class="line">    std_msgs::String str;</span><br><span class="line">    str.data = std::<span class="built_in">string</span>(<span class="built_in">to_string</span>(num) );</span><br><span class="line">    <span class="keyword">if</span>(!published &amp;&amp; num&gt;<span class="number">8</span>)   <span class="comment">// 在num&gt;8时发布一次,以后再也不发布</span></span><br><span class="line">    &#123;</span><br><span class="line">      pubPtr-&gt;<span class="built_in">publish</span>(str);</span><br><span class="line">      published = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc,argv, <span class="string">&quot;Sub&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">    ros::Subscriber sub = nh.subscribe&lt;std_msgs::Int8&gt;(<span class="string">&quot;topic&quot;</span>,<span class="number">20</span>,callback);</span><br><span class="line">    ros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(<span class="string">&quot;new&quot;</span>,<span class="number">50</span>,<span class="literal">false</span>);</span><br><span class="line">    pubPtr = &amp;pub;</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="让订阅者停止订阅"><a href="#让订阅者停止订阅" class="headerlink" title="让订阅者停止订阅"></a>让订阅者停止订阅</h3><p>ROS官方有这么一段话：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function   subscribe() 　returns a Subscriber object that you must hold on to until you want to unsubscribe. When all copies of the Subscriber object go out of scope, this callback will automatically be unsubscribed from this topic.</span><br><span class="line"></span><br><span class="line">function  shutdown()   Unsubscribe the callback associated with this Subscriber.</span><br><span class="line">This method usually does not need to be explicitly called, as automatic shutdown happens when all copies of this Subscriber go out of scope</span><br><span class="line">This method overrides the automatic reference counted unsubscribe, and immediately unsubscribes the callback associated with this Subscriber</span><br></pre></td></tr></table></figure><br>根据说明，有以下三种方法：</p>
<ol>
<li><p>一般让订阅者停止订阅的方法是等<code>subscribe()</code>生成的订阅者对象出作用域．</p>
</li>
<li><p>另一种方法就是explicitly调用<code>shutdown()</code>，典型方法是声明订阅者对象为全局变量，在回调函数中满足某条件时，对此对象调用<code>shutdown()</code>，但这样会直接退出程序，并不好</p>
</li>
<li><p>第三种方法其实与第二种类似，声明一个bool全局变量ok，订阅时执行</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!ok)</span><br><span class="line">&#123;</span><br><span class="line">    ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在回调函数中满足某条件时，让ok=true</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/16/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/ROS%E5%AE%9A%E6%97%B6%E5%99%A8/">ROS定时器</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a></span><div class="content"><p>roscpp的定时器会计划在某一速率下执行一次回调操作，在订阅或服务中的回调函数队列机制中使用。</p>
<h3 id="创建定时器"><a href="#创建定时器" class="headerlink" title="创建定时器"></a>创建定时器</h3><p>通过ros::NodeHandle::createTimer()创建: <code>ros::Timer timer = nh.createTimer(ros::Duration(0.1), timerCallback);</code>  其实有多个重载，这是用的比较多的一种。</p>
<p>回调函数只能是这种形式: <code>void callback(const ros::TimerEvent&amp;);</code><br>ros::TimerEvent结构体作为参数传入，它提供时间的相关信息，对于调试和配置非常有用。ros::TimerEvent结构体说明：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ros::Time last_expected 上次回调期望发生的时间</span><br><span class="line">ros::Time last_real 上次回调实际发生的时间</span><br><span class="line">ros::Time current_expected 本次回调期待发生的时间</span><br><span class="line">ros::Time current_real 本次回调实际发生的时间</span><br><span class="line">ros::WallTime profile.last_duration 上次回调的时间间隔（结束时间-开始时间），是wall-clock时间。</span><br></pre></td></tr></table></figure></p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>比如某些情况下，我们需要一直监视机器人的里程计数据状态，并在某个界面上显示出来。这种情况下可以用到定时器，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void odomTimerCb(const ros::TimerEvent&amp; e);</span><br><span class="line">void odomSubCb(const nav_msgs::OdometryConstPtr&amp; m);</span><br><span class="line">ros::Timer　odomTimer ;</span><br><span class="line">riki_msgs::HealthStatus msg;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    ros::init(argc,argv,&quot;healthStatus&quot;);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    odomTimer = nh.createTimer(ros::Duration(5), odomTimerCb);</span><br><span class="line">    ros::Subscriber odomSub = nh.subscribe(&quot;odom&quot;, 1000, odomSubCb);</span><br><span class="line"></span><br><span class="line">    ros::Publisher pub = nh.advertise&lt;riki_msgs::HealthStatus&gt;(&quot;healthStatus&quot;, 1000);</span><br><span class="line">    ros::Rate loop_rate(1);</span><br><span class="line">    while(ros::ok())</span><br><span class="line">    &#123;</span><br><span class="line">        pub.publish(msg);</span><br><span class="line">        ros::spinOnce();</span><br><span class="line">        loop_rate.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void odomTimerCb(const ros::TimerEvent&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    msg.odomData = false;</span><br><span class="line">&#125;</span><br><span class="line">void odomSubCb(const nav_msgs::OdometryConstPtr&amp; m)</span><br><span class="line">&#123;</span><br><span class="line">    msg.odomData = true;</span><br><span class="line">    odomTimer.stop();</span><br><span class="line">    odomTimer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未发布odom主题时，不会进入订阅者的回调函数<code>odomSubCb</code>，只进入定时器的回调<code>odomTimerCb</code>，此时消息成员<code>odomData</code>一直是false。<br>发布odom后，进入订阅者回调，此时<code>odomData</code>成为true，此时需要先停止计时器再打开。如果不停止，还会进入计时器回调，让消息成员赋值为false，实际造成赋值混乱。但是还得打开，因为一旦<code>odom</code>话题关闭了，就不会再进入订阅者回调，需要设法调用计时器回调，赋值false。订阅<code>odom</code>话题成功再打开计时器后，不会进入计时器回调。</p>
<p>参考: <a target="_blank" rel="noopener" href="https://www.ncnynl.com/archives/201702/1296.html">ROS与C++入门教程-Timers</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/16/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/%E5%8F%AA%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85%E4%B8%80%E6%AC%A1%E6%B6%88%E6%81%AF/">ROS只发布和订阅一次消息</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a></span><div class="content"><h3 id="只发布一次消息"><a href="#只发布一次消息" class="headerlink" title="只发布一次消息"></a>只发布一次消息</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;op_motor&quot;</span>);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">ros::Publisher pub = nh.advertise&lt;std_msgs::Bool&gt;(<span class="string">&quot;Switch&quot;</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//不必判断订阅者，直接等待１秒钟，只发布一次</span></span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">pub.<span class="built_in">publish</span>(msg); </span><br></pre></td></tr></table></figure>
<p>只发布一次消息就简单了，不必用while循环，直接发布就可以，但是最好也延时一次，防止订阅者的网络状况不好，当然如果不考虑有没有订阅者就不必延时了，不过这样没什么意义。</p>
<p><br></p>
<h3 id="ROS只订阅一次消息"><a href="#ROS只订阅一次消息" class="headerlink" title="ROS只订阅一次消息"></a>ROS只订阅一次消息</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ros::<span class="built_in">init</span>(argc,argv,<span class="string">&quot;node&quot;</span>);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">boost::shared_ptr&lt;riki_msgs::Battery <span class="keyword">const</span>&gt; batEdge;    <span class="comment">// 必须有const</span></span><br><span class="line">batEdge = ros::topic::waitForMessage&lt;riki_msgs::Battery&gt;(<span class="string">&quot;BMS&quot;</span>,ros::<span class="built_in">Duration</span>(<span class="number">3</span>));</span><br><span class="line"><span class="keyword">if</span>(batEdge != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    riki_msgs::Battery  bat = *batEdge;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;battery:&quot;</span>&lt;&lt;  bat.Ah  &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;battery:&quot;</span>&lt;&lt;  batEdge-&gt;Ah  &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;no topic BMS&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>这里用到的函数是<code>ros::topic::waitForMessage</code>，没有涉及回调函数，它有4个重载，常用的是两个:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class M&gt; boost::shared_ptr&lt; M <span class="keyword">const</span> &gt;   <span class="title">waitForMessage</span> <span class="params">(<span class="keyword">const</span> std::string &amp;topic, ros::Duration timeout)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class M&gt; boost::shared_ptr&lt; M <span class="keyword">const</span> &gt;  <span class="title">waitForMessage</span> <span class="params">(<span class="keyword">const</span> std::string &amp;topic, ros::NodeHandle &amp;nh)</span></span></span><br></pre></td></tr></table></figure><br>第一个是订阅话题topic，假如没有发布话题，那么等待时间timeout，超时后程序继续执行；第二个是如果没有发现话题topic，会一直阻塞，不能向下运行，除非执行<code>rosnode kill</code>。前一个用的比较多，注意时间不要设置太短，否则可能因为网络状况不好而订阅失败。</p>
<p>返回类型一看就知道是模板类的Boost共享指针，从这里就可以看出， <font color = blue>  <font size= 3> 消息是以Boost共享指针的形式传输，我们可以存储它而又不需要复制数据</font> &lt;/font&gt;，<code>waitForMessage</code>就是返回了订阅到的消息，取指向就可以获得消息成员，也可以直接用指针获得消息成员。<br><strong>注意模板类型有const</strong>，否则不符合重载声明</p>
<p>参考:<br><a target="_blank" rel="noopener" href="https://answers.ros.org/question/11167/how-do-i-publish-exactly-one-message/">How do I publish exactly one message</a><br><a target="_blank" rel="noopener" href="http://docs.ros.org/jade/api/roscpp/html/namespaceros_1_1topic.html">ros::topic Namespace</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/09/ROS/rviz%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/%E4%BD%BF%E7%94%A8Qt%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91rviz(%E4%B8%89)%20rviz%E7%9A%84%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/">使用Qt二次开发rviz(三) rviz的插件开发实战</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/rviz%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/">rviz深入研究</a></span><div class="content"><p>开发一个rviz插件，用以显示机器人的剩余电量、充电状态、急停状态、导航速度，只做个示范，界面不太完善。<br>环境配置可参考上一节，<a target="_blank" rel="noopener" href="https://github.com/rjosodtssp/ROS-Program/tree/master/topic_viewer">程序的地址</a></p>
<p>回调函数中判断电池剩余电量百分比，根据不同的值加载不同图片。充电状态也是同理<br>急停按钮按下时，显示急停的图片，否则不显示。</p>
<p>注意：</p>
<ul>
<li>插件加载的图片路径只能是绝对路径，相对路径会加载失败</li>
<li>Qt样式表不正常，估计跟rviz冲突<br><img src="https://c1.staticflickr.com/5/4894/32812868008_d7c8fcd0ae_b.jpg" alt=""></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/07/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/%E8%B6%85%E5%A3%B0%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8%E5%92%8C%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E5%99%A8%E7%9A%84%E6%8E%A7%E5%88%B6/">超声波传感器和电机驱动器的控制</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/">ROS机器人</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2019/01/07/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/%E8%B6%85%E5%A3%B0%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8%E5%92%8C%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E5%99%A8%E7%9A%84%E6%8E%A7%E5%88%B6/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/05/ROS/rviz%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/rviz%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB(%E4%B8%89)/">rviz源码解读（三） 插件中的interaction</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/rviz%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/">rviz深入研究</a></span><div class="content"><p>类继承关系：DisplayContext: public QObject<br>VisualizationManager: public DisplayContext<br>MockContext: public DisplayContext</p>
<p>VisualizationFrame::initialize<br>VisualizationManager  handleMouseEvent</p>
<p><code>ImageDisplay::onInitialize()</code>——<code>render_panel_ = new RenderPanel();</code><br>执行顺序:<br>InteractionTool   construct<br>InteractionTool   onInitialize<br>InteractionTool   activate<br>VisualizationManager  handleMouseEvent<br>InteractionTool   processMouseEvent<br>InteractionTool   updateFocus</p>
<p>event.panel = context<em>-&gt;getViewManager()-&gt;getRenderPanel();<br>event.viewport = context</em>-&gt;getViewManager()-&gt;getRenderPanel()-&gt;getRenderWindow()-&gt;getViewport(0);</p>
<hr>
<p>render<em>panel</em>-&gt;initialize( manager<em>-&gt;getSceneManager(), manager</em> );</p>
<p>void RenderPanel::wheelEvent( QWheelEvent* event )<br>{<br>  int last<em>x = mouse_x</em>;<br>  int last<em>y = mouse_y</em>;</p>
<p>  mouse<em>x</em> = event-&gt;x();<br>  mouse<em>y</em> = event-&gt;y();</p>
<p>  if (context_)<br>  {<br>    setFocus( Qt::MouseFocusReason );</p>
<pre><code>ViewportMouseEvent vme(this, getViewport(), event, last_x, last_y);
context_-&gt;handleMouseEvent(vme);
event-&gt;accept();
</code></pre><p>  }<br>}</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/12/30/ROS/rviz%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/rviz%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB(%E4%BA%8C)/">rviz源码解读(二)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/rviz%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/">rviz深入研究</a></span><div class="content"><p>rviz增加panel也是在fillTree</p>
<p><code>VisualizationFrame::initMenus()</code>是rviz的菜单栏，其中的显示工具栏是<code>initToolbars</code>的<code>toolbar_</code>。<br><code>关于</code>是函数<code>VisualizationFrame::onHelpAbout()</code></p>
<p>rviz/src/CMakeLists.txt :<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_subdirectory(rviz)</span><br><span class="line">add_subdirectory(image_view)</span><br><span class="line">if (CATKIN_ENABLE_TESTING)</span><br><span class="line">  add_subdirectory(test)</span><br><span class="line">endif()</span><br><span class="line"># Python bindings are only support with Qt5, PyQt5, and PySide2 for Kinetic+.</span><br><span class="line">if (UseQt5)</span><br><span class="line">  add_subdirectory(python_bindings)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure><br>其实是包含了4个子目录，最重要的当然是<code>rviz</code>目录了，其他目录在调试时可以先注释掉。</p>
<p><code>rviz/CMakeLists.txt</code>内容:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">find_package(PkgConfig)</span><br><span class="line">pkg_check_modules(NEW_YAMLCPP yaml-cpp&gt;=0.5)</span><br><span class="line">if(NEW_YAMLCPP_FOUND)</span><br><span class="line">  add_definitions(-DRVIZ_HAVE_YAMLCPP_05)</span><br><span class="line">endif(NEW_YAMLCPP_FOUND)</span><br><span class="line"></span><br><span class="line">if(UNIX AND NOT APPLE)</span><br><span class="line">  find_package(X11 REQUIRED)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">add_subdirectory(default_plugin)</span><br><span class="line"></span><br><span class="line">include_directories(.)</span><br><span class="line"></span><br><span class="line"># Build the version number and other build-time constants into the</span><br><span class="line"># source for access at run-time.</span><br><span class="line">set(ENV_CONFIG_FILE $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/env_config.cpp)</span><br><span class="line">set(RVIZ_VERSION $&#123;rviz_VERSION&#125;)</span><br><span class="line">message(&quot;making version $&#123;RVIZ_VERSION&#125;.&quot;)</span><br><span class="line">set(ROS_DISTRO $ENV&#123;ROS_DISTRO&#125;)</span><br><span class="line">configure_file(env_config.cpp.in $&#123;ENV_CONFIG_FILE&#125; @ONLY)</span><br><span class="line"></span><br><span class="line"># We create one lib with the C++...</span><br><span class="line">add_library($&#123;PROJECT_NAME&#125;  bit_allocator.cpp  ...... yaml_config_reader.cpp  yaml_config_writer.cpp    $&#123;ENV_CONFIG_FILE&#125;  )</span><br><span class="line"></span><br><span class="line">if(NOT WIN32)</span><br><span class="line">  set_target_properties($&#123;PROJECT_NAME&#125; PROPERTIES COMPILE_FLAGS &quot;-std=c++11&quot;)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">target_link_libraries($&#123;PROJECT_NAME&#125;</span><br><span class="line">  $&#123;Boost_LIBRARIES&#125;</span><br><span class="line">  $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">  $&#123;QT_LIBRARIES&#125;</span><br><span class="line">  $&#123;OGRE_OV_LIBRARIES_ABS&#125;</span><br><span class="line">  $&#123;OPENGL_LIBRARIES&#125;</span><br><span class="line">  $&#123;rviz_ADDITIONAL_LIBRARIES&#125;</span><br><span class="line">  $&#123;TinyXML_LIBRARIES&#125;</span><br><span class="line">  $&#123;X11_X11_LIB&#125;</span><br><span class="line">  assimp</span><br><span class="line">  yaml-cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">########### The rviz executable ###########</span><br><span class="line">add_executable(executable main.cpp)</span><br><span class="line"></span><br><span class="line">if(NOT WIN32)</span><br><span class="line">  set_target_properties(executable PROPERTIES COMPILE_FLAGS &quot;-std=c++11&quot;)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">target_link_libraries(executable $&#123;PROJECT_NAME&#125; $&#123;QT_LIBRARIES&#125; $&#123;OGRE_OV_LIBRARIES_ABS&#125;)</span><br><span class="line"></span><br><span class="line">set_target_properties(executable   PROPERTIES OUTPUT_NAME $&#123;PROJECT_NAME&#125;)</span><br><span class="line"></span><br><span class="line">install( TARGETS executable $&#123;PROJECT_NAME&#125;</span><br><span class="line">  RUNTIME DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br><span class="line">  LIBRARY DESTINATION $&#123;CATKIN_PACKAGE_LIB_DESTINATION&#125;     )</span><br><span class="line">install(DIRECTORY ./</span><br><span class="line">  DESTINATION $&#123;CATKIN_PACKAGE_INCLUDE_DESTINATION&#125;</span><br><span class="line">  FILES_MATCHING PATTERN &quot;*.h&quot;)</span><br><span class="line"></span><br><span class="line">install(TARGETS executable  DESTINATION $&#123;CATKIN_GLOBAL_BIN_DESTINATION&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>主要部分：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rviz::VisualizerApp vapp;	<span class="comment">//最外层</span></span><br><span class="line">vapp.<span class="built_in">setApp</span>( &amp;qapp );		<span class="comment">//赋值给app_</span></span><br><span class="line"><span class="keyword">if</span>( vapp.<span class="built_in">init</span>( argc, argv ))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> qapp.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="VisualizerApp-init"><a href="#VisualizerApp-init" class="headerlink" title="VisualizerApp::init"></a>VisualizerApp::init</h3><ul>
<li>终端输出rviz, Qt, ogre的版本</li>
<li>基于BOOST检查命令行参数，根据参数进行一些配置</li>
<li>ros::init之后检查是否成功，若不成功则关闭所有窗口</li>
<li>若启动后，与roscore通讯失败，弹出<code>WaitForMasterDialog</code></li>
<li>显示主窗口<code>VisualizationFrame</code>，根据命令行参数进一番设置</li>
<li>主窗口初始化，函数<code>VisualizationFrame::initialize</code>　　//第二层</li>
</ul>
<h3 id="VisualizationFrame-initialize"><a href="#VisualizationFrame-initialize" class="headerlink" title="VisualizationFrame::initialize"></a>VisualizationFrame::initialize</h3><p>  initConfigs();<br>  loadPersistentSettings();<br>  //软件图标<br>  QIcon app<em>icon( QString::fromStdString( (fs::path(package_path</em>) / “icons/package.png”).BOOST<em>FILE_STRING() ) );<br>  setWindowIcon( app_icon );<br>  if( splash_path</em> != “” )<br>  {<br>    QPixmap splash<em>image( splash_path</em> );<br>    splash<em> = new SplashScreen( splash_image );<br>    splash</em>-&gt;show();<br>    connect( this, SIGNAL( statusUpdate( const QString&amp; )), splash_, SLOT( showMessage( const QString&amp; )));<br>  }</p>
<p>加载<code>Grid</code>等<code>Display Type</code>是在<code>DisplayTypeTree::fillTree</code></p>
<p><code>add_button</code>按钮的槽函数——<code>DisplaysPanel::onNewDisplay()</code>——<code>AddDisplayDialog</code>构造函数——<code>DisplayTypeTree::fillTree</code>——</p>
<p><code>VisualizationFrame::prepareToExit()</code></p>
<p>保存配置文件为：<code>VisualizationFrame::onSaveAs()</code></p>
<p>保存配置文件：<code>VisualizationFrame::onSave()</code>——<code>saveDisplayConfig</code>——<code>VisualizationFrame::save</code>——<code>savePanels</code>, <code>saveWindowGeometry</code>,<code>saveToolbars</code>——</p>
<p>初始化加载配置文件：<code>VisualizerApp::init</code>——<code>VisualizationFrame::initialize</code>——<code>VisualizationFrame::loadDisplayConfig</code>——<code>VisualizationFrame::load</code>——<code>loadPanels</code>,  <code>loadWindowGeometry</code>,   <code>configureToolbars</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/12/25/ROS/rviz%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/rviz%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB(%E4%B8%80)/">rviz源码解读(一)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/rviz%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/">rviz深入研究</a></span><div class="content"><p>rviz启动时会加载一个扩展名为<code>.rviz</code>的配置文件，如果没有指定的话，会默认加载<code>~/.rviz/default.rviz</code>做配置文件，如果没有这个文件，就创建一个。</p>
<p>rviz启动时还会读取一个文件<code>/home/user/.rviz/persistent_settings</code>，内容大致如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Last Config Dir: /home/user/.rviz</span><br><span class="line">Last Image Dir: &quot;&quot;</span><br><span class="line">Recent Configs:</span><br><span class="line">  - /home/user/.rviz/default.rviz</span><br></pre></td></tr></table></figure><br>对这个文件的加载是在rviz源码中的函数<code>VisualizationFrame::loadPersistentSettings()</code>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VisualizationFrame::loadPersistentSettings</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  YamlConfigReader reader;</span><br><span class="line">  Config config;</span><br><span class="line">  reader.<span class="built_in">readFile</span>( config, QString::<span class="built_in">fromStdString</span>( persistent_settings_file_ ));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>( !reader.<span class="built_in">error</span>() )</span><br><span class="line">  &#123;</span><br><span class="line">    QString last_config_dir, last_image_dir;</span><br><span class="line">    <span class="keyword">if</span>( config.<span class="built_in">mapGetString</span>( <span class="string">&quot;Last Config Dir&quot;</span>, &amp;last_config_dir ) &amp;&amp;</span><br><span class="line">        config.<span class="built_in">mapGetString</span>( <span class="string">&quot;Last Image Dir&quot;</span>, &amp;last_image_dir ))</span><br><span class="line">    &#123;</span><br><span class="line">      last_config_dir_ = last_config_dir.<span class="built_in">toStdString</span>();</span><br><span class="line">      last_image_dir_ = last_image_dir.<span class="built_in">toStdString</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Config recent_configs_list = config.<span class="built_in">mapGetChild</span>( <span class="string">&quot;Recent Configs&quot;</span> );</span><br><span class="line">    recent_configs_.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num_recent = recent_configs_list.<span class="built_in">listLength</span>();</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_recent; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">      recent_configs_.<span class="built_in">push_back</span>( recent_configs_list.<span class="built_in">listChildAt</span>( i ).<span class="built_in">getValue</span>().<span class="built_in">toString</span>().<span class="built_in">toStdString</span>() );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ROS_ERROR</span>( <span class="string">&quot;%s&quot;</span>, <span class="built_in">qPrintable</span>( reader.<span class="built_in">errorMessage</span>() ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在编译rviz时出错了，就是在读这个配置文件里，追踪bug的路线:<code>VisualizationFrame::loadPersistentSettings</code>——<code>YamlConfigReader::readFile</code>——<code>YamlConfigReader::readStream</code>——<code>YamlConfigReader::readYamlNode</code>，有问题的代码在<code>yaml_config_reader.cpp</code>的76行，但不论怎么修改都未通过。目前把<code>readStream</code>注释掉，估计PersistentSettings不影响使用。</p>
<p>工具栏添加机器人操作的按钮在<code>ToolManager::load</code>，但是先调用了<code>removeAll</code>，导致没有添加按钮。如果没有removeAll，就有四个按钮: <code>Move Camera</code>,   <code>交互</code>,    <code>Select</code>,    <code>校正位置</code>。可以调用函数<code>removeTool(int  index)</code>，去掉不需要的。</p>
<p>用+按钮添加新的按钮时，打开的对话框是<code>NewObjectDialog</code>，列表中加载按钮的函数是<code>NewObjectDialog::fillTree</code>，<code>QStringList classes = factory_-&gt;getDeclaredClassIds();</code>是所有即将显示的项目，我去掉了一部分。</p>
<p>主界面的标题在　<code>VisualizationFrame::setDisplayConfigFile</code><br>工具栏的编辑在　<code>VisualizationFrame::initToolbars()</code><br>Interact改名是在<code>InteractionTool::onInitialize()</code>里加<code>setName()</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/12/24/ROS/rviz%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/%E4%BD%BF%E7%94%A8Qt%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91rviz(%E4%BA%8C)%20rviz%E7%9A%84%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/">使用Qt二次开发rviz(二) rviz的插件开发环境配置</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/rviz%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/">rviz深入研究</a></span><div class="content"><p><code>package.xml</code>文件中的<code>&lt;export&gt;</code>用于添加额外的信息，比如需要嵌入的其它package的插件，或者一些说明信息。<br>例如这样的:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;export&gt;</span><br><span class="line">  &lt;rviz plugin=&quot;$&#123;prefix&#125;/plugin_description.xml&quot;/&gt;</span><br><span class="line">&lt;/export&gt;</span><br></pre></td></tr></table></figure><br>编译ROS插件时，必须添加一个<code>plugin_description.xml</code>文件，与<code>package.xml</code>同级，它包括了插件动态库的位置，使用的类和基类。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">library</span> <span class="attr">path</span>=<span class="string">&quot;libpluginTest&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;my_plugin/PluginTest&quot;</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">type</span> = <span class="string">&quot;my_plugin::PluginTest&quot;</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">base_class_type</span>=<span class="string">&quot;rviz::Panel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">		The first plugin to test</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">library</span>&gt;</span></span><br></pre></td></tr></table></figure><br><code>path</code>是生成的so文件名，可以到lib文件夹查看。这里可以加<code>lib/</code>指定路径，也可以不加。<code>class name</code>必须是<code>命名空间/类名</code>，<code>type</code>必须是<code>命名空间::类名</code>，其他就不用解释了。</p>
<p>还有就是<code>CMakeLists</code>了，除了原有内容，还要加入下面这些:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">find_package(Qt5 COMPONENTS Core Widgets )</span><br><span class="line">set(QT_LIBRARIES Qt5::Widgets)</span><br><span class="line">set(SOURCE_FILES src/my_plugin.cpp include/my_plugin/my_plugin.h)</span><br><span class="line"></span><br><span class="line">add_library(pluginTest $&#123;SOURCE_FILES&#125; )</span><br><span class="line">target_link_libraries(pluginTest</span><br><span class="line">   $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">   $&#123;rviz_DEFAULT_PLUGIN_LIBRARIES&#125;</span><br><span class="line">   $&#123;QT_LIBRARIES&#125;</span><br><span class="line"> )</span><br></pre></td></tr></table></figure><br>添加Qt的库，注意生成的是库文件。<strong>这里要注意源文件和头文件都参与编译，尤其头文件要放在include文件夹里</strong>，否则编译不报错但运行会报错:<img src="https://c2.staticflickr.com/8/7825/46533032612_2780714905.jpg" alt=""></p>
<p>源文件大致是这样的:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> my_plugin</span><br><span class="line">&#123;</span><br><span class="line">  PluginTest::<span class="built_in">PluginTest</span>(QWidget* parent)</span><br><span class="line">    :rviz::<span class="built_in">Panel</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">resize</span>(<span class="number">406</span>, <span class="number">308</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setMaximumSize</span>(<span class="built_in">QSize</span>(<span class="number">436</span>, <span class="number">346</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pluginlib/class_list_macros.h&gt;</span></span></span><br><span class="line"><span class="built_in">PLUGINLIB_EXPORT_CLASS</span>(my_plugin::PluginTest,rviz::Panel)</span><br></pre></td></tr></table></figure><br>最后两句不能缺少，这是输出插件的类名称，<code>rviz::Panel</code>是基类。</p>
<p>编译完成后，先在工作空间里执行一次<code>source devel/setup.bash</code>，然后再打开rviz就能看到插件了。</p>
<p>参考:<br><a target="_blank" rel="noopener" href="http://wiki.ros.org/pluginlib/PluginDescriptionFile">plugin_description文件的官方文档</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/39390512">ROS技术点滴 —— rviz plugin</a><br><a target="_blank" rel="noopener" href="https://answers.ros.org/question/215487/could-not-load-panel-in-rviz-pluginlibfactory-the-plugin-for-class/">Could not load panel in rviz — PluginlibFactory</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/12/24/ROS/rviz%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/%E4%BD%BF%E7%94%A8Qt%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91rviz(%E4%B8%80)%20%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%92%8C%E6%B5%8B%E8%AF%95librviz/">使用Qt二次开发rviz(一) 配置Qt-ROS编译环境</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/rviz%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/">rviz深入研究</a></span><div class="content"><p>新建一个文件夹，在Qt里选中后进行新建工作空间，不必使用<code>ros_workspace_init</code>命令。ROS自带功能包可以直接创建带有Qt界面的package，方法为<code>catkin_create_qt_pkg</code>命令，然后导入Qt中进一步修改为适合自己的GUI节点。</p>
<h3 id="workspace文件"><a href="#workspace文件" class="headerlink" title="workspace文件"></a>workspace文件</h3><p>用qt_ros_plugin创建的工作空间有一个workspace文件，这是普通工作空间没有的，与src同级。内容如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Workspace</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Distribution</span> <span class="attr">name</span>=<span class="string">&quot;kinetic&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DefaultBuildSystem</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">WatchDirectories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Directory</span>&gt;</span>src<span class="tag">&lt;/<span class="name">Directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">WatchDirectories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Workspace</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>添加以下内容:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IncludePaths</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Directory</span>&gt;</span>/opt/ros/kinetic/include<span class="tag">&lt;/<span class="name">Directory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IncludePaths</span>&gt;</span></span><br></pre></td></tr></table></figure><br>这是为了防止不能在代码里使用跟ROS有关的自动提示，不过一般也可以不加。</p>
<h3 id="修改CMakeLists和package-xml"><a href="#修改CMakeLists和package-xml" class="headerlink" title="修改CMakeLists和package.xml"></a>修改CMakeLists和package.xml</h3><p><code>ros_qtc_plugin</code>还是基于Qt4的，目前普遍都是Qt5了，所以对新建的package需要修改编译环境，也就是<code>CMakeLists.txt</code>和<code>package.xml</code>两个文件。这里所用的librvi用到了<code>rviz</code>这个package，所以需要一起修改。</p>
<p>对于<code>package.xml</code>，本来是这样的:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>qt_build<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>libqt4-dev<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>qt_build<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>libqt4-dev<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br></pre></td></tr></table></figure><br>要改成这样:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>qtbase5-dev<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>libqt5-core<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>libqt5-gui<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rviz<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>rviz<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br></pre></td></tr></table></figure><br>也就是换成Qt5的几个库，还要加上rviz</p>
<p>对CMakeLists.txt先删除这一项:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbuild_prepare_qt4(QtCore QtGui)</span><br></pre></td></tr></table></figure><br>再添加:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//另一个find_package中添加rviz</span><br><span class="line">find_package(Qt5 REQUIRED Core Widgets)</span><br><span class="line">set(QT_LIBRARIES Qt5::Widgets)</span><br></pre></td></tr></table></figure><br>修改所有QT4为QT5，还有在<code>file(GLOB_RECURSE QT_MOC RELATIVE</code>中添加头文件<code>*.h</code></p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>点击左侧兰的“项目”，在<code>构建设置</code>页的<code>编辑构建配置</code>一栏选择<code>Default</code>，然后在下图所示光标处点击切换到<code>运行设置</code>页，可以看到一个<code>Add Run Step</code>的选项，可以添加<code>rosrun</code>和<code>roslaunch</code>，可以通过下拉菜单选择package和target，下拉菜单可以通过键入首字母初步定位到你要找的package位置 。<br><img src="https://c2.staticflickr.com/8/7899/45532545255_eeb930b367_b.jpg" alt=""><br>配置好<code>rosrun</code>和<code>roslaunch</code>后，可以直接在Creator中运行节点了，但是还要先运行<code>roscore</code>，否则可以运行节点但是会报错。</p>
<p>参考:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30460905/article/details/79210300"></a><br><a target="_blank" rel="noopener" href="https://uzzz.org/2018/08/05/ee631b67e8705f169072546de0e2cc2c.html"></a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/39/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/39/">39</a><span class="page-number current">40</span><a class="page-number" href="/page/41/">41</a><span class="space">&hellip;</span><a class="page-number" href="/page/46/">46</a><a class="extend next" rel="next" href="/page/41/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/07/13/RCLw5Bx8aFPN74b.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>