<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2022/02/17/HQaCXUBn64zsMIL.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">630</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">52</span></a></div></div></div><nav id="nav" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2018/08/03/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">拷贝构造函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><ul>
<li><p>copy构造函数是一种特殊的构造函数，函数的名称必须和类名称一致，没有返回值。它必须的一个参数是本类型的一个引用变量，如果形参是对象做值传递, 将实参传进函数时, 我们实际是拷贝一个副本,这样又要调用拷贝构造函数, 层层递归, 会把栈堆满。类中可以存在多个copy构造函数。</p>
</li>
<li><p>编译器会自动生成默认copy构造函数，这个构造函数很简单，仅仅使用“老对象”的数据成员的值对“新对象”的数据成员逐个进行赋值，也就是<strong>浅拷贝</strong>。</p>
</li>
<li><p>默认copy构造函数不处理静态变量。如果静态成员变量在构造、析构实例的时候需要修改，那么通常需要手工实现copy构造函数和重载赋值运算符。</p>
</li>
<li><p>如果对象存在了动态成员，那么需要手动实现析构函数，也就需要手动实现copy构造函数，因为默认copy构造函数使用的是浅拷贝，要改用深拷贝。</p>
</li>
<li><p>如果派生类没有自定义拷贝构造函数，它在拷贝时，会调用基类的copy构造函数。如果两个类都自定义copy构造函数，那么只调用派生类的。</p>
</li>
<li><p>copy构造函数也要对常成员变量进行列表初始化</p>
</li>
<li><p>基类定义了带参数的构造函数，派生类没有定义任何带参数的构造函数，则不能直接调用基类的带参构造函数，程序编译不通过</p>
</li>
</ul>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>浅拷贝实际是对变量的引用，深拷贝是对类成员复制并重新分配内存，<font color = blue size =3> 二者的最大区别在于是否手动分配内存 </font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>();</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Base</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>();</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">const</span> Base&amp; obj);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">// 最好用智能指针</span></span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line">Base::<span class="built_in">Base</span>(<span class="keyword">int</span> a):</span><br><span class="line">      <span class="built_in">m</span>(a)</span><br><span class="line">&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>);	<span class="comment">// p内存分配在stack</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base::~<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Base::<span class="built_in">Base</span>(<span class="keyword">const</span> Base &amp;obj)：</span><br><span class="line">        <span class="built_in">m</span>(<span class="number">0</span>),</span><br><span class="line">        <span class="built_in">p</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>))</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;copy构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    m = obj.m;</span><br><span class="line">    <span class="comment">// 动态分配的内存必须自定义copy构造函数，浅拷贝不会处理</span></span><br><span class="line">    <span class="keyword">int</span>* temp = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *temp = *(obj.p);</span><br><span class="line">    <span class="keyword">this</span>-&gt;p = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">    <span class="function">Base <span class="title">b1</span><span class="params">(<span class="number">15</span>)</span></span>;</span><br><span class="line">    <span class="function">Base <span class="title">b2</span><span class="params">(b1)</span></span>;</span><br></pre></td></tr></table></figure>
<p>不能不处理p。假如copy构造函数中没有对p分配内存，编译正确，但运行时b2析构会出现问题。因为默认拷贝执行浅拷贝，把b2里的p也指向了b1里的p，二者地址相同，结果会出现二次析构，内存泄漏。</p>
<p>我用Creator试验二次析构，发现程序结束时报错<font color = orange size= 3> program has unexpectedly finished </font>，再次运行时Qt先报信息<code>Fault tolerant heap shim applied to current process.</code>，这就是内存泄漏造成的，按照<a target="_blank" rel="noopener" href="https://blog.csdn.net/llazy123/article/details/80763448">这个方法</a>解决</p>
<p>标准化容器使用insert、push、assign等成员增加元素的时候也会调用拷贝构造函数</p>
<h2 id="禁用拷贝"><a href="#禁用拷贝" class="headerlink" title="禁用拷贝"></a>禁用拷贝</h2><p>禁用原因主要是两个：</p>
<ol>
<li>浅拷贝问题，也就是上面提到的二次析构。</li>
<li>自定义了基类和派生类的copy构造函数，但派生类对象拷贝时，调用了派生类的拷贝，没有调用自定义的基类拷贝而是调用默认的基类拷贝。这样可能造成不安全，比如出现二次析构问题时，因为不会调用我们自定义的基类深拷贝，还是默认的浅拷贝。</li>
</ol>
<p>Effective C++条款6规定，如果不想用编译器自动生成的函数，就应该明确拒绝。方法一般有三种：</p>
<ol>
<li>C++11对函数声明加delete关键字：<code>Base(const Base&amp; obj) = delete;</code>，不必有函数体，这时再调用拷贝构造会报错</li>
<li>最简单的方法是将copy构造函数声明为private</li>
<li>条款6给出了更好的处理方法：创建一个基类，声明copy构造函数，但访问权限是private，使用的类都继承自这个基类。默认copy构造函数会自动调用基类的copy构造函数，而基类的copy构造函数是private，那么它无法访问，也就无法正常生成copy构造函数。</li>
</ol>
<p>Qt就是这样做的，QObject定义中有这样一段，三条都利用了:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Q_DISABLE_COPY</span>(QMainWindow)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_DISABLE_COPY(Class) \</span></span><br><span class="line"><span class="meta">    Class(const Class &amp;) Q_DECL_EQ_DELETE;\</span></span><br><span class="line"><span class="meta">    Class &amp;operator=(const Class &amp;) Q_DECL_EQ_DELETE;</span></span><br></pre></td></tr></table></figure><br><strong>类的不可拷贝特性是可以继承的，凡是继承自QObject的类都不能使用copy构造函数和赋值运算符</strong></p>
<h3 id="有没有定义派生类copy构造函数的情况的不同结果"><a href="#有没有定义派生类copy构造函数的情况的不同结果" class="headerlink" title="有没有定义派生类copy构造函数的情况的不同结果"></a>有没有定义派生类copy构造函数的情况的不同结果</h3><p>先是没有定义派生类copy构造函数的情况：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived f;</span><br><span class="line"><span class="function">Derived <span class="title">ff</span><span class="params">(f)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>运行结果是这样：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Base constrct      0x75fd20</span><br><span class="line">Derived construct  0x75fd20</span><br><span class="line">Base copy constrct    0x75fd10</span><br><span class="line">*************</span><br><span class="line">Derived deconstruct   0x75fd10</span><br><span class="line">Base deconstrct       0x75fd10</span><br><span class="line">Derived deconstruct  0x75fd20</span><br><span class="line">Base deconstrct      0x75fd20</span><br></pre></td></tr></table></figure><br>对于副本的对象，只调用了基类copy构造函数。</p>
<p><br></p>
<p>然后是定义的情况，运行结果是这样：<br><img src="https://i.loli.net/2019/12/26/Ju65as8BU7VOLeh.png" alt=""><br>先是f的基类构造和派生类构造，然后进入ff，这里的对象是个副本，所以this指针的地址不同了，<font color = blue size =3> 先是基类构造然后是派生类拷贝构造， </font>销毁时倒没什么特别。</p>
<p>这样看来，<font color = blue size=4> 派生类的copy构造函数可以尽量不定义。</font></p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/lwbeyond/article/details/6202256">详解copy构造函数</a><br><a target="_blank" rel="noopener" href="http://blog.guorongfei.com/2016/04/24/why-delete-copy-constructor/">为什么很多人禁用拷贝（复制）构造函数</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/08/03/C++/C++%20%20%E5%9F%BA%E7%A1%80/%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/">结构体与类的字节对齐(终极方案，简单易懂)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E5%9F%BA%E7%A1%80/">C++ 基础</a></span><div class="content"><p>先记住常用类型在32和64位的字节</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">32位</th>
<th style="text-align:center">64位</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">4</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">8</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">指针</td>
<td style="text-align:center">4</td>
<td style="text-align:center">8</td>
</tr>
</tbody>
</table>
</div>
<p>只有指针在64位时不同，是8。函数指针的typedef声明不参与计算。枚举类型占内存4字节。<br>另外注意：gcc中没有要求结构体大小是最大对象的整数倍。</p>
<h2 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h2><p>终于搞清楚结构体的字节对齐怎么计算了，看了那么多国内博客，大部分都不靠谱，要不然就是不知所云，最后看了一个印度三哥的视频讲解，没用3分钟就明白了。其实就一条规则：<strong>计算时按最大成员的大小进行逐个判断，有需要就补位</strong></p>
<p>直接看几个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct bb</span><br><span class="line">&#123;</span><br><span class="line"> int i;	     //4 </span><br><span class="line"> double w;   //8</span><br><span class="line"> float h;     //4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>我们以为它在内存中是这样的: <code>iiii wwwwwwww hhhh</code>   其实是这样的:<code>iiii ---- wwwwwwww hhhh ----</code><br>最大的double占8个，从左向右，每8个为一组，编译器无法把<code>iiii wwww</code>一起处理，那样就把double截断了，所以给int补4位。同理float补4位。总共24.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct s1&#123;</span><br><span class="line">    char c;   //1</span><br><span class="line">    int i;	  // 4 </span><br><span class="line">    short f;  // 2</span><br><span class="line">    double v;  // 8</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原本是这样:<code>c iiii ff vvvvvvvv</code>，从左向右按8补齐，应当是:<code>c--- iiii ff------ vvvvvvvv</code>。c和i总共5，给c补3位就行。f没法和v组合，只能补6位，总共24.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct s1&#123;</span><br><span class="line">    short f;	//2</span><br><span class="line">    char c[3];  //3</span><br><span class="line">    int i;		//4</span><br><span class="line">    double v;	//8</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原来是:<code>ff ccc iiii vvvvvvvv</code>，2+3不足8，2+3+4超过了8，所以给f补3位，然后i补4位，也就是2+3+3+4+4+8=24</p>
<p>最后来个特殊的，计算N的大小:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line">    char c;</span><br><span class="line">    int i;</span><br><span class="line">    char p;</span><br><span class="line">&#125;;</span><br><span class="line">struct N&#123;</span><br><span class="line">    Node n;  //12</span><br><span class="line">    int x;   //4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>按上面的方法可知Node占12，那么按上面的方法，N是不是该占24？错了，在N里的Node应该按<code>cccc iiii pppp</code>处理，这样N就占16.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct s1&#123;</span><br><span class="line">    char c;     //1</span><br><span class="line">    int i;     // 4</span><br><span class="line">    short f;   // 2</span><br><span class="line">    double v;  // 8</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct s2&#123;</span><br><span class="line">    char c;     //1</span><br><span class="line">    short f;   // 2</span><br><span class="line">    int i;     // 4</span><br><span class="line">    double v;  // 8</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第一个的大小是24，第二个是16</p>
<h2 id="pragma-pack-n"><a href="#pragma-pack-n" class="headerlink" title="#pragma pack (n)"></a>#pragma pack (n)</h2><p>这条预处理命令也好理解了，只要把上面规则中最大变量的大小换成n就行，注意假设结构体中最大元素占内存m，当n如果超过m是不起作用的。</p>
<h2 id="类的sizeof计算"><a href="#类的sizeof计算" class="headerlink" title="类的sizeof计算"></a>类的sizeof计算</h2><p>1.类的大小为类的非静态成员数据的类型大小之和，也就是说静态成员数据不作考虑。</p>
<p>2.普通成员函数和构造函数与sizeof无关。</p>
<p>3.虚函数由于要维护在虚函数表，所以要占据一个指针大小，也就是4字节。</p>
<p>4.类的总大小也遵守字节对齐规则。</p>
<p>将类定义如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Base();</span><br><span class="line">    explicit Base(int a);</span><br><span class="line">    virtual ~Base();</span><br><span class="line">    void test();</span><br><span class="line">    virtual void test_virtual();</span><br><span class="line">private:</span><br><span class="line">    void foo();</span><br><span class="line">protected:</span><br><span class="line">    int m;</span><br></pre></td></tr></table></figure><br>执行sizeof的结果是8，如果把虚析构函数去掉就变成4，再把<code>int m</code>去掉就变成了1，实际是空类，但是空类实例化也要在内存占用地址，由编译器添加一个字节以区分不同对象。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/08/02/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/">回调函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><p>之前对回调函数理解一直不到位，需要深入分析一下。<br>一般函数都是系统提供或程序员自定义的，让程序员使用的。但回调函数恰恰相反，它是程序员定义(注册)，在特定条件(常常是用户触发)发生时由系统API调用的，是通过函数指针实现调用的。函数定义在高层，调用在底层。</p>
<p>Linux信号处理机制就是利用回调函数实现的，例如signaction某个形参就有一个成员是函数指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;signal %d catched  !\n&quot;</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = func;</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;act.sa_mask,SIGQUIT);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sigaction</span>(SIGINT,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当程序运行后，按Ctrl+C会发送SIGINT信号，然后内核调用函数<code>func</code>，输出文本。</p>
<h3 id="类的成员函数做回调函数"><a href="#类的成员函数做回调函数" class="headerlink" title="类的成员函数做回调函数"></a>类的成员函数做回调函数</h3><p>由于this指针的作用，使得将一个CALLBACK型的成员函数作为回调函数安装时就会因为隐含的this指针使得函数参数个数不匹配，从而导致回调函数安装失败。定义类成员函数时，在该函数前加CALLBACK即可将其定义为回调函数。</p>
<ol>
<li>类的静态成员函数实现回调函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;signal: &quot;</span>&lt;&lt;sig&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(sig == <span class="number">15</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;SIGTERM&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;SIGINT&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;signal: &quot;</span>&lt;&lt;sig&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(sig == <span class="number">15</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;receive signal SIGTERM&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, func);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM, Foo::func);  <span class="comment">// 第二个参数也可以是func</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)    <span class="comment">// 设法阻塞</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从终端启动程序，会阻塞。按下Ctrl+C，会触发SIGINT信号。执行pkill命令，会触发SIGTERM信号。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/07/30/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/this%E6%8C%87%E9%92%88/">this指针</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><p>this指针指向对象的地址，本身是一个常量指针<code>MyClass *const this</code>，也就是不能改变指向的对象。</p>
<p>this指针是在创建对象前就有了，在编译时刻已经确定，this指针放在栈上。当一个对象创建后，整个程序运行期间只有一个this指针.</p>
<p>我是这样理解类和this指针的：类相当于房子的户型，根据这个户型可以造出很多房子，这就相当于对象。每个房子的地址不同，这就相当于内存地址。当你进入一个房子后，你可以看见桌子、椅子、地板等，但是房子你是看不到全貌了。this就是房子里面的一个标识，说明了房子的地址，但这个标识又不占房子空间。</p>
<p><font color = blue size =3> this指针不属于对象本身的一部分，不会影响sizeof作用。 </font>顺便一提，一个空的类，<code>sizeof</code>的大小是1</p>
<p>this指针是编译器默认传给类中非静态函数的隐含形参，其<strong>作用域在非静态成员函数的函数体内。</strong><br>在类的赋值运算符重载函数中，我们可以一般使用<code>*this</code>作为当前对象返回。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_pub</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相当于void Base::test(Base* const this)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Base::test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;base test&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Base::test_pub</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;base test_pub&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用两函数的结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00DDF9A0</span><br><span class="line">base <span class="built_in">test</span></span><br><span class="line">00DDF9A0</span><br><span class="line">base test_pub</span><br></pre></td></tr></table></figure><br>也就是说运行时只有一个this指针。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/07/26/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0/">类的静态变量和静态函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><p>如果有N个同类的对象，那么每一个对象都分别有自己的成员变量，不同对象的成员变量各自有值，互不相干。但是有时我们希望有某一个或几个成员变量为所有对象共有，这样可以实现数据共享。</p>
<p>可以使用全局变量，但用全局变量的安全性得不到保证，由于在各处都可以自由地修改全局变量的值，很有可能偶然失误，<strong>因此在实际开发中很少使用全局变量。</strong></p>
<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><ul>
<li><p>对于类的静态成员变量，<strong>只有static const int类型和 enum 类型能在类里面初始化</strong>，其他只能在.cpp里初始化,但不能在类体内初始化，因为静态数据成员为类的各个对象共享，否则每次创建一个类的对象则静态数据成员都要被重新初始化。</p>
</li>
<li><p>静态成员函数和静态变量在类体外初始化时，无须加static关键字，否则是错误的。</p>
</li>
<li><p>static成员变量的内存空间是在初始化时分配，程序结束才释放，跟类对象的销毁无关。</p>
</li>
<li><p>静态变量不参与sizeof计算，因为它不占用对象的内存</p>
</li>
<li><p>静态成员仍然遵循public，private，protected访问准则。</p>
</li>
</ul>
<h3 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h3><ul>
<li><p>静态成员函数只能调用静态变量，因为没有this指针。<font color = blue size =3> 设计它的初衷是把类名当成namespace用，控制类内的static变量。 </font></p>
</li>
<li><p>静态成员函数仍然遵循访问等级，但最好是public，否则不能直接用<code>类名::</code>调用</p>
</li>
<li><p>非静态成员函数可以任意地访问静态成员函数和静态数据成员。</p>
</li>
<li><p>静态成员函数不能声明为<strong>虚函数</strong>，编译直接报错</p>
</li>
<li><p>静态成员函数与成员函数不能同名同参数，也就是静态和非静态函数不能重载，否则编译器不知调用哪个</p>
</li>
</ul>
<p>举例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Obj</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> Obj* instance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Obj* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源文件</span></span><br><span class="line">Obj* Obj::instance=<span class="number">0</span>;   <span class="comment">//类外定义</span></span><br><span class="line"><span class="keyword">int</span> Obj::n = <span class="number">4</span>; 	   <span class="comment">//类外定义</span></span><br><span class="line"><span class="function">Obj* <span class="title">Obj::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!instance)</span><br><span class="line">    &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="built_in">Obj</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考:<br><a href="">Essential C++ 115页</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/07/23/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">单例模式的多种形态</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><p>应用实例：线程池，日志类，windows系统的任务管理器</p>
<p>一个单例模式应具备以下特征：</p>
<ol>
<li>只能实例化同一个对象</li>
<li>可以全局访问</li>
<li>禁止拷贝</li>
<li>线程安全</li>
</ol>
<p>针对第一条，可以将构造函数权限设为private，如果是public那么每次实例化调用构造函数，对象的内存地址都不同，也就是说只准调用一次构造函数。那问题来了，构造函数都private了，怎么实例化对象？显然要用某个public方法来调用，这又有问题：都没实例化对象，怎么调用public方法？所以这个public方法只能是静态的了。</p>
<p>针对第二条，全局性很容易想到静态函数，它是属于类的，而不是属于某个对象的。</p>
<p>第三条很容易，将拷贝构造函数和复制运算符声明为private即可。</p>
<p>综上，单例类的雏形应该是这样的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 单例方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:    <span class="comment">//构造函数或析构函数为私有函数，所以该类是无法被继承的，</span></span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;单例构造&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">    ~<span class="built_in">Singleton</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;单例析构&quot;</span>&lt;&lt;endl;  &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">    <span class="keyword">static</span> Singleton* m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>关键就是怎么实现public static方法。</p>
<h3 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h3><p>首先想到这样的方法:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Singleton <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton s;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果报错<code>构造函数和析构函数是private</code>，第一行就编译不过</p>
<h3 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h3><p>测试下面这种方法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Singleton* <span class="title">instance1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton *s = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">Singleton* s1 = Singleton::<span class="built_in">instance1</span>();</span><br><span class="line">Singleton *s2 = Singleton::<span class="built_in">instance1</span>();</span><br><span class="line"><span class="keyword">delete</span> s1;</span><br><span class="line"><span class="keyword">delete</span> s2;</span><br></pre></td></tr></table></figure><br>结果发现有两个构造函数，而且无法析构。</p>
<h3 id="有缺陷的懒汉模式"><a href="#有缺陷的懒汉模式" class="headerlink" title="有缺陷的懒汉模式"></a>有缺陷的懒汉模式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">LazyInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!m)</span><br><span class="line">            m = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Singleton</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;单例析构&quot;</span>&lt;&lt;endl;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;单例构造&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton &amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;)=<span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Singleton* m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在类外要初始化静态变量： SingleTon* SingleTon::instance = nullptr;</span></span><br><span class="line">Singleton* s = Singleton::<span class="built_in">LazyInstance</span>();</span><br><span class="line">std::cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">Singleton* s2 = s;</span><br><span class="line">std::cout&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line"><span class="keyword">delete</span> s;</span><br><span class="line"><span class="comment">// delete s2;   不能这样，否则二次析构</span></span><br></pre></td></tr></table></figure><br>s和s2的内存地址相同，说明是单例。但类中只负责new出对象，却没有负责delete对象，结果发现只调用一次构造函数，还需要手动<code>delete s</code>。可以用智能指针修正</p>
<p>如果有两个线程，假设pthread_1刚判断完 intance 为NULL 为真，准备创建实例的时候，切换到了pthread_2, 此时pthread_2也判断intance为NULL为真，创建了一个实例，再切回pthread_1的时候继续创建一个实例返回，那么此时就不再满足单例模式的要求</p>
<h3 id="双检锁-智能指针的懒汉模式"><a href="#双检锁-智能指针的懒汉模式" class="headerlink" title="双检锁+智能指针的懒汉模式"></a>双检锁+智能指针的懒汉模式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> boost::unique_ptr&lt;SingleTon&gt; Ptr;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Ptr <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(instance==<span class="literal">nullptr</span>)</span><br><span class="line">                instance = boost::shared_unique&lt;SingleTon&gt;(<span class="keyword">new</span> SingleTon);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">SingleTon</span>()&#123; <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;destruct&quot;</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleTon</span>()&#123; <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;construct&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">SingleTon</span>(<span class="keyword">const</span> SingleTon&amp; s)&#123;&#125;</span><br><span class="line">    SingleTon&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SingleTon&amp; s)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> std::mutex m_mutex;</span><br><span class="line">    <span class="keyword">static</span> Ptr instance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改用智能指针做静态类型，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在类外要初始化静态变量: SingleTon::Ptr SingleTon::instance = nullptr;</span></span><br><span class="line">SingleTon::Ptr s = SingleTon::<span class="built_in">getInstance</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; s.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">SingleTon::Ptr s1 = SingleTon::<span class="built_in">getInstance</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; s1.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>
<p>结果二者地址相同，也运行了析构函数。  加了锁，使用互斥量来达到线程安全。这里使用了两个if判断语句的技术称为<strong>双检锁</strong>；好处是，只有判断指针为空的时候才加锁，避免每次调用<code>getInstance</code>的方法都加锁，锁的开销毕竟还是有点大的。</p>
<p>缺点：使用智能指针会要求用户也得使用智能指针；使用锁也有开销; 同时代码量也增多了；在某些平台，双检锁会失效</p>
<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>优点：不需要加锁，执行效率高，线程安全的</p>
<p>缺点：初始化即实例化，浪费内存<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singelton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="built_in">Singelton</span>()&#123;&#125;</span><br><span class="line">      <span class="keyword">static</span> Singelton *single;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">static</span> Singelton *<span class="title">GetSingelton</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 饿汉模式的关键：初始化即实例化</span></span><br><span class="line">Singelton *Singelton::single = <span class="keyword">new</span> Singelton;</span><br><span class="line"></span><br><span class="line"><span class="function">Singelton *<span class="title">Singelton::GetSingelton</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不再需要进行实例化</span></span><br><span class="line">    <span class="comment">//if(single == nullptr)&#123;</span></span><br><span class="line">    <span class="comment">//    single = new Singelton;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">return</span> single;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Meyers模式"><a href="#Meyers模式" class="headerlink" title="Meyers模式"></a>Meyers模式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> App SingleTon::MeyersInstance()</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SingleTon&amp; <span class="title">MeyersInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SingleTon s;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式所用到的特性是在C++11标准中的<strong>Magic Static</strong>特性。如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。这样保证了并发线程在获取静态局部变量的时候一定是初始化过的，所以具有线程安全性。</p>
<p>在 MeyersInstance() 函数内定义局部静态变量的好处是,构造函数只会在第一次调用MeyersInstance() 时被初始化, 保证了成员变量和 Singleton 本身的初始化顺序。<br>它还有一个潜在的安全措施, MeyersInstance() 返回的是对局部静态变量的引用, 如果返回的是指针, MeyersInstance() 的调用者很可能会误认为他要检查指针的有效性, 并负责销毁。</p>
<h3 id="Qt中的全局指针"><a href="#Qt中的全局指针" class="headerlink" title="Qt中的全局指针"></a>Qt中的全局指针</h3><p>Qt里有一个全局指针<code>qApp</code>，在任意地方都能使用，看看是不是单例模式。</p>
<p>QApplication中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> qApp (static_cast<span class="meta-string">&lt;QApplication *&gt;</span>(QCoreApplication::instance()))</span></span><br></pre></td></tr></table></figure></p>
<p>QCoreapplication中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  qApp  QCoreApplication::instance()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> QCoreApplication  *<span class="title">instance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> QCoreApplication  *self;</span><br><span class="line"></span><br><span class="line"><span class="comment">//源文件中</span></span><br><span class="line">QCoreApplication *QCoreApplication::self = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">QCoreApplication::<span class="built_in">QCoreApplication</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">d_func</span>()-&gt;q_ptr = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">d_func</span>()-&gt;<span class="built_in">init</span>();</span><br><span class="line">    QCoreApplicationPrivate::eventDispatcher-&gt;<span class="built_in">startingUp</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就是 d_func()-&gt;init();</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QCoreApplicationPrivate::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="built_in">Q_ASSERT_X</span>(!QCoreApplication::self, <span class="string">&quot;QCoreApplication&quot;</span>, <span class="string">&quot;there should be only one application object&quot;</span>);</span><br><span class="line">    QCoreApplication::self = q;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从QCoreapplication来看，qApp是个宏，实际是函数<code>QCoreApplication::instance()</code>，QCoreApplication这个类十分关键，构造函数肯定不能是private。从这个self来看，特别像懒汉模式，self是在QCoreApplication构造函数里赋值，赋给它的q指针实际就是QCoreApplication的this指针。</p>
<p>但是在程序里使用qApp，你会发现其地址都一样，也就是同一个全局指针，这就在于Q_ASSERT_X这句限定了只能有一个QCoreApplication对象，再加上拷贝构造函数和赋值运算符都在QObject限定为private，因此<strong>qApp也是一种单例模式</strong>。所以我们可以说单例模式不一定限定构造和析构是private，这个使用了Qt特有的d指针和q指针，技巧性太高，还是用meyers模式吧</p>
<h3 id="ROS中的单例模式"><a href="#ROS中的单例模式" class="headerlink" title="ROS中的单例模式"></a>ROS中的单例模式</h3><p>看ROS源码中的类<code>TopicManager</code>，它用到了单例模式，我模仿写了一个类如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> boost::shared_ptr&lt;SingleTon&gt; SingleTonPtr;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Ptr SingleTon::getInstance()</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SingleTon</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> SingleTonPtr&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> SingleTonPtr f = boost::make_shared&lt;SingleTon&gt;();</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot; out put &quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>结果发现构造函数只能是public，如果是private，就会报错，原因在<code>make_shared</code>中。这样一来就不能实现单例了，看来这种做法不可行。</p>
<p><br></p>
<p>参考:<a target="_blank" rel="noopener" href="https://blog.csdn.net/crayondeng/article/details/24853471">探究 C++ Singleton（单例模式）</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/07/22/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E4%BA%94%E5%A4%A7cast%E8%BD%AC%E5%9E%8B/">五大cast转型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><ul>
<li>const_cast是唯一能将const性质转化掉的操作符，但执行其他任何类型的转换都会引起编译错误。</li>
</ul>
<p>单纯的把常量转为变量是没多少意义的，也就是这种代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> con =<span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> cc= <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(con);</span><br></pre></td></tr></table></figure><br>直接用变量或者mutable就好了。</p>
<p>如果定义了一个非const的变量，却使用了一个指向const值的指针来指向它（不规范的风格），在程序的某处我们想改变这个变量的值了，但手头只持有指针，这是const_cast就可以用到了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> constant = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* const_p = &amp;constant;</span><br><span class="line"><span class="keyword">int</span>* modifier = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(const_p);</span><br><span class="line">*modifier = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><br>这并不是一个好的设计，还是应该遵从这样的原则：使用<code>const_cast</code>去除const限定的目的绝对不是为了修改它的内容，只是出于无奈，所以最好少用转型。</p>
<p>如果有一个函数，它的形参是non-const类型变量，而且函数不会对实参的值进行改动，这时我们可以使用类型为const的变量来调用函数，也就用到const_cast了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputInt</span><span class="params">(<span class="keyword">int</span> * num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;*num&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> constant = <span class="number">21</span>;</span><br><span class="line">    <span class="built_in">InputInt</span>(<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;constant));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>dynamic_cast用于类继承层次间的 <font color = blue size=4>指针或引用 </font>的转换。和<code>qobject_cast</code>类似，用于执行<strong>安全的向下转型</strong></p>
<p><code>dynamic_cast</code> <font color = blue size =3> 只能用于含有虚函数的类，虚函数表是是dynamic_cast操作符转换能够进行的前提条件。虚表的最前面是指向 type_info 的指针，包含了类的继承信息、类的描述等。能否转换成功，所依据的就是<code>type_info</code>。</font>如果转换失败，new_type 是指针，那么将返回NULL；如果 new_type 是引用，那么将抛出异常 std::bad_cast</p>
<p>向下转型有两种情况。一种是基类指针指向派生类的对象，这种转换是安全的；另一种是基类指针所指对象为基类类型，在这种情况下dynamic_cast在<strong>运行时做类型检查</strong>，转换失败，返回结果为0</p>
<p>最常用的情况是这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base* bb = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">Derive* dd = <span class="keyword">dynamic_cast</span>&lt;Derive*&gt;(bb);</span><br><span class="line">dd-&gt;<span class="built_in">test</span>();</span><br></pre></td></tr></table></figure><br>如果没有虚函数，会报错: <font color = orange size=4>error: C2683: “dynamic_cast”:“Base”不是多态类型 </font></p>
<p>dynamic_cast在基类和派生类指针之间转换时，会<strong>遍历整个继承体系进行类型检查</strong>,因此dynamic_cast时间和空间代价较高。比如4级的继承结构，<code>dynamic_cast&lt;Base&gt;</code>将会调用4次才能确定最终的那个子类型，<strong>尤其避免连续使用转型</strong>，用虚函数代替这种情况。</p>
<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>类似于C风格的强制转换。无条件转换，静态类型转换。用于：</p>
<ul>
<li><p>子类转换为父类：其中子类指针转换成父类指针是安全的；但父类指针转换成子类指针是不安全的，此时用dynamic_cast</p>
</li>
<li><p>基本数据类型转换，例如double, int, char, float等，不能进行无关类型（如非基类和子类）指针之间的转换。</p>
</li>
<li><p><code>void*</code> 转换为某类型指针</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">1.999</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(a); 	<span class="comment">//相当于a = b ;</span></span><br></pre></td></tr></table></figure>
<p>大多数的编译器都会给出一个警告：从“double”转换到“int”，可能丢失数据。<code>static_cast</code>可以明确告诉编译器，这种损失精度的转换是在知情的情况下进行的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">1.999</span>;</span><br><span class="line"><span class="keyword">void</span> * vptr = &amp; a;</span><br><span class="line"><span class="keyword">double</span> * dptr = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(vptr);</span><br><span class="line">cout&lt;&lt; *dptr &lt;&lt;endl;		<span class="comment">//输出 1.999</span></span><br></pre></td></tr></table></figure>
<p>从这里能看出，static_cast进行的是简单粗暴的转换，<strong>static_cast不做运行时的类型检查以保证转换的安全性</strong>，所以static_cast不如dynamic_cast安全，其正确性完全由程序员自己保证。</p>
<h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>十分危险，平时不要使用。</p>
<ul>
<li><p>从底层对数据进行重新解释，依赖具体的平台，可移植性差</p>
</li>
<li><p>可以在指针和引用随意的转换</p>
</li>
<li><p>可以将整型转换为指针，也可以把指针转换为数组</p>
</li>
</ul>
<h2 id="qobject-cast"><a href="#qobject-cast" class="headerlink" title="qobject_cast"></a>qobject_cast</h2><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/dbzhang800/article/details/6665298">qobject_cast 分析及QTBUG 20616</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/07/21/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/">静态绑定和动态绑定</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><p>对于非虚成员函数，Ｃ++是静态绑定的，而虚函数都是动态绑定，如此才可实现多态性。这也是Ｃ++语言和其它语言Java, Python的一个显著区别。</p>
<p>几个名词定义：</p>
<ul>
<li>静态类型：对象在声明时采用的类型，在编译期既已确定；</li>
<li>动态类型：通常是指一个指针或引用目前所指对象的类型，表现一个对象将会有什么行为，是在运行期决定的；</li>
<li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</li>
<li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</li>
</ul>
<p>看这样的代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_pub</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test_virtual</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Base::test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;base test&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Base::test_pub</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m = <span class="number">10</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;base test_pub&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Base::test_virtual</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;base virtual&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base *b = <span class="literal">NULL</span>;</span><br><span class="line">b-&gt;<span class="built_in">test</span>();</span><br><span class="line">b-&gt;<span class="built_in">test_pub</span>();</span><br><span class="line">b-&gt;<span class="built_in">test_virtual</span>();</span><br></pre></td></tr></table></figure><br>如果对三个函数分别测试，会发现只有<code>test()</code>能正常运行，后两个函数运行时会等待一小段时间，然后就返回了。</p>
<p>指针为空，仍然能正常运行test函数，这是因为代码进行了静态绑定，在编译期就确定了。那为什么<code>test_pub</code>不行？因为涉及到了this指针，也就是说这两个函数实际是这样的:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Base::test</span><span class="params">(Base* <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;base test&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Base::test_pub</span><span class="params">(Base* <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m = <span class="number">10</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;base test_pub&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果this指针是NULL，当然无法操作成员变量，所以报错。在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址（即this指针）作为一个隐含参数传递给函数。说白了，<code>test</code>函数传入了一个错误的参数，但又没用到这个参数，所以可以运行。但如果是静态函数，那么编译器不会给它传this指针。</p>
<p>这里对成员函数的解析，和查找对应的代码都是在编译阶段完成的，这就是所谓的静态绑定。只要函数不涉及this指针，空类指针也可以调用函数，<strong>C++只关心指针类型，不关心指针指向的对象是否有效，C++要求程序员自己保证指针的有效性</strong>，这也是为什么规范的代码经常会有<code>if(b!=NULL)</code>这样的语句。</p>
<p>那么<code>test_virtual</code>为什么也不能正常运行？<code>test_virtual</code>是虚函数，对它的调用只能等到运行期才能确定，然后才发现是空指针，无法运行。</p>
<p>参考：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/lizhenghn/p/3657717.html">C++中的静态绑定和动态绑定</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/07/21/C++/C++%20%20%E5%9F%BA%E7%A1%80/strcat%20%20strcpy%20%20strcmp%20/">strcat strcpy strlen strcmp</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E5%9F%BA%E7%A1%80/">C++ 基础</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/">面试笔试</a></span><div class="content"><h2 id="strcat"><a href="#strcat" class="headerlink" title="strcat"></a>strcat</h2><p>我自己写的是这样:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* _strcat(<span class="keyword">char</span> *_Dest, <span class="keyword">const</span> <span class="keyword">char</span> *_Source)</span><br><span class="line">&#123;</span><br><span class="line">    assert((_Dest != <span class="literal">NULL</span>) &amp;&amp; (_Source != <span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">char</span>* p= _Dest;</span><br><span class="line">    <span class="keyword">while</span>(*p!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* temp = _Source;</span><br><span class="line">    <span class="keyword">while</span>( *temp!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p=*temp;</span><br><span class="line">        p++;</span><br><span class="line">        temp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _Dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>strcat</code>的源码如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">char *strcat(char *des, const char *src)</span><br><span class="line">&#123;</span><br><span class="line">	assert((des!=NULL) &amp;&amp; (src!=NULL));</span><br><span class="line">	char* address = des;</span><br><span class="line">	while(*des != &#x27;\0&#x27;)  // 移动到字符串末尾</span><br><span class="line">		++des;</span><br><span class="line">	while(*des++ = *src++)	//dest的下一个字符用src的下一个字符赋值</span><br><span class="line">		;</span><br><span class="line">	return address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>必须加assert判断，src指向的字符添加到dest所指向的结尾处，覆盖原来的<code>\0</code>，添加新的<code>\0</code>。二者所指的内存区不可重叠，并且<strong>dest要有足够的内存容纳src字符串</strong>，但源码也没有对此判断，所以它是危险的。注意其中dest不能指向常量区。</p>
<p>这样用是错的，p1指向了常量字符串:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *p1 = &quot;123&quot;;</span><br><span class="line">char *p2 = &quot;ABC&quot;;</span><br><span class="line">std::cout&lt;&lt;strcat(p1,p2)&lt;&lt;endl;</span><br></pre></td></tr></table></figure></p>
<p>改变连接的起始点:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char p1[4]=&quot;123&quot;;</span><br><span class="line">char p2[4]=&quot;ABC&quot;;</span><br><span class="line">std::cout&lt;&lt;strcat(p1+2,p2)&lt;&lt;endl;</span><br></pre></td></tr></table></figure><br>结果是<code>3ABC</code>。</p>
<p>以’\0’作为连接的标志:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char p1[40]=&quot;123\0abc&quot;;</span><br><span class="line">char p2[8]=&quot;ABC\0DEF&quot;;</span><br><span class="line">std::cout&lt;&lt;strcat(p1,p2)&lt;&lt;endl;</span><br></pre></td></tr></table></figure><br>结果是<code>123ABC</code>。</p>
<h2 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h2><p>函数源码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* _strcpy(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span><br><span class="line">&#123;</span><br><span class="line">    assert((dst!=<span class="literal">NULL</span>)&amp;&amp;(src!=<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">char</span>* p1 =dst;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p2 = src;</span><br><span class="line">    <span class="keyword">while</span>(*p1!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p1 = *p2;</span><br><span class="line">        p1++;</span><br><span class="line">        p2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数不安全，src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。<br>源指针所指的字符串内容是不能修改的，因此应该声明为 const 类型。与<code>strcat</code>相比，没有先移动到dst末尾。注意复制src到<code>\0</code>为止。</p>
<p>测试代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char s1[]=&quot;12345&quot;;</span><br><span class="line">char s2[]=&quot;abc&quot;;</span><br><span class="line">std::cout&lt;&lt;strcpy(s1,s2)&lt;&lt;endl;     //abc</span><br></pre></td></tr></table></figure><br>复制s2到s1时，以<code>\0</code>为准。</p>
<h2 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h2><p>我写的实现代码:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int _strlen(const char* s)</span><br><span class="line">&#123;</span><br><span class="line">    assert(s!=NULL);</span><br><span class="line">    char* p =s;</span><br><span class="line">    int n=0;</span><br><span class="line">    while(*p!=&#x27;\0&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        p++;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意指针不能为NULL，不统计最后的’\0’</p>
<h2 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h2><p>两个字符串的大小不能用关系运算符判断，应该用<code>strcmp(a,b)</code>，两个字符串相同时返回0，a&gt;b返回一个正值,否则返回负值.<br>从左向右逐个比较a,b中的字符，根据二者的ASCII值确定结果，如果二者一直相同，但字符串a长度较小，那么结果为负。<br>我用的编译器对正负的处理是1和-1，有的是ASCII的差值。<br>我是这样实现的:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int _strcmp(const char *dst, const char *src)</span><br><span class="line">&#123;</span><br><span class="line">    assert((dst!=NULL)&amp;&amp;(src!=NULL));</span><br><span class="line">    const char* p1 = dst;</span><br><span class="line">    const char* p2 = src;</span><br><span class="line">    while(*p1!=&#x27;\0&#x27; &amp;&amp; *p2!=&#x27;\0&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(*p1 &gt; *p2)</span><br><span class="line">            return 1;</span><br><span class="line">        else if(*p1 &lt; *p2)</span><br><span class="line">            return -1;</span><br><span class="line">        p1++;</span><br><span class="line">        p2++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(*p1!=&#x27;\0&#x27; &amp;&amp; *p2==&#x27;\0&#x27;)</span><br><span class="line">        return 1;</span><br><span class="line">    else if(*p1==&#x27;\0&#x27; &amp;&amp; *p2!=&#x27;\0&#x27;)</span><br><span class="line">        return -1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一种源码是这样的:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="comment">//两字符串相等的情况,如果两个字符串中所有的字符相等,则返回0  </span></span><br><span class="line">    <span class="keyword">while</span> (*s1 == *s2++)    <span class="comment">//两个字符相等  </span></span><br><span class="line">        <span class="keyword">if</span> (*s1++ == <span class="number">0</span>) <span class="comment">//达到字符串末尾  </span></span><br><span class="line">                <span class="keyword">return</span> (<span class="number">0</span>);  </span><br><span class="line">   <span class="comment">//不相等,则返回值为第一次不相等时的两字符之差  </span></span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)s1 - *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)--s2);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p>
<p>以上几个函数中的src全要加const限定，strcmp的两个参数都要加const</p>
<p>参考: <a target="_blank" rel="noopener" href="https://songlee24.github.io/2015/03/15/string-operating-function/"></a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/07/21/C++/C++%20%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6%E8%99%9A%E5%87%BD%E6%95%B0/">深入探究虚函数 (一)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/">C++</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></span><div class="content"><p>对基类和派生类如下使用:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base* ba = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">Derive *de = ba;</span><br></pre></td></tr></table></figure><br>反射性地会说ba是个基类指针，指向派生类对象。但是运行程序竟然报错了: <font color = orange size=4> error: C2440: “初始化”: 无法从<code>Base *</code> 转换为 <code>Derive *</code> 从基类型到派生类型的强制转换需要 dynamic_cast 或 static_cast </font>。也就是需要向下转型，为什么？ba不是指向派生类对象吗？</p>
<p>这就是虚函数的动态绑定，<font color = blue size=4> 在运行期才指向派生类对象，而在编译期还是基类指针，</font>不能赋给<code>de</code>，语法检查就过不了，当然报错了。 </p>
<p>我们一般说ba的静态类型是<code>Base*</code>，动态类型是<code>Derive*</code>。如果第一行改为<code>Base* ba</code>，那么静态类型是<code>Base*</code>，没有动态类型。</p>
<ul>
<li><p>所谓静态多态是指通过模板或者函数重载实现的多态，其在编译期确定行为。动态多态是指通过虚函数技术实现在运行期动态绑定的技术。</p>
</li>
<li><p>普通函数在编译时就确定了函数地址，但虚函数在运行时查询虚函数表，所以效率较低。</p>
</li>
<li><p>要正确实现虚函数，只能通过<strong>基类的指针或引用来指向派生类对象</strong></p>
</li>
<li><p>派生类重新实现基类中的虚函数，这就叫覆盖</p>
</li>
<li><p>成员虚函数不能有同名同参数的静态函数</p>
</li>
<li><p>多个虚函数对sizeof的计算相当于一个，因为它们都存在虚函数表里，虚函数表只对应一个虚指针，所以不会扩大占用内存</p>
</li>
</ul>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>基类有纯虚函数时，就是抽象类，抽象类无法实例化，也无法声明指针。派生类可以不实现这个纯虚函数，但这样就没有意义了。 基类中的纯虚函数其实也可以实现，但没有必要，因为派生类都会重新实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">testPureVirtual</span><span class="params">()</span> </span>= <span class="number">0</span>;	 <span class="comment">// 基类中声明纯虚函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Base::testPureVirtual</span><span class="params">()</span>		<span class="comment">// 基类中实现纯虚函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;base pure virtual test  &quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Derived::testPureVirtual</span><span class="params">()</span>		<span class="comment">// 派生类中实现虚函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base::<span class="built_in">testPureVirtual</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;derived pure virtual test&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">Derived d;</span><br><span class="line">d.<span class="built_in">testPureVirtual</span>();</span><br></pre></td></tr></table></figure>
<p>这里的代码在派生类中调用了基类中的纯虚函数，由于抽象类无法实例化，所以基类纯虚函数是不能直接调用的。</p>
<h3 id="不要重新定义继承而来的虚函数的默认参数值"><a href="#不要重新定义继承而来的虚函数的默认参数值" class="headerlink" title="不要重新定义继承而来的虚函数的默认参数值"></a>不要重新定义继承而来的虚函数的默认参数值</h3><p>绝对不要重新定义一个继承而来的virtual函数的缺省参数值，因为缺省参数值都是静态绑定（为了执行效率），而virtual函数却是动态绑定。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">test_virtual</span><span class="params">(<span class="keyword">int</span> i=<span class="number">0</span>)</span></span>;   <span class="comment">// 默认值为0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Base::test_virtual</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;base virtual  &quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_virtual</span><span class="params">(<span class="keyword">int</span> i=<span class="number">1</span>)</span></span>;     <span class="comment">// 默认值改为1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Derive::test_virtual</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;derive virtual  &quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还是那个常用的调用:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base* ba = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">ba-&gt;<span class="built_in">test_virtual</span>();</span><br></pre></td></tr></table></figure><br>结果竟然是:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">derive virtual  0   // 函数为派生类的，默认值为基类的</span><br></pre></td></tr></table></figure><br>原因在于虚函数是动态绑定的，但参数是静态绑定的，<font color = blue size=4> 覆盖虚函数时只能覆盖动态绑定的部分，所以不能改变参数。</font>虚函数的效率较差，如果对参数也进行动态绑定，那么对执行速度和编译器简易度不利，所以C++做了分开的处理。</p>
<h2 id="不能声明为虚函数的函数"><a href="#不能声明为虚函数的函数" class="headerlink" title="不能声明为虚函数的函数"></a>不能声明为虚函数的函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>首先明确一点，<font color = blue size=4>在编译期，编译器完成了虚表的创建，而虚指针在构造函数期间被初始化 </font></p>
<p>如果构造函数是虚函数，那必然需要通过虚指针来找到虚构造函数的入口地址，但是这个时候我们还没有把虚指针初始化。因此，构造函数不能是虚函数。</p>
<h3 id="內联函数"><a href="#內联函数" class="headerlink" title="內联函数"></a>內联函数</h3><p>编译期內联函数在调用处被展开，而虚函数在运行时才能被确定具体调用哪个类的虚函数。<strong>內联函数体现的是编译期机制，而虚函数体现的是运行期机制。</strong> 二者不是同一范畴的东西。</p>
<h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>静态成员函数和类有关，即使没有生成一个实例对象，也可以调用类的静态成员函数。而虚函数的调用和虚指针有关，虚指针存在于一个类的实例对象中，如果静态成员函数被声明成虚函数，那么调用成员静态函数时又如何访问虚指针呢。也就是说，<strong>静态成员函数与类有关，而虚函数与类的实例对象有关。</strong> 二者也不是同一范畴的东西。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态存在的3个必要条件：</p>
<ol>
<li>继承</li>
<li>函数的重写</li>
<li>父类引用或指针指向子类对象</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B0</span>    //基类<span class="title">BO</span>声明</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:     <span class="comment">//外部接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span>  <span class="comment">//虚成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B0 display0&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> :</span><span class="keyword">public</span> B0</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B1 display0&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试形参改为 B0&amp; ptr 或 B0* ptr</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(B0 ptr)</span>    <span class="comment">//普通函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ptr.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line">B0 b0;		<span class="comment">//声明基类对象</span></span><br><span class="line">B1 b1;		<span class="comment">//声明派生类对象</span></span><br><span class="line"><span class="built_in">fun</span>(b0);	<span class="comment">//调用基类B0函数成员</span></span><br><span class="line"><span class="built_in">fun</span>(b1);	<span class="comment">//调用派生类B1函数成员</span></span><br></pre></td></tr></table></figure>
<p>运行结果是<code>B0 display0  B0 display0</code>。<br>虚函数的动态绑定仅在 <strong>基类指针或引用</strong> 绑定派生类对象时发生，fun的形参不是指针而是对象，所以调用哪个版本的函数在编译时就已经确定。</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/lihao21/article/details/50688337">C++虚函数表剖析</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/LF_2016/article/details/52311227">深入C++对象模型&amp;虚函数表</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/61/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/61/">61</a><span class="page-number current">62</span><a class="page-number" href="/page/63/">63</a><a class="extend next" rel="next" href="/page/63/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2022/11/17/QOR8cePIS5NdDrK.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2023 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>