<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Charon Cheung"><meta name="copyright" content="Charon Cheung"><title>If you wish for peace, prepare for war | 沉默杀手</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Charon Cheung</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">465</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">42</span></a></div></div></div><nav id="nav" style="background-image: url(https://i.loli.net/2021/07/13/RCLw5Bx8aFPN74b.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默杀手</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">沉默杀手</div><div id="site-sub-title">If you wish for peace, prepare for war</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/07/11/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/tf2%E7%9A%84%E5%AD%A6%E4%B9%A0/">tf2的学习</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></span><div class="content"><p><strong>现在的ROS提倡使用tf2</strong></p>
<p><code>tf2</code>经过重新设计，只提供tf的关键功能，不涉及转换等函数。</p>
<p>tf_conversions.transformations.quaternion_from_euler(roll, pitch, yaw)</p>
<p>每个listener都有一个buffer储存所有tf广播发出的transforms，当广播发出transform时，需要花点时间(毫秒级)才会进入buffer，所以请求now的transform时，会有一小段时间差。</p>
<p>使用<code>tf2_ros::Buffer</code>的<code>lookupTransform()</code>函数可以获得tf树的指定时间的转换。常用的指定时间是<code>ros::Time(0)</code>和<code>ros::Time::now</code>，前者是<strong>缓冲区中最新可用的转换</strong>，后者就是当前的时间。对于now，由于时间差，可能出现报警<br><img src="https://i.loli.net/2020/07/13/4Gu9rg6FiszSJpn.png" alt=""></p>
<p>有时会出现报警： <font size=4 color = orange >Lookup would require extrapolation into the past </font></p>
<p>对于这个报警，我们有四种解决方法：</p>
<ol>
<li>完善lookupTransform的参数，增加ros::Duration(sec)，sec大于报警中的时间差即可</li>
<li>使用tf2_ros::Buffer的canTransform函数，有可用的变换了再获得</li>
<li>使用tf message filter</li>
<li>忽视这个报警，未成功获取的新transform会放弃</li>
</ol>
<p>一个比较优雅的程序是这样的:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;ros/ros.h&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;tf2_ros/transform_listener.h&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;geometry_msgs/TransformStamped.h&gt;</span></span><br><span class="line"></span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;tf_node&quot;</span>);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line">tf2_ros::Buffer buff;</span><br><span class="line"><span class="function">tf2_ros::TransformListener <span class="title">listener</span><span class="params">(buff)</span></span>;</span><br><span class="line">ros::Publisher pub = nh.advertise&lt;geometry_msgs::TransformStamped&gt;(<span class="string">&quot;transform&quot;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">400</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span>(nh.<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line">    geometry_msgs::TransformStamped trans;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ros::Time now = ros::Time::<span class="built_in">now</span>();</span><br><span class="line">       <span class="comment">// if(buff.canTransform(&quot;base_footprint&quot;,&quot;imu&quot;,now,</span></span><br><span class="line">        <span class="comment">// ros::Duration(0.03),NULL)</span></span><br><span class="line">        <span class="comment">// 30毫秒应该足够了</span></span><br><span class="line">        trans = buff.<span class="built_in">lookupTransform</span>(<span class="string">&quot;base_footprint&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;imu&quot;</span>, now, </span><br><span class="line">                         ros::<span class="built_in">Duration</span>(<span class="number">0.03</span>) );</span><br><span class="line">       <span class="comment">// else</span></span><br><span class="line">           <span class="comment">// ROS_WARN(&quot;no transform in buffer&quot;);</span></span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span> (tf2::TransformException &amp; ex) &#123;</span><br><span class="line">        <span class="built_in">ROS_WARN</span>(<span class="string">&quot;%s&quot;</span>, ex.<span class="built_in">what</span>());</span><br><span class="line">        ros::<span class="built_in">Duration</span>(<span class="number">1.0</span>).<span class="built_in">sleep</span>();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pub.<span class="built_in">publish</span>(trans);</span><br><span class="line">    rate.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>创建listener后，会接受tf2 transformations，对其缓存10秒。TransformListener对象应当是persist，否则cache不能填充。常见方法是让TransformListener对象作为类的成员变量。</p>
<p><code>lookupTransform</code>获取的是TransformStamped消息，最后发布出来。因为加了Duration，try catch可以去掉。</p>
<p>由于实际上加了Duration，所以得到的不是当前的，而是上一个“当前”。换句话说，想得到当前最新的transform其实是没有意义的，一般都用<code>ros::Time(0)</code>，Wiki上也是这么说的</p>
<p>怎么才知道我们修改后的程序有效了？一个是看程序运行后是否报警，还有就是echo transform话题，结果可以看到头部<br><img src="https://i.loli.net/2020/07/13/iyVx1GD7vpYdEuh.png" alt=""><br>只看seq和时间，如果增长一直很流畅，那就是修改生效了。如果修改还有问题，比如Duration时间太短，seq在增长一会后会有停顿，然后继续增长，这就是buffer里面空了，tf数据还没有插入到里面</p>
<h2 id="已知点在子坐标系中的坐标和父子坐标系的变换，求点在父坐标系的坐标"><a href="#已知点在子坐标系中的坐标和父子坐标系的变换，求点在父坐标系的坐标" class="headerlink" title="已知点在子坐标系中的坐标和父子坐标系的变换，求点在父坐标系的坐标"></a>已知点在子坐标系中的坐标和父子坐标系的变换，求点在父坐标系的坐标</h2><table><tr><td bgcolor=yellow> 用tf::transformPose更方便 </td></tr></table>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs::PointStamped point_in, point_out;</span><br><span class="line">point_in.header.frame_id = <span class="string">&quot;child&quot;</span>;</span><br><span class="line">point_in.header.seq = <span class="number">0</span>;</span><br><span class="line">point_in.header.stamp = ros::<span class="built_in">Time</span>(<span class="number">0</span>);</span><br><span class="line">point_in.point.x = <span class="number">2</span>;</span><br><span class="line">point_in.point.y = <span class="number">1</span>;</span><br><span class="line">point_in.point.z = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// buff跟上面的使用一样， 返回的point_out是point_in在 parent坐标系 的坐标</span></span><br><span class="line">point_out = buff.<span class="built_in">transform</span>(point_in, point_out, <span class="string">&quot;parent&quot;</span>, ros::<span class="built_in">Duration</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>使用这段程序前，必须在<code>find_package</code>里添加 <code>tf2-geometry-msgs</code>，否则编译不成功。如果没有，需要先安装这两个包：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依赖库，  即使目前有，也要安装，可能需要更新</span></span><br><span class="line">sudo apt-get install ros-kinetic-orocos-kdl</span><br><span class="line">sudo apt-get install ros-kinetic-tf2-geometry-msgs</span><br></pre></td></tr></table></figure></p>
<h2 id="手动实现-tf2-ros-Buffer-transform函数"><a href="#手动实现-tf2-ros-Buffer-transform函数" class="headerlink" title="手动实现 tf2_ros::Buffer::transform函数"></a>手动实现 tf2_ros::Buffer::transform函数</h2><p>也就是用程序实现上面的转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;test_tf&quot;</span>);</span><br><span class="line">ros::NodeHandle nh;</span><br><span class="line"></span><br><span class="line">tf2_ros::Buffer buff;</span><br><span class="line"><span class="function">tf2_ros::TransformListener <span class="title">listener</span><span class="params">(buff)</span></span>;</span><br><span class="line">geometry_msgs::TransformStamped transform =</span><br><span class="line">        buff.<span class="built_in">lookupTransform</span>(<span class="string">&quot;parent&quot;</span>,<span class="string">&quot;child&quot;</span>,ros::<span class="built_in">Time</span>(<span class="number">0</span>),ros::<span class="built_in">Duration</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;transform from parent to child  x: %f&quot;</span>,transform.transform.translation.x);</span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;transform from parent to child  y: %f&quot;</span>,transform.transform.translation.y);</span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;transform from parent to child  z: %f\n&quot;</span>,transform.transform.translation.z);</span><br><span class="line"></span><br><span class="line">geometry_msgs::PointStamped point_in, point_out;</span><br><span class="line">point_in.header.frame_id = <span class="string">&quot;child&quot;</span>;</span><br><span class="line">point_in.header.seq = <span class="number">0</span>;</span><br><span class="line">point_in.header.stamp = ros::<span class="built_in">Time</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 在 child 坐标系中的点</span></span><br><span class="line">point_in.point.x = <span class="number">2</span>;</span><br><span class="line">point_in.point.y = <span class="number">1</span>;</span><br><span class="line">point_in.point.z = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;point in child: 2, 1, 4\n&quot;</span>);</span><br><span class="line">point_out = buff.<span class="built_in">transform</span>(point_in, point_out, <span class="string">&quot;parent&quot;</span>, ros::<span class="built_in">Duration</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;point int parent, x: %f&quot;</span>,point_out.point.x);</span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;point int parent, y: %f&quot;</span>,point_out.point.y);</span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;point int parent, z: %f\n&quot;</span>,point_out.point.z);</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">Eigen::Quaterniond <span class="title">quaternion</span><span class="params">(transform.transform.rotation.w,</span></span></span><br><span class="line"><span class="params"><span class="function">                              transform.transform.rotation.x,</span></span></span><br><span class="line"><span class="params"><span class="function">                              transform.transform.rotation.y,</span></span></span><br><span class="line"><span class="params"><span class="function">                              transform.transform.rotation.z</span></span></span><br><span class="line"><span class="params"><span class="function">                              )</span></span>;</span><br><span class="line">Eigen::Matrix3d rotation = quaternion.<span class="built_in">matrix</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;rotation matrix: &quot;</span> &lt;&lt;endl&lt;&lt; rotation &lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">Eigen::Matrix4d m;</span><br><span class="line">m.<span class="built_in">block</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>) = rotation;</span><br><span class="line"></span><br><span class="line">Eigen::Vector4d Vcol, Vrow;</span><br><span class="line">Vcol &lt;&lt; transform.transform.translation.x,</span><br><span class="line">        transform.transform.translation.y,</span><br><span class="line">        transform.transform.translation.z, <span class="number">1</span>;</span><br><span class="line">m.<span class="built_in">col</span>(<span class="number">3</span>) = Vcol;</span><br><span class="line"></span><br><span class="line">Vrow &lt;&lt; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>;</span><br><span class="line">m.<span class="built_in">row</span>(<span class="number">3</span>) = Vrow.<span class="built_in">transpose</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;transform matrix: &quot;</span>&lt;&lt;endl&lt;&lt; m&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">Eigen::Vector4d point;</span><br><span class="line">point &lt;&lt; point_in.point.x,</span><br><span class="line">         point_in.point.y,</span><br><span class="line">         point_in.point.z, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Eigen::Vector4d transformed_point = m * point;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;transformed point: &quot;</span>&lt;&lt;endl&lt;&lt;transformed_point.<span class="built_in">head</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>我们已知parent-child的变换，首先需要从位移和欧拉角获得<strong>齐次变换矩阵</strong>，把point_in变换为齐次坐标，然后左乘齐次矩阵，再取结果的前三个元素。  <font color = blue size=4>tf变换的本质就是左乘变换矩阵 </font></p>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> tf2::Transform::<span class="built_in">setIdentity</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Matrix3x3 m_basis;</span></span><br><span class="line">    m_basis.<span class="built_in">setIdentity</span>();   <span class="comment">// 单位矩阵</span></span><br><span class="line">    <span class="comment">// Vector3   m_origin;</span></span><br><span class="line">    m_origin.<span class="built_in">setValue</span>(<span class="built_in">tf2Scalar</span>(<span class="number">0.0</span>), <span class="built_in">tf2Scalar</span>(<span class="number">0.0</span>), <span class="built_in">tf2Scalar</span>(<span class="number">0.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Transform::<span class="keyword">operator</span>*(<span class="keyword">const</span> Transform&amp; t) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Transform</span>(m_basis * t.m_basis, </span><br><span class="line">               (*<span class="keyword">this</span>)(t.m_origin)  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<br><a target="_blank" rel="noopener" href="http://docs.ros.org/indigo/api/tf2_ros/html/c++/classtf2__ros_1_1Buffer.html">tf2_ros::Buffer Class</a><br><a target="_blank" rel="noopener" href="http://wiki.ros.org/tf2/Tutorials/Using%20stamped%20datatypes%20with%20tf2%3A%3AMessageFilter">tf2_ros::MessageFilter</a><br><a target="_blank" rel="noopener" href="http://docs.ros.org/melodic/api/tf2_ros/html/c++/classtf2__ros_1_1BufferInterface.html#a221071b82eb6a887fcea5c0223a25b1f">tf2_ros::BufferInterface</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhchp-blog/p/7203079.html">using “tf2” to transform coordinates</a></p>
<p><a target="_blank" rel="noopener" href="https://www.guyuehome.com/4463">古月学院：位置角度平移旋转，“乱七八糟”的坐标变换</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/07/11/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/(%E4%BA%94)%20trajectory_builder_2d%E5%8F%82%E6%95%B0/">(五) 前端 trajectory_builder_2d.lua 参数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/">原理和配置</a></span><div class="content"><p>Local SLAM的工作是建立一系列的子图。每一个子图是局部一致的，但是可以接受它随着时间会发生漂移。</p>
<p>when the scan matching is bad, nothing much will save you. </p>
<p>本文件中，距离的单位： 米， 角度的单位： 度，时间的单位： 秒</p>
<h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use_imu_data = <span class="literal">true</span>,</span><br><span class="line">min_range = 0.,</span><br><span class="line">max_range = 30.,</span><br><span class="line"><span class="comment"># 设置雷达数据在z轴上的滤波将3d数据转成2d的</span></span><br><span class="line">min_z = -0.8,</span><br><span class="line">max_z = 2.,</span><br><span class="line"></span><br><span class="line">missing_data_ray_length = 5.,</span><br><span class="line">num_accumulated_range_data = 1,</span><br><span class="line"><span class="comment"># 使用voxel滤波时立方体边长的大小，这个值是固定的</span></span><br><span class="line">voxel_filter_size = 0.025,</span><br></pre></td></tr></table></figure>
<ul>
<li>use_imu_data： 进行2D SLAM时，Cartographer的默认配置是使用imu的，如果不想要imu就要<code>TRAJECTORY_BUILDER_2D.use_imu_data = false</code>。在源码<code>LocalTrajectoryBuilder2D::AddRangeData</code>中可以看到，如果设置为false，会直接初始化位姿估计器；如果设置为true，会等收到imu数据后初始化位姿估计器，如果没有启动imu程序，Cartographer会一直等待imu的数据而无法进行。</li>
</ul>
<p>如果不用imu的话，构图的时候一定要移动的很慢，使用了imu就可以让小车飞快的跑。</p>
<p>对于3D雷达没有这个选项，3D SLAM必须使用imu，因为它提供了重力的精确方向和激光方向的一个初始猜测值，巨大地减少了scan matching的复杂度</p>
<ul>
<li>从min_range到max_z： 相当于带通滤波，减少传感器的噪声，z用于3D SLAM，在源码的<code>sensor::CropRangeData</code>函数。<code>min_range</code>和<code>max_range</code>用于局部地图下的激光点测量范围。</li>
</ul>
<ul>
<li>missing_data_ray_length: 官方的解释是 <font color = blue size=4> Points beyond ‘max_range’ will be inserted with this length as empty space.</font>这是用于处理miss集合的，但是我看了源码之后，有所疑惑。源码部分：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Eigen::Vector3f delta = hit_in_local.position - origin_in_local;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> range = delta.<span class="built_in">norm</span>();</span><br></pre></td></tr></table></figure>
<p>用<code>range</code>跟min<em>range和max_range比较，在范围内的插入`accumulated_range_data</em>.returns<code>；超出max_range的做如下处理</code>hit<em>in_local.position = origin_in_local + options</em>.missing_data_ray_length() / range * delta`</p>
<p>也就是相当于把<code>hit_in_local = origin + delta</code>变成了<code>hit_in_local = origin + missing_data_ray_length/delta.norm()  *  delta</code>，delta多了个因子。没看明白为什么这样计算，暂时让<code>missing_data_ray_length</code>小于<code>max_range</code>，这个参数显然跟雷达相关。</p>
<ul>
<li><p>num_accumulated_range_data： 每当累积的传感器数据数量超过了这个值，Cartographer才执行前端部分。从现象上看这和减少运动带来的雷达数据的畸变有关。Cartographer把<strong>num_accumulated_range_data</strong>个帧集合 (accumulate) 成一个大帧作为算法的输入。<br>Cartographer认为这每一帧都是独立的，以帧为单位补偿运动导致的激光雷达数据产生的畸变，然后再把这些帧集合到一块去。所以Cartographer接收到的数据帧的频率越高，Cartographer 的补偿效果越好，算法的输入数据质量越高。<br>当我设置为10后，雷达的scan更新很慢，跟不上机器人的运动，所以对2D雷达一般都设置为1。如果同时用两个雷达，每个的一帧激光用1个ROS消息，那么设置为2。 在源码中的<code>LocalTrajectoryBuilder2D::AddRangeData</code><br><img src="https://i.loli.net/2020/07/23/OK4GiwDsgtEUvaN.png" alt=""></p>
</li>
<li><p>voxel_filter_size: 离雷达较近的表面 (如路面) 经常得到更多采样点, 而远处的物体的采样点比较稀少。为了降低计算量，需要对点云数据进行下采样，简单的随机采样仍然会导致低密度区的点更少，而高密度区的点仍然比较多。<br>因此 cartographer 采用 voxel_filter (体素滤波) 的方法。通过输入的点云数据创建一个三维体素栅格（可把体素栅格想象为微小的空间三维立方体的集合），然后在每个体素内，用体素中所有点的重心来近似显示体素中其他点，这样该体素内所有点就用一个重心点表示，点云滤波后仍然保持之前的几何特征。<code>voxel_filter_size</code>即为立方体的大小。如果立方体较小的话会导致密集的数据，所耗的计算量更大。较大的话可能会导致数据丢失，但是计算速度会更快。</p>
</li>
</ul>
<h2 id="自适应的voxel滤波"><a href="#自适应的voxel滤波" class="headerlink" title="自适应的voxel滤波"></a>自适应的voxel滤波</h2><p>使用固定的voxel滤波之后，再使用自适应的voxel滤波，voxel_filter用于生成稀疏点云，以进行扫描匹配<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">adaptive_voxel_filter = &#123; </span><br><span class="line">	max_length = 0.5,       <span class="comment"># 尝试确定最佳的立方体边长，边长最大为0.5</span></span><br><span class="line">	<span class="comment"># 如果存在较多点，并且大于min_num_points，则减小体素长度以尝试获得该最小点数</span></span><br><span class="line">  <span class="comment"># 如果point_cloud.size()小于该参数则返回，说明点云已经够稀疏了</span></span><br><span class="line">	min_num_points = 200,</span><br><span class="line">	max_range = 50.,        <span class="comment"># 距远离原点超过max_range 的点被移除 </span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment"># 用于生成稀疏点云 以进行 闭环检测</span></span><br><span class="line">loop_closure_adaptive_voxel_filter = &#123;</span><br><span class="line">	max_length = 0.9,       </span><br><span class="line">	min_num_points = 100,</span><br><span class="line">	max_range = 50.,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><br>在提供了定大小的 voxel_filter, Cartographer 还提供了一个<code>adaptive_voxel_filter</code>, 可以在最大边长<code>adaptive_voxel_filter.max_length</code>的限制下优化确定<code>voxel_filter_size</code>来实现目标的points数<code>adaptive_voxel_filter.min_num_points</code>。在3D中，使用两个自适应的体素滤波器来生成一个更高分辨率和一个低分辨率的点云，其使用方法在Local SLAM.</p>
<p><code>adaptive_voxel_filter</code>的参数不是没用，我调整<code>max_length=3</code>之后，地图中出现了这样的情况：<br><img src="https://i.loli.net/2020/09/09/IolnedbQ7mrCRhD.png" alt="错位.png"><br>改成2就好了，默认的1也行</p>
<h2 id="两个scan-matcher"><a href="#两个scan-matcher" class="headerlink" title="两个scan matcher"></a>两个scan matcher</h2><p>一旦从大量雷达数据中经过assemble和两个filter得到scan，就可以用于Local SLAM。Local SLAM从<code>pose extrapolator</code>获得一个<strong>初值</strong>，通过scan matching把一个新的scan插入到当前的子图中。<code>pose extrapolator</code>的原理就是使用雷达外的其他传感器(即里程计和IMU)预测下一个scan应该被插入到submap的位置。</p>
<p>有2种解决scan match问题的方法：</p>
<ul>
<li><p><code>CeresScanMatcher</code>以初值作为先验，并找到最佳的点，该点就是通过scan match获得的在子地图中的位置，实现方式是interpolating the submap and sub-pixel aligning the scan. 这种方式的速度很快，计算复杂度高，鲁棒性好，但不能修正比子图分辨率大很多的误差。如果你的传感器和时间戳是合理的，只使用CeresScanMatcher通常是最好的选择。</p>
</li>
<li><p>如果你没有其他传感器或你不信任它们的精度，Cartographer还提供了一个<code>RealTimeCorrelativeScanMatcher</code>。它使用类似于在回环检测中激光与子地图匹配的方式，但是它是与当前子地图进行匹配，然后最好的匹配用作CeresScanMatcher的先验。这个scan matcher非常消耗资源，基本上会override雷达之外的其他传感器的信号，但它在特征丰富的环境中是很鲁棒。</p>
</li>
</ul>
<h3 id="real-time-correlative-scan-matcher"><a href="#real-time-correlative-scan-matcher" class="headerlink" title="real_time_correlative_scan_matcher"></a>real_time_correlative_scan_matcher</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">use_online_correlative_scan_matching = <span class="literal">false</span>,</span><br><span class="line">real_time_correlative_scan_matcher = </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment"># 找到最佳扫描匹配的  最小线性搜索窗口</span></span><br><span class="line">  linear_search_window = 0.1,</span><br><span class="line">  <span class="comment"># 找到最佳扫描匹配的  最小角度搜索窗口</span></span><br><span class="line">  angular_search_window = math.rad(20.),</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 用于计算各部分score的权重，如果一个平台的瞬间平移很少，</span></span><br><span class="line">  <span class="comment"># 则可以降低平移的权重，旋转也是一样</span></span><br><span class="line">  <span class="comment"># 源码在 ScoreCandidates</span></span><br><span class="line">  translation_delta_cost_weight = 1e-1,</span><br><span class="line">  rotation_delta_cost_weight = 1e-1,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><code>use_online_correlative_scan_matching = true</code>，这一项配置很重要，如果不配置这项得到的建图效果将非常差。如果这项为false，则扫描匹配使用的是通过前一帧位置的先验，将当前scan与之前做对比，使用<strong>高斯牛顿法</strong> 迭代地求解最小二乘问题，求得当前scan的坐标变换；</p>
<p>如果这项为true，则使用<strong>实时的闭环检测</strong>的方法进行前端的扫描匹配，将当前scan在一定的搜索范围内搜索，范围为设定的平移距离及角度大小，然后在将scan插入到匹配的最优位置处。设置为true后，建图的效果非常好，<strong>即使建图有漂移也能够修正回去</strong>，但是计算复杂度非常高，很耗CPU</p>
<h3 id="ceres-scan-matcher"><a href="#ceres-scan-matcher" class="headerlink" title="ceres_scan_matcher"></a>ceres_scan_matcher</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将前一时刻的位姿作为先验，使用odom或者imu的数据提供初值，以确定scan的最优位姿</span></span><br><span class="line">ceres_scan_matcher = </span><br><span class="line">&#123;</span><br><span class="line">  occupied_space_weight = 1.,   <span class="comment"># 每个Cost因素的 尺度因子</span></span><br><span class="line">  translation_weight = 10., </span><br><span class="line">  rotation_weight = 40.,    </span><br><span class="line">  ceres_solver_options = &#123;</span><br><span class="line">    use_nonmonotonic_steps = <span class="literal">false</span>,</span><br><span class="line">    max_num_iterations = 20,</span><br><span class="line">    num_threads = 1,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><code>CeresScanMatcher</code>可以针对它的输入设置权重，体现了对数据的信任程度，这可以看作静态协方差，彼此之间不能相互比较。某种数据的权重越大，Cartographer在做scan matching时就更重视这种数据。数据有：<code>occupied space</code>(来自scan中的点), 来自<code>pose extrapolator</code>(或者RealTimeCorrelativeScanMatcher)的平移和旋转</p>
<h2 id="motion-filter"><a href="#motion-filter" class="headerlink" title="motion_filter"></a>motion_filter</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只有当scan的平移、旋转或者时间 超过阈值时，才会被加入到 submap 中，不超过则舍弃</span></span><br><span class="line">  motion_filter = &#123;</span><br><span class="line">    max_time_seconds = 5.,</span><br><span class="line">    max_distance_meters = 0.2,</span><br><span class="line">    max_angle_radians = math.rad(1.),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment"># 移动时通过imu观测10s，以确定重力的平均方向</span></span><br><span class="line">  imu_gravity_time_constant = 10.,</span><br></pre></td></tr></table></figure>
<p>为了避免每个子图插入太多的scan，一旦scan matcher发现两个scan之间有motion，它就会进入motion filter. 只要scan的motion达到一个参数要求，就会插入到<strong>当前子图</strong>，否则被抛弃。</p>
<p>代码在<code>LocalTrajectoryBuilder2D::InsertIntoSubmap</code>的开头，只调用一个函数<code>MotionFilter::IsSimilar</code></p>
<p>建图时会发现，如果机器人停着不动，过一段时间图会逐渐形成轮廓，边界变黑变粗，这就是<code>max_time_seconds</code>决定的，可以稍微降低。</p>
<p><code>imu_gravity_time_constant</code>为align重力的时间间隔，也是IMU一阶低通滤波中的滤波器常数，调用在<code>ImuTracker::AddImuLinearAccelerationObservation</code>，平时不必修改，如果要认真修改，最好使用Matlab理解一阶滤波算法</p>
<h2 id="submaps"><a href="#submaps" class="headerlink" title="submaps"></a>submaps</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 平时可能修改的只有 num_range_data</span></span><br><span class="line">submaps = </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment"># 每个submap的scan总数为num_range_data的2倍，前一半进行初始化而不匹配，后一半进行匹配</span></span><br><span class="line">  num_range_data = 90,</span><br><span class="line">  grid_options_2d = &#123;</span><br><span class="line">    grid_type = <span class="string">&quot;PROBABILITY_GRID&quot;</span>,</span><br><span class="line">    resolution = 0.05,   <span class="comment"># 栅格的尺寸</span></span><br><span class="line">  &#125;,</span><br><span class="line">  range_data_inserter = </span><br><span class="line">  &#123;</span><br><span class="line">    range_data_inserter_type = <span class="string">&quot;PROBABILITY_GRID_INSERTER_2D&quot;</span>,</span><br><span class="line">    probability_grid_range_data_inserter = &#123;</span><br><span class="line">      insert_free_space = <span class="literal">true</span>,</span><br><span class="line">      hit_probability = 0.55,   <span class="comment"># 占用,  &gt;= 0.5</span></span><br><span class="line">      miss_probability = 0.49,  <span class="comment"># 空闲,  &lt;= 0.5</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<ul>
<li>num_range_data： 子图由多少scan构成。<strong>这个参数对建图效果有很大影响，</strong> 可以试试<code>50~70</code>。当Local SLAM收到足够的雷达数据后，子图才算完整。Local SLAM会随时间而漂移，这就需要Global SLAM来解决了。</li>
</ul>
<p>子图必须足够小，<strong>使其内部的漂移低于分辨率</strong>，以便它们是局部正确的。另一方面，它们应该足够大以使loop closure能够正常工作。 对应得源码在<code>ActiveSubmaps2D::InsertRangeData</code></p>
<p>这个值与CPU有这样一种关系：值比较小(10)，CPU使用率比较稳定，但整体偏高；值大时，CPU平时使用率低，但会短暂爆增。如果再增大(140)，CPU长时间占用低，偶尔才出现一两次高峰。所以可以认为<font color = orange size=4> num_range_data越小，CPU占用的高峰越多，可能就是插入子图完成的时候增大CPU占用</font></p>
<ul>
<li><p>grid_type：submap存储雷达数据的格式，最常用的是概率栅格。在2D中，另一种是<strong>Truncated Signed Distance Fields (TSDF)</strong>. 源码在<code>ActiveSubmaps2D::CreateGrid</code></p>
</li>
<li><p>resolution: 栅格尺寸，常常是0.05。并不是越小越好，我在2000米的环境下设置为0.02，结果建图严重错位，全局优化也没有纠正过来，应该是算力不够了。设置为0.05，对后端参数不必特别设置，建图效果也很好。</p>
</li>
<li><p>range_data_inserter： 概率栅格把空间剪切成一个2D或者3D的表格，该表格的每一个cell有一个固定的大小，并包含了被构造(obstructed)的可能性。可能性是根据hits(测量范围数据)和misses(传感器和测量点之间的自由空间)来进行更新，hits和misses二者在占据概率计算中可能有不同的权重，该占据概率计算或多或少相信占据或者自由空间的测量。</p>
</li>
<li><p><code>insert_free_space</code>对应的源码在<code>CastRays</code>函数，是否处理miss事件，如果为 false，则free的栅格不会改变占用网格中的概率。  后两个参数在<code>ProbabilityGridRangeDataInserter2D</code>的构造函数中使用。</p>
</li>
</ul>
<p>概率栅格地图的Odds are updated according to “hits” (where the range data is measured) and “misses” (the free space between the sensor and the measured points)。可以根据对被占据 occupied 和 free space 的雷达数据的置信度，加减 hits 和 misses 的 weight 值（Both hits and misses can have a different weight in occupancy probability calculations giving more or less trust to occupied or free space measurements）。</p>
<p>在2D中，每个子图只有一个概率栅格地图被存储。在3D中，由于scan matching性能的原因，两个混合的概率栅格被使用，并分别应用了一个adaptive_voxel_filter。对于远距离测量，使用一个低分辨率的混合栅格；对于近距离测量，使用一个高分辨率的混合栅格；scan matching先使用低分辨率的点云来与低分辨率的栅格进行对齐，然后通过高分辨率的近处点云与高分辨率的 hybrid grid 对齐来 refine pose。</p>
<p>RViz插件可以观察子图，可以根据索引选择子图</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/07/11/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/%E9%85%8D%E7%BD%AE%E5%B0%8F%E5%BC%BA%E7%9A%84vncserver/">配置 vnc server</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/">ROS机器人</a></span><div class="content"><p>SSH是不带界面的协议，之前在机器人远程机配置vnc4server，从本地连接到远程机，希望能在远程机直接运行rviz以进行观测，不知道失败了多少次，今天又试了试，这次得到如下结果：<br><img src="https://i.loli.net/2020/07/11/ygLBFvqMCIOr8DR.png" alt="vnc4server环境加载rviz失败.png"><br>这是因为rviz是基于Qt和OpenGL的，但是vnc4server对OpenGL的支持有问题，所以报错</p>
<p>目前最好的就是x11vnc。这个程序不仅不收费，是开源的，而且还支持opengl程序，rviz之类的程序也可以正常打开了。</p>
<ol>
<li>安装x11vnc</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y x11vnc net-tools</span><br></pre></td></tr></table></figure>
<ol>
<li>设置访问密码</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo x11vnc -storepasswd /etc/x11vnc.pass</span><br></pre></td></tr></table></figure>
<p>按提示设置密码，密码一般放在<code>/home/user/.vnc/passwd</code></p>
<ol>
<li>创建服务文件</li>
</ol>
<p>在<code>/etc/init</code>下创建一个x11vnc.conf的文件，文件内容如下:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">description <span class="string">&quot;xiaoqiang vnc server&quot;</span></span><br><span class="line">start on runlevel [2345]</span><br><span class="line">stop on runlevel [06]</span><br><span class="line"></span><br><span class="line">respawn</span><br><span class="line">respawn <span class="built_in">limit</span> 20 5</span><br><span class="line"></span><br><span class="line">script</span><br><span class="line">    <span class="built_in">exec</span> /usr/bin/x11vnc -auth guess -capslock -forever -loop -noxdamage -repeat -rfbauth /etc/x11vnc.pass -rfbport 5900 -shared</span><br><span class="line">end script</span><br></pre></td></tr></table></figure></p>
<ol>
<li>启动服务: <code>sudo service x11vnc start</code></li>
</ol>
<p>一般来说，经过上面步骤就成功了。但是可能出现下面错误<br><img src="https://i.loli.net/2021/09/25/RwUnJkdHSKyox8p.png" alt="status running.png"><br><img src="https://i.loli.net/2021/09/25/WfPSG7OL3htRgNn.png" alt="failed for display.png"></p>
<p>其实上面一大堆配置都是为了开机启动，在<code>4</code>之前可以先手动运行，直接<code>x11vnc</code>即可，看输出的文本是否正常，端口有可能是5901，可以用<code>netstat</code>命令检查</p>
<p><img src="https://i.loli.net/2021/09/26/ThsztjCZrBSfckP.png" alt="手动启动x11vnc的结果"><br><img src="https://i.loli.net/2021/09/26/SDPplxQLKGFgVub.png" alt="Linux安装x11vnc server的结果"></p>
<p><img src="https://i.loli.net/2021/10/11/SqRCylFn4JYcd6a.png" alt="成功运行VNC的 netstat"></p>
<ol>
<li>客户端</li>
</ol>
<p>下载<a target="_blank" rel="noopener" href="https://www.realvnc.com/en/connect/download/viewer/">vnc viewer</a>，输入目标IP，端口5900，之后就可以正常连接了，比如<code>192.168.0.103:5900</code></p>
<p>如果在不插显示器使用rviz时还是报错，插上hdmi转vga的转接头（不接显示器，只是转接头）就可以打开正常使用了。在设置里面调整分辨率和比例</p>
<p>如果感觉VNC速度慢，可以禁用Compiz</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gftz-hww/p/14805765.html">ubuntu18.04安装x11vnc</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/07/06/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/(%E4%B8%89)%20%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/">(三) 常用参数配置</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/">原理和配置</a></span><div class="content"><p>launch 和 lua 配置文件都是在<code>install_isolated/share/cartographer_ros/launch/</code> 和 <code>install_isolated/share/cartographer_ros/configuration_files/</code> 下，所以如果只修改了cartographer_ros软件包中的launch 和 lua 文件之后是需要重新编译的，编译之后才能将修改的文件安装到install_isolated文件中。</p>
<p>从cartographer启动时输出的信息可知，我们自己的lua加载的其他lua有：<code>map_builder.lua</code>, <code>pose_graph.lua</code>, <code>trajectory_builder.lua</code>, <code>trajectory_builder_2d.lua</code>.  它们的路径都在<code>/usr/local/share/cartographer/configuration_files</code>。如果我们需要改这些基本lua的参数，可以在自己lua里覆盖地修改，直接改原文件不太好，它们的关系如下：<br><img src="https://i.loli.net/2020/07/07/cWHdEYj4VXK7ymL.png" alt=""></p>
<p><code>map_builder.lua</code>和<code>trajectory_build.lua</code>起着总领的作用，前者包括的<code>pose_graph.lua</code>为后端优化的具体参数配置； 后者是前端的参数配置，分为2d和3d两个文件。</p>
<p><code>cartographer_node</code>出现下面输出：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ScopedRosLogSink::send   line_51  submap_2d.cc:187 ] Added submap 1</span><br><span class="line">[ScopedRosLogSink::send   line_51  map_builder_bridge.cc:130 ] Added trajectory with ID <span class="string">&#x27;0&#x27;</span>.</span><br></pre></td></tr></table></figure></p>
<h2 id="自定义lua的参数"><a href="#自定义lua的参数" class="headerlink" title="自定义lua的参数"></a>自定义lua的参数</h2><p>我用的是<code>home.lua</code>， 先看options的内容，这是通用的参数。options块中定义的值定义了cartographer前端应当如何与机器人进行交互。  定义在options段后的值用于调试cartographer的内部信息</p>
<p>开头的<code>map_builder = MAP_BUILDER</code>和<code>trajectory_builder = TRAJECTORY_BUILDER</code>万年不变:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">map_builder = MAP_BUILDER,</span><br><span class="line">trajectory_builder = TRAJECTORY_BUILDER,</span><br><span class="line">map_frame = <span class="string">&quot;map&quot;</span>,</span><br><span class="line">tracking_frame = <span class="string">&quot;imu&quot;</span>,</span><br><span class="line">published_frame = <span class="string">&quot;odom&quot;</span>,</span><br><span class="line">odom_frame = <span class="string">&quot;odom&quot;</span>,</span><br><span class="line">provide_odom_frame = <span class="literal">false</span>,</span><br><span class="line">publish_frame_projected_to_2d = <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">use_odometry = <span class="literal">true</span>,</span><br><span class="line">use_nav_sat = <span class="literal">false</span>,</span><br><span class="line">use_landmarks = <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">num_laser_scans = 1,</span><br><span class="line">num_multi_echo_laser_scans = 0,</span><br><span class="line">num_subdivisions_per_laser_scan = 1,</span><br><span class="line">num_point_clouds = 0,</span><br><span class="line"></span><br><span class="line">lookup_transform_timeout_sec = 0.2,</span><br><span class="line">submap_publish_period_sec = 0.3,</span><br><span class="line">pose_publish_period_sec = 5e-3,  --频率可能比较高</span><br><span class="line">trajectory_publish_period_sec = 30e-3,</span><br><span class="line"></span><br><span class="line">rangefinder_sampling_ratio = 1.,</span><br><span class="line">odometry_sampling_ratio = 1.,</span><br><span class="line">fixed_frame_pose_sampling_ratio = 1.,</span><br><span class="line">imu_sampling_ratio = 1.,</span><br><span class="line">landmarks_sampling_ratio = 1.,</span><br></pre></td></tr></table></figure></p>
<h3 id="坐标系组"><a href="#坐标系组" class="headerlink" title="坐标系组"></a>坐标系组</h3><ul>
<li><p>map_frame: 用于发布submaps的ROS坐标系，也是位姿的父坐标系，通常是map</p>
</li>
<li><p>tracking_frame: 通常，如果使用IMU，就是<code>imu_link</code>; 如果不用IMU，可以用<code>laser</code>。博物馆的lua写的base_link</p>
</li>
<li><p>published_frame: 位姿子坐标系的ROS坐标系，例如”odom”坐标系，如果一个odom坐标系由系统的不同部分提供，在这种情况下，map_frame中的<code>odom</code>姿势将被发布。 否则，将其设置为<code>base_link</code>可能是合适的</p>
</li>
<li><p>provide_odom_frame: true 适用于机器人本身没有odom坐标系的情况，如果启用，将发布局部、非闭环、持续的位姿，也就是odom_frame在map_frame中的坐标</p>
</li>
<li>odom_frame: 在provide_odom_frame为true才启用，坐标系在published_frame和map_frame之间用于发布局部SLAM结果，通常是”odom”</li>
<li><p>use_odometry: 如果启用，会订阅关于odom话题(或者叫其他名字)的<code>nav_msgs/Odometry</code>消息。应当提供里程信息，这些信息包含在SLAM里</p>
</li>
<li><p>use_nav_sat: 是否使用gps数据。如果启用，将订阅<code>sensor_msgs/NavSatFix</code>的话题，比如fix. 应当提供导航数据，将用于全局SLAM</p>
</li>
<li>use_landmarks: 如果启用，订阅<code>cartographer_ros_msgs/LandmarkList</code>的话题，比如landmarks. 应当提供Landmarks信息，这些信息包含在SLAM里</li>
</ul>
<h3 id="num组"><a href="#num组" class="headerlink" title="num组"></a>num组</h3><p><code>Cartographer</code>可以订阅的主题有三种，我们一般用<code>scan</code>，还可以用<code>echoes</code>或<code>points2</code>，这三个是互斥的。分别对应lua中的<code>num_laser_scans</code>, <code>num_multi_echo_laser_scans</code>,<code>num_point_clouds</code>. </p>
<p>lua中将<code>num_laser_scans</code>设置为1，则<code>scan</code>将用作SLAM的输入，如果<code>num_laser_scans</code>大于1，则多个编号的扫描主题（即scan_1，scan_2，scan_3，……直到并包括num_laser_scans）将用作SLAM的输入.</p>
<p>同理，如果将<code>num_multi_echo_laser_scans</code>设置为１，则<code>echoes</code>做输入，但仅使用第一个回声，如果大于1，则多个编号的回声主题（即echoes_1，echoes_2，echoes_3，……直到并包括num_multi_echo_laser_scans）将用作SLAM的输入。<code>echoes</code>的消息类型为<code>sensor_msgs/MultiEchoLaserScan</code>，不同之处在于<code>sensor_msgs/LaserEcho[] ranges</code>和<code>sensor_msgs/LaserEcho[] intensities</code></p>
<font color = blue size=4> 首先需要雷达支持多echo，即每个脉冲发出以后，会有多个echo返回。我们知道一般雷达要避免扫描玻璃，因为laser会穿透过去，但多echo雷达不仅可以获得玻璃返回的echo，也能获得玻璃后面的墙返回的echo，这样我们就获得不同深度的信息，对建图定位的帮助更大。</font>

<p><code>points２</code>也是这样，消息类型<code>sensor_msgs/PointCloud2</code>，<code>num_point_clouds</code>适用于多线雷达，对于单线，设置为0</p>
<ul>
<li>num_subdivisions_per_laser_scan: 将雷达一帧的数据拆分成几次发出来，默认10。在<code>SensorBridge::HandleLaserScan</code>中调用, 对点云points细分。比如雷达scan有200束激光，本参数为10，那么转换成点云后，对点云取很多小段处理：(0,20)、(20,40)……(190,200)。 对于普通雷达来说，此处为1即可</li>
</ul>
<h3 id="period组"><a href="#period组" class="headerlink" title="period组"></a>period组</h3><ul>
<li>lookup_transform_timeout_sec: 使用tf2查找变换的超时秒数</li>
<li>submap_publish_period_sec: 发布submap的间隔</li>
<li>pose_publish_period_sec:  cartographer发布tf变换的间隔，例如5e-3，对应tf发布频率为200Hz</li>
<li>trajectory_publish_period_sec: 发布轨迹标记的时间间隔</li>
</ul>
<h3 id="ratio组"><a href="#ratio组" class="headerlink" title="ratio组"></a>ratio组</h3><p>5种观测的权重比</p>
<ul>
<li><p>rangefinder_sampling_ratio: Fixed ratio sampling for range finders messages.</p>
</li>
<li><p>odometry_sampling_ratio: Fixed ratio sampling for odometry messages. 如odom的数据非常不准，可以设置为0.3，以减小odom对整体优化的影响</p>
</li>
<li><p>fixed_frame_sampling_ratio: Fixed ratio sampling for fixed frame messages.</p>
</li>
<li><p>imu_sampling_ratio: Fixed ratio sampling for IMU messages.</p>
</li>
<li><p>landmarks_sampling_ratio: Fixed ratio sampling for landmarks messages.</p>
</li>
</ul>
<p>options结束后，一般有一句：<code>MAP_BUILDER.use_trajectory_builder_2d = true</code>，这是因为<code>map_builder.lua</code>中的这个参数设置为false了，我们在这里可以重新赋值，选择使用2D还是3D</p>
<h3 id="不使用机器人的IMU和Odom"><a href="#不使用机器人的IMU和Odom" class="headerlink" title="不使用机器人的IMU和Odom"></a>不使用机器人的IMU和Odom</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map_frame = <span class="string">&quot;map&quot;</span>,</span><br><span class="line">tracking_frame = <span class="string">&quot;base_footprint&quot;</span>,</span><br><span class="line">published_frame = <span class="string">&quot;base_footprint&quot;</span>,	</span><br><span class="line">odom_frame = <span class="string">&quot;odom&quot;</span>,</span><br><span class="line">provide_odom_frame = <span class="literal">true</span>,</span><br><span class="line">publish_frame_projected_to_2d = <span class="literal">false</span>,</span><br><span class="line">use_odometry = <span class="literal">false</span>,</span><br><span class="line">TRAJECTORY_BUILDER_2D.use_imu_data = <span class="literal">false</span>  --默认<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>进行2d slam时，carto的默认配置是使用imu的，所以如果没有imu就要<code>TRAJECTORY_BUILDER_2D.use_imu_data = false</code>，否则会一直等待imu的数据而进行不下去。而3D slam 必须使用imu，所以不必修改这个参数。</p>
<ul>
<li>为什么3D必须有IMU，而2D可以不用？</li>
</ul>
<p>在2D中，Cartographer支持运行相关的扫描匹配器，用于局部SLAM中寻找循环关闭的约束条件。它的计算代价很大，但通常会使odometry或IMU数据的加入变得不必要。2D也有假设平坦世界的好处，也就是说，上升是隐式定义的。<br>在三维中，IMU主要用于测量重力。重力在测量中是一个很有用的量，因为它不漂移，而且是一个非常强的信号，而且通常包含了大部分所要测量的加速度。</p>
<ul>
<li>屏蔽机器人的里程计</li>
</ul>
<p>如果我们不想使用轮式里程计， cartographer的lua无法屏蔽里程计，只能自己修改机器人的程序，不让它发布odom话题和<code>odom---&gt;base_footprint</code>的tf变换。如果不修改，使用时会发现tf变换一会儿由 cartographer发布，一会儿由机器人程序发布，<strong>千万不能由两个节点发布同一个tf变换，</strong>从rviz看上去，RobotModel和LaserScan摇晃地很厉害。</p>
<p>这里有一个技巧， <font color = blue size=4> 观察一个tf变换是否由两个节点发布，用rosrun tf view_frame是看不出来的，应该用rosrun rqt_tf_tree rqt_tf_tree，然后用刷新按钮观察。</font></p>
<font color = blue size=4> 如果不用IMU，Odom + Lidar在局部存在纠偏失败的可能。</font>

<h3 id="使用机器人的odom和imu，lua做如下设置"><a href="#使用机器人的odom和imu，lua做如下设置" class="headerlink" title="使用机器人的odom和imu，lua做如下设置:"></a>使用机器人的odom和imu，lua做如下设置:</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map_frame = <span class="string">&quot;map&quot;</span>,</span><br><span class="line">tracking_frame = <span class="string">&quot;imu&quot;</span>,</span><br><span class="line">published_frame = <span class="string">&quot;odom&quot;</span>,</span><br><span class="line">odom_frame = <span class="string">&quot;odom&quot;</span>,</span><br><span class="line">provide_odom_frame = <span class="literal">false</span>,</span><br><span class="line">publish_frame_projected_to_2d = <span class="literal">false</span>,</span><br><span class="line">use_odometry = <span class="literal">true</span>,</span><br></pre></td></tr></table></figure>
<p>一开始，我增加了参数<code>TRAJECTORY_BUILDER_2D.num_accumulated_range_data = 10</code>，结果出现了scan一直在转的情况，使用<code>tf_echo</code>  map和laser坐标系的关系，发现y位移一直在增大，但x z基本不变。去掉这个参数后，不再一直转了，但是过了几分钟还是有所偏，地图还出现了重影，这说明是机器人的里程计误差问题，需要校准，这个参数应该是放大了这种现象。</p>
<p>如果不想每过一段时间就校准，那么<code>odom</code>到<code>base_link</code>的tf就用cartographer的，因为它有重定位，累计误差比较小，而且可以得到修正</p>
<p>对是否使用odom的两套程序如下：<br><img src="https://i.loli.net/2020/07/15/xQBXdeTDlG9Mgmt.png" alt="不用odom的程序组合.png"></p>
<p><img src="https://i.loli.net/2020/07/15/4LaCfrFoxwA8291.png" alt="使用机器人odom的程序组合.png"><br>查看节点<code>cartographer_node</code>是否订阅了IMU和Odom，检查是否用到了它们</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p>使用IMU后，有时启动时会报警：<br><img src="https://i.loli.net/2020/07/05/Oe6mSACf71RvilY.png" alt="启动cartographer报错 1.png"><br><img src="https://i.loli.net/2020/07/05/jctZgfXP2Gqhusm.png" alt="启动cartographer报错 2.png"><br>出问题的代码在<code>cartographer::mapping::ImuTracker::AddImuLinearAccelerationObservation()</code>。启动一下imu程序，如果<code>rostopic echo /xqserial_server/IMU/linear_acceleration</code>就会发现，imu线加速度开始为0，过了一秒左右才有数据，这应该是节点通信的问题。所以cartographer读取到的线加速度全是0，在程序里就会报错。此时再重启就没事了</p>
</li>
<li><p>建图时地图围绕原点转圈，画出来的是一团黑，可能是用到的IMU的加速度有问题，需要校准IMU。还有可能是ceres的平移和旋转的权重没有进行重新配置。</p>
</li>
<li><p>如果出现下面的输出，一般是<code>scan</code>话题没有订阅到:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ WARN][/cartographer_node] [ScopedRosLogSink::send] line_55  W0711 <span class="number">20</span>:05:<span class="number">58.000000</span> <span class="number">12245</span> ordered_multi_queue.cc:<span class="number">155</span>] Queue waiting <span class="keyword">for</span> data: (<span class="number">0</span>, scan)</span><br></pre></td></tr></table></figure>
<p>正确的是这样：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ INFO][/cartographer_node] [ScopedRosLogSink::send] line_51  I0711 <span class="number">20</span>:<span class="number">14</span>:<span class="number">56.000000</span> <span class="number">25541</span> ordered_multi_queue.cc:<span class="number">172</span>] All sensor data <span class="keyword">for</span> trajectory <span class="number">0</span> <span class="keyword">is</span> available starting at <span class="string">&#x27;637300664959145564&#x27;</span>.</span><br></pre></td></tr></table></figure>
</li>
<li><p>常常启动后出现这个报警：<br><img src="https://i.loli.net/2020/07/11/Z52LHSFxUqphT6Y.png" alt="tf报警.png"><br>这其实是tf坐标系的问题，cartographer源码里lookupTransform写的不好，不管也可以，详细分析可见</p>
</li>
</ul>
<p><a href="https://charon-cheung.github.io/2020/07/11/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/tf%E6%8A%A5%E8%AD%A6%EF%BC%9ALookup%20would%20require%20extrapolation%20into%20the%20past/">tf报警：Lookup would require extrapolation into the past</a></p>
<ul>
<li>机器人在地图中的位置不稳定，有轻微摆动，tf_echo如下：</li>
</ul>
<p><img src="https://i.loli.net/2020/07/28/U3WKdLxVi8497RP.png" alt="base_footprint在map中的坐标.png"><br>yaw有跳变， 判断是里程计累计误差</p>
<ul>
<li><font color = blue size=4> cartographer对雷达频率要求比较高，20Hz以上比较好，当频率达到30hz时，做纯旋转运动时不会产生地图的偏移。因为只有频率越高，2帧间的时间越短，误差才能越小。</font>
</li>
<li><p>如果雷达比较差，地图边界会比较粗糙，用robosense雷达明显效果好</p>
</li>
</ul>
<h2 id="map-builder-lua-和-trajectory-builder-lua"><a href="#map-builder-lua-和-trajectory-builder-lua" class="headerlink" title="map_builder.lua 和 trajectory_builder.lua"></a>map_builder.lua 和 trajectory_builder.lua</h2><p>内容只有几行:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">&quot;pose_graph.lua&quot;</span></span><br><span class="line"></span><br><span class="line">MAP_BUILDER = &#123;</span><br><span class="line">  use_trajectory_builder_2d = <span class="literal">false</span>,</span><br><span class="line">  use_trajectory_builder_3d = <span class="literal">false</span>,</span><br><span class="line">  num_background_threads = 4,</span><br><span class="line">  pose_graph = POSE_GRAPH,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>map_builder.lua内容太简单了，配置是使用<code>trajectory_build_2d</code>还是<code>trajectory_build_3d</code>，以及后端使用的线程数。 <code>use_trajectory_builder_2d</code>在上面讲过改为true，其他一般不动，如果CPU性能好，可以增大<code>num_background_threads</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">&quot;trajectory_builder_2d.lua&quot;</span></span><br><span class="line">include <span class="string">&quot;trajectory_builder_3d.lua&quot;</span></span><br><span class="line"></span><br><span class="line">TRAJECTORY_BUILDER = &#123;</span><br><span class="line">  trajectory_builder_2d = TRAJECTORY_BUILDER_2D,</span><br><span class="line">  trajectory_builder_3d = TRAJECTORY_BUILDER_3D,</span><br><span class="line">  pure_localization = <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>trajectory_builder.lua</code>更简单，只有一个<code>pure_localization</code>区分是否使用carto用于机器人纯定位</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/07/02/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/%E7%BA%AF%E5%AE%9A%E4%BD%8D%E6%A8%A1%E5%BC%8F%20(%E4%B8%80)/">纯定位模式 (一)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/">原理和配置</a></span><div class="content">abstract Welcome to my blog, enter password to read.</div><a class="more" href="/2020/07/02/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/%E7%BA%AF%E5%AE%9A%E4%BD%8D%E6%A8%A1%E5%BC%8F%20(%E4%B8%80)/#more">Read more</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/30/%E8%A7%86%E8%A7%89SLAM/Realsense%20D435i%E5%85%B3%E9%97%ADIR%E7%BB%93%E6%9E%84%E5%85%89/">Realsense D435i关闭IR结构光</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%A7%86%E8%A7%89SLAM/">视觉SLAM</a></span><div class="content"><p>由于要做Realsense D435i的双目结构光相机标定，其中用到了ROS来录制数据包，但是结构光会影响标定，所以得先关闭IR结构光发射器。</p>
<h2 id="一次性关闭IR光"><a href="#一次性关闭IR光" class="headerlink" title="一次性关闭IR光"></a>一次性关闭IR光</h2><p>其实就是动态参数调整<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roslaunch realsense2_camera rs_camera.launch </span><br><span class="line">rosrun rqt_reconfigure rqt_reconfigure </span><br></pre></td></tr></table></figure><br><a target="_blank" rel="noopener" href="https://i.loli.net/2020/06/30/nxGBZTqfiQR31hj.png">rqt_reconfigure</a><br><code>emitter_enabled</code>有三项: Laser(1),  Laser Auto(2), Off(0)。 选Off即可</p>
<p>通过肉眼看相机发射器已经不再发射IR光了，打开rqt，找到<code>/camera/infra1/image_rect_raw</code>和<code>/camera/infra2/image_rect_raw</code>，发现确实没有白斑了。</p>
<h2 id="永久关闭"><a href="#永久关闭" class="headerlink" title="永久关闭"></a>永久关闭</h2><p>其实就是通过<code>realsense-viewer</code>，这个是驱动层面的操作，更加底层<br><img src="https://i.loli.net/2020/06/30/CGYw92XUWgnKb7c.png" alt="配置栏.png"></p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Hanghang_/article/details/103612300">Realsense D435i 关闭IR光</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/30/ROS/ROS%20Kinetic%E7%9F%A5%E8%AF%86/ROS%E7%9A%84topic_tools%E5%8C%85/">ROS的topic_tools包</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/">ROS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a></span><div class="content"><h2 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h2><p>转播 (relay)话题, 限制最大发布频率或者带宽。使用格式: <code>rosrun topic_tools throttle messages &lt;intopic&gt; &lt;msgs_per_sec&gt; [outtopic]</code></p>
<p>messages是当前使用的是throttle的messages模式,限制发布频率. intopic是指你想要改变频率的那个topic, msgs_per_sec是指你想要它发布的频率，而outtopic是指改变发布频率后的topic的名称，可以省略，<strong>如果省略则自动在原来topic的名字上后缀throttle</strong></p>
<p>另外还有bytes模式, 用以限制带宽: <code>rosrun topic_tools throttle bytes &lt;intopic&gt; &lt;bytes_per_sec&gt; &lt;window&gt; [outtopic]</code></p>
<p>例如，让雷达的带宽占用降至1KBps，则命令为：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun topic_tools throttle bytes base_scan 1024 1.0</span><br></pre></td></tr></table></figure></p>
<p>改变topic发布频率并不是说原来的topic就没了，或者直接在原来的topic上更改，而是更throttle把其更改后的topic发布出来，原来的topic仍然存在.</p>
<p>有三个参数,需要注意的是<code>~lazy</code>，如果它等于True的话，只有当你订阅到throttle发出来的消息，它才会工作，这显然是ros::publish函数的lazy模式了</p>
<p>最大的问题是<font color=orange size=5> 频率控制的精度低,我要求4Hz,实际却在3.6Hz左右</font>，所以实际要设置的大一些</p>
<h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p>订阅一个topic或topic field，并在应用给定的Python表达式后将传入的数据发布到另一个topic。它主要用于简单的消息转换，例如计算向量或四元数的范数，甚至将四元数转换为欧拉角。它可以处理任何消息类型。</p>
<p><code>transform &lt;input&gt; &lt;output_topic&gt; &lt;output_type&gt; [&lt;expression&gt;] [--import &lt;module&gt; [&lt;module&gt; ...]]</code></p>
<ul>
<li>input：要订阅的传入topic（或topic field）</li>
<li>output_topic:要发布的输出topic</li>
<li>expression:转换输入消息的Python表达式，在变量m中给出。默认表达式是m，它将输入（可以是topic field）转发到output_topic</li>
<li>import :要在表达式中导入和使用的Python模块的列表。默认导入numpy模块</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算IMU给出的方向四元数的范数</span></span><br><span class="line">rosrun topic_tools transform /imu/orientation /norm std_msgs/Float64 <span class="string">&#x27;numpy.linalg.norm([m.x, m.y, m.z, m.w])&#x27;</span></span><br><span class="line"><span class="comment"># 将方向四元数转换为Euler角度</span></span><br><span class="line">rosrun topic_tools transform /imu/orientation /euler geometry_msgs/Vector3 <span class="string">&#x27;tf.transformations.euler_from_quaternion([m.x, m.y, m.z, m.w])&#x27;</span> --import tf</span><br></pre></td></tr></table></figure>
<p><br></p>
<p>mux: multiplex between multiple topics.</p>
<p>relay: republish data on one topic to another.</p>
<p>relay_field: allow to republish data in a different message type</p>
<p>drop: relay a topic, dropping X out of every Y message.</p>
<p>参考:<a target="_blank" rel="noopener" href="http://wiki.ros.org/topic_tools/throttle">throttle Wiki</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/30/%E8%A7%86%E8%A7%89SLAM/%E6%A0%87%E5%AE%9AD435i%E7%9A%84%E7%9B%B8%E6%9C%BA(%E4%BA%8C)/">标定D435i(二) 相机</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%A7%86%E8%A7%89SLAM/">视觉SLAM</a></span><div class="content"><p>Kalibr可以解决以下的标定问题:</p>
<ul>
<li>多相机标定: 一个相机系统的内外参标定，这几个相机没有全局性重叠的视角</li>
<li>视觉惯性标定(camera-IMU): IMU关于相机系统的时空间标定</li>
<li>Rolling Shutter Camera calibration: full intrinsic calibration (projection, distortion and shutter parameters) of rolling shutter cameras</li>
</ul>
<p>可以下载Kalibr源码编译生成可执行文件，也可以下载其CDE精简版包。这中间有个坑就是CDE精简包是没有办法标定彩色图片的，而D435输出的是彩色图。所以还是按编译源码的方式</p>
<p>使用Kalibr标定相机的内参和多个相机相对位置关系即外参</p>
<h2 id="安装Kalibr"><a href="#安装Kalibr" class="headerlink" title="安装Kalibr"></a>安装Kalibr</h2><ol>
<li><p>安装依赖项</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-pyx python-setuptools python-rosinstall ipython libeigen3-dev libboost-all-dev doxygen ros-kinetic-vision-opencv ros-kinetic-image-transport-plugins ros-kinetic-cmake-modules python-software-properties software-properties-common libpoco-dev python-matplotlib python-scipy python-git python-pip ipython libtbb-dev libblas-dev liblapack-dev python-catkin-tools libv4l-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>源码放入工作空间进行编译，会花很长时间，所以编译命令要这样:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 视情况取j8</span></span><br><span class="line">catkin_make -DCMAKE_BUILD_TYPE=Release -j4</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>编译kalibr可能会出现<font color=orange size=4> fatal error: numpy/arrayobject.h: No such file or directory </font>，解决方法： <code>sudo apt-get install --reinstall python-numpy</code></p>
<p>可能出现catkin_make时，下载suitesparse过久甚至失败的问题。解决方法： 修改<code>～/catkin_ws/src/kalibr/suitesparse</code>中的CMakeLists.txt为<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/charon-cheung/xiaoqiang_robot/master/Calibration/Kalibr_CMakeLists.md">新CMakeLists.txt</a>, 然后重新catkin_make</p>
<h2 id="标定板"><a href="#标定板" class="headerlink" title="标定板"></a>标定板</h2><p><a target="_blank" rel="noopener" href="https://github.com/ethz-asl/kalibr/wiki/downloads">下载标定板</a></p>
<p>我下载的是<code>Aprilgrid 6x6 0.5x0.5m</code>(unscaled)， 打印在A3纸上</p>
<p>原版的参数是:6X6 tags，6乘6个格子，一个大格子size=5.5cm，一个小格子spacing=1.65cm</p>
<p>A3纸上的缩放:6X6 tags，一个大格子size=3.5cm，一个小格子spacing=1cm。记得打印出来用尺子量一下，以免出现差错。<br><img src="https://i.loli.net/2020/06/30/U68mzoAjeQEPvug.png" alt="标定板参数示意图"></p>
<p>下载官网提供的yaml格式文件，需要按照设定的尺寸进行修改<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target_type: <span class="string">&#x27;aprilgrid&#x27;</span> <span class="comment">#gridtype</span></span><br><span class="line">tagCols: 6               <span class="comment">#number of apriltags</span></span><br><span class="line">tagRows: 6               <span class="comment">#number of apriltags</span></span><br><span class="line">tagSize: 0.035           <span class="comment">#size of apriltag, edge to edge [m]</span></span><br><span class="line">tagSpacing: 0.3          <span class="comment">#ratio of space between tags to tagSize</span></span><br></pre></td></tr></table></figure></p>
<p>找一个适合的能拍到棋盘格的距离,启动相机: <code>roslaunch realsense2_camera rs_camera.launch</code></p>
<p>d453i是有红外发射器的，可以发射很多红外小斑点，如果打开你会在rviz看到很多光斑，可能不利于标定，所以标定时关闭这个发射器的。</p>
<h2 id="降低图像话题的频率，录制图像数据包"><a href="#降低图像话题的频率，录制图像数据包" class="headerlink" title="降低图像话题的频率，录制图像数据包"></a>降低图像话题的频率，录制图像数据包</h2><p>kalibr在处理标定数据的时候要求图像的频率不可过高，一般为4hz(后面计算过程报错，改为20)。使用如下指令来限制图像频率:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rosrun topic_tools throttle messages /camera/color/image_raw 4 /color</span><br><span class="line">rosrun topic_tools throttle messages /camera/infra2/image_rect_raw 4 /infra_left</span><br><span class="line">rosrun topic_tools throttle messages /camera/infra1/image_rect_raw 4 /infra_right</span><br></pre></td></tr></table></figure><br>用topic_tools throttle限制频率后,一定要查看限制后的topic输出频率：<code>rostopic hz /topic</code>，你会发现实际的频率与设定的频率并不一致，比如：<code>rosrun topic_tools throttle messages /topic_1  25  /topic_2</code>，如果topic_1是40hz，/topic_2可能不是25hz，而是20hz，而且每次的实际频率可能不同，具体原因不明。</p>
<p>注意这里是采用了新的话题<code>/color</code>去发布,所以下面录制要写<code>/color</code>话题</p>
<p>将标定目标AprilGrid置于相机前方合理距离范围内，准备录制两分钟:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag record -O multicameras_calibration /infra_left /infra_right /color</span><br></pre></td></tr></table></figure><br>开始缓慢移动标定板，让所有摄像头看到标定板不要太远，不然无法检测到标定目标的特征，这个过程中看不到图案的识别结果，这是kalibr的原因。在标定算法中需要检测是否有足够数量图片检测到标定特征，否则直接无法标定。移动标定物时候不要过快导致运动模糊，我们只需要获取不同位置和角度的图像，确保图像清晰和特征完整即可。另外要尽可能多角度和多位置（上下左右等）甚至到摄像头捕捉图像的边缘，这样移动目标1min左右即可。</p>
<p>移动的方式可以参考<a target="_blank" rel="noopener" href="https://vision.in.tum.de/data/datasets/visual-inertial-dataset">TUM CALIBRATION SEQUENCES的标定方式</a>，点play即可播放</p>
<h2 id="kalibr算法计算各个摄像头的内参和外参"><a href="#kalibr算法计算各个摄像头的内参和外参" class="headerlink" title="kalibr算法计算各个摄像头的内参和外参"></a>kalibr算法计算各个摄像头的内参和外参</h2><p><code>april_6x6_A3.yaml</code>: 标定物的参数，具体是标定目标的尺寸之类，因为我是缩小打印在A3上，所以要对参数进行修改；pinhole-equi – 选择的相机模型，kalibr提供了很多相机模型，可以自己选择; —bag-from-to 可以选择时间段，毕竟录制的时候不能保证整体都录制的很好。<strong>标定会花很长时间，最后会输出一个pdf和txt文件，有内外参数据。</strong></p>
<p>只标定主相机:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kalibr_calibrate_cameras --target ../yaml/april_6x6_A4.yaml --bag ./bag/0_multicameras_calibration.bag --model pinhole-equi  --topic  /color  --show-extraction --approx-sync 0.04</span><br></pre></td></tr></table></figure></p>
<p>最后还是标定的多相机：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kalibr_calibrate_cameras --target april_6x6_A3.yaml --bag multicameras_calibration.bag --models pinhole-equi pinhole-equi pinhole-equi --topics /infra_left /infra_right /color  --show-extraction --approx-sync 0.04 --bag-from-to 10 100</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>pinhole-radtan</code>指的是针孔相机模型和畸变模型，每个相机都要指定。还有<code>Pinhole + FOV</code>等等</li>
<li><code>--bag-from-to 10 100</code>指的是录制的第26秒到100秒这段时间</li>
<li><code>--show-extraction</code>, 在标定过程中可视化角点检测情况是否良好</li>
<li><code>--approx-sync 0.04</code></li>
</ul>
<p>结果报错： <font color = orange size=4> ImportError: No module named igraph </font><br>解决方法： <code>sudo apt-get install python2.7-igraph</code></p>
<p>需要在有界面的情况下标定，因为会弹出几个窗口，所以不能通过SSH进行，类似这样：<br><img src="https://i.loli.net/2020/07/01/FnbTkojVMxBCSlP.png" alt=""></p>
<p>可以使用calibration validator进行标定的验证，原理是对重投影误差进行量化分析，同样需要有界面：<br><code>kalibr_camera_validator --cam camchain-multicameras_calibration.yaml --target april_6x6_A3.yaml</code><br><img src="https://i.loli.net/2020/07/02/yZHWnB25hlm4cCO.png" alt="验证结果.png"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/29/%E8%A7%86%E8%A7%89SLAM/%E6%A0%87%E5%AE%9AD435i%E7%9A%84IMU(%E4%B8%80)/">标定D435i(一) IMU</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%A7%86%E8%A7%89SLAM/">视觉SLAM</a></span><div class="content"><p>realsense d435i包含两个红外相机、红外发射器、RGB相机和IMU四个模块，显然四个传感器的空间位置是不同的，我们在处理图像和IMU数据时需要将这些数据都放在统一的坐标系上去。比如我们用d435i运行vins，处理的图像和IMU数据都需要放在同一个坐标系下，因此需要标定IMU相对RGB相机的空间位置（包括旋转和位移）。</p>
<p>另外，相机固有参数比如焦距、畸变参数等以及IMU的零偏和scale系数等都需要提前知道。前者称为外参，后者称为内参，在运行程序前我们需要标定它们，不论程序是否有自标定功能，毕竟好的初始标定值对于自标定来说也是有利的。</p>
<p>标定顺序：<strong>IMU标定 —&gt; 相机标定 —&gt; IMU+相机联合标定</strong>. 这么设定顺序是因为最后一步的IMU和相机的联合标定需要 IMU和相机的内参</p>
<h2 id="Allan方差"><a href="#Allan方差" class="headerlink" title="Allan方差"></a>Allan方差</h2><p>在IMU采集数据时，会产生两种误差：确定性误差和随机性误差，为获得精确的数据，需要对上述两种误差进行标定,加速度计和陀螺仪随机误差的标定通常使用Allan方差法，它是20世纪60年代由美国国家标准局的David Allan提出的基于时域的分析方法。</p>
<p>A ROS package tool to analyze the IMU performance. C++ version of Allan Variance Tool. The figures are drawn by Matlab, in scripts.</p>
<p>Actually, just analyze the Allan Variance for the IMU data. Collect the data while the IMU is Stationary, with a two hours duration.<br>code_utils标定IMU的噪音密度和随机游走系数。</p>
<h2 id="安装库和依赖项"><a href="#安装库和依赖项" class="headerlink" title="安装库和依赖项"></a>安装库和依赖项</h2><p>安装依赖项，不装之后的编译会报错： <code>sudo apt-get -y install libdw-dev</code>，结果可能提示<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The following packages have unmet dependencies:</span><br><span class="line"> libdw-dev : Depends: libelf-dev but it is not going to be installed</span><br><span class="line">             Depends: libdw1 (= 0.165-3ubuntu1) but it is not going to be installed</span><br><span class="line">E: Unable to correct problems, you have held broken packages.</span><br></pre></td></tr></table></figure><br>这是因为一个依赖项已经安装了不同版本：<code>Depends: libelf1 (= 0.165-3ubuntu1) but 0.165-3ubuntu1.2 is to be installed</code>。 解决方法: <code>sudo aptitude install libdw-dev</code>，对给出的方案，选择第二个，降级 libelf1[0.165-3ubuntu1.1 (now) -&gt; 0.158-0ubuntu]</p>
<h2 id="编译code-utils和imu-utils"><a href="#编译code-utils和imu-utils" class="headerlink" title="编译code_utils和imu_utils"></a>编译code_utils和imu_utils</h2><p>全局安装ceres库，因为<code>code_imu</code>依赖ceres。不要同时把imu_utils和code_utils一起放到src下进行编译。因为imu_utils 依赖 code_utils，原作者的CMakeLists写的不好，所以先编译code_utils再编译后者。 </p>
<p>在<code>code_utils</code>下面找到<code>sumpixel_test.cpp</code>，修改<code>#include &quot;backward.hpp&quot;</code>为<code>#include&quot;code_utils/backward.hpp&quot;</code>，再依次编译两个包</p>
<h2 id="发布D435i的IMU数据"><a href="#发布D435i的IMU数据" class="headerlink" title="发布D435i的IMU数据"></a>发布D435i的IMU数据</h2><p>可以直接在rs_camera.launch基础上针对IMU校准做修改。目的是将acc、gyro数据对齐使用同一个topic发布。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 更改前原版本arg name=&quot;unite_imu_method&quot;          default=&quot;&quot;/--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;unite_imu_method&quot;</span>          <span class="attr">default</span>=<span class="string">&quot;linear_interpolation&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--或着将参数改为copy--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;unite_imu_method&quot;</span>          <span class="attr">default</span>=<span class="string">&quot;copy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><br>启动: <code>roslaunch realsense2_camera rs_imu_calibration.launch</code>，然后录制imu数据包<code>rosbag record -O imu_calibration /camera/imu</code>，让IMU静止不动两个小时，录制IMU的bag.</p>
<h2 id="标定"><a href="#标定" class="headerlink" title="标定"></a>标定</h2><p>根据<code>imu_utils</code>文件夹里面的<code>A3.launch</code>改写D435i标定启动文件：<code>d435i_imu_calib.launch</code>注意，记得修改max_time_min对应的参数，默认是120，也就是两个小时，如果ros包里的imu数据长度没有两个小时，等bag播放完了，还是停留在<code>wait for imu data</code>这里，不会生成标定文件。我录了1小时59分多一点，所以还得改成119</p>
<p><code>d435i_imu_calibration.launch</code>如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;imu_utils&quot;</span> <span class="attr">type</span>=<span class="string">&quot;imu_an&quot;</span> <span class="attr">name</span>=<span class="string">&quot;imu_an&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--TOPIC名称和上面一致--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;imu_topic&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">value</span>= <span class="string">&quot;/camera/imu&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--imu_name 无所谓--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;imu_name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">value</span>= <span class="string">&quot;D435i&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--标定结果存放路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;data_save_path&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">value</span>= <span class="string">&quot;$(find imu_utils)/data/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据录制时间-min--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;max_time_min&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>= <span class="string">&quot;120&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--采样频率，即是IMU频率，采样频率可以使用rostopic hz /camera/imu查看，设置为200，也就是rosbag play播放频率--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;max_cluster&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>= <span class="string">&quot;200&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><br>先启动标定程序: <code>roslaunch imu_utils d435i_imu_calib.launch</code>，再播放bag: <code>rosbag play -r 200 imu_calibration.bag</code></p>
<h2 id="标定结果"><a href="#标定结果" class="headerlink" title="标定结果"></a>标定结果</h2><p>标定结果是<code>D435i_imu_param.yaml</code>:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">%YAML:1.0</span><br><span class="line">---</span><br><span class="line"><span class="built_in">type</span>: IMU</span><br><span class="line">name: D435i</span><br><span class="line">Gyr:</span><br><span class="line">   unit: <span class="string">&quot; rad/s&quot;</span></span><br><span class="line">   avg-axis:</span><br><span class="line">      gyr_n: 3.6673681012835031e-03</span><br><span class="line">      gyr_w: 7.0017785520472972e-05</span><br><span class="line">   x-axis:</span><br><span class="line">      gyr_n: 3.6001489799186333e-03</span><br><span class="line">      gyr_w: 6.2846247607788020e-05</span><br><span class="line">   y-axis:</span><br><span class="line">      gyr_n: 4.7157261366663813e-03</span><br><span class="line">      gyr_w: 7.5207268006344615e-05</span><br><span class="line">   z-axis:</span><br><span class="line">      gyr_n: 2.6862291872654953e-03</span><br><span class="line">      gyr_w: 7.1999840947286307e-05</span><br><span class="line">Acc:</span><br><span class="line">   unit: <span class="string">&quot; m/s^2&quot;</span></span><br><span class="line">   avg-axis:</span><br><span class="line">      acc_n: 2.7436489578044256e-02</span><br><span class="line">      acc_w: 1.0915021608117670e-03</span><br><span class="line">   x-axis:</span><br><span class="line">      acc_n: 1.8271976632141730e-02</span><br><span class="line">      acc_w: 5.5394830052109354e-04</span><br><span class="line">   y-axis:</span><br><span class="line">      acc_n: 2.8924134998445018e-02</span><br><span class="line">      acc_w: 1.5674764920646303e-03</span><br><span class="line">   z-axis:</span><br><span class="line">      acc_n: 3.5113357103546017e-02</span><br><span class="line">      acc_w: 1.1530816898495772e-03</span><br></pre></td></tr></table></figure><br>我们一会只用到<strong>Gyr</strong>中的<code>avg-axis</code>的<code>gyr_n</code>和<code>gyr_w</code>, <strong>Acc</strong>中的<code>avg-axis</code>的<code>acc_n</code>和<code>acc_w</code><br><br></p>
<p>终端输出结果:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">gyr x  numData 781205</span><br><span class="line">gyr x  start_t 1.59343e+09</span><br><span class="line">gyr x  end_t 1.59344e+09</span><br><span class="line">gyr x dt </span><br><span class="line">-------------7140.59 s</span><br><span class="line">-------------119.01 min</span><br><span class="line">-------------1.9835 h</span><br><span class="line">gyr x  freq 109.403</span><br><span class="line">gyr x  period 0.00914049</span><br><span class="line">gyr y  numData 781205</span><br><span class="line">gyr y  start_t 1.59343e+09</span><br><span class="line">gyr y  end_t 1.59344e+09</span><br><span class="line">gyr y dt </span><br><span class="line">-------------7140.59 s</span><br><span class="line">-------------119.01 min</span><br><span class="line">-------------1.9835 h</span><br><span class="line">gyr y  freq 109.403</span><br><span class="line">gyr y  period 0.00914049</span><br><span class="line">gyr z  numData 781205</span><br><span class="line">gyr z  start_t 1.59343e+09</span><br><span class="line">gyr z  end_t 1.59344e+09</span><br><span class="line">gyr z dt </span><br><span class="line">-------------7140.59 s</span><br><span class="line">-------------119.01 min</span><br><span class="line">-------------1.9835 h</span><br><span class="line">gyr z  freq 109.403</span><br><span class="line">gyr z  period 0.00914049</span><br><span class="line">Gyro X </span><br><span class="line">C   -6.83161    94.2973   -19.0588      2.983 -0.0404918</span><br><span class="line"> Bias Instability 2.37767e-05 rad/s</span><br><span class="line"> Bias Instability 6.28462e-05 rad/s, at 63.1334 s</span><br><span class="line"> White Noise 12.9453 rad/s</span><br><span class="line"> White Noise 0.00360015 rad/s</span><br><span class="line">  bias -0.363298 degree/s</span><br><span class="line">-------------------</span><br><span class="line">Gyro y </span><br><span class="line">C   -8.74367    117.584   -15.9277    2.47408 -0.0373467</span><br><span class="line"> Bias Instability 6.41864e-05 rad/s</span><br><span class="line"> Bias Instability 7.52073e-05 rad/s, at 104.256 s</span><br><span class="line"> White Noise 16.8998 rad/s</span><br><span class="line"> White Noise 0.00471573 rad/s</span><br><span class="line">  bias -0.544767 degree/s</span><br><span class="line">-------------------</span><br><span class="line">Gyro z </span><br><span class="line">C   -4.51808    68.1919   -9.33284    1.95333 -0.0262641</span><br><span class="line"> Bias Instability 8.50869e-05 rad/s</span><br><span class="line"> Bias Instability 7.19998e-05 rad/s, at 63.1334 s</span><br><span class="line"> White Noise 9.43212 rad/s</span><br><span class="line"> White Noise 0.00268623 rad/s</span><br><span class="line">  bias -0.0762471 degree/s</span><br><span class="line">-------------------</span><br><span class="line">==============================================</span><br><span class="line">==============================================</span><br><span class="line">acc x  numData 781205</span><br><span class="line">acc x  start_t 1.59343e+09</span><br><span class="line">acc x  end_t 1.59344e+09</span><br><span class="line">acc x dt </span><br><span class="line">-------------7140.59 s</span><br><span class="line">-------------119.01 min</span><br><span class="line">-------------1.9835 h</span><br><span class="line">acc x  freq 109.403</span><br><span class="line">acc x  period 0.00914049</span><br><span class="line">acc y  numData 781205</span><br><span class="line">acc y  start_t 1.59343e+09</span><br><span class="line">acc y  end_t 1.59344e+09</span><br><span class="line">acc y dt </span><br><span class="line">-------------7140.59 s</span><br><span class="line">-------------119.01 min</span><br><span class="line">-------------1.9835 h</span><br><span class="line">acc y  freq 109.403</span><br><span class="line">acc y  period 0.00914049</span><br><span class="line">acc z  numData 781205</span><br><span class="line">acc z  start_t 1.59343e+09</span><br><span class="line">acc z  end_t 1.59344e+09</span><br><span class="line">acc z dt </span><br><span class="line">-------------7140.59 s</span><br><span class="line">-------------119.01 min</span><br><span class="line">-------------1.9835 h</span><br><span class="line">acc z  freq 109.403</span><br><span class="line">acc z  period 0.00914049</span><br><span class="line">acc X </span><br><span class="line">C  3.36177e-05   0.00175435 -0.000159698  7.23303e-05 -7.16006e-07</span><br><span class="line"> Bias Instability 0.000553948 m/s^2</span><br><span class="line"> White Noise 0.018272 m/s^2</span><br><span class="line">-------------------</span><br><span class="line">acc y </span><br><span class="line">C  9.36955e-05   0.00234733   0.00012197  0.000243676 -2.66252e-06</span><br><span class="line"> Bias Instability 0.00156748 m/s^2</span><br><span class="line"> White Noise 0.0289241 m/s^2</span><br><span class="line">-------------------</span><br><span class="line">acc z </span><br><span class="line">C  5.07832e-05   0.00331104 -0.000381222  0.000199602 -2.43776e-06</span><br><span class="line"> Bias Instability 0.00115308 m/s^2</span><br><span class="line"> White Noise 0.0351134 m/s^2</span><br></pre></td></tr></table></figure><br>经过这些标定会生成一个yaml文件和很多txt文件，主要是yaml文件，给出了加速度计和陀螺仪三轴的<code>noise_density</code>和<code>random_walk</code>，同时计算出了平均值，后面IMU+摄像头联合标定的时候需要这些均值。</p>
<h3 id="标定外参的准备"><a href="#标定外参的准备" class="headerlink" title="标定外参的准备"></a>标定外参的准备</h3><p>将Acc和Gyr的第一组平均数据拷贝到kalibr对应的<code>imu.yaml</code>文件中<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rostopic: /camera/imu</span><br><span class="line">update_rate: 200.0  <span class="comment">#Hz</span></span><br><span class="line"> </span><br><span class="line">accelerometer_noise_density: 2.89e-01 <span class="comment">#continous</span></span><br><span class="line">accelerometer_random_walk: 4.55e-04 </span><br><span class="line">gyroscope_noise_density: 3.02e-03 <span class="comment">#continous</span></span><br><span class="line">gyroscope_random_walk: 2.29e-05</span><br></pre></td></tr></table></figure><br>分别是加速度计和陀螺仪的高斯白噪声和随机游走的平均值，是IMU噪声模型中的两种噪声。</p>
<h2 id="查看默认imu与相机参数"><a href="#查看默认imu与相机参数" class="headerlink" title="　查看默认imu与相机参数"></a>　查看默认imu与相机参数</h2><p>D435i相关的imu_info话题如下:<br><img src="https://i.loli.net/2020/06/30/nQftEcampMWxThw.png" alt="imu_info列表"></p>
<p><img src="https://i.loli.net/2020/06/30/vUu4FljdA5tJRwQ.png" alt="/camera/gyro/imu_info和/camera/accel/imu_info没有结果"></p>
<p><code>realsense_camera/IMUInfo</code> with the header.frame_id set to either <code>imu_accel</code> or <code>imu_gyro</code> to distinguish between <code>accel</code> and <code>gyro</code> info. 消息成员如下:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string frame_id</span><br><span class="line">float64[12] data</span><br><span class="line">float64[3] noise_variances</span><br><span class="line">float64[3] bias_variances</span><br></pre></td></tr></table></figure></p>
<p><code>rostopic echo -n1 /camera/color/camera_info</code>得到结果:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  frame_id: <span class="string">&quot;camera_color_optical_frame&quot;</span></span><br><span class="line">height: 480</span><br><span class="line">width: 640</span><br><span class="line">distortion_model: <span class="string">&quot;plumb_bob&quot;</span></span><br><span class="line">D: [0.0, 0.0, 0.0, 0.0, 0.0]</span><br><span class="line">K: [611.3538208007812, 0.0, 327.437744140625, 0.0, 610.015869140625, 239.99667358398438, 0.0, 0.0, 1.0]</span><br><span class="line">R: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]</span><br><span class="line">P: [611.3538208007812, 0.0, 327.437744140625, 0.0, 0.0, 610.015869140625, 239.99667358398438, 0.0, 0.0, 0.0, 1.0, 0.0]</span><br><span class="line">binning_x: 0</span><br><span class="line">binning_y: 0</span><br><span class="line">roi: </span><br><span class="line">  x_offset: 0</span><br><span class="line">  y_offset: 0</span><br><span class="line">  height: 0</span><br><span class="line">  width: 0</span><br><span class="line">  do_rectify: False</span><br></pre></td></tr></table></figure></p>
<p>对于<code>/camera/depth/imu_info</code>，结果是:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">frame_id: <span class="string">&quot;camera_depth_optical_frame&quot;</span></span><br><span class="line">height: 480</span><br><span class="line">width: 640</span><br><span class="line">distortion_model: <span class="string">&quot;plumb_bob&quot;</span></span><br><span class="line">D: [0.0, 0.0, 0.0, 0.0, 0.0]</span><br><span class="line">K: [380.23321533203125, 0.0, 316.4999084472656, 0.0, 380.23321533203125, 237.40985107421875, 0.0, 0.0, 1.0]</span><br><span class="line">R: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]</span><br><span class="line">P: [380.23321533203125, 0.0, 316.4999084472656, 0.0, 0.0, 380.23321533203125, 237.40985107421875, 0.0, 0.0, 0.0, 1.0, 0.0]</span><br><span class="line">binning_x: 0</span><br><span class="line">binning_y: 0</span><br><span class="line">roi: </span><br><span class="line">  x_offset: 0</span><br><span class="line">  y_offset: 0</span><br><span class="line">  height: 0</span><br><span class="line">  width: 0</span><br><span class="line">  do_rectify: False</span><br></pre></td></tr></table></figure></p>
<p>话题<code>/camera/infra2/camera_info</code>和<code>/camera/infra2/camera_info</code>的结果完全一样:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">frame_id: <span class="string">&quot;camera_infra1_optical_frame&quot;</span></span><br><span class="line">height: 480</span><br><span class="line">width: 640</span><br><span class="line">distortion_model: <span class="string">&quot;plumb_bob&quot;</span></span><br><span class="line">D: [0.0, 0.0, 0.0, 0.0, 0.0]</span><br><span class="line">K: [380.23321533203125, 0.0, 316.4999084472656, 0.0, 380.23321533203125, 237.40985107421875, 0.0, 0.0, 1.0]</span><br><span class="line">R: [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]</span><br><span class="line">P: [380.23321533203125, 0.0, 316.4999084472656, 0.0, 0.0, 380.23321533203125, 237.40985107421875, 0.0, 0.0, 0.0, 1.0, 0.0]</span><br><span class="line">binning_x: 0</span><br><span class="line">binning_y: 0</span><br><span class="line">roi: </span><br><span class="line">  x_offset: 0</span><br><span class="line">  y_offset: 0</span><br><span class="line">  height: 0</span><br><span class="line">  width: 0</span><br><span class="line">  do_rectify: False</span><br></pre></td></tr></table></figure><br>可以看出，实际上出厂没有标定IMU</p>
<h2 id="绘制Allan曲线"><a href="#绘制Allan曲线" class="headerlink" title="绘制Allan曲线"></a>绘制Allan曲线</h2><p><code>imu_utils/scripts</code>中是Matlab写的.m文件，按照<code>draw_allan.m</code>创建文件<code>draw_allan_acc.m</code>和<code>draw_allan_gyr.m</code></p>
<p>由于Ubuntu下安装Matlab比较麻烦，因此将数据和.m文件都拷贝到Windows系统下绘制，注意文件路径和m文件中要对应，<strong>尤其matlab中的当前路径指的是左侧栏的路径，而不是m文件所在的路径</strong></p>
<p><img src="https://i.loli.net/2020/06/30/4z9OaMhDF8gnsBH.jpg" alt="allan_gyr.jpg"><br><img src="https://i.loli.net/2020/06/30/CDxL3nBrWPtYu21.jpg" alt="allan_acc.jpg"></p>
<p>参考:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/fb_941219/article/details/104709049">RealSense D435i Calibration</a><br><a target="_blank" rel="noopener" href="https://github.com/gaowenliang/imu_utils">官方Github</a><br><a target="_blank" rel="noopener" href="https://www.geek-share.com/detail/2798533390.html">VIO标定IMU随机误差——Allan方差法</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/29/%E8%A7%86%E8%A7%89SLAM/%E6%A0%87%E5%AE%9AD435i%E7%9A%84%E5%A4%96%E5%8F%82%E6%95%B0(%E4%B8%89)/">标定D435i(三) 外参数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E8%A7%86%E8%A7%89SLAM/">视觉SLAM</a></span><div class="content"><ul>
<li>标定板pattern尽量选择apriltag，尽量不要用纸质的</li>
<li>选择合适的相机模型</li>
<li>标定手法看看TUM的</li>
</ul>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/21/">&lt;&lt; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><span class="page-number current">22</span><a class="page-number" href="/page/23/">23</a><span class="space">&hellip;</span><a class="page-number" href="/page/47/">47</a><a class="extend next" rel="next" href="/page/23/">Next &gt;&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/07/13/RCLw5Bx8aFPN74b.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2021 By Charon Cheung</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>