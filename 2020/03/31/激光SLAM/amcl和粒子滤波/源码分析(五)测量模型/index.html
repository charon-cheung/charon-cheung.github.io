<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>源码分析(五)测量模型 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="测量模型主要用来做scan-match。 光束模型比较古老，实际已经不怎么使用，它的缺陷比较明显：在杂乱的环境(非结构化环境clutter)中，输入的小变化会导致输出的大变化。amcl中实现了这个模型，但是可以选择用还是不用 似然场模型不仅适应于结构化和非结构化的环境，而且在任何环境中的期望值对位姿都是平滑的，还可以通过查表的得到栅格的似然度。 工具函数和类1234567891011&#x2F;&#x2F; Tran">
<meta property="og:type" content="article">
<meta property="og:title" content="源码分析(五)测量模型">
<meta property="og:url" content="http://example.com/2020/03/31/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%94)%E6%B5%8B%E9%87%8F%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="测量模型主要用来做scan-match。 光束模型比较古老，实际已经不怎么使用，它的缺陷比较明显：在杂乱的环境(非结构化环境clutter)中，输入的小变化会导致输出的大变化。amcl中实现了这个模型，但是可以选择用还是不用 似然场模型不仅适应于结构化和非结构化的环境，而且在任何环境中的期望值对位姿都是平滑的，还可以通过查表的得到栅格的似然度。 工具函数和类1234567891011&#x2F;&#x2F; Tran">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-03-31T12:09:43.000Z">
<meta property="article:modified_time" content="2020-09-13T02:39:31.551Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-激光SLAM/amcl和粒子滤波/源码分析(五)测量模型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/03/31/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%94)%E6%B5%8B%E9%87%8F%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2020-03-31T12:09:43.000Z" itemprop="datePublished">2020-03-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a>►<a class="article-category-link" href="/categories/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/">amcl和粒子滤波</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      源码分析(五)测量模型
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>测量模型主要用来做scan-match。</p>
<p>光束模型比较古老，实际已经不怎么使用，它的缺陷比较明显：在杂乱的环境(非结构化环境clutter)中，输入的小变化会导致输出的大变化。amcl中实现了这个模型，但是可以选择用还是不用</p>
<p>似然场模型不仅适应于结构化和非结构化的环境，而且在任何环境中的期望值对位姿都是平滑的，还可以通过查表的得到栅格的似然度。</p>
<h2 id="工具函数和类"><a href="#工具函数和类" class="headerlink" title="工具函数和类"></a>工具函数和类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transform from local to global coords (a + b)</span></span><br><span class="line"><span class="function"><span class="keyword">pf_vector_t</span> <span class="title">pf_vector_coord_add</span><span class="params">(<span class="keyword">pf_vector_t</span> a, <span class="keyword">pf_vector_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pf_vector_t</span> c;</span><br><span class="line"></span><br><span class="line">  c.v[<span class="number">0</span>] = b.v[<span class="number">0</span>] + a.v[<span class="number">0</span>] * <span class="built_in">cos</span>(b.v[<span class="number">2</span>]) - a.v[<span class="number">1</span>] * <span class="built_in">sin</span>(b.v[<span class="number">2</span>]);</span><br><span class="line">  c.v[<span class="number">1</span>] = b.v[<span class="number">1</span>] + a.v[<span class="number">0</span>] * <span class="built_in">sin</span>(b.v[<span class="number">2</span>]) + a.v[<span class="number">1</span>] * <span class="built_in">cos</span>(b.v[<span class="number">2</span>]);</span><br><span class="line">  c.v[<span class="number">2</span>] = b.v[<span class="number">2</span>] + a.v[<span class="number">2</span>];</span><br><span class="line">  c.v[<span class="number">2</span>] = <span class="built_in">atan2</span>(<span class="built_in">sin</span>(c.v[<span class="number">2</span>]), <span class="built_in">cos</span>(c.v[<span class="number">2</span>]));</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="laserReceived-中的准备工作"><a href="#laserReceived-中的准备工作" class="headerlink" title="laserReceived 中的准备工作"></a>laserReceived 中的准备工作</h2><p>这一段是紧接着laserReceived中运动模型的准备工作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 刚启动amcl时不执行,机器人移动后执行, update the filter</span></span><br><span class="line"><span class="keyword">if</span>(lasers_update_[laser_index])   <span class="comment">// 在运动模型的准备工作里赋值true</span></span><br><span class="line">&#123;</span><br><span class="line">    AMCLLaserData ldata;</span><br><span class="line">    <span class="comment">// 成员sensor是指向传感器的指针</span></span><br><span class="line">    ldata.sensor = lasers_[laser_index];</span><br><span class="line">    <span class="comment">// 动态数组ranges的大小，可以用 rostopic echo --noarr /scan 获得</span></span><br><span class="line">    ldata.range_count = laser_scan-&gt;ranges.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 雷达在base_link坐标系的最小和最大偏角</span></span><br><span class="line">    tf::Quaternion q;</span><br><span class="line">    <span class="comment">// 获得雷达的扫描起始角度，例如思岚A2的是-3.124，带时间戳和坐标系名称</span></span><br><span class="line">    q.<span class="built_in">setRPY</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, laser_scan-&gt;angle_min);</span><br><span class="line">    <span class="function">tf::Stamped&lt;tf::Quaternion&gt; <span class="title">min_q</span><span class="params">(q, laser_scan-&gt;header.stamp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      laser_scan-&gt;header.frame_id)</span></span>;</span><br><span class="line">    <span class="comment">// angle_increment为角度分辨率，例如思岚A2的是0.017， inc_q: 起始角度+角度分辨率</span></span><br><span class="line">    q.<span class="built_in">setRPY</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, laser_scan-&gt;angle_min + laser_scan-&gt;angle_increment为);</span><br><span class="line">    <span class="function">tf::Stamped&lt;tf::Quaternion&gt; <span class="title">inc_q</span><span class="params">(q, laser_scan-&gt;header.stamp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      laser_scan-&gt;header.frame_id)</span></span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;      <span class="comment">// 获得两个角度在base_link坐标系中的Quaternion</span></span><br><span class="line">      tf_-&gt;<span class="built_in">transformQuaternion</span>(base_frame_id_, min_q, min_q);</span><br><span class="line">      tf_-&gt;<span class="built_in">transformQuaternion</span>(base_frame_id_, inc_q, inc_q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(tf::TransformException&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">ROS_WARN</span>(<span class="string">&quot;Unable to transform min/max laser angles into base frame: %s&quot;</span>,</span><br><span class="line">               e.<span class="built_in">what</span>());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 现在是base_link中的起始yaw和偏航角分辨率，单位rad</span></span><br><span class="line">    <span class="keyword">double</span> angle_min = tf::<span class="built_in">getYaw</span>(min_q);</span><br><span class="line">    <span class="keyword">double</span> angle_increment = tf::<span class="built_in">getYaw</span>(inc_q) - angle_min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把角度映射到[-pi ~ pi]的范围</span></span><br><span class="line">    angle_increment = <span class="built_in">fmod</span>(angle_increment + <span class="number">5</span>*M_PI, <span class="number">2</span>*M_PI) - M_PI;</span><br><span class="line">    <span class="built_in">ROS_DEBUG</span>(<span class="string">&quot;Laser %d angles in base frame: min: %.3f inc: %.3f&quot;</span>, laser_index, angle_min, angle_increment);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply range min/max thresholds, if the user supplied them</span></span><br><span class="line">    <span class="comment">// 来自参数 laser_max_range 和 laser_min_range， 准备后面使用</span></span><br><span class="line">    <span class="keyword">if</span>(laser_max_range_ &gt; <span class="number">0.0</span>)</span><br><span class="line">        ldata.range_max = std::<span class="built_in">min</span>(laser_scan-&gt;range_max, (<span class="keyword">float</span>)laser_max_range_);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ldata.range_max = laser_scan-&gt;range_max;</span><br><span class="line">    <span class="keyword">double</span> range_min;</span><br><span class="line">    <span class="keyword">if</span>(laser_min_range_ &gt; <span class="number">0.0</span>)</span><br><span class="line">        range_min = std::<span class="built_in">max</span>(laser_scan-&gt;range_min, (<span class="keyword">float</span>)laser_min_range_);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        range_min = laser_scan-&gt;range_min;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二维数组，AMCLLaserData 的析构函数会释放这段内存</span></span><br><span class="line">    <span class="comment">// 每行第1个元素是激光射程，第2个是相对机器人的夹角</span></span><br><span class="line">    ldata.ranges = <span class="keyword">new</span> <span class="keyword">double</span>[ldata.range_count][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">ROS_ASSERT</span>(ldata.ranges);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ldata.range_count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// amcl还没有最小射程的概念，如果range的值不正常，小于最小值，则映射为最大值 </span></span><br><span class="line">      <span class="comment">// 雷达数据的赋值</span></span><br><span class="line">      <span class="keyword">if</span>(laser_scan-&gt;ranges[i] &lt;= range_min)</span><br><span class="line">          ldata.ranges[i][<span class="number">0</span>] = ldata.range_max;</span><br><span class="line">      <span class="keyword">else</span>   <span class="comment">// 射程的正常赋值，来自话题scan</span></span><br><span class="line">          ldata.ranges[i][<span class="number">0</span>] = laser_scan-&gt;ranges[i];</span><br><span class="line">          <span class="comment">// Compute bearing 夹角的赋值</span></span><br><span class="line">          ldata.ranges[i][<span class="number">1</span>] = angle_min + (i * angle_increment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心函数， 更新传感器数据</span></span><br><span class="line">    lasers_[laser_index]-&gt;<span class="built_in">UpdateSensor</span>(pf_, (AMCLSensorData*)&amp;ldata);</span><br><span class="line">    lasers_update_[laser_index] = <span class="literal">false</span>;  <span class="comment">// 完成更新传感器数据，标志位变为false</span></span><br><span class="line"></span><br><span class="line">    pf_odom_pose_ = pose;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p><code>UpdateSensor函数</code>的调用过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AMCLLaser::UpdateSensor</span><span class="params">(<span class="keyword">pf_t</span> *pf, AMCLSensorData *data)</span></span></span><br><span class="line"><span class="function"><span class="comment">// pf_sensor_model_fn_t是函数指针的类型</span></span></span><br><span class="line"><span class="function"><span class="title">pf_update_sensor</span><span class="params">(pf, (<span class="keyword">pf_sensor_model_fn_t</span>) LikelihoodFieldModel, data)</span></span>;</span><br></pre></td></tr></table></figure>
<p>涉及两个函数： <code>LikelihoodFieldModel</code> 似然域模型，<code>pf_update_sensor</code> 粒子更新</p>
<h2 id="LikelihoodFieldModel-函数"><a href="#LikelihoodFieldModel-函数" class="headerlink" title="LikelihoodFieldModel 函数"></a>LikelihoodFieldModel 函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">AMCLLaser::LikelihoodFieldModel</span><span class="params">(AMCLLaserData *data, <span class="keyword">pf_sample_set_t</span>* set)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  AMCLLaser *self;</span><br><span class="line">  <span class="keyword">int</span> i, j, step;</span><br><span class="line">  <span class="keyword">double</span> z, pz;</span><br><span class="line">  <span class="keyword">double</span> p;</span><br><span class="line">  <span class="keyword">double</span> obs_range, obs_bearing;</span><br><span class="line">  <span class="keyword">double</span> total_weight;</span><br><span class="line">  <span class="keyword">pf_sample_t</span> *sample;</span><br><span class="line">  <span class="keyword">pf_vector_t</span> pose;</span><br><span class="line">  <span class="keyword">pf_vector_t</span> hit;</span><br><span class="line"></span><br><span class="line">  self = (AMCLLaser*) data-&gt;sensor;</span><br><span class="line">  total_weight = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the sample weights 遍历整个粒子集合，重新计算权重</span></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; set-&gt;sample_count; j++)</span><br><span class="line">  &#123;</span><br><span class="line">    sample = set-&gt;samples + j;</span><br><span class="line">    pose = sample-&gt;pose;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传感器局部坐标经过三角变换映射到全局坐标系下，与激光雷达数据匹配</span></span><br><span class="line">    pose = <span class="built_in">pf_vector_coord_add</span>(self-&gt;laser_pose, pose);</span><br><span class="line">    p = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预计算似然域，离散栅格化，《P.R》Page 130, 其实是对sigma和Zmax的赋值</span></span><br><span class="line">    <span class="keyword">double</span> z_hit_denom = <span class="number">2</span> * self-&gt;sigma_hit * self-&gt;sigma_hit; <span class="comment">//测量噪声的方差</span></span><br><span class="line">    <span class="keyword">double</span> z_rand_mult = <span class="number">1.0</span>/data-&gt;range_max;  <span class="comment">// 无法解释的随机测量的分布</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为时间的问题，不对所有的点都进行似然计算，这里只是间隔地选点</span></span><br><span class="line">    step = (data-&gt;range_count - <span class="number">1</span>) / (self-&gt;max_beams - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(step &lt; <span class="number">1</span>)  <span class="comment">// 步长至少为1</span></span><br><span class="line">      step = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 利用与最近物体的欧氏距离计算激光模型似然，对所有特征（激光点）进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; data-&gt;range_count; i += step)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 距离和角度的赋值，根源在上面的准备工作里</span></span><br><span class="line">      obs_range = data-&gt;ranges[i][<span class="number">0</span>];  </span><br><span class="line">      obs_bearing = data-&gt;ranges[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//忽略极大的range，rostopic echo可看到有很多range是inf</span></span><br><span class="line">      <span class="keyword">if</span>(obs_range &gt;= data-&gt;range_max)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// Check for NaN</span></span><br><span class="line">      <span class="keyword">if</span>(obs_range != obs_range)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      pz = <span class="number">0.0</span>;</span><br><span class="line">      <span class="comment">//激光点通过两次转化到全局坐标系，  map  base_link  lase</span></span><br><span class="line">      <span class="comment">// Compute the endpoint of the beam</span></span><br><span class="line">      hit.v[<span class="number">0</span>] = pose.v[<span class="number">0</span>] + obs_range * <span class="built_in">cos</span>(pose.v[<span class="number">2</span>] + obs_bearing);</span><br><span class="line">      hit.v[<span class="number">1</span>] = pose.v[<span class="number">1</span>] + obs_range * <span class="built_in">sin</span>(pose.v[<span class="number">2</span>] + obs_bearing);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将激光数据在栅格地图中进行离散化, 获得激光点在栅格地图的坐标</span></span><br><span class="line">      <span class="comment">// 我理解的查表就是这里</span></span><br><span class="line">      <span class="keyword">int</span> mi, mj;</span><br><span class="line">      mi = <span class="built_in">MAP_GXWX</span>(self-&gt;map, hit.v[<span class="number">0</span>]);</span><br><span class="line">      <span class="comment">// 计算函数在map_cspace.cpp的map_update_cspace中实现遍历计算</span></span><br><span class="line">      <span class="comment">// 该函数是被AMCLLaser::SetModelLikelihoodField调用</span></span><br><span class="line">      mj = <span class="built_in">MAP_GYWY</span>(self-&gt;map, hit.v[<span class="number">1</span>]);  <span class="comment">//距离和角度格栅</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 找到距离激光点最近的障碍，距离值是提前计算好的</span></span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">MAP_VALID</span>(self-&gt;map, mi, mj))</span><br><span class="line">        z = self-&gt;map-&gt;max_occ_dist;   <span class="comment">//不在地图范围内的当成最大距离</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 这个就是我们需要的最近距离，相当于《P.R》130页的dist</span></span><br><span class="line">        z = self-&gt;map-&gt;cells[<span class="built_in">MAP_INDEX</span>(self-&gt;map,mi,mj)].occ_dist;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 高斯模型，130页的算法第8行</span></span><br><span class="line">      <span class="comment">// 计算Zt似然域的算法，在障碍物点周围用正态分布和均匀分布计算似然域，是关于dist的函数</span></span><br><span class="line">      pz += self-&gt;z_hit * <span class="built_in">exp</span>(-(z * z) / z_hit_denom);  <span class="comment">//高斯测量</span></span><br><span class="line">      pz += self-&gt;z_rand * z_rand_mult;   <span class="comment">//随机测量</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> outlier rejection for short readings</span></span><br><span class="line">      <span class="built_in">assert</span>(pz &lt;= <span class="number">1.0</span>);</span><br><span class="line">      <span class="built_in">assert</span>(pz &gt;= <span class="number">0.0</span>);</span><br><span class="line">      <span class="comment">//  p *= pz;  这个是书上的公式</span></span><br><span class="line">      <span class="comment">// here we have an ad-hoc weighting scheme for combining beam probs</span></span><br><span class="line">      <span class="comment">// 注意： 实际使用的公式和书上的不同</span></span><br><span class="line">      p += pz*pz*pz;  	<span class="comment">//将每个激光点的似然域累加起来（多大范围）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sample-&gt;weight 在之前的pf_alloc和pf_init里赋值为 最大粒子数的倒数</span></span><br><span class="line">    sample-&gt;weight *= p;    <span class="comment">// 概率等于权重</span></span><br><span class="line">    total_weight += sample-&gt;weight;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>(total_weight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致的思想是这样:</p>
<p><font color = orange size =3> 不解的地方：  </font></p>
<p>测量模型的最后使用的公式是<code>p += pz*pz*pz</code>，并不是书上的<code>p *= pz</code>，怀疑3个pz对应 [x,y,θ]</p>
<p><code>sample-&gt;weight</code>在之前赋值为 <font color = blue size =3> 1/max_particles </font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将激光点的世界坐标转为栅格地图的坐标</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAP_GXWX(map, x) (floor( (x - map-&gt;origin_x) / map-&gt;scale + 0.5) + map-&gt;size_x / 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAP_GYWY(map, y) (floor( (y - map-&gt;origin_y) / map-&gt;scale + 0.5) + map-&gt;size_y / 2)</span></span><br></pre></td></tr></table></figure>

<p>公式 <code>step = (laser_range_count - 1) / (max_beams - 1);</code>：<br>因为时间问题，不对所有点进行似然计算，而是间隔选点，step就是步长. </p>
<p><code>lser_rang_count</code>可以用<code>rostopic echo --noarr /scan</code>得到,<code>max_beams</code>由自己设置. 如果step小于1,程序里会设置为1.</p>
<p>因为寻找最近障碍物是最耗时的，可以将似然域预先计算好，搜索时直接查表即可。我理解的查表是查激光点在查栅格地图的坐标。</p>
<p>似然域模型的最后重新确定了每个粒子的重要性权重<code>sample-&gt;weight</code></p>
<h2 id="pf-update-sensor-函数"><a href="#pf-update-sensor-函数" class="headerlink" title="pf_update_sensor 函数"></a>pf_update_sensor 函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据观测值更新滤波器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pf_update_sensor</span><span class="params">(<span class="keyword">pf_t</span> *pf, <span class="keyword">pf_sensor_model_fn_t</span> sensor_fn, <span class="keyword">void</span> *sensor_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">pf_sample_set_t</span> *set;</span><br><span class="line">  <span class="keyword">pf_sample_t</span> *sample;</span><br><span class="line">  <span class="keyword">double</span> total;</span><br><span class="line"></span><br><span class="line">  set = pf-&gt;sets + pf-&gt;current_set;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 粒子总权重</span></span><br><span class="line">  total = (*sensor_fn) (sensor_data, set);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (total &gt; <span class="number">0.0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">		<span class="comment">// Normalize weights</span></span><br><span class="line">		<span class="keyword">double</span> w_avg=<span class="number">0.0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; set-&gt;sample_count; i++)</span><br><span class="line">		&#123;</span><br><span class="line">		  sample = set-&gt;samples + i;</span><br><span class="line">		  w_avg += sample-&gt;weight;</span><br><span class="line">		  sample-&gt;weight /= total;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Update running averages of likelihood of samples</span></span><br><span class="line">		w_avg /= set-&gt;sample_count;</span><br><span class="line">		<span class="keyword">if</span>(pf-&gt;w_slow == <span class="number">0.0</span>)</span><br><span class="line">		  pf-&gt;w_slow = w_avg;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		  pf-&gt;w_slow += pf-&gt;alpha_slow * (w_avg - pf-&gt;w_slow);</span><br><span class="line">    </span><br><span class="line">		<span class="keyword">if</span>(pf-&gt;w_fast == <span class="number">0.0</span>)</span><br><span class="line">		  pf-&gt;w_fast = w_avg;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		  pf-&gt;w_fast += pf-&gt;alpha_fast * (w_avg - pf-&gt;w_fast);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Handle zero total</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; set-&gt;sample_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      sample = set-&gt;samples + i;</span><br><span class="line">      sample-&gt;weight = <span class="number">1.0</span> / set-&gt;sample_count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，就是196页的AMCL算法的7~11行。 不解的地方是 <font color = orange size =3> sample-&gt;weight最后又除以了粒子总权重 </font></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/03/31/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%94)%E6%B5%8B%E9%87%8F%E6%A8%A1%E5%9E%8B/" data-id="ckr29hnha00g4d4lm1v8cgyz5" data-title="源码分析(五)测量模型" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/03/31/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)laserReceived%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          源码分析(三)laserReceived回调函数
        
      </div>
    </a>
  
  
    <a href="/2020/03/30/%E6%BF%80%E5%85%89SLAM/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/robot_pose_ekf%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">robot_pose_ekf源码分析</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C/Boost/">Boost</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/C-%E5%9F%BA%E7%A1%80/">C++ 基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/C-%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/">C++ 模板与STL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++ 面向对象</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux%E5%9F%BA%E7%A1%80/">Linux基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Matlab/">Matlab</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PCL%E7%82%B9%E4%BA%91/">PCL点云</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ROS/">ROS</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ROS/ROS-Kinetic%E7%9F%A5%E8%AF%86/">ROS Kinetic知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ROS/ROS%E6%9C%BA%E5%99%A8%E4%BA%BA/">ROS机器人</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ROS/ROS%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ROS程序和源码分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ROS/rviz%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/">rviz深入研究</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ROS/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AF%BC%E8%88%AA/">机器人导航</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/SLAM%E5%B7%A5%E5%85%B7/">SLAM工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Valgrind%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">Valgrind和内存管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Wireshark/">Wireshark</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/cmake-qmake/">cmake/qmake</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8D%97%E4%BA%AC%E5%AF%BC%E8%88%AA%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98/">南京导航程序的疑难问题</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/">常用工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">数学基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/">激光SLAM</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/">Cartographer</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E5%8E%9F%E7%90%86%E5%92%8C%E9%85%8D%E7%BD%AE/">原理和配置</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">源码解读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/ICP/">ICP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/amcl%E5%92%8C%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2/">amcl和粒子滤波</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/gmapping/">gmapping</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/">卡尔曼滤波</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/%E5%8F%8D%E5%85%89%E6%9D%BF/">反光板</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC/">算法推导</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BF%80%E5%85%89SLAM/%E9%9B%B7%E8%BE%BE/">雷达</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/">第三方库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%84%9A%E6%9C%AC/">脚本</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%A7%86%E8%A7%89SLAM/">视觉SLAM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/">路径规划</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/">TEB算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/TEB%E7%AE%97%E6%B3%95/costmap-converter/">costmap converter</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/move-base%E5%88%86%E6%9E%90/">move_base分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E4%BB%A3%E4%BB%B7%E5%9C%B0%E5%9B%BE/">代价地图</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%85%A8%E5%B1%80%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/">全局路径算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%9F%BA%E4%BA%8Erealsense%E6%89%AB%E6%8F%8F%E7%82%B9%E4%BA%91%E7%9A%84%E4%BD%8E%E7%9F%AE%E9%81%BF%E9%9A%9C/">基于realsense扫描点云的低矮避障</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%A4%A7%E8%BD%AE%E5%BB%93%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E5%AF%BC%E8%88%AA/">大轮廓机器人的导航</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/">面试笔试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/web%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">web服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%91%84%E5%83%8F%E5%A4%B4/" rel="tag">摄像头</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95/" rel="tag">编译调试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/" rel="tag">面试笔试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/web%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">web服务器</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">内存管理</a> <a href="/tags/%E6%91%84%E5%83%8F%E5%A4%B4/" style="font-size: 15px;">摄像头</a> <a href="/tags/%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95/" style="font-size: 20px;">编译调试</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/" style="font-size: 10px;">面试笔试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/13/%E6%BF%80%E5%85%89SLAM/%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC/%E9%AB%98%E6%96%AF%E7%89%9B%E9%A1%BF%E6%B3%95/">17747</a>
          </li>
        
          <li>
            <a href="/2021/07/13/%E6%BF%80%E5%85%89SLAM/%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC/%E7%89%9B%E9%A1%BF%E6%B3%95/">牛顿法</a>
          </li>
        
          <li>
            <a href="/2021/07/12/%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/ROS/">ROS</a>
          </li>
        
          <li>
            <a href="/2021/07/12/%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/">算法</a>
          </li>
        
          <li>
            <a href="/2021/07/07/%E6%BF%80%E5%85%89SLAM/Cartographer/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/AddAccumulatedRangeData%E5%87%BD%E6%95%B0(3)/">AddAccumulatedRangeData函数(3) 加入位姿估计器和插入子图</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>